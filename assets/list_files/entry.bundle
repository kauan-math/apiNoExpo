var __BUNDLE_START_TIME__=globalThis.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=true,process=globalThis.process||{},__METRO_GLOBAL_PREFIX__='',__requireCycleIgnorePatterns=[/(^|\/|\\)node_modules($|\/|\\)/];process.env=process.env||{};process.env.NODE_ENV=process.env.NODE_ENV||"development";
(function (global) {
  'use strict';

  if (__DEV__ || !global[`${__METRO_GLOBAL_PREFIX__}__d`]) {
    global.__r = metroRequire;
    global[`${__METRO_GLOBAL_PREFIX__}__d`] = define;
    global.__c = clear;
    global.__registerSegment = registerSegment;
  }
  var modules = clear();
  const EMPTY = {};
  const CYCLE_DETECTED = {};
  const {
    hasOwnProperty
  } = {};
  if (__DEV__) {
    global.$RefreshReg$ = global.$RefreshReg$ ?? (() => {});
    global.$RefreshSig$ = global.$RefreshSig$ ?? (() => type => type);
  }
  function clear() {
    modules = new Map();
    return modules;
  }
  if (__DEV__) {
    var initializingModuleIds = [];
  }
  function define(factory, moduleId, dependencyMap) {
    if (modules.has(moduleId)) {
      if (__DEV__) {
        const inverseDependencies = arguments[4];
        if (inverseDependencies) {
          global.__accept(moduleId, factory, dependencyMap, inverseDependencies);
        }
      }
      return;
    }
    const mod = {
      dependencyMap,
      factory,
      hasError: false,
      importedAll: EMPTY,
      importedDefault: EMPTY,
      isInitialized: false,
      publicModule: {
        exports: {}
      }
    };
    modules.set(moduleId, mod);
    if (__DEV__) {
      mod.hot = createHotReloadingObject();
      const verboseName = arguments[3];
      if (verboseName) {
        mod.verboseName = verboseName;
      }
    }
  }
  function metroRequire(moduleId, moduleIdHint) {
    if (moduleId === null) {
      if (__DEV__ && typeof moduleIdHint === 'string') {
        throw new Error("Cannot find module '" + moduleIdHint + "'");
      }
      throw new Error('Cannot find module');
    }
    if (__DEV__) {
      const initializingIndex = initializingModuleIds.indexOf(moduleId);
      if (initializingIndex !== -1) {
        const cycle = initializingModuleIds.slice(initializingIndex).map(id => {
          var _modules_get;
          return ((_modules_get = modules.get(id)) == null ? void 0 : _modules_get.verboseName) ?? '[unknown]';
        });
        if (shouldPrintRequireCycle(cycle)) {
          cycle.push(cycle[0]);
          console.warn(`Require cycle: ${cycle.join(' -> ')}\n\n` + 'Require cycles are allowed, but can result in uninitialized values. ' + 'Consider refactoring to remove the need for a cycle.');
        }
      }
    }
    const module = modules.get(moduleId);
    return module && module.isInitialized ? module.publicModule.exports : guardedLoadModule(moduleId, module, moduleIdHint);
  }
  function shouldPrintRequireCycle(modules) {
    const rcip = __METRO_GLOBAL_PREFIX__ + '__requireCycleIgnorePatterns';
    const regExps = globalThis[rcip] ?? global[rcip] ?? [/(^|\/|\\)node_modules($|\/|\\)/];
    if (!Array.isArray(regExps)) {
      return true;
    }
    const isIgnored = module => module != null && regExps.some(regExp => regExp.test(module));
    return modules.every(module => !isIgnored(module));
  }
  function metroImportDefault(moduleId) {
    var _modules_get;
    if (modules.has(moduleId) && ((_modules_get = modules.get(moduleId)) == null ? void 0 : _modules_get.importedDefault) !== EMPTY) {
      return modules.get(moduleId).importedDefault;
    }
    const exports = metroRequire(moduleId);
    const importedDefault = exports && exports.__esModule ? exports.default : exports;
    return modules.get(moduleId).importedDefault = importedDefault;
  }
  metroRequire.importDefault = metroImportDefault;
  function metroImportAll(moduleId) {
    var _modules_get;
    if (modules.has(moduleId) && ((_modules_get = modules.get(moduleId)) == null ? void 0 : _modules_get.importedAll) !== EMPTY) {
      return modules.get(moduleId).importedAll;
    }
    const exports = metroRequire(moduleId);
    let importedAll;
    if (exports && exports.__esModule) {
      importedAll = exports;
    } else {
      importedAll = {};
      if (exports) {
        for (const key in exports) {
          if (hasOwnProperty.call(exports, key)) {
            importedAll[key] = exports[key];
          }
        }
      }
      importedAll.default = exports;
    }
    return modules.get(moduleId).importedAll = importedAll;
  }
  metroRequire[Symbol.for('expo.require')] = true;
  metroRequire.importAll = metroImportAll;
  metroRequire.context = function fallbackRequireContext() {
    if (__DEV__) {
      throw new Error('The experimental Metro feature `require.context` is not enabled in your project.\nThis can be enabled by setting the `transformer.unstable_allowRequireContext` property to `true` in your Metro configuration.');
    }
    throw new Error('The experimental Metro feature `require.context` is not enabled in your project.');
  };
  metroRequire.resolveWeak = function fallbackRequireResolveWeak() {
    if (__DEV__) {
      throw new Error('require.resolveWeak cannot be called dynamically. Ensure you are using the same version of `metro` and `metro-runtime`.');
    }
    throw new Error('require.resolveWeak cannot be called dynamically.');
  };
  metroRequire.unguarded = function requireUnguarded(moduleId, moduleIdHint) {
    if (__DEV__) {
      const initializingIndex = initializingModuleIds.indexOf(moduleId);
      if (initializingIndex !== -1) {
        const cycle = initializingModuleIds.slice(initializingIndex).map(id => {
          var _modules_get;
          return ((_modules_get = modules.get(id)) == null ? void 0 : _modules_get.verboseName) ?? '[unknown]';
        });
        if (shouldPrintRequireCycle(cycle)) {
          cycle.push(cycle[0]);
          console.warn(`Require cycle: ${cycle.join(' -> ')}\n\n` + 'Require cycles are allowed, but can result in uninitialized values. ' + 'Consider refactoring to remove the need for a cycle.');
        }
      }
    }
    const module = modules.get(moduleId);
    return module && module.isInitialized ? module.publicModule.exports : loadModuleImplementation(moduleId, module, moduleIdHint);
  };
  let inGuard = false;
  function guardedLoadModule(moduleId, module, moduleIdHint) {
    if (!inGuard && global.ErrorUtils) {
      inGuard = true;
      let returnValue;
      try {
        returnValue = loadModuleImplementation(moduleId, module, moduleIdHint);
      } catch (e) {
        global.ErrorUtils.reportFatalError(e);
      }
      inGuard = false;
      return returnValue;
    } else {
      return loadModuleImplementation(moduleId, module, moduleIdHint);
    }
  }
  const ID_MASK_SHIFT = 16;
  const LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;
  function unpackModuleId(moduleId) {
    if (typeof moduleId !== 'number') {
      throw new Error('Module ID must be a number in unpackModuleId.');
    }
    const segmentId = moduleId >>> ID_MASK_SHIFT;
    const localId = moduleId & LOCAL_ID_MASK;
    return {
      segmentId,
      localId
    };
  }
  metroRequire.unpackModuleId = unpackModuleId;
  function packModuleId(value) {
    return (value.segmentId << ID_MASK_SHIFT) + value.localId;
  }
  metroRequire.packModuleId = packModuleId;
  const moduleDefinersBySegmentID = [];
  const definingSegmentByModuleID = new Map();
  function registerSegment(segmentId, moduleDefiner, moduleIds) {
    moduleDefinersBySegmentID[segmentId] = moduleDefiner;
    if (__DEV__) {
      if (segmentId === 0 && moduleIds) {
        throw new Error('registerSegment: Expected moduleIds to be null for main segment');
      }
      if (segmentId !== 0 && !moduleIds) {
        throw new Error('registerSegment: Expected moduleIds to be passed for segment #' + segmentId);
      }
    }
    if (moduleIds) {
      moduleIds.forEach(moduleId => {
        if (!modules.has(moduleId) && !definingSegmentByModuleID.has(moduleId)) {
          definingSegmentByModuleID.set(moduleId, segmentId);
        }
      });
    }
  }
  function loadModuleImplementation(moduleId, module, moduleIdHint) {
    if (!module && moduleDefinersBySegmentID.length > 0) {
      const segmentId = definingSegmentByModuleID.get(moduleId) ?? 0;
      const definer = moduleDefinersBySegmentID[segmentId];
      if (definer != null) {
        definer(moduleId);
        module = modules.get(moduleId);
        definingSegmentByModuleID.delete(moduleId);
      }
    }
    if (!module) {
      throw unknownModuleError(moduleId, moduleIdHint);
    }
    if (module.hasError) {
      throw module.error;
    }
    if (__DEV__) {
      var Systrace = requireSystrace();
      var Refresh = requireRefresh();
    }
    module.isInitialized = true;
    const {
      factory,
      dependencyMap
    } = module;
    if (__DEV__) {
      initializingModuleIds.push(moduleId);
    }
    try {
      if (__DEV__) {
        Systrace.beginEvent('JS_require_' + (module.verboseName || moduleId));
      }
      const moduleObject = module.publicModule;
      if (__DEV__) {
        moduleObject.hot = module.hot;
        var prevRefreshReg = global.$RefreshReg$;
        var prevRefreshSig = global.$RefreshSig$;
        if (Refresh != null) {
          const RefreshRuntime = Refresh;
          global.$RefreshReg$ = (type, id) => {
            const prefixedModuleId = __METRO_GLOBAL_PREFIX__ + ' ' + moduleId + ' ' + id;
            RefreshRuntime.register(type, prefixedModuleId);
          };
          global.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
        }
      }
      moduleObject.id = moduleId;
      factory == null ? void 0 : factory(global, metroRequire, metroImportDefault, metroImportAll, moduleObject, moduleObject.exports, dependencyMap);
      if (!__DEV__) {
        module.factory = undefined;
        module.dependencyMap = undefined;
      }
      if (__DEV__) {
        Systrace.endEvent();
        if (Refresh != null) {
          const prefixedModuleId = __METRO_GLOBAL_PREFIX__ + ' ' + moduleId;
          registerExportsForReactRefresh(Refresh, moduleObject.exports, prefixedModuleId);
        }
      }
      return moduleObject.exports;
    } catch (e) {
      module.hasError = true;
      module.error = e;
      module.isInitialized = false;
      module.publicModule.exports = undefined;
      throw e;
    } finally {
      if (__DEV__) {
        if (initializingModuleIds.pop() !== moduleId) {
          throw new Error('initializingModuleIds is corrupt; something is terribly wrong');
        }
        global.$RefreshReg$ = prevRefreshReg;
        global.$RefreshSig$ = prevRefreshSig;
      }
    }
  }
  function unknownModuleError(id, moduleIdHint) {
    let message = 'Requiring unknown module "' + (id ?? moduleIdHint ?? `[unknown optional import]`) + '".';
    if (__DEV__) {
      message += ' If you are sure the module exists, try restarting Metro. ' + 'You may also want to run `yarn` or `npm install`.';
    }
    return Error(message);
  }
  if (__DEV__) {
    metroRequire.Systrace = {
      beginEvent: () => {},
      endEvent: () => {}
    };
    metroRequire.getModules = () => {
      return modules;
    };
    var createHotReloadingObject = function () {
      const hot = {
        _acceptCallback: null,
        _disposeCallback: null,
        _didAccept: false,
        accept: callback => {
          hot._didAccept = true;
          hot._acceptCallback = callback;
        },
        dispose: callback => {
          hot._disposeCallback = callback;
        }
      };
      return hot;
    };
    let reactRefreshTimeout = null;
    const metroHotUpdateModule = function (id, factory, dependencyMap, inverseDependencies) {
      const mod = modules.get(id);
      if (!mod) {
        if (factory) {
          return;
        }
        throw unknownModuleError(id);
      }
      if (!mod.hasError && !mod.isInitialized) {
        mod.factory = factory;
        mod.dependencyMap = dependencyMap;
        return;
      }
      const Refresh = requireRefresh();
      const refreshBoundaryIDs = new Set();
      let didBailOut = false;
      let updatedModuleIDs;
      try {
        updatedModuleIDs = topologicalSort([id], pendingID => {
          const pendingModule = modules.get(pendingID);
          if (pendingModule == null) {
            return [];
          }
          const pendingHot = pendingModule.hot;
          if (pendingHot == null) {
            throw new Error('[Refresh] Expected module.hot to always exist in DEV.');
          }
          let canAccept = pendingHot._didAccept;
          if (!canAccept && Refresh != null) {
            const isBoundary = isReactRefreshBoundary(Refresh, pendingModule.publicModule.exports);
            if (isBoundary) {
              canAccept = true;
              refreshBoundaryIDs.add(pendingID);
            }
          }
          if (canAccept) {
            return [];
          }
          const parentIDs = inverseDependencies[pendingID];
          if (parentIDs.length === 0) {
            performFullRefresh('No root boundary', {
              source: mod,
              failed: pendingModule
            });
            didBailOut = true;
            return [];
          }
          return parentIDs;
        }, () => didBailOut).reverse();
      } catch (e) {
        if (e === CYCLE_DETECTED) {
          performFullRefresh('Dependency cycle', {
            source: mod
          });
          return;
        }
        throw e;
      }
      if (didBailOut) {
        return;
      }
      const seenModuleIDs = new Set();
      for (let i = 0; i < updatedModuleIDs.length; i++) {
        const updatedID = updatedModuleIDs[i];
        if (seenModuleIDs.has(updatedID)) {
          continue;
        }
        seenModuleIDs.add(updatedID);
        const updatedMod = modules.get(updatedID);
        if (updatedMod == null) {
          throw new Error('[Refresh] Expected to find the updated module.');
        }
        const prevExports = updatedMod.publicModule.exports;
        const didError = runUpdatedModule(updatedID, updatedID === id ? factory : undefined, updatedID === id ? dependencyMap : undefined);
        const nextExports = updatedMod.publicModule.exports;
        if (didError) {
          return;
        }
        if (refreshBoundaryIDs.has(updatedID)) {
          const isNoLongerABoundary = !isReactRefreshBoundary(Refresh, nextExports);
          const didInvalidate = shouldInvalidateReactRefreshBoundary(Refresh, prevExports, nextExports);
          if (isNoLongerABoundary || didInvalidate) {
            const parentIDs = inverseDependencies[updatedID];
            if (parentIDs.length === 0) {
              performFullRefresh(isNoLongerABoundary ? 'No longer a boundary' : 'Invalidated boundary', {
                source: mod,
                failed: updatedMod
              });
              return;
            }
            for (let j = 0; j < parentIDs.length; j++) {
              const parentID = parentIDs[j];
              const parentMod = modules.get(parentID);
              if (parentMod == null) {
                throw new Error('[Refresh] Expected to find parent module.');
              }
              const canAcceptParent = isReactRefreshBoundary(Refresh, parentMod.publicModule.exports);
              if (canAcceptParent) {
                refreshBoundaryIDs.add(parentID);
                updatedModuleIDs.push(parentID);
              } else {
                performFullRefresh('Invalidated boundary', {
                  source: mod,
                  failed: parentMod
                });
                return;
              }
            }
          }
        }
      }
      if (Refresh != null) {
        if (reactRefreshTimeout == null) {
          reactRefreshTimeout = setTimeout(() => {
            reactRefreshTimeout = null;
            Refresh.performReactRefresh();
          }, 30);
        }
      }
    };
    const topologicalSort = function (roots, getEdges, earlyStop) {
      const result = [];
      const visited = new Set();
      const stack = new Set();
      function traverseDependentNodes(node) {
        if (stack.has(node)) {
          throw CYCLE_DETECTED;
        }
        if (visited.has(node)) {
          return;
        }
        visited.add(node);
        stack.add(node);
        const dependentNodes = getEdges(node);
        if (earlyStop(node)) {
          stack.delete(node);
          return;
        }
        dependentNodes.forEach(dependent => {
          traverseDependentNodes(dependent);
        });
        stack.delete(node);
        result.push(node);
      }
      roots.forEach(root => {
        traverseDependentNodes(root);
      });
      return result;
    };
    const runUpdatedModule = function (id, factory, dependencyMap) {
      const mod = modules.get(id);
      if (mod == null) {
        throw new Error('[Refresh] Expected to find the module.');
      }
      const {
        hot
      } = mod;
      if (!hot) {
        throw new Error('[Refresh] Expected module.hot to always exist in DEV.');
      }
      if (hot._disposeCallback) {
        try {
          hot._disposeCallback();
        } catch (error) {
          console.error(`Error while calling dispose handler for module ${id}: `, error);
        }
      }
      if (factory) {
        mod.factory = factory;
      }
      if (dependencyMap) {
        mod.dependencyMap = dependencyMap;
      }
      mod.hasError = false;
      mod.error = undefined;
      mod.importedAll = EMPTY;
      mod.importedDefault = EMPTY;
      mod.isInitialized = false;
      const prevExports = mod.publicModule.exports;
      mod.publicModule.exports = {};
      hot._didAccept = false;
      hot._acceptCallback = null;
      hot._disposeCallback = null;
      metroRequire(id);
      if (mod.hasError) {
        mod.hasError = false;
        mod.isInitialized = true;
        mod.error = null;
        mod.publicModule.exports = prevExports;
        return true;
      }
      if (hot._acceptCallback) {
        try {
          hot._acceptCallback();
        } catch (error) {
          console.error(`Error while calling accept handler for module ${id}: `, error);
        }
      }
      return false;
    };
    const performFullRefresh = (reason, modules) => {
      if (typeof window !== 'undefined' && window.location != null && typeof window.location.reload === 'function') {
        window.location.reload();
      } else {
        const Refresh = requireRefresh();
        if (Refresh != null) {
          var _modules_source, _modules_failed;
          const sourceName = ((_modules_source = modules.source) == null ? void 0 : _modules_source.verboseName) ?? 'unknown';
          const failedName = ((_modules_failed = modules.failed) == null ? void 0 : _modules_failed.verboseName) ?? 'unknown';
          Refresh.performFullRefresh(`Fast Refresh - ${reason} <${sourceName}> <${failedName}>`);
        } else {
          console.warn('Could not reload the application after an edit.');
        }
      }
    };
    var isSpecifierSafeToCheck = (moduleExports, key) => {
      if (moduleExports && moduleExports.__esModule) {
        return true;
      } else {
        const desc = Object.getOwnPropertyDescriptor(moduleExports, key);
        return !desc || !desc.get;
      }
    };
    var isReactRefreshBoundary = function (Refresh, moduleExports) {
      if (Refresh.isLikelyComponentType(moduleExports)) {
        return true;
      }
      if (moduleExports == null || typeof moduleExports !== 'object') {
        return false;
      }
      let hasExports = false;
      let areAllExportsComponents = true;
      for (const key in moduleExports) {
        hasExports = true;
        if (key === '__esModule') {
          continue;
        } else if (!isSpecifierSafeToCheck(moduleExports, key)) {
          return false;
        }
        const exportValue = moduleExports[key];
        if (!Refresh.isLikelyComponentType(exportValue)) {
          areAllExportsComponents = false;
        }
      }
      return hasExports && areAllExportsComponents;
    };
    var shouldInvalidateReactRefreshBoundary = (Refresh, prevExports, nextExports) => {
      const prevSignature = getRefreshBoundarySignature(Refresh, prevExports);
      const nextSignature = getRefreshBoundarySignature(Refresh, nextExports);
      if (prevSignature.length !== nextSignature.length) {
        return true;
      }
      for (let i = 0; i < nextSignature.length; i++) {
        if (prevSignature[i] !== nextSignature[i]) {
          return true;
        }
      }
      return false;
    };
    var getRefreshBoundarySignature = (Refresh, moduleExports) => {
      const signature = [];
      signature.push(Refresh.getFamilyByType(moduleExports));
      if (moduleExports == null || typeof moduleExports !== 'object') {
        return signature;
      }
      for (const key in moduleExports) {
        if (key === '__esModule') {
          continue;
        } else if (!isSpecifierSafeToCheck(moduleExports, key)) {
          continue;
        }
        const exportValue = moduleExports[key];
        signature.push(key);
        signature.push(Refresh.getFamilyByType(exportValue));
      }
      return signature;
    };
    var registerExportsForReactRefresh = (Refresh, moduleExports, moduleID) => {
      Refresh.register(moduleExports, moduleID + ' %exports%');
      if (moduleExports == null || typeof moduleExports !== 'object') {
        return;
      }
      for (const key in moduleExports) {
        if (!isSpecifierSafeToCheck(moduleExports, key)) {
          continue;
        }
        const exportValue = moduleExports[key];
        const typeID = moduleID + ' %exports% ' + key;
        Refresh.register(exportValue, typeID);
      }
    };
    global.__accept = metroHotUpdateModule;
  }
  if (__DEV__) {
    var requireSystrace = function requireSystrace() {
      return global[__METRO_GLOBAL_PREFIX__ + '__SYSTRACE'] || metroRequire.Systrace;
    };
    var requireRefresh = function requireRefresh() {
      return global[__METRO_GLOBAL_PREFIX__ + '__ReactRefresh'] || global[global.__METRO_GLOBAL_PREFIX__ + '__ReactRefresh'] || metroRequire.Refresh;
    };
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  global.$$require_external = typeof require !== "undefined" ? m => require(m) : () => null;
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
/* HMR env vars from Expo CLI (dev-only) */ process.env=Object.defineProperties(process.env, {"EXPO_PUBLIC_PROJECT_ROOT": { enumerable: true, value: "C:\\Users\\kauan math\\Desktop\\ApiNoExpo" }});
(function (global) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   * @nolint
   * @polyfill
   */

  'use client';

  /* eslint-disable no-shadow, eqeqeq, no-unused-vars, no-control-regex  */

  /**
   * This pipes all of our console logging functions to native logging so that
   * JavaScript errors in required modules show up in Xcode via NSLog.
   */
  const inspect = function () {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    //
    // https://github.com/joyent/node/blob/master/lib/util.js

    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        formatValueCalls: 0,
        stylize: stylizeNoColor
      };
      return formatValue(ctx, obj, opts.depth);
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      ctx.formatValueCalls++;
      if (ctx.formatValueCalls > 200) {
        return `[TOO BIG formatValueCalls ${ctx.formatValueCalls} exceeded limit of 200]`;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
        array = false,
        braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value)) return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').slice(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, name.length - 1);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    function isNull(arg) {
      return arg === null;
    }
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    function isString(arg) {
      return typeof arg === 'string';
    }
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    function isUndefined(arg) {
      return arg === void 0;
    }
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    return inspect;
  }();
  const INDEX_COLUMN_NAME = '(index)';
  const LOG_LEVELS = {
    trace: 0,
    info: 1,
    warn: 2,
    error: 3
  };
  function getNativeLogFunction(level) {
    return function () {
      let str;
      if (arguments.length === 1 && typeof arguments[0] === 'string') {
        str = arguments[0];
      } else {
        str = Array.prototype.map.call(arguments, function (arg) {
          return inspect(arg, {
            depth: 10
          });
        }).join(', ');
      }

      // TRICKY
      // If more than one argument is provided, the code above collapses them all
      // into a single formatted string. This transform wraps string arguments in
      // single quotes (e.g. "foo" -> "'foo'") which then breaks the "Warning:"
      // check below. So it's important that we look at the first argument, rather
      // than the formatted argument string.
      const firstArg = arguments[0];
      let logLevel = level;
      if (typeof firstArg === 'string' && firstArg.slice(0, 9) === 'Warning: ' && logLevel >= LOG_LEVELS.error) {
        // React warnings use console.error so that a stack trace is shown,
        // but we don't (currently) want these to show a redbox
        // (Note: Logic duplicated in ExceptionsManager.js.)
        logLevel = LOG_LEVELS.warn;
      }
      if (groupStack.length) {
        str = groupFormat('', str);
      }
      global.nativeLoggingHook(str, logLevel);
    };
  }
  function repeat(element, n) {
    return Array.apply(null, Array(n)).map(function () {
      return element;
    });
  }
  function formatCellValue(cell, key) {
    if (key === INDEX_COLUMN_NAME) {
      return cell[key];
    }
    if (cell.hasOwnProperty(key)) {
      var cellValue = cell[key];
      switch (typeof cellValue) {
        case 'function':
          return 'ƒ';
        case 'string':
          return "'" + cellValue + "'";
        case 'object':
          return cellValue == null ? 'null' : '{…}';
      }
      return String(cellValue);
    }
    return '';
  }
  function consoleTablePolyfill(data, columns) {
    var rows;

    // convert object -> array
    if (Array.isArray(data)) {
      rows = data.map((row, index) => {
        var processedRow = {};
        processedRow[INDEX_COLUMN_NAME] = String(index);
        Object.assign(processedRow, row);
        return processedRow;
      });
    } else {
      rows = [];
      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          var processedRow = {};
          processedRow[INDEX_COLUMN_NAME] = key;
          Object.assign(processedRow, data[key]);
          rows.push(processedRow);
        }
      }
    }
    if (rows.length === 0) {
      global.nativeLoggingHook('', LOG_LEVELS.info);
      return;
    }
    if (Array.isArray(columns)) {
      columns = [INDEX_COLUMN_NAME].concat(columns);
    } else {
      columns = Array.from(rows.reduce((columnSet, row) => {
        Object.keys(row).forEach(key => columnSet.add(key));
        return columnSet;
      }, new Set()));
    }
    var stringRows = [];
    var columnWidths = [];

    // Convert each cell to a string. Also
    // figure out max cell width for each column
    columns.forEach(function (k, i) {
      columnWidths[i] = k.length;
      for (var j = 0; j < rows.length; j++) {
        var cellStr = formatCellValue(rows[j], k);
        stringRows[j] = stringRows[j] || [];
        stringRows[j][i] = cellStr;
        columnWidths[i] = Math.max(columnWidths[i], cellStr.length);
      }
    });

    // Join all elements in the row into a single string with | separators
    // (appends extra spaces to each cell to make separators  | aligned)
    function joinRow(row, space) {
      var cells = row.map(function (cell, i) {
        var extraSpaces = repeat(' ', columnWidths[i] - cell.length).join('');
        return cell + extraSpaces;
      });
      space = space || ' ';
      return '| ' + cells.join(space + '|' + space) + ' |';
    }
    var separators = columnWidths.map(function (columnWidth) {
      return repeat('-', columnWidth).join('');
    });
    var separatorRow = joinRow(separators);
    var header = joinRow(columns);
    var table = [header, separatorRow];
    for (var i = 0; i < rows.length; i++) {
      table.push(joinRow(stringRows[i]));
    }

    // Notice extra empty line at the beginning.
    // Native logging hook adds "RCTLog >" at the front of every
    // logged string, which would shift the header and screw up
    // the table
    global.nativeLoggingHook('\n' + table.join('\n'), LOG_LEVELS.info);
  }
  const GROUP_PAD = '\u2502'; // Box light vertical
  const GROUP_OPEN = '\u2510'; // Box light down+left
  const GROUP_CLOSE = '\u2518'; // Box light up+left

  const groupStack = [];
  function groupFormat(prefix, msg) {
    // Insert group formatting before the console message
    return groupStack.join('') + prefix + ' ' + (msg || '');
  }
  function consoleGroupPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_OPEN, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }
  function consoleGroupCollapsedPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }
  function consoleGroupEndPolyfill() {
    groupStack.pop();
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE), LOG_LEVELS.info);
  }
  function consoleAssertPolyfill(expression, label) {
    if (!expression) {
      global.nativeLoggingHook('Assertion failed: ' + label, LOG_LEVELS.error);
    }
  }

  // https://developer.mozilla.org/en-US/docs/Web/API/console/timeStamp_static.
  // Non-standard API for recording markers on a timeline of the Performance instrumentation.
  // The actual logging is not provided by definition.
  function consoleTimeStampPolyfill() {}
  if (global.nativeLoggingHook) {
    const originalConsole = global.console;
    // Preserve the original `console` as `originalConsole`
    if (__DEV__ && originalConsole) {
      const descriptor = Object.getOwnPropertyDescriptor(global, 'console');
      if (descriptor) {
        Object.defineProperty(global, 'originalConsole', descriptor);
      }
    }
    global.console = Object.assign({
      timeStamp: consoleTimeStampPolyfill
    }, originalConsole ?? {}, {
      error: getNativeLogFunction(LOG_LEVELS.error),
      info: getNativeLogFunction(LOG_LEVELS.info),
      log: getNativeLogFunction(LOG_LEVELS.info),
      warn: getNativeLogFunction(LOG_LEVELS.warn),
      trace: getNativeLogFunction(LOG_LEVELS.trace),
      debug: getNativeLogFunction(LOG_LEVELS.trace),
      table: consoleTablePolyfill,
      group: consoleGroupPolyfill,
      groupEnd: consoleGroupEndPolyfill,
      groupCollapsed: consoleGroupCollapsedPolyfill,
      assert: consoleAssertPolyfill
    });

    // TODO(T206796580): This was copy-pasted from ExceptionsManager.js
    // Delete the copy there after the c++ pipeline is rolled out everywhere.
    if (global.RN$useAlwaysAvailableJSErrorHandling === true) {
      let originalConsoleError = console.error;
      console.reportErrorsAsExceptions = true;
      function stringifySafe(arg) {
        return inspect(arg, {
          depth: 10
        }).replace(/\n\s*/g, ' ');
      }
      console.error = function (...args) {
        originalConsoleError.apply(this, args);
        if (!console.reportErrorsAsExceptions) {
          return;
        }
        if (global.RN$inExceptionHandler?.()) {
          return;
        }
        let error;
        const firstArg = args[0];
        if (firstArg?.stack) {
          // RN$handleException will console.error this with high enough fidelity.
          error = firstArg;
        } else {
          if (typeof firstArg === 'string' && firstArg.startsWith('Warning: ')) {
            // React warnings use console.error so that a stack trace is shown, but
            // we don't (currently) want these to show a redbox
            return;
          }
          const message = args.map(arg => typeof arg === 'string' ? arg : stringifySafe(arg)).join(' ');
          error = new Error(message);
          error.name = 'console.error';
        }
        const isFatal = false;
        const reportToConsole = false;
        global.RN$handleException(error, isFatal, reportToConsole);
      };
    }
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });

    // If available, also call the original `console` method since that is
    // sometimes useful. Ex: on OS X, this will let you see rich output in
    // the Safari Web Inspector console.
    if (__DEV__ && originalConsole) {
      Object.keys(console).forEach(methodName => {
        const reactNativeMethod = console[methodName];
        if (originalConsole[methodName] && reactNativeMethod !== originalConsole[methodName]) {
          console[methodName] = function () {
            originalConsole[methodName](...arguments);
            reactNativeMethod.apply(console, arguments);
          };
        }
      });

      // The following methods are not supported by this polyfill but
      // we still should pass them to original console if they are
      // supported by it.
      ['clear', 'dir', 'dirxml', 'profile', 'profileEnd'].forEach(methodName => {
        if (typeof originalConsole[methodName] === 'function') {
          console[methodName] = function () {
            originalConsole[methodName](...arguments);
          };
        }
      });
    }
  } else if (!global.console) {
    function stub() {}
    const log = global.print || stub;
    global.console = {
      debug: log,
      error: log,
      info: log,
      log: log,
      trace: log,
      warn: log,
      assert(expression, label) {
        if (!expression) {
          log('Assertion failed: ' + label);
        }
      },
      clear: stub,
      dir: stub,
      dirxml: stub,
      group: stub,
      groupCollapsed: stub,
      groupEnd: stub,
      profile: stub,
      profileEnd: stub,
      table: stub,
      timeStamp: stub
    };
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  let _inGuard = 0;
  let _globalHandler = global.RN$useAlwaysAvailableJSErrorHandling === true ? global.RN$handleException : (e, isFatal) => {
    throw e;
  };
  const ErrorUtils = {
    setGlobalHandler(fun) {
      _globalHandler = fun;
    },
    getGlobalHandler() {
      return _globalHandler;
    },
    reportError(error) {
      _globalHandler && _globalHandler(error, false);
    },
    reportFatalError(error) {
      _globalHandler && _globalHandler(error, true);
    },
    applyWithGuard(fun, context, args, unused_onError, unused_name) {
      try {
        _inGuard++;
        return fun.apply(context, args);
      } catch (e) {
        ErrorUtils.reportError(e);
      } finally {
        _inGuard--;
      }
      return null;
    },
    applyWithGuardIfNeeded(fun, context, args) {
      if (ErrorUtils.inGuard()) {
        return fun.apply(context, args);
      } else {
        ErrorUtils.applyWithGuard(fun, context, args);
      }
      return null;
    },
    inGuard() {
      return !!_inGuard;
    },
    guard(fun, name, context) {
      if (typeof fun !== 'function') {
        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);
        return null;
      }
      const guardName = name ?? fun.name ?? '<generated guard>';
      function guarded(...args) {
        return ErrorUtils.applyWithGuard(fun, context ?? this, args, null, guardName);
      }
      return guarded;
    }
  };
  global.ErrorUtils = ErrorUtils;
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0], "expo-router/entry-classic");
},0,[1],"node_modules/expo-router/entry.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0], "@expo/metro-runtime");
  var _expoRouterBuildQualifiedEntry = require(_dependencyMap[1], "expo-router/build/qualified-entry");
  var _expoRouterBuildRenderRootComponent = require(_dependencyMap[2], "expo-router/build/renderRootComponent");
  // `@expo/metro-runtime` MUST be the first import to ensure Fast Refresh works
  // on web.

  // This file should only import and register the root. No components or exports
  // should be added here.
  (0, _expoRouterBuildRenderRootComponent.renderRootComponent)(_expoRouterBuildQualifiedEntry.App);
},1,[2,242,742],"node_modules/expo-router/entry-classic.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0], "./location/install");
  require(_dependencyMap[1], "@expo/metro-runtime/rsc/runtime");
  /**
   * Copyright © 2023 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  if (__DEV__) {
    require(_dependencyMap[2], "./metroServerLogs").captureStackForServerLogs();

    // TODO: Remove when fixed upstream. Expected in RN 0.82.
    // https://github.com/facebook/react-native/commit/c4082c9ce208a324c2d011823ca2ba432411aafc
    require(_dependencyMap[3], "./promiseRejectionTracking").enablePromiseRejectionTracking();

    // @ts-expect-error: TODO: Remove this when we remove the log box.
    globalThis.__expo_dev_resetErrors = require(_dependencyMap[4], "./error-overlay/LogBox").default.clearAllLogs;
  }
},2,[3,4,5,6,7],"node_modules/@expo/metro-runtime/src/index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},3,[],"node_modules/@expo/metro-runtime/src/location/install.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright © 2024 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // React Native's error handling is full of bugs which cause the app to crash in production.
  // We'll disable their handling in production native builds to ensure missing modules are shown to the user.
  const disableReactNativeMissingModuleHandling = !__DEV__ && (false || typeof window === 'undefined');
  globalThis.__webpack_chunk_load__ = id => {
    return global[`${__METRO_GLOBAL_PREFIX__}__loadBundleAsync`](id);
  };
  globalThis.__webpack_require__ = id => {
    // This logic can be tested by running a production iOS build without virtual client boundaries. This will result in all split chunks being missing and
    // errors being thrown on RSC load.

    const original = ErrorUtils.reportFatalError;
    if (disableReactNativeMissingModuleHandling) {
      ErrorUtils.reportFatalError = err => {
        // Throw the error so the __r function exits as expected. The error will then be caught by the nearest error boundary.
        throw err;
      };
    }
    try {
      return global[`${__METRO_GLOBAL_PREFIX__}__r`](id);
    } finally {
      // Restore the original error handling.
      if (disableReactNativeMissingModuleHandling) {
        ErrorUtils.reportFatalError = original;
      }
    }
  };
},4,[],"node_modules/@expo/metro-runtime/rsc/runtime.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.captureStackForServerLogs = captureStackForServerLogs;
  function captureStackForServerLogs() {}
},5,[],"node_modules/@expo/metro-runtime/src/metroServerLogs.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.enablePromiseRejectionTracking = enablePromiseRejectionTracking;
  // NOTE(@krystofwoldrich): This is only needed for native runtimes (hermes)
  function enablePromiseRejectionTracking() {}
},6,[],"node_modules/@expo/metro-runtime/src/promiseRejectionTracking.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "LogData", {
    enumerable: true,
    get: function () {
      return _DataLogBoxData.LogData;
    }
  });
  Object.defineProperty(exports, "ExtendedExceptionData", {
    enumerable: true,
    get: function () {
      return _DataParseLogBoxLog.ExtendedExceptionData;
    }
  });
  Object.defineProperty(exports, "IgnorePattern", {
    enumerable: true,
    get: function () {
      return _DataLogBoxData.IgnorePattern;
    }
  });
  var _DataLogBoxData = require(_dependencyMap[0], "./Data/LogBoxData");
  var _DataParseLogBoxLog = require(_dependencyMap[1], "./Data/parseLogBoxLog");
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  let LogBox;
  /**
   * LogBox displays logs in the app.
   */
  if (__DEV__) {
    const LogBoxData = require(_dependencyMap[2], "./Data/LogBoxData");
    const {
      parseLogBoxLog,
      parseInterpolation
    } = require(_dependencyMap[3], "./Data/parseLogBoxLog");
    let originalConsoleError;
    let consoleErrorImpl;
    let isLogBoxInstalled = false;
    LogBox = {
      install() {
        if (isLogBoxInstalled) {
          return;
        }
        isLogBoxInstalled = true;

        // Trigger lazy initialization of module.
        // require("../NativeModules/specs/NativeLogBox");

        // IMPORTANT: we only overwrite `console.error` and `console.warn` once.
        // When we uninstall we keep the same reference and only change its
        // internal implementation
        const isFirstInstall = originalConsoleError == null;
        if (isFirstInstall) {
          originalConsoleError = console.error.bind(console);
          console.error = (...args) => {
            consoleErrorImpl?.(...args);
          };
        }
        consoleErrorImpl = registerError;
        if (process.env.NODE_ENV === 'test') {
          LogBoxData.setDisabled(true);
        }
      },
      uninstall() {
        if (!isLogBoxInstalled) {
          return;
        }
        isLogBoxInstalled = false;

        // IMPORTANT: we don't re-assign to `console` in case the method has been
        // decorated again after installing LogBox. E.g.:
        // Before uninstalling: original > LogBox > OtherErrorHandler
        // After uninstalling:  original > LogBox (noop) > OtherErrorHandler
        consoleErrorImpl = originalConsoleError;
        delete console.disableLogBox;
      },
      isInstalled() {
        return isLogBoxInstalled;
      },
      ignoreLogs(patterns) {
        LogBoxData.addIgnorePatterns(patterns);
      },
      ignoreAllLogs(value) {
        LogBoxData.setDisabled(value == null ? true : value);
      },
      clearAllLogs() {
        LogBoxData.clear();
      },
      addLog(log) {
        if (isLogBoxInstalled) {
          LogBoxData.addLog(log);
        }
      },
      addException(error) {
        if (isLogBoxInstalled) {
          LogBoxData.addException(error);
        }
      }
    };
    const isWarningModuleWarning = (...args) => {
      return typeof args[0] === 'string' && args[0].startsWith('Warning: ');
    };
    const registerError = (...args) => {
      // Let errors within LogBox itself fall through.
      if (LogBoxData.isLogBoxErrorMessage(args[0])) {
        originalConsoleError?.(...args);
        return;
      }
      try {
        if (!isWarningModuleWarning(...args)) {
          // Only show LogBox for the 'warning' module, otherwise pass through.
          // By passing through, this will get picked up by the React console override,
          // potentially adding the component stack. React then passes it back to the
          // React Native ExceptionsManager, which reports it to LogBox as an error.
          //
          // The 'warning' module needs to be handled here because React internally calls
          // `console.error('Warning: ')` with the component stack already included.
          originalConsoleError?.(...args);
          return;
        }
        const {
          category,
          message,
          componentStack
        } = parseLogBoxLog(args);
        if (!LogBoxData.isMessageIgnored(message.content)) {
          // Interpolate the message so they are formatted for adb and other CLIs.
          // This is different than the message.content above because it includes component stacks.
          const interpolated = parseInterpolation(args);
          originalConsoleError?.(interpolated.message.content);
          LogBoxData.addLog({
            // Always show the static rendering issues as full screen since they
            // are too confusing otherwise.
            level: /did not match\. Server:/.test(message.content) ? 'fatal' : 'error',
            category,
            message,
            componentStack
          });
        }
      } catch (err) {
        LogBoxData.reportUnexpectedLogBoxError(err);
      }
    };
  } else {
    LogBox = {
      install() {},
      uninstall() {},
      isInstalled() {
        return false;
      },
      ignoreLogs(_patterns) {},
      ignoreAllLogs(_value) {},
      clearAllLogs() {},
      addLog(_log) {},
      addException(_ex) {}
    };
  }
  var _default = LogBox;
},7,[8,22,8,22],"node_modules/@expo/metro-runtime/src/error-overlay/LogBox.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use client';
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\Data\\LogBoxData.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.reportLogBoxError = reportLogBoxError;
  exports.reportUnexpectedLogBoxError = reportUnexpectedLogBoxError;
  exports.isLogBoxErrorMessage = isLogBoxErrorMessage;
  exports.isMessageIgnored = isMessageIgnored;
  exports.addLog = addLog;
  exports.addException = addException;
  exports.symbolicateLogNow = symbolicateLogNow;
  exports.retrySymbolicateLogNow = retrySymbolicateLogNow;
  exports.symbolicateLogLazy = symbolicateLogLazy;
  exports.clear = clear;
  exports.setSelectedLog = setSelectedLog;
  exports.clearWarnings = clearWarnings;
  exports.clearErrors = clearErrors;
  exports.dismiss = dismiss;
  exports.getIgnorePatterns = getIgnorePatterns;
  exports.addIgnorePatterns = addIgnorePatterns;
  exports.setDisabled = setDisabled;
  exports.isDisabled = isDisabled;
  exports.observe = observe;
  exports.withSubscription = withSubscription;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsNativeEventEmitter = require(_dependencyMap[1], "react-native-web/dist/exports/NativeEventEmitter");
  var NativeEventEmitter = _interopDefault(_reactNativeWebDistExportsNativeEventEmitter);
  var _LogBoxLog = require(_dependencyMap[2], "./LogBoxLog");
  var _LogContext = require(_dependencyMap[3], "./LogContext");
  var _parseLogBoxLog = require(_dependencyMap[4], "./parseLogBoxLog");
  var _modulesNativeLogBox = require(_dependencyMap[5], "../modules/NativeLogBox");
  var NativeLogBox = _interopDefault(_modulesNativeLogBox);
  var _modulesParseErrorStack = require(_dependencyMap[6], "../modules/parseErrorStack");
  var parseErrorStack = _interopDefault(_modulesParseErrorStack);
  var _reactJsxDevRuntime = require(_dependencyMap[7], "react/jsx-dev-runtime");
  const observers = new Set();
  const ignorePatterns = new Set();
  let logs = new Set();
  let updateTimeout = null;
  let _isDisabled = false;
  let _selectedIndex = -1;
  const LOGBOX_ERROR_MESSAGE = 'An error was thrown when attempting to render log messages via LogBox.';
  function getNextState() {
    return {
      logs,
      isDisabled: _isDisabled,
      selectedLogIndex: _selectedIndex
    };
  }
  function reportLogBoxError(error, componentStack) {
    const ExceptionsManager = require(_dependencyMap[8], "../modules/ExceptionsManager").default;
    if (componentStack != null) {
      error.componentStack = componentStack;
    }
    ExceptionsManager.handleException(error);
  }
  function reportUnexpectedLogBoxError(error, componentStack) {
    error.message = `${LOGBOX_ERROR_MESSAGE}\n\n${error.message}`;
    return reportLogBoxError(error, componentStack);
  }
  function isLogBoxErrorMessage(message) {
    return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);
  }
  function isMessageIgnored(message) {
    for (const pattern of ignorePatterns) {
      if (pattern instanceof RegExp && pattern.test(message) || typeof pattern === 'string' && message.includes(pattern)) {
        return true;
      }
    }
    return false;
  }
  function handleUpdate() {
    if (updateTimeout == null) {
      updateTimeout = setTimeout(() => {
        updateTimeout = null;
        const nextState = getNextState();
        observers.forEach(({
          observer
        }) => observer(nextState));
      }, 0);
    }
  }
  function appendNewLog(newLog) {
    // Don't want store these logs because they trigger a
    // state update when we add them to the store.
    if (isMessageIgnored(newLog.message.content)) {
      return;
    }

    // If the next log has the same category as the previous one
    // then roll it up into the last log in the list by incrementing
    // the count (similar to how Chrome does it).
    const lastLog = Array.from(logs).pop();
    if (lastLog && lastLog.category === newLog.category) {
      lastLog.incrementCount();
      handleUpdate();
      return;
    }
    if (newLog.level === 'fatal') {
      // If possible, to avoid jank, we don't want to open the error before
      // it's symbolicated. To do that, we optimistically wait for
      // symbolication for up to a second before adding the log.
      const OPTIMISTIC_WAIT_TIME = 1000;
      let addPendingLog = () => {
        logs.add(newLog);
        if (_selectedIndex < 0) {
          setSelectedLog(logs.size - 1);
        } else {
          handleUpdate();
        }
        addPendingLog = null;
      };
      const optimisticTimeout = setTimeout(() => {
        if (addPendingLog) {
          addPendingLog();
        }
      }, OPTIMISTIC_WAIT_TIME);

      // TODO: HANDLE THIS
      newLog.symbolicate('component');
      newLog.symbolicate('stack', status => {
        if (addPendingLog && status !== 'PENDING') {
          addPendingLog();
          clearTimeout(optimisticTimeout);
        } else if (status !== 'PENDING') {
          // The log has already been added but we need to trigger a render.
          handleUpdate();
        }
      });
    } else if (newLog.level === 'syntax') {
      logs.add(newLog);
      setSelectedLog(logs.size - 1);
    } else {
      logs.add(newLog);
      handleUpdate();
    }
  }
  function addLog(log) {
    const errorForStackTrace = new Error();

    // Parsing logs are expensive so we schedule this
    // otherwise spammy logs would pause rendering.
    setTimeout(() => {
      try {
        const stack = (0, parseErrorStack.default)(errorForStackTrace?.stack);
        appendNewLog(new _LogBoxLog.LogBoxLog({
          level: log.level,
          message: log.message,
          isComponentError: false,
          stack,
          category: log.category,
          componentStack: log.componentStack
        }));
      } catch (error) {
        reportUnexpectedLogBoxError(error);
      }
    }, 0);
  }
  function addException(error) {
    // Parsing logs are expensive so we schedule this
    // otherwise spammy logs would pause rendering.
    setTimeout(() => {
      try {
        appendNewLog(new _LogBoxLog.LogBoxLog((0, _parseLogBoxLog.parseLogBoxException)(error)));
      } catch (loggingError) {
        reportUnexpectedLogBoxError(loggingError);
      }
    }, 0);
  }
  function symbolicateLogNow(type, log) {
    log.symbolicate(type, () => {
      handleUpdate();
    });
  }
  function retrySymbolicateLogNow(type, log) {
    log.retrySymbolicate(type, () => {
      handleUpdate();
    });
  }
  function symbolicateLogLazy(type, log) {
    log.symbolicate(type);
  }
  function clear() {
    if (logs.size > 0) {
      logs = new Set();
      setSelectedLog(-1);
    }
  }
  function setSelectedLog(proposedNewIndex) {
    const oldIndex = _selectedIndex;
    let newIndex = proposedNewIndex;
    const logArray = Array.from(logs);
    let index = logArray.length - 1;
    while (index >= 0) {
      // The latest syntax error is selected and displayed before all other logs.
      if (logArray[index].level === 'syntax') {
        newIndex = index;
        break;
      }
      index -= 1;
    }
    _selectedIndex = newIndex;
    handleUpdate();
    if (NativeLogBox.default) {
      setTimeout(() => {
        if (oldIndex < 0 && newIndex >= 0) {
          NativeLogBox.default.show();
        } else if (oldIndex >= 0 && newIndex < 0) {
          NativeLogBox.default.hide();
        }
      }, 0);
    }
  }
  function clearWarnings() {
    const newLogs = Array.from(logs).filter(log => log.level !== 'warn');
    if (newLogs.length !== logs.size) {
      logs = new Set(newLogs);
      setSelectedLog(-1);
      handleUpdate();
    }
  }
  function clearErrors() {
    const newLogs = Array.from(logs).filter(log => log.level !== 'error' && log.level !== 'fatal');
    if (newLogs.length !== logs.size) {
      logs = new Set(newLogs);
      setSelectedLog(-1);
    }
  }
  function dismiss(log) {
    if (logs.has(log)) {
      logs.delete(log);
      handleUpdate();
    }
  }
  function getIgnorePatterns() {
    return Array.from(ignorePatterns);
  }
  function addIgnorePatterns(patterns) {
    const existingSize = ignorePatterns.size;
    // The same pattern may be added multiple times, but adding a new pattern
    // can be expensive so let's find only the ones that are new.
    patterns.forEach(pattern => {
      if (pattern instanceof RegExp) {
        for (const existingPattern of ignorePatterns) {
          if (existingPattern instanceof RegExp && existingPattern.toString() === pattern.toString()) {
            return;
          }
        }
        ignorePatterns.add(pattern);
      }
      ignorePatterns.add(pattern);
    });
    if (ignorePatterns.size === existingSize) {
      return;
    }
    // We need to recheck all of the existing logs.
    // This allows adding an ignore pattern anywhere in the codebase.
    // Without this, if you ignore a pattern after the a log is created,
    // then we would keep showing the log.
    logs = new Set(Array.from(logs).filter(log => !isMessageIgnored(log.message.content)));
    handleUpdate();
  }
  function setDisabled(value) {
    if (value === _isDisabled) {
      return;
    }
    _isDisabled = value;
    handleUpdate();
  }
  function isDisabled() {
    return _isDisabled;
  }
  function observe(observer) {
    const subscription = {
      observer
    };
    observers.add(subscription);
    observer(getNextState());
    return {
      unsubscribe() {
        observers.delete(subscription);
      }
    };
  }
  const emitter = new NativeEventEmitter.default({
    addListener() {},
    removeListeners() {}
  });
  function withSubscription(WrappedComponent) {
    class LogBoxStateSubscription extends React.Component {
      static getDerivedStateFromError() {
        return {
          hasError: true
        };
      }
      constructor(props) {
        super(props);
        if (process.env.NODE_ENV === 'development') {
          emitter.addListener('devLoadingView:hide', () => {
            if (this.state.hasError) {
              this.retry();
            }
          });
        }
      }
      componentDidCatch(err, errorInfo) {
        /* $FlowFixMe[class-object-subtyping] added when improving typing for
         * this parameters */
        reportLogBoxError(err, errorInfo.componentStack);
      }
      state = {
        logs: new Set(),
        isDisabled: false,
        hasError: false,
        selectedLogIndex: -1
      };
      retry = () => {
        return new Promise(resolve => {
          this.setState({
            hasError: false
          }, () => {
            resolve();
          });
        });
      };
      render() {
        return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_LogContext.LogContext.Provider, {
          value: {
            selectedLogIndex: this.state.selectedLogIndex,
            isDisabled: this.state.isDisabled,
            logs: Array.from(this.state.logs)
          },
          children: [this.state.hasError ? null : this.props.children, /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(WrappedComponent, {}, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 408,
            columnNumber: 11
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 401,
          columnNumber: 9
        }, this);
      }
      componentDidMount() {
        this._subscription = observe(data => {
          // Ignore the initial empty log
          if (data.selectedLogIndex === -1) return;
          React.startTransition(() => {
            this.setState(data);
          });
        });
      }
      componentWillUnmount() {
        if (this._subscription != null) {
          this._subscription.unsubscribe();
        }
      }
      _handleDismiss = () => {
        // Here we handle the cases when the log is dismissed and it
        // was either the last log, or when the current index
        // is now outside the bounds of the log array.
        const {
          selectedLogIndex,
          logs: stateLogs
        } = this.state;
        const logsArray = Array.from(stateLogs);
        if (selectedLogIndex != null) {
          if (logsArray.length - 1 <= 0) {
            setSelectedLog(-1);
          } else if (selectedLogIndex >= logsArray.length - 1) {
            setSelectedLog(selectedLogIndex - 1);
          }
          dismiss(logsArray[selectedLogIndex]);
        }
      };
      _handleMinimize = () => {
        setSelectedLog(-1);
      };
      _handleSetSelectedLog = index => {
        setSelectedLog(index);
      };
    }

    // @ts-expect-error
    return LogBoxStateSubscription;
  }
},8,[9,12,18,21,22,26,23,33,241],"node_modules/@expo/metro-runtime/src/error-overlay/Data/LogBoxData.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react.development.js");
  }
},9,[10,11],"node_modules/react/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},10,[],"node_modules/metro-runtime/src/modules/empty-module.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function () {
          console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
        }
      });
    }
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = !0);
    }
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_CONTEXT_TYPE:
          return (type.displayName || "Context") + ".Provider";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x) {}
      }
      return null;
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE) return "<>";
      if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
      self = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
        enumerable: !1,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", {
        enumerable: !1,
        value: null
      });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(oldElement.type, newKey, void 0, void 0, oldElement._owner, oldElement.props, oldElement._debugStack, oldElement._debugTask);
      oldElement._store && (newKey._store.validated = oldElement._store.validated);
      return newKey;
    }
    function isValidElement(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
      var escaperLookup = {
        "=": "=0",
        ":": "=2"
      };
      return "$" + key.replace(/[=:]/g, function (match) {
        return escaperLookup[match];
      });
    }
    function getElementKey(element, index) {
      return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
    }
    function noop$1() {}
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function (fulfilledValue) {
            "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          }, function (error) {
            "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
          })), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = !1;
      if (null === children) invokeCallback = !0;else switch (type) {
        case "bigint":
        case "string":
        case "number":
          invokeCallback = !0;
          break;
        case "object":
          switch (children.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              invokeCallback = !0;
              break;
            case REACT_LAZY_TYPE:
              return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
          }
      }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function (c) {
          return c;
        })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children)) for (var i = 0; i < children.length; i++) nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if (i = getIteratorFn(children), "function" === typeof i) for (i === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0), children = i.call(children), i = 0; !(nameSoFar = children.next()).done;) nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if ("object" === type) {
        if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
        array = String(children);
        throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [],
        count = 0;
      mapIntoArray(children, result, "", "", function (child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(function (moduleObject) {
          if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
        }, function (error) {
          if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
        });
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return ctor = payload._result, void 0 === ctor && console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", ctor), "default" in ctor || console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", ctor), ctor.default;
      throw payload._result;
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
      return dispatcher;
    }
    function noop() {}
    function enqueueTask(task) {
      if (null === enqueueTaskImpl) try {
        var requireString = ("require" + Math.random()).slice(0, 7);
        enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
      } catch (_err) {
        enqueueTaskImpl = function (callback) {
          !1 === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = !0, "undefined" === typeof MessageChannel && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
          var channel = new MessageChannel();
          channel.port1.onmessage = callback;
          channel.port2.postMessage(void 0);
        };
      }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors) {
      return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
      prevActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
      actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      var queue = ReactSharedInternals.actQueue;
      if (null !== queue) if (0 !== queue.length) try {
        flushActQueue(queue);
        enqueueTask(function () {
          return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
        });
        return;
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      } else ReactSharedInternals.actQueue = null;
      0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = !0;
        var i = 0;
        try {
          for (; i < queue.length; i++) {
            var callback = queue[i];
            do {
              ReactSharedInternals.didUsePromise = !1;
              var continuation = callback(!1);
              if (null !== continuation) {
                if (ReactSharedInternals.didUsePromise) {
                  queue[i] = callback;
                  queue.splice(0, i);
                  return;
                }
                callback = continuation;
              } else break;
            } while (1);
          }
          queue.length = 0;
        } catch (error) {
          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
        } finally {
          isFlushing = !1;
        }
      }
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      didWarnStateUpdateForUnmountedComponent = {},
      ReactNoopUpdateQueue = {
        isMounted: function () {
          return !1;
        },
        enqueueForceUpdate: function (publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function (publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function (publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      },
      assign = Object.assign,
      emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function (partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
        isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
        replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
      },
      fnName;
    for (fnName in deprecatedAPIs) deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = !0;
    var isArrayImpl = Array.isArray,
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      },
      hasOwnProperty = Object.prototype.hasOwnProperty,
      createTask = console.createTask ? console.createTask : function () {
        return null;
      };
    deprecatedAPIs = {
      "react-stack-bottom-frame": function (callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = deprecatedAPIs["react-stack-bottom-frame"].bind(deprecatedAPIs, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutMaps = !1,
      userProvidedKeyEscapeRegex = /\/+/g,
      reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error: error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      },
      didWarnAboutMessageChannel = !1,
      enqueueTaskImpl = null,
      actScopeDepth = 0,
      didWarnNoAwaitAct = !1,
      isFlushing = !1,
      queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function (callback) {
        queueMicrotask(function () {
          return queueMicrotask(callback);
        });
      } : enqueueTask;
    deprecatedAPIs = Object.freeze({
      __proto__: null,
      c: function (size) {
        return resolveDispatcher().useMemoCache(size);
      }
    });
    exports.Children = {
      map: mapChildren,
      forEach: function (children, forEachFunc, forEachContext) {
        mapChildren(children, function () {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      },
      count: function (children) {
        var n = 0;
        mapChildren(children, function () {
          n++;
        });
        return n;
      },
      toArray: function (children) {
        return mapChildren(children, function (child) {
          return child;
        }) || [];
      },
      only: function (children) {
        if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = deprecatedAPIs;
    exports.act = function (callback) {
      var prevActQueue = ReactSharedInternals.actQueue,
        prevActScopeDepth = actScopeDepth;
      actScopeDepth++;
      var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [],
        didAwaitActCall = !1;
      try {
        var result = callback();
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      }
      if (0 < ReactSharedInternals.thrownErrors.length) throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      if (null !== result && "object" === typeof result && "function" === typeof result.then) {
        var thenable = result;
        queueSeveralMicrotasks(function () {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
        });
        return {
          then: function (resolve, reject) {
            didAwaitActCall = !0;
            thenable.then(function (returnValue) {
              popActScope(prevActQueue, prevActScopeDepth);
              if (0 === prevActScopeDepth) {
                try {
                  flushActQueue(queue), enqueueTask(function () {
                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  });
                } catch (error$0) {
                  ReactSharedInternals.thrownErrors.push(error$0);
                }
                if (0 < ReactSharedInternals.thrownErrors.length) {
                  var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                  ReactSharedInternals.thrownErrors.length = 0;
                  reject(_thrownError);
                }
              } else resolve(returnValue);
            }, function (error) {
              popActScope(prevActQueue, prevActScopeDepth);
              0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
            });
          }
        };
      }
      var returnValue$jscomp$0 = result;
      popActScope(prevActQueue, prevActScopeDepth);
      0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function () {
        didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
      }), ReactSharedInternals.actQueue = null);
      if (0 < ReactSharedInternals.thrownErrors.length) throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      return {
        then: function (resolve, reject) {
          didAwaitActCall = !0;
          0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function () {
            return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);
          })) : resolve(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function (fn) {
      return function () {
        return fn.apply(null, arguments);
      };
    };
    exports.captureOwnerStack = function () {
      var getCurrentStack = ReactSharedInternals.getCurrentStack;
      return null === getCurrentStack ? null : getCurrentStack();
    };
    exports.cloneElement = function (element, config, children) {
      if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
      var props = assign({}, element.props),
        key = element.key,
        owner = element._owner;
      if (null != config) {
        var JSCompiler_inline_result;
        a: {
          if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config, "ref").get) && JSCompiler_inline_result.isReactWarning) {
            JSCompiler_inline_result = !1;
            break a;
          }
          JSCompiler_inline_result = void 0 !== config.ref;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
        for (propName in config) !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      }
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;else if (1 < propName) {
        JSCompiler_inline_result = Array(propName);
        for (var i = 0; i < propName; i++) JSCompiler_inline_result[i] = arguments[i + 2];
        props.children = JSCompiler_inline_result;
      }
      props = ReactElement(element.type, key, void 0, void 0, owner, props, element._debugStack, element._debugTask);
      for (key = 2; key < arguments.length; key++) owner = arguments[key], isValidElement(owner) && owner._store && (owner._store.validated = 1);
      return props;
    };
    exports.createContext = function (defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function (type, config, children) {
      for (var i = 2; i < arguments.length; i++) {
        var node = arguments[i];
        isValidElement(node) && node._store && (node._store.validated = 1);
      }
      i = {};
      node = null;
      if (null != config) for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = !0, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = "" + config.key), config) hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) i.children = children;else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++) childArray[_i] = arguments[_i + 2];
        Object.freeze && Object.freeze(childArray);
        i.children = childArray;
      }
      if (type && type.defaultProps) for (propName in childrenLength = type.defaultProps, childrenLength) void 0 === i[propName] && (i[propName] = childrenLength[propName]);
      node && defineKeyPropWarningGetter(i, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return ReactElement(type, node, void 0, void 0, getOwner(), i, propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack, propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.createRef = function () {
      var refObject = {
        current: null
      };
      Object.seal(refObject);
      return refObject;
    };
    exports.forwardRef = function (render) {
      null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : "function" !== typeof render ? console.error("forwardRef requires a render function but was given %s.", null === render ? "null" : typeof render) : 0 !== render.length && 2 !== render.length && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", 1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
      null != render && null != render.defaultProps && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
      var elementType = {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render: render
        },
        ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          render.name || render.displayName || (Object.defineProperty(render, "name", {
            value: name
          }), render.displayName = name);
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function (ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: {
          _status: -1,
          _result: ctor
        },
        _init: lazyInitializer
      };
    };
    exports.memo = function (type, compare) {
      null == type && console.error("memo: The first argument must be a component. Instead received: %s", null === type ? "null" : typeof type);
      compare = {
        $$typeof: REACT_MEMO_TYPE,
        type: type,
        compare: void 0 === compare ? null : compare
      };
      var ownName;
      Object.defineProperty(compare, "displayName", {
        enumerable: !1,
        configurable: !0,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name;
          type.name || type.displayName || (Object.defineProperty(type, "name", {
            value: name
          }), type.displayName = name);
        }
      });
      return compare;
    };
    exports.startTransition = function (scope) {
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      currentTransition._updatedFibers = new Set();
      try {
        var returnValue = scope(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function () {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function (usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function (action, initialState, permalink) {
      return resolveDispatcher().useActionState(action, initialState, permalink);
    };
    exports.useCallback = function (callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function (Context) {
      var dispatcher = resolveDispatcher();
      Context.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
      return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function (value, formatterFn) {
      return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function (value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function (create, createDeps, update) {
      null == create && console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      var dispatcher = resolveDispatcher();
      if ("function" === typeof update) throw Error("useEffect CRUD overload is not enabled in this build of React.");
      return dispatcher.useEffect(create, createDeps);
    };
    exports.useId = function () {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function (ref, create, deps) {
      return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function (create, deps) {
      null == create && console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function (create, deps) {
      null == create && console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function (create, deps) {
      return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function (passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function (reducer, initialArg, init) {
      return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function (initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function (initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function (subscribe, getSnapshot, getServerSnapshot) {
      return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    };
    exports.useTransition = function () {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.1.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
},11,[],"node_modules/react/cjs/react.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeEventEmitterNativeEventEmitter = require(_dependencyMap[0], "../../vendor/react-native/EventEmitter/NativeEventEmitter");
  var NativeEventEmitter = _interopDefault(_vendorReactNativeEventEmitterNativeEventEmitter);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _default = NativeEventEmitter.default;
},12,[13],"node_modules/react-native-web/dist/exports/NativeEventEmitter/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return NativeEventEmitter;
    }
  });
  var _exportsPlatform = require(_dependencyMap[0], "../../../exports/Platform");
  var Platform = _interopDefault(_exportsPlatform);
  var _RCTDeviceEventEmitter = require(_dependencyMap[1], "./RCTDeviceEventEmitter");
  var RCTDeviceEventEmitter = _interopDefault(_RCTDeviceEventEmitter);
  var _fbjsLibInvariant = require(_dependencyMap[2], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * `NativeEventEmitter` is intended for use by Native Modules to emit events to
   * JavaScript listeners. If a `NativeModule` is supplied to the constructor, it
   * will be notified (via `addListener` and `removeListeners`) when the listener
   * count changes to manage "native memory".
   *
   * Currently, all native events are fired via a global `RCTDeviceEventEmitter`.
   * This means event names must be globally unique, and it means that call sites
   * can theoretically listen to `RCTDeviceEventEmitter` (although discouraged).
   */
  class NativeEventEmitter {
    constructor(nativeModule) {
      if (Platform.default.OS === 'ios') {
        (0, invariant.default)(nativeModule != null, '`new NativeEventEmitter()` requires a non-null argument.');
        this._nativeModule = nativeModule;
      }
    }
    addListener(eventType, listener, context) {
      var _this$_nativeModule;
      (_this$_nativeModule = this._nativeModule) == null ? void 0 : _this$_nativeModule.addListener(eventType);
      var subscription = RCTDeviceEventEmitter.default.addListener(eventType, listener, context);
      return {
        remove: () => {
          if (subscription != null) {
            var _this$_nativeModule2;
            (_this$_nativeModule2 = this._nativeModule) == null ? void 0 : _this$_nativeModule2.removeListeners(1);
            // $FlowFixMe[incompatible-use]
            subscription.remove();
            subscription = null;
          }
        }
      };
    }

    /**
     * @deprecated Use `remove` on the EventSubscription from `addListener`.
     */
    removeListener(eventType, listener) {
      var _this$_nativeModule3;
      (_this$_nativeModule3 = this._nativeModule) == null ? void 0 : _this$_nativeModule3.removeListeners(1);
      // NOTE: This will report a deprecation notice via `console.error`.
      // $FlowFixMe[prop-missing] - `removeListener` exists but is deprecated.
      RCTDeviceEventEmitter.default.removeListener(eventType, listener);
    }
    emit(eventType) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      // Generally, `RCTDeviceEventEmitter` is directly invoked. But this is
      // included for completeness.
      RCTDeviceEventEmitter.default.emit(eventType, ...args);
    }
    removeAllListeners(eventType) {
      var _this$_nativeModule4;
      (0, invariant.default)(eventType != null, '`NativeEventEmitter.removeAllListener()` requires a non-null argument.');
      (_this$_nativeModule4 = this._nativeModule) == null ? void 0 : _this$_nativeModule4.removeListeners(this.listenerCount(eventType));
      RCTDeviceEventEmitter.default.removeAllListeners(eventType);
    }
    listenerCount(eventType) {
      return RCTDeviceEventEmitter.default.listenerCount(eventType);
    }
  }
},13,[14,15,17],"node_modules/react-native-web/dist/vendor/react-native/EventEmitter/NativeEventEmitter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var Platform = {
    OS: 'web',
    select: obj => 'web' in obj ? obj.web : obj.default,
    get isTesting() {
      if (process.env.NODE_ENV === 'test') {
        return true;
      }
      return false;
    },
    get Version() {
      return '0.0.0';
    }
  };
  var _default = Platform;
},14,[],"node_modules/react-native-web/dist/exports/Platform/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorEmitterEventEmitter = require(_dependencyMap[0], "../vendor/emitter/EventEmitter");
  var EventEmitter = _interopDefault(_vendorEmitterEventEmitter);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  // FIXME: use typed events

  /**
   * Global EventEmitter used by the native platform to emit events to JavaScript.
   * Events are identified by globally unique event names.
   *
   * NativeModules that emit events should instead subclass `NativeEventEmitter`.
   */
  var _default = new EventEmitter.default();
},15,[16],"node_modules/react-native-web/dist/vendor/react-native/EventEmitter/RCTDeviceEventEmitter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return EventEmitter;
    }
  });
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * EventEmitter manages listeners and publishes events to them.
   *
   * EventEmitter accepts a single type parameter that defines the valid events
   * and associated listener argument(s).
   *
   * @example
   *
   *   const emitter = new EventEmitter<{
   *     success: [number, string],
   *     error: [Error],
   *   }>();
   *
   *   emitter.on('success', (statusCode, responseText) => {...});
   *   emitter.emit('success', 200, '...');
   *
   *   emitter.on('error', error => {...});
   *   emitter.emit('error', new Error('Resource not found'));
   *
   */
  class EventEmitter {
    constructor() {
      this._registry = {};
    }
    /**
     * Registers a listener that is called when the supplied event is emitted.
     * Returns a subscription that has a `remove` method to undo registration.
     */
    addListener(eventType, listener, context) {
      var registrations = allocate(this._registry, eventType);
      var registration = {
        context,
        listener,
        remove() {
          registrations.delete(registration);
        }
      };
      registrations.add(registration);
      return registration;
    }

    /**
     * Emits the supplied event. Additional arguments supplied to `emit` will be
     * passed through to each of the registered listeners.
     *
     * If a listener modifies the listeners registered for the same event, those
     * changes will not be reflected in the current invocation of `emit`.
     */
    emit(eventType) {
      var registrations = this._registry[eventType];
      if (registrations != null) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        for (var _i = 0, _arr = [...registrations]; _i < _arr.length; _i++) {
          var registration = _arr[_i];
          registration.listener.apply(registration.context, args);
        }
      }
    }

    /**
     * Removes all registered listeners.
     */
    removeAllListeners(eventType) {
      if (eventType == null) {
        this._registry = {};
      } else {
        delete this._registry[eventType];
      }
    }

    /**
     * Returns the number of registered listeners for the supplied event.
     */
    listenerCount(eventType) {
      var registrations = this._registry[eventType];
      return registrations == null ? 0 : registrations.size;
    }
  }
  function allocate(registry, eventType) {
    var registrations = registry[eventType];
    if (registrations == null) {
      registrations = new Set();
      registry[eventType] = registrations;
    }
    return registrations;
  }
},16,[],"node_modules/react-native-web/dist/vendor/react-native/vendor/emitter/EventEmitter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  'use strict';

  var validateFormat = process.env.NODE_ENV !== "production" ? function (format) {
    if (format === undefined) {
      throw new Error('invariant(...): Second argument must be a string.');
    }
  } : function (format) {};
  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments to provide
   * information about what broke and what you were expecting.
   *
   * The invariant message will be stripped in production, but the invariant will
   * remain to ensure logic does not differ in production.
   */

  function invariant(condition, format) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    validateFormat(format);
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return String(args[argIndex++]);
        }));
        error.name = 'Invariant Violation';
      }
      error.framesToPop = 1; // Skip invariant's own stack frame.

      throw error;
    }
  }
  module.exports = invariant;
},17,[],"node_modules/fbjs/lib/invariant.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "LogBoxLog", {
    enumerable: true,
    get: function () {
      return LogBoxLog;
    }
  });
  var _LogBoxSymbolication = require(_dependencyMap[0], "./LogBoxSymbolication");
  var LogBoxSymbolication = _interopNamespace(_LogBoxSymbolication);
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  function componentStackToStack(componentStack) {
    return componentStack.map(stack => ({
      file: stack.fileName,
      methodName: stack.content,
      lineNumber: stack.location?.row ?? 0,
      column: stack.location?.column ?? 0,
      arguments: []
    }));
  }
  class LogBoxLog {
    symbolicated = {
      stack: {
        error: null,
        stack: null,
        status: 'NONE'
      },
      component: {
        error: null,
        stack: null,
        status: 'NONE'
      }
    };
    callbacks = new Map();
    constructor(data) {
      this.level = data.level;
      this.type = data.type ?? 'error';
      this.message = data.message;
      this.stack = data.stack;
      this.category = data.category;
      this.componentStack = data.componentStack;
      this.codeFrame = data.codeFrame;
      this.isComponentError = data.isComponentError;
      this.count = 1;
      this.symbolicated = data.symbolicated ?? this.symbolicated;
    }
    incrementCount() {
      this.count += 1;
    }
    getAvailableStack(type) {
      if (this.symbolicated[type].status === 'COMPLETE') {
        return this.symbolicated[type].stack;
      }
      return this.getStack(type);
    }
    flushCallbacks(type) {
      const callbacks = this.callbacks.get(type);
      const status = this.symbolicated[type].status;
      if (callbacks) {
        for (const callback of callbacks) {
          callback(status);
        }
        callbacks.clear();
      }
    }
    pushCallback(type, callback) {
      let callbacks = this.callbacks.get(type);
      if (!callbacks) {
        callbacks = new Set();
        this.callbacks.set(type, callbacks);
      }
      callbacks.add(callback);
    }
    retrySymbolicate(type, callback) {
      this._symbolicate(type, true, callback);
    }
    symbolicate(type, callback) {
      this._symbolicate(type, false, callback);
    }
    _symbolicate(type, retry, callback) {
      if (callback) {
        this.pushCallback(type, callback);
      }
      const status = this.symbolicated[type].status;
      if (status === 'COMPLETE') {
        return this.flushCallbacks(type);
      }
      if (retry) {
        LogBoxSymbolication.deleteStack(this.getStack(type));
        this.handleSymbolicate(type);
      } else {
        if (status === 'NONE') {
          this.handleSymbolicate(type);
        }
      }
    }
    componentStackCache = null;
    getStack(type) {
      if (type === 'component') {
        if (this.componentStackCache == null) {
          this.componentStackCache = componentStackToStack(this.componentStack);
        }
        return this.componentStackCache;
      }
      return this.stack;
    }
    handleSymbolicate(type) {
      if (type === 'component' && !this.componentStack?.length) {
        return;
      }
      if (this.symbolicated[type].status !== 'PENDING') {
        this.updateStatus(type, null, null, null);
        LogBoxSymbolication.symbolicate(ensureStackFilesHaveParams(this.getStack(type))).then(data => {
          this.updateStatus(type, null, data?.stack, data?.codeFrame);
        }, error => {
          this.updateStatus(type, error, null, null);
        });
      }
    }
    updateStatus(type, error, stack, codeFrame) {
      const lastStatus = this.symbolicated[type].status;
      if (error != null) {
        this.symbolicated[type] = {
          error,
          stack: null,
          status: 'FAILED'
        };
      } else if (stack != null) {
        if (codeFrame) {
          this.codeFrame = codeFrame;
        }
        this.symbolicated[type] = {
          error: null,
          stack,
          status: 'COMPLETE'
        };
      } else {
        this.symbolicated[type] = {
          error: null,
          stack: null,
          status: 'PENDING'
        };
      }
      const status = this.symbolicated[type].status;
      if (lastStatus !== status) {
        if (['COMPLETE', 'FAILED'].includes(status)) {
          this.flushCallbacks(type);
        }
      }
    }
  }

  // Sometime the web stacks don't have correct query params, this can lead to Metro errors when it attempts to resolve without a platform.
  // This will attempt to reconcile the issue by adding the current query params to the stack frames if they exist, or fallback to some common defaults.
  function ensureStackFilesHaveParams(stack) {
    const currentSrc = typeof document !== 'undefined' && document.currentScript ? 'src' in document.currentScript && document.currentScript.src || null : null;
    const currentParams = currentSrc ? new URLSearchParams(currentSrc) : new URLSearchParams({
      platform: 'web',
      dev: String(__DEV__)
    });
    return stack.map(frame => {
      if (!frame.file?.startsWith('http') ||
      // Account for Metro malformed URLs
      frame.file.includes('&platform=')) return frame;
      const url = new URL(frame.file);
      if (url.searchParams.has('platform')) {
        return frame;
      }
      currentParams.forEach((value, key) => {
        if (url.searchParams.has(key)) return;
        url.searchParams.set(key, value);
      });
      return Object.assign({}, frame, {
        file: url.toString()
      });
    });
  }
},18,[19],"node_modules/@expo/metro-runtime/src/error-overlay/Data/LogBoxLog.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.deleteStack = deleteStack;
  exports.symbolicate = symbolicate;
  var _modulesSymbolicateStackTrace = require(_dependencyMap[0], "../modules/symbolicateStackTrace");
  var symbolicateStackTrace = _interopDefault(_modulesSymbolicateStackTrace);
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const cache = new Map();

  /**
   * Sanitize because sometimes, `symbolicateStackTrace` gives us invalid values.
   */
  const sanitize = ({
    stack: maybeStack,
    codeFrame
  }) => {
    if (!Array.isArray(maybeStack)) {
      throw new Error('Expected stack to be an array.');
    }
    const stack = [];
    for (const maybeFrame of maybeStack) {
      let collapse = false;
      if ('collapse' in maybeFrame) {
        if (typeof maybeFrame.collapse !== 'boolean') {
          throw new Error('Expected stack frame `collapse` to be a boolean.');
        }
        collapse = maybeFrame.collapse;
      }
      stack.push({
        arguments: [],
        column: maybeFrame.column,
        file: maybeFrame.file,
        lineNumber: maybeFrame.lineNumber,
        methodName: maybeFrame.methodName,
        collapse
      });
    }
    return {
      stack,
      codeFrame
    };
  };
  function deleteStack(stack) {
    cache.delete(stack);
  }
  function symbolicate(stack) {
    let promise = cache.get(stack);
    if (promise == null) {
      promise = (0, symbolicateStackTrace.default)(stack).then(sanitize);
      cache.set(stack, promise);
    }
    return promise;
  }
},19,[20],"node_modules/@expo/metro-runtime/src/error-overlay/Data/LogBoxSymbolication.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  async function symbolicateStackTrace(stack) {
    const baseUrl = typeof window === 'undefined' ? process.env.EXPO_DEV_SERVER_ORIGIN : window.location.protocol + '//' + window.location.host;
    const response = await fetch(baseUrl + '/symbolicate', {
      method: 'POST',
      body: JSON.stringify({
        stack
      })
    });
    return await response.json();
  }
  var _default = symbolicateStackTrace;
},20,[],"node_modules/@expo/metro-runtime/src/error-overlay/modules/symbolicateStackTrace/index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "LogContext", {
    enumerable: true,
    get: function () {
      return LogContext;
    }
  });
  exports.useLogs = useLogs;
  exports.useSelectedLog = useSelectedLog;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopDefault(_react);
  var _LogBoxLog = require(_dependencyMap[1], "./LogBoxLog");
  // Context provider for Array<LogBoxLog>

  const LogContext = /*#__PURE__*/React.default.createContext(null);
  function useLogs() {
    const logs = React.default.useContext(LogContext);
    if (!logs) {
      if (true && typeof window !== 'undefined') {
        // Logbox data that is pre-fetched on the dev server and rendered here.
        const expoCliStaticErrorElement = document.getElementById('_expo-static-error');
        if (expoCliStaticErrorElement?.textContent) {
          const raw = JSON.parse(expoCliStaticErrorElement.textContent);
          return Object.assign({}, raw, {
            logs: raw.logs.map(raw => new _LogBoxLog.LogBoxLog(raw))
          });
        }
      }
      throw new Error('useLogs must be used within a LogProvider');
    }
    return logs;
  }
  function useSelectedLog() {
    const {
      selectedLogIndex,
      logs
    } = useLogs();
    return logs[selectedLogIndex];
  }
},21,[9,18],"node_modules/@expo/metro-runtime/src/error-overlay/Data/LogContext.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.parseInterpolation = parseInterpolation;
  exports.parseComponentStack = parseComponentStack;
  exports.parseLogBoxException = parseLogBoxException;
  exports.parseLogBoxLog = parseLogBoxLog;
  var _modulesParseErrorStack = require(_dependencyMap[0], "../modules/parseErrorStack");
  var parseErrorStack = _interopDefault(_modulesParseErrorStack);
  var _modulesStringifySafe = require(_dependencyMap[1], "../modules/stringifySafe");
  var stringifySafe = _interopDefault(_modulesStringifySafe);
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \((\d+):(\d+)\)\n\n([\s\S]+)/;
  const BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:.*):? (?:.*?)([/|\\].*): ([\s\S]+?)\n([ >]{2}[\d\s]+ \|[\s\S]+|\u{001b}[\s\S]+)/u;
  const METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) (.*): (.*) \((\d+):(\d+)\)\n\n([\s\S]+)/u;
  const SUBSTITUTION = '\ufeff%s';
  function parseInterpolation(args) {
    const categoryParts = [];
    const contentParts = [];
    const substitutionOffsets = [];
    const remaining = [...args];
    if (typeof remaining[0] === 'string') {
      const formatString = String(remaining.shift());
      const formatStringParts = formatString.split('%s');
      const substitutionCount = formatStringParts.length - 1;
      const substitutions = remaining.splice(0, substitutionCount);
      let categoryString = '';
      let contentString = '';
      let substitutionIndex = 0;
      for (const formatStringPart of formatStringParts) {
        categoryString += formatStringPart;
        contentString += formatStringPart;
        if (substitutionIndex < substitutionCount) {
          if (substitutionIndex < substitutions.length) {
            // Don't stringify a string type.
            // It adds quotation mark wrappers around the string,
            // which causes the LogBox to look odd.
            const substitution = typeof substitutions[substitutionIndex] === 'string' ? substitutions[substitutionIndex] : (0, stringifySafe.default)(substitutions[substitutionIndex]);
            substitutionOffsets.push({
              length: substitution.length,
              offset: contentString.length
            });
            categoryString += SUBSTITUTION;
            contentString += substitution;
          } else {
            substitutionOffsets.push({
              length: 2,
              offset: contentString.length
            });
            categoryString += '%s';
            contentString += '%s';
          }
          substitutionIndex++;
        }
      }
      categoryParts.push(categoryString);
      contentParts.push(contentString);
    }
    const remainingArgs = remaining.map(arg => {
      // Don't stringify a string type.
      // It adds quotation mark wrappers around the string,
      // which causes the LogBox to look odd.
      return typeof arg === 'string' ? arg : (0, stringifySafe.default)(arg);
    });
    categoryParts.push(...remainingArgs);
    contentParts.push(...remainingArgs);
    return {
      category: categoryParts.join(' '),
      message: {
        content: contentParts.join(' '),
        substitutions: substitutionOffsets
      }
    };
  }
  function isComponentStack(consoleArgument) {
    const isOldComponentStackFormat = / {4}in/.test(consoleArgument);
    const isNewComponentStackFormat = / {4}at/.test(consoleArgument);
    const isNewJSCComponentStackFormat = /@.*\n/.test(consoleArgument);
    return isOldComponentStackFormat || isNewComponentStackFormat || isNewJSCComponentStackFormat;
  }
  function parseComponentStack(message) {
    // In newer versions of React, the component stack is formatted as a call stack frame.
    // First try to parse the component stack as a call stack frame, and if that doesn't
    // work then we'll fallback to the old custom component stack format parsing.
    const stack = (0, parseErrorStack.default)(message);
    if (stack && stack.length > 0) {
      return stack.map(frame => ({
        content: frame.methodName,
        collapse: frame.collapse || false,
        fileName: frame.file == null ? 'unknown' : frame.file,
        location: {
          column: frame.column == null ? -1 : frame.column,
          row: frame.lineNumber == null ? -1 : frame.lineNumber
        }
      }));
    }
    return message.split(/\n {4}in /g).map(s => {
      if (!s) {
        return null;
      }
      const match = s.match(/(.*) \(at (.*\.js):([\d]+)\)/);
      if (!match) {
        return null;
      }
      const [content, fileName, row] = match.slice(1);
      return {
        content,
        fileName,
        location: {
          column: -1,
          row: parseInt(row, 10)
        }
      };
    }).filter(Boolean);
  }
  function parseLogBoxException(error) {
    const message = error.originalMessage != null ? error.originalMessage : 'Unknown';
    const metroInternalError = message.match(METRO_ERROR_FORMAT);
    if (metroInternalError) {
      const [content, fileName, row, column, codeFrame] = metroInternalError.slice(1);
      return {
        level: 'fatal',
        type: 'Metro Error',
        stack: [],
        isComponentError: false,
        componentStack: [],
        codeFrame: {
          fileName,
          location: {
            row: parseInt(row, 10),
            column: parseInt(column, 10)
          },
          content: codeFrame
        },
        message: {
          content,
          substitutions: []
        },
        category: `${fileName}-${row}-${column}`
      };
    }
    const babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);
    if (babelTransformError) {
      // Transform errors are thrown from inside the Babel transformer.
      const [fileName, content, row, column, codeFrame] = babelTransformError.slice(1);
      return {
        level: 'syntax',
        stack: [],
        isComponentError: false,
        componentStack: [],
        codeFrame: {
          fileName,
          location: {
            row: parseInt(row, 10),
            column: parseInt(column, 10)
          },
          content: codeFrame
        },
        message: {
          content,
          substitutions: []
        },
        category: `${fileName}-${row}-${column}`
      };
    }
    const babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);
    if (babelCodeFrameError) {
      // Codeframe errors are thrown from any use of buildCodeFrameError.
      const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);
      return {
        level: 'syntax',
        stack: [],
        isComponentError: false,
        componentStack: [],
        codeFrame: {
          fileName,
          location: null,
          // We are not given the location.
          content: codeFrame
        },
        message: {
          content,
          substitutions: []
        },
        category: `${fileName}-${1}-${1}`
      };
    }
    if (message.match(/^TransformError /)) {
      return {
        level: 'syntax',
        stack: error.stack,
        isComponentError: error.isComponentError,
        componentStack: [],
        message: {
          content: message,
          substitutions: []
        },
        category: message
      };
    }
    const componentStack = error.componentStack;
    if (error.isFatal || error.isComponentError) {
      return Object.assign({
        level: 'fatal',
        stack: error.stack,
        isComponentError: error.isComponentError,
        componentStack: componentStack != null ? parseComponentStack(componentStack) : []
      }, parseInterpolation([message]));
    }
    if (componentStack != null) {
      // It is possible that console errors have a componentStack.
      return Object.assign({
        level: 'error',
        stack: error.stack,
        isComponentError: error.isComponentError,
        componentStack: parseComponentStack(componentStack)
      }, parseInterpolation([message]));
    }

    // Most `console.error` calls won't have a componentStack. We parse them like
    // regular logs which have the component stack burried in the message.
    return Object.assign({
      level: 'error',
      stack: error.stack,
      isComponentError: error.isComponentError
    }, parseLogBoxLog([message]));
  }
  function parseLogBoxLog(args) {
    const message = args[0];
    let argsWithoutComponentStack = [];
    let componentStack = [];

    // Extract component stack from warnings like "Some warning%s".
    if (typeof message === 'string' && message.slice(-2) === '%s' && args.length > 0) {
      const lastArg = args[args.length - 1];
      if (typeof lastArg === 'string' && isComponentStack(lastArg)) {
        argsWithoutComponentStack = args.slice(0, -1);
        argsWithoutComponentStack[0] = message.slice(0, -2);
        componentStack = parseComponentStack(lastArg);
      }
    }
    if (componentStack.length === 0) {
      // Try finding the component stack elsewhere.
      for (const arg of args) {
        if (typeof arg === 'string' && isComponentStack(arg)) {
          // Strip out any messages before the component stack.
          let messageEndIndex = arg.search(/\n {4}(in|at) /);
          if (messageEndIndex < 0) {
            // Handle JSC component stacks.
            messageEndIndex = arg.search(/\n/);
          }
          if (messageEndIndex > 0) {
            argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));
          }
          componentStack = parseComponentStack(arg);
        } else {
          argsWithoutComponentStack.push(arg);
        }
      }
    }
    return Object.assign({}, parseInterpolation(argsWithoutComponentStack), {
      componentStack
    });
  }
},22,[23,25],"node_modules/@expo/metro-runtime/src/error-overlay/Data/parseLogBoxLog.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _stacktraceParser = require(_dependencyMap[0], "stacktrace-parser");
  function parseErrorStack(stack) {
    if (stack == null) {
      return [];
    }
    if (Array.isArray(stack)) {
      return stack;
    }
    return (0, _stacktraceParser.parse)(stack).map(frame => {
      // frame.file will mostly look like `http://localhost:8081/index.bundle?platform=web&dev=true&hot=false`
      return Object.assign({}, frame, {
        column: frame.column != null ? frame.column - 1 : null
      });
    });
  }
  var _default = parseErrorStack;
},23,[24],"node_modules/@expo/metro-runtime/src/error-overlay/modules/parseErrorStack/index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function () {
      return parse;
    }
  });
  var UNKNOWN_FUNCTION = '<unknown>';
  /**
   * This parses the different stack traces and puts them into one format
   * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
   */

  function parse(stackString) {
    var lines = stackString.split('\n');
    return lines.reduce(function (stack, line) {
      var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
      if (parseResult) {
        stack.push(parseResult);
      }
      return stack;
    }, []);
  }
  var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  function parseChrome(line) {
    var parts = chromeRe.exec(line);
    if (!parts) {
      return null;
    }
    var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line

    var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

    var submatch = chromeEvalRe.exec(parts[2]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line/column number
      parts[2] = submatch[1]; // url

      parts[3] = submatch[2]; // line

      parts[4] = submatch[3]; // column
    }
    return {
      file: !isNative ? parts[2] : null,
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: isNative ? [parts[2]] : [],
      lineNumber: parts[3] ? +parts[3] : null,
      column: parts[4] ? +parts[4] : null
    };
  }
  var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function parseWinjs(line) {
    var parts = winjsRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }
  var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  function parseGecko(line) {
    var parts = geckoRe.exec(line);
    if (!parts) {
      return null;
    }
    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
    var submatch = geckoEvalRe.exec(parts[3]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line number
      parts[3] = submatch[1];
      parts[4] = submatch[2];
      parts[5] = null; // no column when eval
    }
    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: parts[2] ? parts[2].split(',') : [],
      lineNumber: parts[4] ? +parts[4] : null,
      column: parts[5] ? +parts[5] : null
    };
  }
  var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  function parseJSC(line) {
    var parts = javaScriptCoreRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[4],
      column: parts[5] ? +parts[5] : null
    };
  }
  var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function parseNode(line) {
    var parts = nodeRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }
},24,[],"node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  exports.createStringifySafeWithLimits = createStringifySafeWithLimits;
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Tries to stringify with JSON.stringify and toString, but catches exceptions
   * (e.g. from circular objects) and always returns a string and never throws.
   */
  function createStringifySafeWithLimits(limits) {
    const {
      maxDepth = Number.POSITIVE_INFINITY,
      maxStringLimit = Number.POSITIVE_INFINITY,
      maxArrayLimit = Number.POSITIVE_INFINITY,
      maxObjectKeysLimit = Number.POSITIVE_INFINITY
    } = limits;
    const stack = [];
    function replacer(_key, value) {
      while (stack.length && this !== stack[0]) {
        stack.shift();
      }
      if (typeof value === 'string') {
        const truncatedString = '...(truncated)...';
        if (value.length > maxStringLimit + truncatedString.length) {
          return value.substring(0, maxStringLimit) + truncatedString;
        }
        return value;
      }
      if (typeof value !== 'object' || value === null) {
        return value;
      }
      let retval = value;
      if (Array.isArray(value)) {
        if (stack.length >= maxDepth) {
          retval = `[ ... array with ${value.length} values ... ]`;
        } else if (value.length > maxArrayLimit) {
          retval = value.slice(0, maxArrayLimit).concat([`... extra ${value.length - maxArrayLimit} values truncated ...`]);
        }
      } else {
        // Add refinement after Array.isArray call.
        if (typeof value !== 'object') {
          throw new Error('This was already found earlier');
        }
        const keys = Object.keys(value);
        if (stack.length >= maxDepth) {
          retval = `{ ... object with ${keys.length} keys ... }`;
        } else if (keys.length > maxObjectKeysLimit) {
          // Return a sample of the keys.
          retval = {};
          for (const k of keys.slice(0, maxObjectKeysLimit)) {
            retval[k] = value[k];
          }
          const truncatedKey = '...(truncated keys)...';
          retval[truncatedKey] = keys.length - maxObjectKeysLimit;
        }
      }
      stack.unshift(retval);
      return retval;
    }
    return function stringifySafe(arg) {
      if (arg === undefined) {
        return 'undefined';
      } else if (arg === null) {
        return 'null';
      } else if (typeof arg === 'function') {
        try {
          return arg.toString();
        } catch {
          return '[function unknown]';
        }
      } else if (arg instanceof Error) {
        return arg.name + ': ' + arg.message;
      } else {
        // Perform a try catch, just in case the object has a circular
        // reference or stringify throws for some other reason.
        try {
          const ret = JSON.stringify(arg, replacer);
          if (ret === undefined) {
            return '["' + typeof arg + '" failed to stringify]';
          }
          return ret;
        } catch {
          if (typeof arg.toString === 'function') {
            try {
              // $FlowFixMe[incompatible-use] : toString shouldn't take any arguments in general.
              return arg.toString();
            } catch {}
          }
        }
      }
      return '["' + typeof arg + '" failed to stringify]';
    };
  }
  const stringifySafe = createStringifySafeWithLimits({
    maxDepth: 10,
    maxStringLimit: 100,
    maxArrayLimit: 50,
    maxObjectKeysLimit: 50
  });
  var _default = stringifySafe;
},25,[],"node_modules/@expo/metro-runtime/src/error-overlay/modules/stringifySafe/index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\modules\\NativeLogBox\\index.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  require(_dependencyMap[0], "react");
  var _reactDomClient = require(_dependencyMap[1], "react-dom/client");
  var ReactDOM = _interopDefault(_reactDomClient);
  var _reactJsxDevRuntime = require(_dependencyMap[2], "react/jsx-dev-runtime");
  let currentRoot = null;
  var _default = {
    show() {
      if (currentRoot) {
        return;
      }
      const ErrorOverlay = require(_dependencyMap[3], "../../ErrorOverlay").default;
      // Create a new div with ID `error-overlay` element and render LogBoxInspector into it.
      const div = document.createElement('div');
      div.id = 'error-overlay';
      document.body.appendChild(div);
      currentRoot = ReactDOM.default.createRoot(div);
      currentRoot.render(/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ErrorOverlay, {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 16,
        columnNumber: 24
      }, this));
    },
    hide() {
      // Remove div with ID `error-overlay`
      if (currentRoot) {
        currentRoot.unmount();
        currentRoot = null;
      }
      const div = document.getElementById('error-overlay');
      div?.remove();
    }
  };
},26,[9,27,33,35],"node_modules/@expo/metro-runtime/src/error-overlay/modules/NativeLogBox/index.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
      return;
    }
    if (process.env.NODE_ENV !== 'production') {
      // This branch is unreachable because this function is only called
      // in production, but the condition is true only in development.
      // Therefore if the branch is still here, dead code elimination wasn't
      // properly applied.
      // Don't change the message. React DevTools relies on it. Also make sure
      // this message doesn't occur elsewhere in this function, or it will cause
      // a false positive.
      throw new Error('^_^');
    }
    try {
      // Verify that the code above has been dead code eliminated (DCE'd).
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      // DevTools shouldn't crash React, no matter what.
      // We should still report in case we break this code.
      console.error(err);
    }
  }
  if (process.env.NODE_ENV === 'production') {
    // DCE check should happen before ReactDOM bundle executes so that
    // DevTools can report bad minification during injection.
    checkDCE();
    module.exports = require(_dependencyMap[0], "./cjs/react-dom-client.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-dom-client.development.js");
  }
},27,[10,28],"node_modules/react-dom/client.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /*
   Modernizr 3.0.0pre (Custom Build) | MIT
  */
  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function findHook(fiber, id) {
      for (fiber = fiber.memoizedState; null !== fiber && 0 < id;) fiber = fiber.next, id--;
      return fiber;
    }
    function copyWithSetImpl(obj, path, index, value) {
      if (index >= path.length) return value;
      var key = path[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
      return updated;
    }
    function copyWithRename(obj, oldPath, newPath) {
      if (oldPath.length !== newPath.length) console.warn("copyWithRename() expects paths of the same length");else {
        for (var i = 0; i < newPath.length - 1; i++) if (oldPath[i] !== newPath[i]) {
          console.warn("copyWithRename() expects paths to be the same except for the deepest key");
          return;
        }
        return copyWithRenameImpl(obj, oldPath, newPath, 0);
      }
    }
    function copyWithRenameImpl(obj, oldPath, newPath, index) {
      var oldKey = oldPath[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);
      return updated;
    }
    function copyWithDeleteImpl(obj, path, index) {
      var key = path[index],
        updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
      updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
      return updated;
    }
    function shouldSuspendImpl() {
      return !1;
    }
    function shouldErrorImpl() {
      return null;
    }
    function warnForMissingKey() {}
    function warnInvalidHookAccess() {
      console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
    }
    function warnInvalidContextAccess() {
      console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    }
    function noop$2() {}
    function setToSortedString(set) {
      var array = [];
      set.forEach(function (value) {
        array.push(value);
      });
      return array.sort().join(", ");
    }
    function createFiber(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function scheduleRoot(root, element) {
      root.context === emptyContextObject && (updateContainerImpl(root.current, 2, element, root, null, null), flushSyncWork$1());
    }
    function scheduleRefresh(root, update) {
      if (null !== resolveFamily) {
        var staleFamilies = update.staleFamilies;
        update = update.updatedFamilies;
        flushPendingEffects();
        scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);
        flushSyncWork$1();
      }
    }
    function setRefreshHandler(handler) {
      resolveFamily = handler;
    }
    function isValidContainer(node) {
      return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber,
        nearestMounted = fiber;
      if (fiber.alternate) for (; node.return;) node = node.return;else {
        fiber = node;
        do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return; while (fiber);
      }
      return 3 === node.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber) throw Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate) throw Error("Unable to find node on an unmounted component.");
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate;;) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b = parentA.return;
          if (null !== b) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB;) {
            if (parentB === a) return assertIsMounted(parentA), fiber;
            if (parentB === b) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (a.return !== b.return) a = parentA, b = parentB;else {
          for (var didFindChild = !1, _child = parentA.child; _child;) {
            if (_child === a) {
              didFindChild = !0;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = !0;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            for (_child = parentB.child; _child;) {
              if (_child === a) {
                didFindChild = !0;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = !0;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild) throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (a.alternate !== b) throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (3 !== a.tag) throw Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
      for (node = node.child; null !== node;) {
        tag = findCurrentHostFiberImpl(node);
        if (null !== tag) return tag;
        node = node.sibling;
      }
      return null;
    }
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_CONTEXT_TYPE:
          return (type.displayName || "Context") + ".Provider";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x) {}
      }
      return null;
    }
    function getComponentNameFromOwner(owner) {
      return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
    }
    function getComponentNameFromFiber(fiber) {
      var type = fiber.type;
      switch (fiber.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (type._context.displayName || "Context") + ".Consumer";
        case 10:
          return (type.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return type;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return getComponentNameFromType(type);
        case 8:
          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if ("function" === typeof type) return type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          break;
        case 29:
          type = fiber._debugInfo;
          if (null != type) for (var i = type.length - 1; 0 <= i; i--) if ("string" === typeof type[i].name) return type[i].name;
          if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);
      }
      return null;
    }
    function createCursor(defaultValue) {
      return {
        current: defaultValue
      };
    }
    function pop(cursor, fiber) {
      0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
    }
    function push(cursor, value, fiber) {
      index$jscomp$0++;
      valueStack[index$jscomp$0] = cursor.current;
      fiberStack[index$jscomp$0] = fiber;
      cursor.current = value;
    }
    function requiredContext(c) {
      null === c && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return c;
    }
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance, fiber);
      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor, null, fiber);
      var nextRootContext = nextRootInstance.nodeType;
      switch (nextRootContext) {
        case 9:
        case 11:
          nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
          nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
          break;
        default:
          if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI) nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(nextRootInstance, nextRootContext);else switch (nextRootContext) {
            case "svg":
              nextRootInstance = HostContextNamespaceSvg;
              break;
            case "math":
              nextRootInstance = HostContextNamespaceMath;
              break;
            default:
              nextRootInstance = HostContextNamespaceNone;
          }
      }
      nextRootContext = nextRootContext.toLowerCase();
      nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
      nextRootContext = {
        context: nextRootInstance,
        ancestorInfo: nextRootContext
      };
      pop(contextStackCursor, fiber);
      push(contextStackCursor, nextRootContext, fiber);
    }
    function popHostContainer(fiber) {
      pop(contextStackCursor, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
      return requiredContext(contextStackCursor.current);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
      var context = requiredContext(contextStackCursor.current);
      var type = fiber.type;
      var nextContext = getChildHostContextProd(context.context, type);
      type = updatedAncestorInfoDev(context.ancestorInfo, type);
      nextContext = {
        context: nextContext,
        ancestorInfo: type
      };
      context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
    }
    function typeName(value) {
      return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
    }
    function willCoercionThrow(value) {
      try {
        return testStringCoercion(value), !1;
      } catch (e) {
        return !0;
      }
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkAttributeStringCoercion(value, attributeName) {
      if (willCoercionThrow(value)) return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName(value)), testStringCoercion(value);
    }
    function checkCSSPropertyStringCoercion(value, propName) {
      if (willCoercionThrow(value)) return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propName, typeName(value)), testStringCoercion(value);
    }
    function checkFormFieldValueStringCoercion(value) {
      if (willCoercionThrow(value)) return console.error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.", typeName(value)), testStringCoercion(value);
    }
    function injectInternals(internals) {
      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled) return !0;
      if (!hook.supportsFiber) return console.error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"), !0;
      try {
        rendererID = hook.inject(internals), injectedHook = hook;
      } catch (err) {
        console.error("React instrumentation encountered an error: %s.", err);
      }
      return hook.checkDCE ? !0 : !1;
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode) try {
        injectedHook.setStrictMode(rendererID, newIsStrictMode);
      } catch (err) {
        hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
      }
    }
    function injectProfilingHooks(profilingHooks) {
      injectedProfilingHooks = profilingHooks;
    }
    function markCommitStopped() {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();
    }
    function markComponentRenderStarted(fiber) {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);
    }
    function markComponentRenderStopped() {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();
    }
    function markRenderStarted(lanes) {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);
    }
    function markRenderStopped() {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();
    }
    function markStateUpdateScheduled(fiber, lane) {
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
    }
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
    }
    function getLabelForLane(lane) {
      if (lane & 1) return "SyncHydrationLane";
      if (lane & 2) return "Sync";
      if (lane & 4) return "InputContinuousHydration";
      if (lane & 8) return "InputContinuous";
      if (lane & 16) return "DefaultHydration";
      if (lane & 32) return "Default";
      if (lane & 128) return "TransitionHydration";
      if (lane & 4194048) return "Transition";
      if (lane & 62914560) return "Retry";
      if (lane & 67108864) return "SelectiveHydration";
      if (lane & 134217728) return "IdleHydration";
      if (lane & 268435456) return "Idle";
      if (lane & 536870912) return "Offscreen";
      if (lane & 1073741824) return "Deferred";
    }
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), lanes;
      }
    }
    function getNextLanes(root, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0,
        suspendedLanes = root.suspendedLanes,
        pingedLanes = root.pingedLanes;
      root = root.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root, renderLanes) {
      return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), -1;
      }
    }
    function claimNextTransitionLane() {
      var lane = nextTransitionLane;
      nextTransitionLane <<= 1;
      0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
      return lane;
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root, updateLane) {
      root.pendingLanes |= updateLane;
      268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
    }
    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root.pendingLanes;
      root.pendingLanes = remainingLanes;
      root.suspendedLanes = 0;
      root.pingedLanes = 0;
      root.warmLanes = 0;
      root.expiredLanes &= remainingLanes;
      root.entangledLanes &= remainingLanes;
      root.errorRecoveryDisabledLanes &= remainingLanes;
      root.shellSuspendCounter = 0;
      var entanglements = root.entanglements,
        expirationTimes = root.expirationTimes,
        hiddenUpdates = root.hiddenUpdates;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;) {
        var index = 31 - clz32(remainingLanes),
          lane = 1 << index;
        entanglements[index] = 0;
        expirationTimes[index] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index];
        if (null !== hiddenUpdatesForLane) for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
          var update = hiddenUpdatesForLane[index];
          null !== update && (update.lane &= -536870913);
        }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
      0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
      root.pendingLanes |= spawnedLane;
      root.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root.entangledLanes |= spawnedLane;
      root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
    }
    function markRootEntangled(root, entangledLanes) {
      var rootEntangledLanes = root.entangledLanes |= entangledLanes;
      for (root = root.entanglements; rootEntangledLanes;) {
        var index = 31 - clz32(rootEntangledLanes),
          lane = 1 << index;
        lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function addFiberToLanesMap(root, fiber, lanes) {
      if (isDevToolsPresent) for (root = root.pendingUpdatersLaneMap; 0 < lanes;) {
        var index = 31 - clz32(lanes),
          lane = 1 << index;
        root[index].add(fiber);
        lanes &= ~lane;
      }
    }
    function movePendingFibersToMemoized(root, lanes) {
      if (isDevToolsPresent) for (var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;) {
        var index = 31 - clz32(lanes);
        root = 1 << index;
        index = pendingUpdatersLaneMap[index];
        0 < index.size && (index.forEach(function (fiber) {
          var alternate = fiber.alternate;
          null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
        }), index.clear());
        lanes &= ~root;
      }
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return ReactDOMSharedInternals.p = priority, fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropsKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode;) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
          parentNode = targetInst.alternate;
          if (null !== targetInst.child || null !== parentNode && null !== parentNode.child) for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode;) {
            if (parentNode = targetNode[internalInstanceKey]) return parentNode;
            targetNode = getParentSuspenseInstance(targetNode);
          }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node) {
      if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
        var tag = node.tag;
        if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag) return node;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function getResourcesFromRoot(root) {
      var resources = root[internalRootNodeResourcesKey];
      resources || (resources = root[internalRootNodeResourcesKey] = {
        hoistableStyles: new Map(),
        hoistableScripts: new Map()
      });
      return resources;
    }
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = !0;
    }
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] && console.error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
      registrationNameDependencies[registrationName] = dependencies;
      var lowerCasedName = registrationName.toLowerCase();
      possibleRegistrationNames[lowerCasedName] = registrationName;
      "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
      for (registrationName = 0; registrationName < dependencies.length; registrationName++) allNativeEvents.add(dependencies[registrationName]);
    }
    function checkControlledValueProps(tagName, props) {
      hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
      props.onChange || props.readOnly || props.disabled || null == props.checked || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return !0;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) return validatedAttributeNameCache[attributeName] = !0;
      illegalAttributeNameCache[attributeName] = !0;
      console.error("Invalid attribute name: `%s`", attributeName);
      return !1;
    }
    function getValueForAttributeOnCustomComponent(node, name, expected) {
      if (isAttributeNameSafe(name)) {
        if (!node.hasAttribute(name)) {
          switch (typeof expected) {
            case "symbol":
            case "object":
              return expected;
            case "function":
              return expected;
            case "boolean":
              if (!1 === expected) return expected;
          }
          return void 0 === expected ? void 0 : null;
        }
        node = node.getAttribute(name);
        if ("" === node && !0 === expected) return !0;
        checkAttributeStringCoercion(expected, name);
        return node === "" + expected ? expected : node;
      }
    }
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name)) if (null === value) node.removeAttribute(name);else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
            node.removeAttribute(name);
            return;
          case "boolean":
            var prefix = name.toLowerCase().slice(0, 5);
            if ("data-" !== prefix && "aria-" !== prefix) {
              node.removeAttribute(name);
              return;
            }
        }
        checkAttributeStringCoercion(value, name);
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForKnownAttribute(node, name, value) {
      if (null === value) node.removeAttribute(name);else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (null === value) node.removeAttribute(name);else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    function disabledLog() {}
    function disableLogs() {
      if (0 === disabledDepth) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: !0,
          enumerable: !0,
          value: disabledLog,
          writable: !0
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (0 === disabledDepth) {
        var props = {
          configurable: !0,
          enumerable: !0,
          writable: !0
        };
        Object.defineProperties(console, {
          log: assign({}, props, {
            value: prevLog
          }),
          info: assign({}, props, {
            value: prevInfo
          }),
          warn: assign({}, props, {
            value: prevWarn
          }),
          error: assign({}, props, {
            value: prevError
          }),
          group: assign({}, props, {
            value: prevGroup
          }),
          groupCollapsed: assign({}, props, {
            value: prevGroupCollapsed
          }),
          groupEnd: assign({}, props, {
            value: prevGroupEnd
          })
        });
      }
      0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix) try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || "";
        suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
      return "\n" + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      var frame = componentFrameCache.get(fn);
      if (void 0 !== frame) return frame;
      reentry = !0;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher = null;
      previousDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function () {
            try {
              if (construct) {
                var Fake = function () {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function () {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function () {});
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot"
        });
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"),
            controlLines = controlStack.split("\n");
          for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
          for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");) _RunInRootFrame$Deter++;
          if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];) _RunInRootFrame$Deter--;
          for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--) if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
            if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
              do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                "function" === typeof fn && componentFrameCache.set(fn, _frame);
                return _frame;
              } while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
            }
            break;
          }
        }
      } finally {
        reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
      "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function formatOwnerStack(error) {
      var prevPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      error = error.stack;
      Error.prepareStackTrace = prevPrepareStackTrace;
      error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
      prevPrepareStackTrace = error.indexOf("\n");
      -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
      prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
      -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf("\n", prevPrepareStackTrace));
      if (-1 !== prevPrepareStackTrace) error = error.slice(0, prevPrepareStackTrace);else return "";
      return error;
    }
    function describeFiber(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, !1);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, !1);
        case 1:
          return describeNativeComponentFrame(fiber.type, !0);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress) {
      try {
        var info = "";
        do {
          info += describeFiber(workInProgress);
          var debugInfo = workInProgress._debugInfo;
          if (debugInfo) for (var i = debugInfo.length - 1; 0 <= i; i--) {
            var entry = debugInfo[i];
            if ("string" === typeof entry.name) {
              var JSCompiler_temp_const = info,
                env = entry.env;
              var JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (env ? " [" + env + "]" : ""));
              info = JSCompiler_temp_const + JSCompiler_inline_result;
            }
          }
          workInProgress = workInProgress.return;
        } while (workInProgress);
        return info;
      } catch (x) {
        return "\nError generating stack: " + x.message + "\n" + x.stack;
      }
    }
    function describeFunctionComponentFrameWithoutLineNumber(fn) {
      return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
    }
    function getCurrentFiberOwnerNameInDevOrNull() {
      if (null === current) return null;
      var owner = current._debugOwner;
      return null != owner ? getComponentNameFromOwner(owner) : null;
    }
    function getCurrentFiberStackInDev() {
      if (null === current) return "";
      var workInProgress = current;
      try {
        var info = "";
        6 === workInProgress.tag && (workInProgress = workInProgress.return);
        switch (workInProgress.tag) {
          case 26:
          case 27:
          case 5:
            info += describeBuiltInComponentFrame(workInProgress.type);
            break;
          case 13:
            info += describeBuiltInComponentFrame("Suspense");
            break;
          case 19:
            info += describeBuiltInComponentFrame("SuspenseList");
            break;
          case 31:
            info += describeBuiltInComponentFrame("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            workInProgress._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress.type));
            break;
          case 11:
            workInProgress._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress.type.render));
        }
        for (; workInProgress;) if ("number" === typeof workInProgress.tag) {
          var fiber = workInProgress;
          workInProgress = fiber._debugOwner;
          var debugStack = fiber._debugStack;
          workInProgress && debugStack && ("string" !== typeof debugStack && (fiber._debugStack = debugStack = formatOwnerStack(debugStack)), "" !== debugStack && (info += "\n" + debugStack));
        } else if (null != workInProgress.debugStack) {
          var ownerStack = workInProgress.debugStack;
          (workInProgress = workInProgress.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
        } else break;
        var JSCompiler_inline_result = info;
      } catch (x) {
        JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
      }
      return JSCompiler_inline_result;
    }
    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
      var previousFiber = current;
      setCurrentFiber(fiber);
      try {
        return null !== fiber && fiber._debugTask ? fiber._debugTask.run(callback.bind(null, arg0, arg1, arg2, arg3, arg4)) : callback(arg0, arg1, arg2, arg3, arg4);
      } finally {
        setCurrentFiber(previousFiber);
      }
      throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
    }
    function setCurrentFiber(fiber) {
      ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
      isRendering = !1;
      current = fiber;
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return checkFormFieldValueStringCoercion(value), value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type = elem.type;
      return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
    }
    function trackValueOnNode(node) {
      var valueField = isCheckable(node) ? "checked" : "value",
        descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
      checkFormFieldValueStringCoercion(node[valueField]);
      var currentValue = "" + node[valueField];
      if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
        var get = descriptor.get,
          set = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: !0,
          get: function () {
            return get.call(this);
          },
          set: function (value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
            set.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function () {
            return currentValue;
          },
          setValue: function (value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
          },
          stopTracking: function () {
            node._valueTracker = null;
            delete node[valueField];
          }
        };
      }
    }
    function track(node) {
      node._valueTracker || (node._valueTracker = trackValueOnNode(node));
    }
    function updateValueIfChanged(node) {
      if (!node) return !1;
      var tracker = node._valueTracker;
      if (!tracker) return !0;
      var lastValue = tracker.getValue();
      var value = "";
      node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
      node = value;
      return node !== lastValue ? (tracker.setValue(node), !0) : !1;
    }
    function getActiveElement(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function (ch) {
        return "\\" + ch.charCodeAt(0).toString(16) + " ";
      });
    }
    function validateInputProps(element, props) {
      void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnCheckedDefaultChecked = !0);
      void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnValueDefaultValue$1 = !0);
    }
    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
      element.name = "";
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
      if (null != value) {
        if ("number" === type) {
          if (0 === value && "" === element.value || element.value != value) element.value = "" + getToStringValue(value);
        } else element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
      } else "submit" !== type && "reset" !== type || element.removeAttribute("value");
      null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
      null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
      null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
    }
    function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating) {
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
      if (null != value || null != defaultValue) {
        if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) return;
        defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
      element.checked = isHydrating ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
    }
    function setDefaultValue(node, type, value) {
      "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
    }
    function validateOptionProps(element, props) {
      null == props.value && ("object" === typeof props.children && null !== props.children ? React.Children.forEach(props.children, function (child) {
        null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = !0, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."));
      }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = !0, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")));
      null == props.selected || didWarnSelectedSetOnOption || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
    }
    function getDeclarationErrorAddendum() {
      var ownerName = getCurrentFiberOwnerNameInDevOrNull();
      return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var i = 0; i < propValue.length; i++) multiple["$" + propValue[i]] = !0;
        for (propValue = 0; propValue < node.length; propValue++) i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = !0);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i = 0; i < node.length; i++) {
          if (node[i].value === propValue) {
            node[i].selected = !0;
            setDefaultSelected && (node[i].defaultSelected = !0);
            return;
          }
          null !== multiple || node[i].disabled || (multiple = node[i]);
        }
        null !== multiple && (multiple.selected = !0);
      }
    }
    function validateSelectProps(element, props) {
      for (element = 0; element < valuePropNames.length; element++) {
        var propName = valuePropNames[element];
        if (null != props[propName]) {
          var propNameIsArray = isArrayImpl(props[propName]);
          props.multiple && !propNameIsArray ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum()) : !props.multiple && propNameIsArray && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
        }
      }
      void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnValueDefaultValue = !0);
    }
    function validateTextareaProps(element, props) {
      void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component"), didWarnValDefaultVal = !0);
      null != props.children && null == props.value && console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
    }
    function updateTextarea(element, value, defaultValue) {
      if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          if (isArrayImpl(children)) {
            if (1 < children.length) throw Error("<textarea> can only have at most one child.");
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue && "" !== children && null !== children && (element.value = children);
    }
    function findNotableNode(node, indent) {
      return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
    }
    function indentation(indent) {
      return "  " + "  ".repeat(indent);
    }
    function added(indent) {
      return "+ " + "  ".repeat(indent);
    }
    function removed(indent) {
      return "- " + "  ".repeat(indent);
    }
    function describeFiberType(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return fiber.type;
        case 16:
          return "Lazy";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        case 11:
          return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
        case 1:
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        default:
          return null;
      }
    }
    function describeTextNode(content, maxLength) {
      return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
    }
    function describeTextDiff(clientText, serverProps, indent) {
      var maxLength = 120 - 2 * indent;
      if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + "\n";
      if ("string" === typeof serverProps) {
        for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);
        firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
        return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
      }
      return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
    }
    function objectName(object) {
      return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function (m, p0) {
        return p0;
      });
    }
    function describeValue(value, maxLength) {
      switch (typeof value) {
        case "string":
          return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
        case "object":
          if (null === value) return "null";
          if (isArrayImpl(value)) return "[...]";
          if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
          var name = objectName(value);
          if ("Object" === name) {
            name = "";
            maxLength -= 2;
            for (var propName in value) if (value.hasOwnProperty(propName)) {
              var jsonPropName = JSON.stringify(propName);
              jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
              maxLength -= propName.length - 2;
              jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);
              maxLength -= jsonPropName.length;
              if (0 > maxLength) {
                name += "" === name ? "..." : ", ...";
                break;
              }
              name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
            }
            return "{" + name + "}";
          }
          return name;
        case "function":
          return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
        default:
          return String(value);
      }
    }
    function describePropValue(value, maxLength) {
      return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
    }
    function describeExpandedElement(type, props, rowPrefix) {
      var remainingRowLength = 120 - rowPrefix.length - type.length,
        properties = [],
        propName;
      for (propName in props) if (props.hasOwnProperty(propName) && "children" !== propName) {
        var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);
        remainingRowLength -= propName.length + propValue.length + 2;
        properties.push(propName + "=" + propValue);
      }
      return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
    }
    function describePropertiesDiff(clientObject, serverObject, indent) {
      var properties = "",
        remainingServerProperties = assign({}, serverObject),
        propName;
      for (propName in clientObject) if (clientObject.hasOwnProperty(propName)) {
        delete remainingServerProperties[propName];
        var maxLength = 120 - 2 * indent - propName.length - 2,
          clientPropValue = describeValue(clientObject[propName], maxLength);
        serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
      }
      for (var _propName in remainingServerProperties) remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + ": " + clientObject + "\n");
      return properties;
    }
    function describeElementDiff(type, clientProps, serverProps, indent) {
      var content = "",
        serverPropNames = new Map();
      for (propName$jscomp$0 in serverProps) serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);
      if (1 === serverPropNames.size && serverPropNames.has("children")) content += describeExpandedElement(type, clientProps, indentation(indent));else {
        for (var _propName2 in clientProps) if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
          var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1,
            serverPropName = serverPropNames.get(_propName2.toLowerCase());
          if (void 0 !== serverPropName) {
            serverPropNames.delete(_propName2.toLowerCase());
            var propName$jscomp$0 = clientProps[_propName2];
            serverPropName = serverProps[serverPropName];
            var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);
            maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);
            "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
          } else content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
        }
        serverPropNames.forEach(function (propName) {
          if ("children" !== propName) {
            var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
            content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
          }
        });
        content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
      }
      type = serverProps.children;
      clientProps = clientProps.children;
      if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
        serverPropNames = "";
        if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps) serverPropNames = "" + clientProps;
        content += describeTextDiff(serverPropNames, "" + type, indent + 1);
      } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps) content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
      return content;
    }
    function describeSiblingFiber(fiber, indent) {
      var type = describeFiberType(fiber);
      if (null === type) {
        type = "";
        for (fiber = fiber.child; fiber;) type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
        return type;
      }
      return indentation(indent) + "<" + type + ">\n";
    }
    function describeNode(node, indent) {
      var skipToNode = findNotableNode(node, indent);
      if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
      skipToNode = "";
      var debugInfo = node.fiber._debugInfo;
      if (debugInfo) for (var i = 0; i < debugInfo.length; i++) {
        var serverComponentName = debugInfo[i].name;
        "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
      }
      debugInfo = "";
      i = node.fiber.pendingProps;
      if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) if (void 0 === node.serverProps) {
        debugInfo = indent;
        var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2,
          content = "";
        for (propName in i) if (i.hasOwnProperty(propName) && "children" !== propName) {
          var propValue = describePropValue(i[propName], 15);
          maxLength -= propName.length + propValue.length + 2;
          if (0 > maxLength) {
            content += " ...";
            break;
          }
          content += " " + propName + "=" + propValue;
        }
        debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
        indent++;
      } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : "string" === typeof node.serverProps ? console.error("Should not have matched a non HostText fiber to a Text node. This is a bug in React.") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);
      var propName = "";
      i = node.fiber.child;
      for (serverComponentName = 0; i && serverComponentName < node.children.length;) maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
      i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
      i = node.serverTail;
      null === node.serverProps && indent--;
      for (node = 0; node < i.length; node++) serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));
      return skipToNode + debugInfo + propName;
    }
    function describeDiff(rootNode) {
      try {
        return "\n\n" + describeNode(rootNode, 0);
      } catch (x) {
        return "";
      }
    }
    function describeAncestors(ancestor, child, props) {
      for (var fiber = child, node = null, distanceFromLeaf = 0; fiber;) fiber === ancestor && (distanceFromLeaf = 0), node = {
        fiber: fiber,
        children: null !== node ? [node] : [],
        serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
        serverTail: [],
        distanceFromLeaf: distanceFromLeaf
      }, distanceFromLeaf++, fiber = fiber.return;
      return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
    }
    function updatedAncestorInfoDev(oldInfo, tag) {
      var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev),
        info = {
          tag: tag
        };
      -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
      -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
      -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
      ancestorInfo.current = info;
      "form" === tag && (ancestorInfo.formTag = info);
      "a" === tag && (ancestorInfo.aTagInScope = info);
      "button" === tag && (ancestorInfo.buttonTagInScope = info);
      "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
      "p" === tag && (ancestorInfo.pTagInButtonScope = info);
      "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
      if ("dd" === tag || "dt" === tag) ancestorInfo.dlItemTagAutoclosing = info;
      "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
      null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? !0 === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = !1) : ancestorInfo.implicitRootScope = !0;
      return ancestorInfo;
    }
    function isTagValidWithParent(tag, parentTag, implicitRootScope) {
      switch (parentTag) {
        case "select":
          return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
        case "optgroup":
          return "option" === tag || "#text" === tag;
        case "option":
          return "#text" === tag;
        case "tr":
          return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
        case "tbody":
        case "thead":
        case "tfoot":
          return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
        case "colgroup":
          return "col" === tag || "template" === tag;
        case "table":
          return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
        case "head":
          return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
        case "html":
          if (implicitRootScope) break;
          return "head" === tag || "body" === tag || "frameset" === tag;
        case "frameset":
          return "frame" === tag;
        case "#document":
          if (!implicitRootScope) return "html" === tag;
      }
      switch (tag) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
        case "rp":
        case "rt":
          return -1 === impliedEndTags.indexOf(parentTag);
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return null == parentTag;
        case "head":
          return implicitRootScope || null === parentTag;
        case "html":
          return implicitRootScope && "#document" === parentTag || null === parentTag;
        case "body":
          return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
      }
      return !0;
    }
    function findInvalidAncestorForTag(tag, ancestorInfo) {
      switch (tag) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return ancestorInfo.pTagInButtonScope;
        case "form":
          return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
        case "li":
          return ancestorInfo.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return ancestorInfo.dlItemTagAutoclosing;
        case "button":
          return ancestorInfo.buttonTagInScope;
        case "a":
          return ancestorInfo.aTagInScope;
        case "nobr":
          return ancestorInfo.nobrTagInScope;
      }
      return null;
    }
    function findAncestor(parent, tagName) {
      for (; parent;) {
        switch (parent.tag) {
          case 5:
          case 26:
          case 27:
            if (parent.type === tagName) return parent;
        }
        parent = parent.return;
      }
      return null;
    }
    function validateDOMNesting(childTag, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
      var parentInfo = ancestorInfo.current;
      ancestorInfo = (parentInfo = isTagValidWithParent(childTag, parentInfo && parentInfo.tag, ancestorInfo.implicitRootScope) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
      ancestorInfo = parentInfo || ancestorInfo;
      if (!ancestorInfo) return !0;
      var ancestorTag = ancestorInfo.tag;
      ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
      if (didWarn[ancestorInfo]) return !1;
      didWarn[ancestorInfo] = !0;
      var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null,
        ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "",
        tagDisplayName = "<" + childTag + ">";
      parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error("In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s", tagDisplayName, ancestorTag, parentInfo, ancestorDescription)) : console.error("In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s", tagDisplayName, ancestorTag, ancestorDescription);
      ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function () {
        console.error("<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.", ancestorTag, tagDisplayName);
      }));
      return !1;
    }
    function validateTextNesting(childText, parentTag, implicitRootScope) {
      if (implicitRootScope || isTagValidWithParent("#text", parentTag, !1)) return !0;
      implicitRootScope = "#text|" + parentTag;
      if (didWarn[implicitRootScope]) return !1;
      didWarn[implicitRootScope] = !0;
      var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
      implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(ancestor, implicitRootScope, 6 !== implicitRootScope.tag ? {
        children: null
      } : null) : "";
      /\S/.test(childText) ? console.error("In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s", parentTag, implicitRootScope) : console.error("In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s", parentTag, implicitRootScope);
      return !1;
    }
    function setTextContent(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    }
    function camelize(string) {
      return string.replace(hyphenPattern, function (_, character) {
        return character.toUpperCase();
      });
    }
    function setValueForStyle(style, styleName, value) {
      var isCustomProperty = 0 === styleName.indexOf("--");
      isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = !0, console.error("Unsupported style property %s. Did you mean %s?", styleName, camelize(styleName.replace(msPattern, "ms-")))) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = !0, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", styleName, styleName.charAt(0).toUpperCase() + styleName.slice(1))) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = !0, console.error('Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.', styleName, value.replace(badStyleValueWithSemicolonPattern, ""))), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = !0, console.error("`NaN` is an invalid value for the `%s` css style property.", styleName)) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = !0, console.error("`Infinity` is an invalid value for the `%s` css style property.", styleName))));
      null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style.setProperty(styleName, "") : "float" === styleName ? style.cssFloat = "" : style[styleName] = "" : isCustomProperty ? style.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style[styleName] = ("" + value).trim()) : style[styleName] = value + "px";
    }
    function setValueForStyles(node, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      styles && Object.freeze(styles);
      node = node.style;
      if (null != prevStyles) {
        if (styles) {
          var expandedUpdates = {};
          if (prevStyles) for (var key in prevStyles) if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key)) for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++) expandedUpdates[longhands[i]] = key;
          for (var _key in styles) if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key])) for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++) expandedUpdates[key[longhands]] = _key;
          _key = {};
          for (var key$jscomp$0 in styles) for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++) _key[key[longhands]] = key$jscomp$0;
          key$jscomp$0 = {};
          for (var _key2 in expandedUpdates) if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
            key$jscomp$0[i] = !0;
            i = console;
            var value = styles[key];
            i.error.call(i, "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating", key, longhands);
          }
        }
        for (var styleName in prevStyles) !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
        for (var _styleName in styles) _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
      } else for (expandedUpdates in styles) styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return !1;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    function getAttributeAlias(name) {
      return aliases.get(name) || name;
    }
    function validateProperty$1(tagName, name) {
      if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) return !0;
      if (rARIACamel$1.test(name)) {
        tagName = "aria-" + name.slice(4).toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (null == tagName) return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties$1[name] = !0;
        if (name !== tagName) return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0;
      }
      if (rARIA$1.test(name)) {
        tagName = name.toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (null == tagName) return warnedProperties$1[name] = !0, !1;
        name !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0);
      }
      return !0;
    }
    function validateProperties$2(type, props) {
      var invalidProps = [],
        key;
      for (key in props) validateProperty$1(type, key) || invalidProps.push(key);
      props = invalidProps.map(function (prop) {
        return "`" + prop + "`";
      }).join(", ");
      1 === invalidProps.length ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type);
    }
    function validateProperty(tagName, name, value, eventRegistry) {
      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) return !0;
      var lowerCasedName = name.toLowerCase();
      if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName) return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties[name] = !0;
      if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name)) return !0;
      if (null != eventRegistry) {
        tagName = eventRegistry.possibleRegistrationNames;
        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name)) return !0;
        eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
        if (null != eventRegistry) return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name, eventRegistry), warnedProperties[name] = !0;
        if (EVENT_NAME_REGEX.test(name)) return console.error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties[name] = !0;
      } else if (EVENT_NAME_REGEX.test(name)) return INVALID_EVENT_NAME_REGEX.test(name) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties[name] = !0;
      if (rARIA.test(name) || rARIACamel.test(name)) return !0;
      if ("innerhtml" === lowerCasedName) return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties[name] = !0;
      if ("aria" === lowerCasedName) return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties[name] = !0;
      if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value) return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties[name] = !0;
      if ("number" === typeof value && isNaN(value)) return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties[name] = !0;
      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
        if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name) return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name, lowerCasedName), warnedProperties[name] = !0;
      } else if (name !== lowerCasedName) return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties[name] = !0;
      switch (name) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return !0;
        case "innerText":
        case "textContent":
          return !0;
      }
      switch (typeof value) {
        case "boolean":
          switch (name) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return !0;
            default:
              lowerCasedName = name.toLowerCase().slice(0, 5);
              if ("data-" === lowerCasedName || "aria-" === lowerCasedName) return !0;
              value ? console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              return warnedProperties[name] = !0;
          }
        case "function":
        case "symbol":
          return warnedProperties[name] = !0, !1;
        case "string":
          if ("false" === value || "true" === value) {
            switch (name) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return !0;
            }
            console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties[name] = !0;
          }
      }
      return !0;
    }
    function warnUnknownProperties(type, props, eventRegistry) {
      var unknownProps = [],
        key;
      for (key in props) validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
      props = unknownProps.map(function (prop) {
        return "`" + prop + "`";
      }).join(", ");
      1 === unknownProps.length ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type);
    }
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (target = internalInstance.stateNode, internalInstance.type) {
          case "input":
            updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode;) props = props.parentNode;
              checkAttributeStringCoercion(internalInstance, "name");
              props = props.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + '"][type="radio"]');
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps) throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                  updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
                }
              }
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, !1);
        }
      }
    }
    function batchedUpdates$1(fn, a, b) {
      if (isInsideEventHandler) return fn(a, b);
      isInsideEventHandler = !0;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (isInsideEventHandler = !1, null !== restoreTarget || null !== restoreQueue) if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn)) for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
          inst = !props;
          break a;
        default:
          inst = !1;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode) throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type.");
      return stateNode;
    }
    function getData() {
      if (fallbackText) return fallbackText;
      var start,
        startValue = startText,
        startLength = startValue.length,
        end,
        endValue = "value" in root ? root.value : root.textContent,
        endLength = endValue.length;
      for (start = 0; start < startLength && startValue[start] === endValue[start]; start++);
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);
      return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return !0;
    }
    function functionThatReturnsFalse() {
      return !1;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface) Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
        this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : !1 === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue);
        },
        stopPropagation: function () {
          var event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue);
        },
        persist: function () {},
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : !1;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return nativeEvent.keyCode !== START_KEYCODE;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
    }
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (nativeEvent.which !== SPACEBAR_CODE) return null;
          hasSpaceKeypress = !0;
          return SPACEBAR_CHAR;
        case "textInput":
          return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing) return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = !1, domEventName) : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
            if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char;
            if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? !0 : !1;
    }
    function isEventSupported(eventNameSuffix) {
      if (!canUseDOM) return !1;
      eventNameSuffix = "on" + eventNameSuffix;
      var isSupported = eventNameSuffix in document;
      isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
      return isSupported;
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length && (nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target), dispatchQueue.push({
        event: nativeEvent,
        listeners: inst
      }));
    }
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    function stopWatchingForValueChange() {
      activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    function handlePropertyChange(nativeEvent) {
      if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName) return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return !0;
      if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return !1;
      var keysA = Object.keys(objA),
        keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return !1;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;
      }
      return !0;
    }
    function getLeafNode(node) {
      for (; node && node.firstChild;) node = node.firstChild;
      return node;
    }
    function getNodeForCharacterOffset(root, offset) {
      var node = getLeafNode(root);
      root = 0;
      for (var nodeEnd; node;) {
        if (3 === node.nodeType) {
          nodeEnd = root + node.textContent.length;
          if (root <= offset && nodeEnd >= offset) return {
            node: node,
            offset: offset - root
          };
          root = nodeEnd;
        }
        a: {
          for (; node;) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = void 0;
        }
        node = getLeafNode(node);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode ? outerNode === innerNode ? !0 : outerNode && 3 === outerNode.nodeType ? !1 : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : !1 : !1;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
      for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement;) {
        try {
          var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = !1;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
    }
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
      mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = {
        start: doc.selectionStart,
        end: doc.selectionEnd
      } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
        anchorNode: doc.anchorNode,
        anchorOffset: doc.anchorOffset,
        focusNode: doc.focusNode,
        focusOffset: doc.focusOffset
      }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
        event: nativeEvent,
        listeners: doc
      }), nativeEvent.target = activeElement)));
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName]) return eventName;
      var prefixMap = vendorPrefixes[eventName],
        styleProp;
      for (styleProp in prefixMap) if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) return prefixedEventNames[eventName] = prefixMap[styleProp];
      return eventName;
    }
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value: value,
          source: source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value: value,
        source: source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = !1, parent = sourceFiber.return; null !== parent;) parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = !0)), sourceFiber = parent, parent = parent.return;
      return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
      null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
      for (var node = sourceFiber, parent = node.return; null !== parent;) null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
      return 3 === node.tag ? node.stateNode : null;
    }
    function resolveFunctionForHotReloading(type) {
      if (null === resolveFamily) return type;
      var family = resolveFamily(type);
      return void 0 === family ? type : family.current;
    }
    function resolveForwardRefForHotReloading(type) {
      if (null === resolveFamily) return type;
      var family = resolveFamily(type);
      return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {
        $$typeof: REACT_FORWARD_REF_TYPE,
        render: family
      }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
      if (null === resolveFamily) return !1;
      var prevType = fiber.elementType;
      element = element.type;
      var needsCompareFamilies = !1,
        $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
      switch (fiber.tag) {
        case 1:
          "function" === typeof element && (needsCompareFamilies = !0);
          break;
        case 0:
          "function" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
          break;
        case 11:
          $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
          break;
        case 14:
        case 15:
          $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
          break;
        default:
          return !1;
      }
      return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
      null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));
    }
    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
      var alternate = fiber.alternate,
        child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type,
        candidateType = null;
      switch (tag) {
        case 0:
        case 15:
        case 1:
          candidateType = type;
          break;
        case 11:
          candidateType = type.render;
      }
      if (null === resolveFamily) throw Error("Expected resolveFamily to be set during hot reload.");
      var needsRender = !1;
      type = !1;
      null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = !0 : updatedFamilies.has(candidateType) && (1 === tag ? type = !0 : needsRender = !0)));
      null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = !0);
      type && (fiber._debugNeedsRemount = !0);
      if (type || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
      null === child || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
      null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
    }
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
      this.actualDuration = -0;
      this.actualStartTime = -1.1;
      this.treeBaseDuration = this.selfBaseDuration = -0;
      this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
      this._debugNeedsRemount = !1;
      this._debugHookTypes = null;
      hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress = current.alternate;
      null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugStack = current._debugStack, workInProgress._debugTask = current._debugTask, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);
      workInProgress.flags = current.flags & 65011712;
      workInProgress.childLanes = current.childLanes;
      workInProgress.lanes = current.lanes;
      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      workInProgress.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress.dependencies = null === pendingProps ? null : {
        lanes: pendingProps.lanes,
        firstContext: pendingProps.firstContext,
        _debugThenableState: pendingProps._debugThenableState
      };
      workInProgress.sibling = current.sibling;
      workInProgress.index = current.index;
      workInProgress.ref = current.ref;
      workInProgress.refCleanup = current.refCleanup;
      workInProgress.selfBaseDuration = current.selfBaseDuration;
      workInProgress.treeBaseDuration = current.treeBaseDuration;
      workInProgress._debugInfo = current._debugInfo;
      workInProgress._debugNeedsRemount = current._debugNeedsRemount;
      switch (workInProgress.tag) {
        case 0:
        case 15:
          workInProgress.type = resolveFunctionForHotReloading(current.type);
          break;
        case 1:
          workInProgress.type = resolveFunctionForHotReloading(current.type);
          break;
        case 11:
          workInProgress.type = resolveForwardRefForHotReloading(current.type);
      }
      return workInProgress;
    }
    function resetWorkInProgress(workInProgress, renderLanes) {
      workInProgress.flags &= 65011714;
      var current = workInProgress.alternate;
      null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {
        lanes: renderLanes.lanes,
        firstContext: renderLanes.firstContext,
        _debugThenableState: renderLanes._debugThenableState
      }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);
      return workInProgress;
    }
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
      var fiberTag = 0,
        resolvedType = type;
      if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);else if ("string" === typeof type) fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;else a: switch (type) {
        case REACT_ACTIVITY_TYPE:
          return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
        case REACT_FRAGMENT_TYPE:
          return createFiberFromFragment(pendingProps.children, mode, lanes, key);
        case REACT_STRICT_MODE_TYPE:
          fiberTag = 8;
          mode |= StrictLegacyMode;
          mode |= StrictEffectsMode;
          break;
        case REACT_PROFILER_TYPE:
          return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {
            effectDuration: 0,
            passiveEffectDuration: 0
          }, key;
        case REACT_SUSPENSE_TYPE:
          return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
        case REACT_SUSPENSE_LIST_TYPE:
          return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
        default:
          if ("object" === typeof type && null !== type) switch (type.$$typeof) {
            case REACT_PROVIDER_TYPE:
            case REACT_CONTEXT_TYPE:
              fiberTag = 10;
              break a;
            case REACT_CONSUMER_TYPE:
              fiberTag = 9;
              break a;
            case REACT_FORWARD_REF_TYPE:
              fiberTag = 11;
              resolvedType = resolveForwardRefForHotReloading(resolvedType);
              break a;
            case REACT_MEMO_TYPE:
              fiberTag = 14;
              break a;
            case REACT_LAZY_TYPE:
              fiberTag = 16;
              resolvedType = null;
              break a;
          }
          resolvedType = "";
          if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
          (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
          fiberTag = 29;
          pendingProps = Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType));
          resolvedType = null;
      }
      key = createFiber(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = resolvedType;
      key.lanes = lanes;
      key._debugOwner = owner;
      return key;
    }
    function createFiberFromElement(element, mode, lanes) {
      mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);
      mode._debugOwner = element._owner;
      mode._debugStack = element._debugStack;
      mode._debugTask = element._debugTask;
      return mode;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiber(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiber(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    function pushTreeFork(workInProgress, totalChildren) {
      warnIfNotHydrating();
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress, totalChildren, index) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress;
      } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;
    }
    function pushMaterializedTreeId(workInProgress) {
      warnIfNotHydrating();
      null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
    }
    function popTreeContext(workInProgress) {
      for (; workInProgress === treeForkProvider;) treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (; workInProgress === treeContextProvider;) treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function warnIfNotHydrating() {
      isHydrating || console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
      if (null === fiber.return) {
        if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {
          fiber: fiber,
          children: [],
          serverProps: void 0,
          serverTail: [],
          distanceFromLeaf: distanceFromLeaf
        };else {
          if (hydrationDiffRootDEV.fiber !== fiber) throw Error("Saw multiple hydration diff roots in a pass. This is a bug in React.");
          hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
        }
        return hydrationDiffRootDEV;
      }
      var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;
      if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
      distanceFromLeaf = {
        fiber: fiber,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: distanceFromLeaf
      };
      siblings.push(distanceFromLeaf);
      return distanceFromLeaf;
    }
    function warnNonHydratedInstance(fiber, rejectedCandidate) {
      didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
    }
    function throwOnHydrationMismatch(fiber) {
      var diff = "",
        diffRoot = hydrationDiffRootDEV;
      null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
      queueHydrationError(createCapturedValueAtFiber(Error("Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff), fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var didHydrate = fiber.stateNode;
      var type = fiber.type,
        props = fiber.memoizedProps;
      didHydrate[internalInstanceKey] = fiber;
      didHydrate[internalPropsKey] = props;
      validatePropertiesInDevelopment(type, props);
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", didHydrate);
          listenToNonDelegatedEvent("close", didHydrate);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "video":
        case "audio":
          for (type = 0; type < mediaEventTypes.length; type++) listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
          break;
        case "source":
          listenToNonDelegatedEvent("error", didHydrate);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", didHydrate);
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", didHydrate);
          break;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateInputProps(didHydrate, props);
          initInput(didHydrate, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, !0);
          track(didHydrate);
          break;
        case "option":
          validateOptionProps(didHydrate, props);
          break;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateSelectProps(didHydrate, props);
          break;
        case "textarea":
          checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(didHydrate, props.value, props.defaultValue, props.children), track(didHydrate);
      }
      type = props.children;
      "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || !0 === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = !0) : didHydrate = !1;
      didHydrate || throwOnHydrationMismatch(fiber);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber;) switch (hydrationParentFiber.tag) {
        case 5:
        case 13:
          rootOrSingletonContext = !1;
          return;
        case 27:
        case 3:
          rootOrSingletonContext = !0;
          return;
        default:
          hydrationParentFiber = hydrationParentFiber.return;
      }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return !1;
      if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;
      var tag = fiber.tag,
        JSCompiler_temp;
      if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
        if (JSCompiler_temp = 5 === tag) JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
        JSCompiler_temp = !JSCompiler_temp;
      }
      if (JSCompiler_temp && nextHydratableInstance) {
        for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp;) {
          var diffNode = buildHydrationDiffNode(fiber, 0),
            description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
          diffNode.serverTail.push(description);
          JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
        }
        throwOnHydrationMismatch(fiber);
      }
      popToNextHostParent(fiber);
      if (13 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
      } else 27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
      return !0;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      didSuspendOrErrorDEV = isHydrating = !1;
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);
      return queuedErrors;
    }
    function queueHydrationError(error) {
      null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    function emitPendingHydrationWarnings() {
      var diffRoot = hydrationDiffRootDEV;
      if (null !== diffRoot) {
        hydrationDiffRootDEV = null;
        for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length;) diffRoot = diffRoot.children[0];
        runWithFiberInDEV(diffRoot.fiber, function () {
          console.error("A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s", "https://react.dev/link/hydration-mismatch", diff);
        });
      }
    }
    function resetContextDependencies() {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      isDisallowedContextReadInDEV = !1;
    }
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue, providerFiber);
      context._currentValue = nextValue;
      push(rendererCursorDEV, context._currentRenderer, providerFiber);
      void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
      context._currentRenderer = rendererSigil;
    }
    function popProvider(context, providerFiber) {
      context._currentValue = valueCursor.current;
      var currentRenderer = rendererCursorDEV.current;
      pop(rendererCursorDEV, providerFiber);
      context._currentRenderer = currentRenderer;
      pop(valueCursor, providerFiber);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
      for (; null !== parent;) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
      parent !== propagationRoot && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {
      var fiber = workInProgress.child;
      null !== fiber && (fiber.return = workInProgress);
      for (; null !== fiber;) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list;) {
            var dependency = list;
            list = fiber;
            for (var i = 0; i < contexts.length; i++) if (dependency.context === contexts[i]) {
              list.lanes |= renderLanes;
              dependency = list.alternate;
              null !== dependency && (dependency.lanes |= renderLanes);
              scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);
              forcePropagateEntireTree || (nextFiber = null);
              break a;
            }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber) throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          nextFiber.lanes |= renderLanes;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;else for (nextFiber = fiber; null !== nextFiber;) {
          if (nextFiber === workInProgress) {
            nextFiber = null;
            break;
          }
          fiber = nextFiber.sibling;
          if (null !== fiber) {
            fiber.return = nextFiber.return;
            nextFiber = fiber;
            break;
          }
          nextFiber = nextFiber.return;
        }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {
      current = null;
      for (var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;) {
        if (!isInsidePropagationBailout) if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;else if (0 !== (parent.flags & 262144)) break;
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent) throw Error("Should have a current fiber. This is a bug in React.");
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent) throw Error("Should have a current fiber. This is a bug in React.");
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);
      workInProgress.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies;) {
        if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue)) return !0;
        currentDependencies = currentDependencies.next;
      }
      return !1;
    }
    function prepareToReadContext(workInProgress) {
      currentlyRenderingFiber$1 = workInProgress;
      lastContextDependency = null;
      workInProgress = workInProgress.dependencies;
      null !== workInProgress && (workInProgress.firstContext = null);
    }
    function readContext(context) {
      isDisallowedContextReadInDEV && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = {
        context: context,
        memoizedValue: value,
        next: null
      };
      if (null === lastContextDependency) {
        if (null === consumer) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        lastContextDependency = context;
        consumer.dependencies = {
          lanes: 0,
          firstContext: context,
          _debugThenableState: null
        };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    function createCache() {
      return {
        controller: new AbortControllerLocal(),
        data: new Map(),
        refCount: 0
      };
    }
    function retainCache(cache) {
      cache.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React.");
      cache.refCount++;
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 > cache.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React.");
      0 === cache.refCount && scheduleCallback$2(NormalPriority, function () {
        cache.controller.abort();
      });
    }
    function pushNestedEffectDurations() {
      var prevEffectDuration = profilerEffectDuration;
      profilerEffectDuration = 0;
      return prevEffectDuration;
    }
    function popNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration = prevEffectDuration;
      return elapsedTime;
    }
    function bubbleNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration += prevEffectDuration;
      return elapsedTime;
    }
    function startProfilerTimer(fiber) {
      profilerStartTime = now();
      0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
    }
    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        fiber.selfBaseDuration = elapsedTime;
        profilerStartTime = -1;
      }
    }
    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        profilerStartTime = -1;
      }
    }
    function recordEffectDuration() {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        profilerStartTime = -1;
        profilerEffectDuration += elapsedTime;
      }
    }
    function startEffectTimer() {
      profilerStartTime = now();
    }
    function transferActualDuration(fiber) {
      for (var child = fiber.child; child;) fiber.actualDuration += child.actualDuration, child = child.sibling;
    }
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function (resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
        null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [],
        thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function (resolve) {
            listeners.push(resolve);
          }
        };
      thenable.then(function () {
        thenableWithOverride.status = "fulfilled";
        thenableWithOverride.value = result;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
      }, function (error) {
        thenableWithOverride.status = "rejected";
        thenableWithOverride.reason = error;
        for (error = 0; error < listeners.length; error++) (0, listeners[error])(void 0);
      });
      return thenableWithOverride;
    }
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool ? null : {
        parent: CacheContext._currentValue,
        pool: cacheFromPool
      };
    }
    function createThenableState() {
      return {
        didWarnAboutUncachedPromise: !1,
        thenables: []
      };
    }
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function noop$3() {}
    function trackUsedThenable(thenableState, thenable, index) {
      null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);
      var trackedThenables = thenableState.thenables;
      index = trackedThenables[index];
      void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), thenable.then(noop$3, noop$3), thenable = index);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
        default:
          if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);else {
            thenableState = workInProgressRoot;
            if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error("An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
            thenableState = thenable;
            thenableState.status = "pending";
            thenableState.then(function (fulfilledValue) {
              if ("pending" === thenable.status) {
                var fulfilledThenable = thenable;
                fulfilledThenable.status = "fulfilled";
                fulfilledThenable.value = fulfilledValue;
              }
            }, function (error) {
              if ("pending" === thenable.status) {
                var rejectedThenable = thenable;
                rejectedThenable.status = "rejected";
                rejectedThenable.reason = error;
              }
            });
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
          }
          suspendedThenable = thenable;
          needsToResetSuspendedThenableDEV = !0;
          throw SuspenseException;
      }
    }
    function getSuspendedThenable() {
      if (null === suspendedThenable) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      var thenable = suspendedThenable;
      suspendedThenable = null;
      needsToResetSuspendedThenableDEV = !1;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException) throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
    }
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          lanes: 0,
          hiddenCallbacks: null
        },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current, workInProgress) {
      current = current.updateQueue;
      workInProgress.updateQueue === current && (workInProgress.updateQueue = {
        baseState: current.baseState,
        firstBaseUpdate: current.firstBaseUpdate,
        lastBaseUpdate: current.lastBaseUpdate,
        shared: current.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return {
        lane: lane,
        tag: UpdateState,
        payload: null,
        callback: null,
        next: null
      };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
        var componentName = getComponentNameFromFiber(fiber);
        console.error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s", componentName);
        didWarnUpdateInsideUpdate = !0;
      }
      if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
      var queue = workInProgress.updateQueue,
        current = workInProgress.alternate;
      if (null !== current && (current = current.updateQueue, queue === current)) {
        var newFirst = null,
          newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
            queue = queue.next;
          } while (null !== queue);
          null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress.updateQueue = queue;
        return;
      }
      workInProgress = queue.lastBaseUpdate;
      null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {
      didReadFromEntangledAsyncAction = !1;
      var queue = workInProgress.updateQueue;
      hasForceUpdate = !1;
      currentlyProcessingQueue = queue.shared;
      var firstBaseUpdate = queue.firstBaseUpdate,
        lastBaseUpdate = queue.lastBaseUpdate,
        pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue,
          firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress.alternate;
        null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913,
            isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
            null !== current && (current = current.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              updateLane = workInProgress;
              var partialState = pendingQueue;
              var nextProps = props,
                instance = instance$jscomp$0;
              switch (partialState.tag) {
                case ReplaceState:
                  partialState = partialState.payload;
                  if ("function" === typeof partialState) {
                    isDisallowedContextReadInDEV = !0;
                    var nextState = partialState.call(instance, newState, nextProps);
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(!0);
                      try {
                        partialState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(!1);
                      }
                    }
                    isDisallowedContextReadInDEV = !1;
                    newState = nextState;
                    break a;
                  }
                  newState = partialState;
                  break a;
                case CaptureUpdate:
                  updateLane.flags = updateLane.flags & -65537 | 128;
                case UpdateState:
                  nextState = partialState.payload;
                  if ("function" === typeof nextState) {
                    isDisallowedContextReadInDEV = !0;
                    partialState = nextState.call(instance, newState, nextProps);
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(!0);
                      try {
                        nextState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(!1);
                      }
                    }
                    isDisallowedContextReadInDEV = !1;
                  } else partialState = nextState;
                  if (null === partialState || void 0 === partialState) break a;
                  newState = assign({}, newState, partialState);
                  break a;
                case ForceUpdate:
                  hasForceUpdate = !0;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else isHiddenUpdate = {
            lane: updateLane,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: pendingQueue.callback,
            next: null
          }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress.lanes = lastBaseUpdate;
        workInProgress.memoizedState = newState;
      }
      currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback) throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
      callback.call(context);
    }
    function commitHiddenCallbacks(updateQueue, context) {
      var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
      if (null !== hiddenCallbacks) for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++) callCallback(hiddenCallbacks[updateQueue], context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks) for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++) callCallback(callbacks[updateQueue], context);
    }
    function pushHiddenContext(fiber, context) {
      var prevEntangledRenderLanes = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, context, fiber);
      entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
    }
    function reuseHiddenContextOnStack(fiber) {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);
    }
    function popHiddenContext(fiber) {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor, fiber);
      pop(prevEntangledRenderLanesCursor, fiber);
    }
    function mountHookTypesDev() {
      var hookName = currentHookNameInDev;
      null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
      var hookName = currentHookNameInDev;
      if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
        var componentName = getComponentNameFromFiber(currentlyRenderingFiber);
        if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {
          for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
            var oldHookName = hookTypesDev[i],
              newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
            for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length;) oldHookName += " ";
            oldHookName += newHookName + "\n";
            table += oldHookName;
          }
          console.error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
        }
      }
    }
    function checkDepsAreArrayDev(deps) {
      void 0 === deps || null === deps || isArrayImpl(deps) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
    }
    function warnOnUseFormStateInDev() {
      var componentName = getComponentNameFromFiber(currentlyRenderingFiber);
      didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", componentName));
    }
    function throwInvalidHookError() {
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (ignorePreviousDependencies) return !1;
      if (null === prevDeps) return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
      nextDeps.length !== prevDeps.length && console.error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
      return !0;
    }
    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress;
      hookTypesDev = null !== current ? current._debugHookTypes : null;
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;
      if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error("%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.", null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"));
      workInProgress.memoizedState = null;
      workInProgress.updateQueue = null;
      workInProgress.lanes = 0;
      ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
      shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & StrictLegacyMode) !== NoMode;
      var children = callComponentInDEV(Component, props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = !1;
      didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));
      if (nextRenderLanes) {
        setIsStrictModeForDevtools(!0);
        try {
          children = renderWithHooksAgain(workInProgress, Component, props, secondArg);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      finishRenderingHooks(current, workInProgress);
      return children;
    }
    function finishRenderingHooks(current, workInProgress) {
      workInProgress._debugHookTypes = hookTypesDev;
      null === workInProgress.dependencies ? null !== thenableState$1 && (workInProgress.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: thenableState$1
      }) : workInProgress.dependencies._debugThenableState = thenableState$1;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
      hookTypesUpdateIndexDev = -1;
      null !== current && (current.flags & 65011712) !== (workInProgress.flags & 65011712) && console.error("Internal React error: Expected static flag was missing. Please notify the React team.");
      didScheduleRenderPhaseUpdate = !1;
      thenableIndexCounter$1 = 0;
      thenableState$1 = null;
      if (didRenderTooFewHooks) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));
      needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;
      current && (workInProgress = getComponentNameFromFiber(workInProgress) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
    }
    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
        thenableIndexCounter$1 = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = !1;
        if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        numberOfReRenders += 1;
        ignorePreviousDependencies = !1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress.updateQueue) {
          var children = workInProgress.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        hookTypesUpdateIndexDev = -1;
        ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
        children = callComponentInDEV(Component, props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H,
        maybeThenable = dispatcher.useState()[0];
      maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress, lanes) {
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.flags = (workInProgress.mode & StrictEffectsMode) !== NoMode ? workInProgress.flags & -402655237 : workInProgress.flags & -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress = workInProgress.memoizedState; null !== workInProgress;) {
          var queue = workInProgress.queue;
          null !== queue && (queue.pending = null);
          workInProgress = workInProgress.next;
        }
        didScheduleRenderPhaseUpdate = !1;
      }
      renderLanes = 0;
      hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
      hookTypesUpdateIndexDev = -1;
      currentHookNameInDev = null;
      didScheduleRenderPhaseUpdateDuringThisPass = !1;
      thenableIndexCounter$1 = localIdCounter = 0;
      thenableState$1 = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
      if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber.alternate) throw Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");
          throw Error("Rendered more hooks than during the previous render.");
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return {
        lastEffect: null,
        events: null,
        stores: null,
        memoCache: null
      };
    }
    function useThenable(thenable) {
      var index = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = createThenableState());
      thenable = trackUsedThenable(thenableState$1, thenable, index);
      index = currentlyRenderingFiber;
      null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
      return thenable;
    }
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error("An unsupported type was passed to use(): " + String(usable));
    }
    function useMemoCache(size) {
      var memoCache = null,
        updateQueue = currentlyRenderingFiber.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber.alternate;
        null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
          data: current.data.map(function (array) {
            return array.slice();
          }),
          index: 0
        })));
      }
      null == memoCache && (memoCache = {
        data: [],
        index: 0
      });
      null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue || ignorePreviousDependencies) for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++) updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;else updateQueue.length !== size && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", updateQueue.length, size);
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (void 0 !== init) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      } else initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);
      return [hook.memoizedState, reducer];
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue,
        pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue !== baseQueue && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;else {
        current = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null,
          newBaseQueueLast = null,
          update = current,
          didReadFromEntangledAsyncAction = !1;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
              lane: 0,
              revertLane: 0,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
              continue;
            } else updateLane = {
              lane: 0,
              revertLane: update.revertLane,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else revertLane = {
            lane: updateLane,
            revertLane: update.revertLane,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(),
        queue = hook.queue;
      if (null === queue) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch,
        lastRenderPhaseUpdate = queue.pending,
        newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do newState = reducer(newState, update.action), update = update.next; while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber,
        hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        var nextSnapshot = getServerSnapshot();
        didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error("The result of getServerSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
      } else {
        nextSnapshot = getSnapshot();
        didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0));
        if (null === workInProgressRoot) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
      }
      hook.memoizedState = nextSnapshot;
      getServerSnapshot = {
        value: nextSnapshot,
        getSnapshot: getSnapshot
      };
      hook.queue = getServerSnapshot;
      mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [subscribe]);
      fiber.flags |= 2048;
      pushSimpleEffect(HasEffect | Passive, createEffectInstance(), updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), null);
      return nextSnapshot;
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber,
        hook = updateWorkInProgressHook(),
        isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        getServerSnapshot = getServerSnapshot();
      } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
        var cachedSnapshot = getSnapshot();
        objectIs(getServerSnapshot, cachedSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
      }
      if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;
      hook = hook.queue;
      var create = subscribeToStore.bind(null, fiber, hook, subscribe);
      updateEffectImpl(2048, Passive, create, [subscribe]);
      if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
        fiber.flags |= 2048;
        pushSimpleEffect(HasEffect | Passive, createEffectInstance(), updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);
        if (null === workInProgressRoot) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = {
        getSnapshot: getSnapshot,
        value: renderedSnapshot
      };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function () {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return !0;
      }
    }
    function forceStoreRerender(fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function mountState(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue,
        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    }
    function mountOptimistic(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !0, queue);
      queue.dispatch = hook;
      return [passthrough, hook];
    }
    function updateOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(hook, currentHook, "function" === typeof reducer ? reducer : basicStateReducer);
    }
    function rerenderOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber)) throw Error("Cannot update form state while rendering.");
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload: payload,
          action: fiber,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function (listener) {
            actionNode.listeners.push(listener);
          }
        };
        null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node) {
      var action = node.action,
        payload = node.payload,
        prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T,
          currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        ReactSharedInternals.T._updatedFibers = new Set();
        try {
          var returnValue = action(prevState, payload),
            onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
        }
      } else try {
        currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
      } catch (error$4) {
        onActionError(actionQueue, node, error$4);
      }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (returnValue.then(function (nextState) {
        onActionSuccess(actionQueue, node, nextState);
      }, function (error) {
        return onActionError(actionQueue, node, error);
      }), node.isTransition || console.error("An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop.")) : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last) {
        last = last.next;
        do actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next; while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var isMatching = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var markerInstance = nextHydratableInstance;
                  for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType;) {
                    if (!inRootOrSingleton) {
                      markerInstance = null;
                      break b;
                    }
                    markerInstance = getNextHydratable(markerInstance.nextSibling);
                    if (null === markerInstance) {
                      markerInstance = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = markerInstance.data;
                  markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                }
                if (markerInstance) {
                  nextHydratableInstance = getNextHydratable(markerInstance.nextSibling);
                  isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                  break a;
                }
              }
              throwOnHydrationMismatch(isMatching);
            }
            isMatching = !1;
          }
          isMatching && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      isMatching = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = isMatching;
      ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, isMatching);
      isMatching.dispatch = ssrFormState;
      isMatching = mountStateImpl(!1);
      inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !1, isMatching.queue);
      isMatching = mountWorkInProgressHook();
      markerInstance = {
        state: initialStateProp,
        dispatch: null,
        action: action,
        pending: null
      };
      isMatching.queue = markerInstance;
      ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, markerInstance, inRootOrSingleton, ssrFormState);
      markerInstance.dispatch = ssrFormState;
      isMatching.memoizedState = action;
      return [initialStateProp, ssrFormState, !1];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then) try {
        var state = useThenable(currentStateHook);
      } catch (x) {
        if (x === SuspenseException) throw SuspenseActionException;
        throw x;
      } else state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue,
        dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(HasEffect | Passive, createEffectInstance(), actionStateActionEffect.bind(null, actionQueue, action), null));
      return [state, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(),
        currentStateHook = currentHook;
      if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, !1];
    }
    function pushSimpleEffect(tag, inst, create, createDeps) {
      tag = {
        tag: tag,
        create: create,
        deps: createDeps,
        inst: inst,
        next: null
      };
      inst = currentlyRenderingFiber.updateQueue;
      null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
      create = inst.lastEffect;
      null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
      return tag;
    }
    function createEffectInstance() {
      return {
        destroy: void 0,
        resource: void 0
      };
    }
    function mountRef(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = {
        current: initialValue
      };
      return hook.memoizedState = initialValue;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
      var hook = mountWorkInProgressHook();
      createDeps = void 0 === createDeps ? null : createDeps;
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, createEffectInstance(), create, createDeps);
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, inst, create, deps));
    }
    function mountEffect(create, createDeps) {
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(276826112, Passive, create, createDeps) : mountEffectImpl(8390656, Passive, create, createDeps);
    }
    function mountLayoutEffect(create, deps) {
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
      return mountEffectImpl(fiberFlags, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if ("function" === typeof ref) {
        create = create();
        var refCleanup = ref(create);
        return function () {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref) return ref.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(ref).join(", ") + "}"), create = create(), ref.current = create, function () {
        ref.current = null;
      };
    }
    function mountImperativeHandle(ref, create, deps) {
      "function" !== typeof create && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== create ? typeof create : "null");
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
      mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function updateImperativeHandle(ref, create, deps) {
      "function" !== typeof create && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== create ? typeof create : "null");
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function mountCallback(callback, deps) {
      mountWorkInProgressHook().memoizedState = [callback, void 0 === deps ? null : deps];
      return callback;
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function mountMemo(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValue(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    }
    function updateDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function rerenderDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;
      if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, !1, queue, pendingState);
      currentTransition._updatedFibers = new Set();
      try {
        var returnValue = callback(),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
          var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
          dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
        } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
      } catch (error) {
        dispatchSetStateInternal(fiber, queue, {
          then: function () {},
          status: "rejected",
          reason: error
        }, requestUpdateLane(fiber));
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
      }
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag) throw Error("Expected the form instance to be a HostComponent. This is a bug in React.");
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop$2 : function () {
        requestFormReset$1(formFiber);
        return action(formData);
      });
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: NotPendingTransition,
        baseState: NotPendingTransition,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: NotPendingTransition
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      null === ReactSharedInternals.T && console.error("requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.");
      var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
      dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));
    }
    function mountTransition() {
      var stateHook = mountStateImpl(!1);
      stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, !0, !1);
      mountWorkInProgressHook().memoizedState = stateHook;
      return [!1, stateHook];
    }
    function updateTransition() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
    }
    function rerenderTransition() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function mountId() {
      var hook = mountWorkInProgressHook(),
        identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var treeId = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
        identifierPrefix = "\u00ab" + identifierPrefix + "R" + treeId;
        treeId = localIdCounter++;
        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
        identifierPrefix += "\u00bb";
      } else treeId = globalClientIdCounter++, identifierPrefix = "\u00ab" + identifierPrefix + "r" + treeId.toString(32) + "\u00bb";
      return hook.memoizedState = identifierPrefix;
    }
    function mountRefresh() {
      return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber);
    }
    function refreshCache(fiber, seedKey) {
      for (var provider = fiber.return; null !== provider;) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane(provider);
            fiber = createUpdate(lane);
            var root = enqueueUpdate(provider, fiber, lane);
            null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));
            provider = createCache();
            null !== seedKey && void 0 !== seedKey && null !== root && console.error("The seed argument is not enabled outside experimental channels.");
            fiber.payload = {
              cache: provider
            };
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var args = arguments;
      "function" === typeof args[3] && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      args = requestUpdateLane(fiber);
      var update = {
        lane: args,
        revertLane: 0,
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
      markStateUpdateScheduled(fiber, args);
    }
    function dispatchSetState(fiber, queue, action) {
      var args = arguments;
      "function" === typeof args[3] && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      args = requestUpdateLane(fiber);
      dispatchSetStateInternal(fiber, queue, action, args);
      markStateUpdateScheduled(fiber, args);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane: lane,
        revertLane: 0,
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);else {
        var alternate = fiber.alternate;
        if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            var currentState = queue.lastRenderedState,
              eagerState = alternate(currentState, action);
            update.hasEagerState = !0;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;
          } catch (error) {} finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;
      }
      return !1;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.");
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        action: action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender) throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      markStateUpdateScheduled(fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
      var pending = queue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root, queue, lane) {
      if (0 !== (lane & 4194048)) {
        var queueLanes = queue.lanes;
        queueLanes &= root.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root, lane);
      }
    }
    function pushDebugInfo(debugInfo) {
      var previousDebugInfo = currentDebugInfo;
      null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
      return previousDebugInfo;
    }
    function validateFragmentProps(element, fiber, returnFiber) {
      for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
        var key = keys[i];
        if ("children" !== key && "key" !== key) {
          null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
          runWithFiberInDEV(fiber, function (erroredKey) {
            console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", erroredKey);
          }, key);
          break;
        }
      }
    }
    function unwrapThenable(thenable) {
      var index = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = createThenableState());
      return trackUsedThenable(thenableState, thenable, index);
    }
    function coerceRef(workInProgress, element) {
      element = element.props.ref;
      workInProgress.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.');
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead.");
    }
    function warnOnFunctionType(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)", invalidChild, invalidChild, invalidChild) : console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>", invalidChild, invalidChild, parentName, invalidChild, parentName));
    }
    function warnOnSymbolType(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error("Symbols are not valid as a React child.\n  root.render(%s)", invalidChild) : console.error("Symbols are not valid as a React child.\n  <%s>%s</%s>", parentName, invalidChild, parentName));
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild;) deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map(); null !== currentFirstChild;) null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugTask = returnFiber._debugTask, current._debugInfo = currentDebugInfo, current;
        current = useFiber(current, textContent);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;
        if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;
        current = createFiberFromElement(element, returnFiber.mode, lanes);
        coerceRef(current, element);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugTask = returnFiber._debugTask, current._debugInfo = currentDebugInfo, current;
        current = useFiber(current, fragment);
        current.return = returnFiber;
        current._debugInfo = currentDebugInfo;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
            case REACT_LAZY_TYPE:
              var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              newChild = callLazyInitInDEV(newChild);
              returnFiber = createChild(returnFiber, newChild, lanes);
              currentDebugInfo = _prevDebugInfo;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
          if ("function" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
            if (null !== key) return null;
            key = pushDebugInfo(newChild._debugInfo);
            returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            currentDebugInfo = key;
            return returnFiber;
          }
          if ("function" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
              newChild = callLazyInitInDEV(newChild);
              returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
              currentDebugInfo = _prevDebugInfo7;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;
          if ("function" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {
        if ("object" !== typeof child || null === child) return knownKeys;
        switch (child.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            warnForMissingKey(returnFiber, workInProgress, child);
            var key = child.key;
            if ("string" !== typeof key) break;
            if (null === knownKeys) {
              knownKeys = new Set();
              knownKeys.add(key);
              break;
            }
            if (!knownKeys.has(key)) {
              knownKeys.add(key);
              break;
            }
            runWithFiberInDEV(workInProgress, function () {
              console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
            });
            break;
          case REACT_LAZY_TYPE:
            child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);
        }
        return knownKeys;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++) oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++) nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function (child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (null == newChildren) throw Error("An iterable object provided no iterator.");
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next()) oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next()) nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function (child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              a: {
                for (var key = newChild.key; null !== currentFirstChild;) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                        lanes = useFiber(currentFirstChild, newChild.props.children);
                        lanes.return = returnFiber;
                        lanes._debugOwner = newChild._owner;
                        lanes._debugInfo = currentDebugInfo;
                        validateFragmentProps(newChild, lanes, returnFiber);
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      lanes._debugOwner = newChild._owner;
                      lanes._debugInfo = currentDebugInfo;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
              }
              returnFiber = placeSingleChild(returnFiber);
              currentDebugInfo = prevDebugInfo;
              return returnFiber;
            case REACT_PORTAL_TYPE:
              a: {
                prevDebugInfo = newChild;
                for (newChild = prevDebugInfo.key; null !== currentFirstChild;) {
                  if (currentFirstChild.key === newChild) {
                    if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          }
          if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (getIteratorFn(newChild)) {
            prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            key = getIteratorFn(newChild);
            if ("function" !== typeof key) throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            var newChildren = key.call(newChild);
            if (newChildren === newChild) {
              if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = !0;
            } else newChild.entries !== key || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
            returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);
            currentDebugInfo = prevDebugInfo;
            return returnFiber;
          }
          if ("function" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
        "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
        "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function (returnFiber, currentFirstChild, newChild, lanes) {
        var prevDebugInfo = currentDebugInfo;
        currentDebugInfo = null;
        try {
          thenableIndexCounter = 0;
          var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
          thenableState = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException || x === SuspenseActionException) throw x;
          var fiber = createFiber(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          var debugInfo = fiber._debugInfo = currentDebugInfo;
          fiber._debugOwner = returnFiber._debugOwner;
          fiber._debugTask = returnFiber._debugTask;
          if (null != debugInfo) for (var i = debugInfo.length - 1; 0 <= i; i--) if ("string" === typeof debugInfo[i].stack) {
            fiber._debugOwner = debugInfo[i];
            fiber._debugTask = debugInfo[i].debugTask;
            break;
          }
          return fiber;
        } finally {
          currentDebugInfo = prevDebugInfo;
        }
      };
    }
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);
      push(suspenseHandlerStackCursor, handler, handler);
      null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushOffscreenSuspenseHandler(fiber) {
      if (22 === fiber.tag) {
        if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {
          var current = fiber.alternate;
          null !== current && null !== current.memoizedState && (shellBoundary = fiber);
        }
      } else reuseSuspenseHandlerOnStack(fiber);
    }
    function reuseSuspenseHandlerOnStack(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor, fiber);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor, fiber);
    }
    function findFirstSuspended(row) {
      for (var node = row; null !== node;) {
        if (13 === node.tag) {
          var state = node.memoizedState;
          if (null !== state && (state = state.dehydrated, null === state || state.data === SUSPENSE_PENDING_START_DATA || isSuspenseInstanceFallback(state))) return node;
        } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
          if (0 !== (node.flags & 128)) return node;
        } else if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row) break;
        for (; null === node.sibling;) {
          if (null === node.return || node.return === row) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    function warnOnInvalidCallback(callback) {
      if (null !== callback && "function" !== typeof callback) {
        var key = String(callback);
        didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
      }
    }
    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
      var prevState = workInProgress.memoizedState,
        partialState = getDerivedStateFromProps(nextProps, prevState);
      if (workInProgress.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(!0);
        try {
          partialState = getDerivedStateFromProps(nextProps, prevState);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", ctor)));
      prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
      workInProgress.memoizedState = prevState;
      0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);
    }
    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
      var instance = workInProgress.stateNode;
      if ("function" === typeof instance.shouldComponentUpdate) {
        oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
        if (workInProgress.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        void 0 === oldProps && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
        return oldProps;
      }
      return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
    }
    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
      var oldState = instance.state;
      "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps) "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if (Component = Component.defaultProps) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var _propName in Component) void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
      console.warn("%s\n\n%s\n", componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.", "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.");
    }
    function defaultOnCaughtError(error) {
      var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.",
        recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
      if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
        var JSCompiler_inline_result = error.environmentName;
        error = ["%o\n\n%s\n\n%s\n", error, componentNameMessage, recreateMessage].slice(0);
        "string" === typeof error[0] ? error.splice(0, 1, badgeFormat + error[0], badgeStyle, pad + JSCompiler_inline_result + pad, resetStyle) : error.splice(0, 0, badgeFormat, badgeStyle, pad + JSCompiler_inline_result + pad, resetStyle);
        error.unshift(console);
        JSCompiler_inline_result = bind.apply(console.error, error);
        JSCompiler_inline_result();
      } else console.error("%o\n\n%s\n\n%s\n", error, componentNameMessage, recreateMessage);
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = null;
        var error = errorInfo.value;
        if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);else {
          var onUncaughtError = root.onUncaughtError;
          onUncaughtError(error, {
            componentStack: errorInfo.stack
          });
        }
      } catch (e$5) {
        setTimeout(function () {
          throw e$5;
        });
      }
    }
    function logCaughtError(root, boundary, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = getComponentNameFromFiber(boundary);
        var onCaughtError = root.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$6) {
        setTimeout(function () {
          throw e$6;
        });
      }
    }
    function createRootErrorUpdate(root, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      lane.payload = {
        element: null
      };
      lane.callback = function () {
        runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      return lane;
    }
    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function () {
          return getDerivedStateFromError(error);
        };
        update.callback = function () {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function () {
        markFailedErrorBoundaryForHotReloading(fiber);
        runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
        "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        callComponentDidCatchInDEV(this, errorInfo);
        "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
      });
    }
    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
      if (null !== value && "object" === typeof value && "function" === typeof value.then) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);
        isHydrating && (didSuspendOrErrorDEV = !0);
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 13:
              return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;
          }
          throw Error("Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React.");
        }
        attachPingListener(root, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return !1;
      }
      if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.", {
        cause: value
      }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering the entire root.", {
        cause: value
      }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;
      var error = createCapturedValueAtFiber(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", {
        cause: value
      }), sourceFiber);
      null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
      workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
      if (null === returnFiber) return !0;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;
          case 1:
            if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return !1;
    }
    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
      workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
    }
    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
      Component = Component.render;
      var ref = workInProgress.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps) "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);
      key = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      isHydrating && key && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
      if (null === current) {
        var type = Component.type;
        if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);
        current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
        current.ref = workInProgress.ref;
        current.return = workInProgress;
        return workInProgress.child = current;
      }
      type = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = null !== Component ? Component : shallowEqual;
        if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      }
      workInProgress.flags |= 1;
      current = createWorkInProgress(type, nextProps);
      current.ref = workInProgress.ref;
      current.return = workInProgress;
      return workInProgress.child = current;
    }
    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      }
      return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
    }
    function updateOffscreenComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        nextChildren = nextProps.children,
        prevState = null !== current ? current.memoizedState : null;
      if ("hidden" === nextProps.mode) {
        if (0 !== (workInProgress.flags & 128)) {
          nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
          if (null !== current) {
            nextChildren = workInProgress.child = current.child;
            for (prevState = 0; null !== nextChildren;) prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
            workInProgress.childLanes = prevState & ~nextProps;
          } else workInProgress.childLanes = 0, workInProgress.child = null;
          return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);
        }
        if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {
          baseLanes: 0,
          cachePool: null
        }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);
      } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
        parent: CacheContext._currentValue,
        pool: JSCompiler_inline_result
      };
      workInProgress.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress, null);
      reuseHiddenContextOnStack(workInProgress);
      pushOffscreenSuspenseHandler(workInProgress);
      null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);
      return null;
    }
    function markRef(current, workInProgress) {
      var ref = workInProgress.ref;
      if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 4194816);else {
        if ("function" !== typeof ref && "object" !== typeof ref) throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
        if (null === current || current.ref !== ref) workInProgress.flags |= 4194816;
      }
    }
    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
      if (Component.prototype && "function" === typeof Component.prototype.render) {
        var componentName = getComponentNameFromType(Component) || "Unknown";
        didWarnAboutBadClass[componentName] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName), didWarnAboutBadClass[componentName] = !0);
      }
      workInProgress.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
      null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", componentName))));
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);
      nextProps = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, Component, renderLanes);
      return workInProgress.child;
    }
    function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {
      prepareToReadContext(workInProgress);
      markComponentRenderStarted(workInProgress);
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;
      workInProgress.updateQueue = null;
      nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);
      finishRenderingHooks(current, workInProgress);
      Component = checkDidRenderIdHook();
      markComponentRenderStopped();
      if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      isHydrating && Component && pushMaterializedTreeId(workInProgress);
      workInProgress.flags |= 1;
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      return workInProgress.child;
    }
    function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
      switch (shouldErrorImpl(workInProgress)) {
        case !1:
          var _instance = workInProgress.stateNode,
            state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;
          _instance.updater.enqueueSetState(_instance, state, null);
          break;
        case !0:
          workInProgress.flags |= 128;
          workInProgress.flags |= 65536;
          _instance = Error("Simulated error coming from DevTools");
          var lane = renderLanes & -renderLanes;
          workInProgress.lanes |= lane;
          state = workInProgressRoot;
          if (null === state) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          lane = createClassErrorUpdate(lane);
          initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));
          enqueueCapturedUpdate(workInProgress, lane);
      }
      prepareToReadContext(workInProgress);
      if (null === workInProgress.stateNode) {
        state = emptyContextObject;
        _instance = Component.contextType;
        "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(Component) || "Component", lane));
        "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
        _instance = new Component(nextProps, state);
        if (workInProgress.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            _instance = new Component(nextProps, state);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
        _instance.updater = classComponentUpdater;
        workInProgress.stateNode = _instance;
        _instance._reactInternals = workInProgress;
        _instance._reactInternalInstance = fakeInternalInstance;
        "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", state, null === _instance.state ? "null" : "undefined", state)));
        if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
          var foundWillUpdateName = lane = state = null;
          "function" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
          "function" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
          "function" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
          if (null !== state || null !== lane || null !== foundWillUpdateName) {
            _instance = getComponentNameFromType(Component) || "Component";
            var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles", _instance, newApiName, null !== state ? "\n  " + state : "", null !== lane ? "\n  " + lane : "", null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""));
          }
        }
        _instance = workInProgress.stateNode;
        state = getComponentNameFromType(Component) || "Component";
        _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", state) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", state));
        !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", state);
        _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", state);
        _instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", state);
        Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", state));
        Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", state));
        "function" === typeof _instance.componentShouldUpdate && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", state);
        Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(Component) || "A pure component");
        "function" === typeof _instance.componentDidUnmount && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", state);
        "function" === typeof _instance.componentDidReceiveProps && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", state);
        "function" === typeof _instance.componentWillRecieveProps && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", state);
        "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", state);
        lane = _instance.props !== nextProps;
        void 0 !== _instance.props && lane && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", state);
        _instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", state, state);
        "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(Component)));
        "function" === typeof _instance.getDerivedStateFromProps && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        "function" === typeof _instance.getDerivedStateFromError && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        "function" === typeof Component.getSnapshotBeforeUpdate && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", state);
        (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
        "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", state);
        _instance = workInProgress.stateNode;
        _instance.props = nextProps;
        _instance.state = workInProgress.memoizedState;
        _instance.refs = {};
        initializeUpdateQueue(workInProgress);
        state = Component.contextType;
        _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
        _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", state)));
        workInProgress.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);
        _instance.state = workInProgress.memoizedState;
        state = Component.getDerivedStateFromProps;
        "function" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);
        "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress) || "Component"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);
        "function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);
        (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 134217728);
        _instance = !0;
      } else if (null === current) {
        _instance = workInProgress.stateNode;
        var unresolvedOldProps = workInProgress.memoizedProps;
        lane = resolveClassComponentProps(Component, unresolvedOldProps);
        _instance.props = lane;
        var oldContext = _instance.context;
        foundWillUpdateName = Component.contextType;
        state = emptyContextObject;
        "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
        newApiName = Component.getDerivedStateFromProps;
        foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
        foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);
        hasForceUpdate = !1;
        var oldState = workInProgress.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 134217728), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 134217728), _instance = !1);
      } else {
        _instance = workInProgress.stateNode;
        cloneUpdateQueue(current, workInProgress);
        state = workInProgress.memoizedProps;
        foundWillUpdateName = resolveClassComponentProps(Component, state);
        _instance.props = foundWillUpdateName;
        newApiName = workInProgress.pendingProps;
        oldState = _instance.context;
        oldContext = Component.contextType;
        lane = emptyContextObject;
        "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);
        hasForceUpdate = !1;
        oldState = workInProgress.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress.memoizedState;
        state !== newApiName || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), "function" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), _instance = !1);
      }
      lane = _instance;
      markRef(current, workInProgress);
      state = 0 !== (workInProgress.flags & 128);
      if (lane || state) {
        lane = workInProgress.stateNode;
        setCurrentFiber(workInProgress);
        if (state && "function" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;else {
          markComponentRenderStarted(workInProgress);
          Component = callRenderInDEV(lane);
          if (workInProgress.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(!0);
            try {
              callRenderInDEV(lane);
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
          markComponentRenderStopped();
        }
        workInProgress.flags |= 1;
        null !== current && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current, workInProgress, Component, renderLanes);
        workInProgress.memoizedState = lane.state;
        current = workInProgress.child;
      } else current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      renderLanes = workInProgress.stateNode;
      _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress) || "a component"), didWarnAboutReassigningProps = !0);
      return current;
    }
    function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {
      resetHydrationState();
      workInProgress.flags |= 256;
      reconcileChildren(current, workInProgress, nextChildren, renderLanes);
      return workInProgress.child;
    }
    function validateFunctionComponentInDev(workInProgress, Component) {
      Component && Component.childContextTypes && console.error("childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...", Component.displayName || Component.name || "Component");
      "function" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error("%s: Function components do not support getDerivedStateFromProps.", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));
      "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error("%s: Function components do not support contextType.", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));
    }
    function mountSuspenseOffscreenState(renderLanes) {
      return {
        baseLanes: renderLanes,
        cachePool: getSuspendedCache()
      };
    }
    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {
      current = null !== current ? current.childLanes & ~renderLanes : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress, renderLanes) {
      var JSCompiler_object_inline_digest_2451;
      var JSCompiler_object_inline_stack_2452 = workInProgress.pendingProps;
      shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);
      var JSCompiler_object_inline_componentStack_2453 = !1;
      var didSuspend = 0 !== (workInProgress.flags & 128);
      (JSCompiler_object_inline_digest_2451 = didSuspend) || (JSCompiler_object_inline_digest_2451 = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
      JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_componentStack_2453 = !0, workInProgress.flags &= -129);
      JSCompiler_object_inline_digest_2451 = 0 !== (workInProgress.flags & 32);
      workInProgress.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          JSCompiler_object_inline_componentStack_2453 ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);
          if (isHydrating) {
            var JSCompiler_object_inline_message_2450 = nextHydratableInstance;
            var JSCompiler_temp;
            if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2450)) {
              c: {
                var instance = JSCompiler_object_inline_message_2450;
                for (JSCompiler_temp = rootOrSingletonContext; 8 !== instance.nodeType;) {
                  if (!JSCompiler_temp) {
                    JSCompiler_temp = null;
                    break c;
                  }
                  instance = getNextHydratable(instance.nextSibling);
                  if (null === instance) {
                    JSCompiler_temp = null;
                    break c;
                  }
                }
                JSCompiler_temp = instance;
              }
              null !== JSCompiler_temp ? (warnIfNotHydrating(), workInProgress.memoizedState = {
                dehydrated: JSCompiler_temp,
                treeContext: null !== treeContextProvider ? {
                  id: treeContextId,
                  overflow: treeContextOverflow
                } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress, workInProgress.child = instance, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp = !0) : JSCompiler_temp = !1;
              JSCompiler_temp = !JSCompiler_temp;
            }
            JSCompiler_temp && (warnNonHydratedInstance(workInProgress, JSCompiler_object_inline_message_2450), throwOnHydrationMismatch(workInProgress));
          }
          JSCompiler_object_inline_message_2450 = workInProgress.memoizedState;
          if (null !== JSCompiler_object_inline_message_2450 && (JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_message_2450.dehydrated, null !== JSCompiler_object_inline_message_2450)) return isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450) ? workInProgress.lanes = 32 : workInProgress.lanes = 536870912, null;
          popSuspenseHandler(workInProgress);
        }
        JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_stack_2452.children;
        JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_stack_2452.fallback;
        if (JSCompiler_object_inline_componentStack_2453) return reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2453 = workInProgress.mode, JSCompiler_object_inline_message_2450 = mountWorkInProgressOffscreenFiber({
          mode: "hidden",
          children: JSCompiler_object_inline_message_2450
        }, JSCompiler_object_inline_componentStack_2453), JSCompiler_object_inline_stack_2452 = createFiberFromFragment(JSCompiler_object_inline_stack_2452, JSCompiler_object_inline_componentStack_2453, renderLanes, null), JSCompiler_object_inline_message_2450.return = workInProgress, JSCompiler_object_inline_stack_2452.return = workInProgress, JSCompiler_object_inline_message_2450.sibling = JSCompiler_object_inline_stack_2452, workInProgress.child = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453 = workInProgress.child, JSCompiler_object_inline_componentStack_2453.memoizedState = mountSuspenseOffscreenState(renderLanes), JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2451, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
        pushPrimaryTreeSuspenseHandler(workInProgress);
        return mountSuspensePrimaryChildren(workInProgress, JSCompiler_object_inline_message_2450);
      }
      var prevState = current.memoizedState;
      if (null !== prevState && (JSCompiler_object_inline_message_2450 = prevState.dehydrated, null !== JSCompiler_object_inline_message_2450)) {
        if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress.mode, JSCompiler_object_inline_stack_2452 = mountWorkInProgressOffscreenFiber({
          mode: "visible",
          children: JSCompiler_object_inline_stack_2452.children
        }, JSCompiler_object_inline_message_2450), JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_message_2450, renderLanes, null), JSCompiler_object_inline_componentStack_2453.flags |= 2, JSCompiler_object_inline_stack_2452.return = workInProgress, JSCompiler_object_inline_componentStack_2453.return = workInProgress, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress.child = JSCompiler_object_inline_stack_2452, reconcileChildFibers(workInProgress, current.child, null, renderLanes), JSCompiler_object_inline_stack_2452 = workInProgress.child, JSCompiler_object_inline_stack_2452.memoizedState = mountSuspenseOffscreenState(renderLanes), JSCompiler_object_inline_stack_2452.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2451, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = JSCompiler_object_inline_componentStack_2453);else if (pushPrimaryTreeSuspenseHandler(workInProgress), isHydrating && console.error("We should not be hydrating here. This is a bug in React. Please file a bug."), isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450)) {
          JSCompiler_object_inline_digest_2451 = JSCompiler_object_inline_message_2450.nextSibling && JSCompiler_object_inline_message_2450.nextSibling.dataset;
          if (JSCompiler_object_inline_digest_2451) {
            JSCompiler_temp = JSCompiler_object_inline_digest_2451.dgst;
            var message = JSCompiler_object_inline_digest_2451.msg;
            instance = JSCompiler_object_inline_digest_2451.stck;
            var componentStack = JSCompiler_object_inline_digest_2451.cstck;
          }
          JSCompiler_object_inline_message_2450 = message;
          JSCompiler_object_inline_digest_2451 = JSCompiler_temp;
          JSCompiler_object_inline_stack_2452 = instance;
          JSCompiler_temp = JSCompiler_object_inline_componentStack_2453 = componentStack;
          JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_message_2450 ? Error(JSCompiler_object_inline_message_2450) : Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          JSCompiler_object_inline_componentStack_2453.stack = JSCompiler_object_inline_stack_2452 || "";
          JSCompiler_object_inline_componentStack_2453.digest = JSCompiler_object_inline_digest_2451;
          JSCompiler_object_inline_digest_2451 = void 0 === JSCompiler_temp ? null : JSCompiler_temp;
          JSCompiler_object_inline_stack_2452 = {
            value: JSCompiler_object_inline_componentStack_2453,
            source: null,
            stack: JSCompiler_object_inline_digest_2451
          };
          "string" === typeof JSCompiler_object_inline_digest_2451 && CapturedStacks.set(JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_stack_2452);
          queueHydrationError(JSCompiler_object_inline_stack_2452);
          workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
        } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_object_inline_digest_2451 = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2451) {
          JSCompiler_object_inline_digest_2451 = workInProgressRoot;
          if (null !== JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_stack_2452 = renderLanes & -renderLanes, JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & 42) ? 1 : getBumpedLaneForHydrationByLane(JSCompiler_object_inline_stack_2452), JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & (JSCompiler_object_inline_digest_2451.suspendedLanes | renderLanes)) ? 0 : JSCompiler_object_inline_stack_2452, 0 !== JSCompiler_object_inline_stack_2452 && JSCompiler_object_inline_stack_2452 !== prevState.retryLane)) throw prevState.retryLane = JSCompiler_object_inline_stack_2452, enqueueConcurrentRenderForLane(current, JSCompiler_object_inline_stack_2452), scheduleUpdateOnFiber(JSCompiler_object_inline_digest_2451, current, JSCompiler_object_inline_stack_2452), SelectiveHydrationException;
          JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
          workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
        } else JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA ? (workInProgress.flags |= 192, workInProgress.child = current.child, workInProgress = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(JSCompiler_object_inline_message_2450.nextSibling), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress), workInProgress = mountSuspensePrimaryChildren(workInProgress, JSCompiler_object_inline_stack_2452.children), workInProgress.flags |= 4096);
        return workInProgress;
      }
      if (JSCompiler_object_inline_componentStack_2453) return reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress.mode, JSCompiler_temp = current.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2452 = createWorkInProgress(JSCompiler_temp, {
        mode: "hidden",
        children: JSCompiler_object_inline_stack_2452.children
      }), JSCompiler_object_inline_stack_2452.subtreeFlags = JSCompiler_temp.subtreeFlags & 65011712, null !== instance ? JSCompiler_object_inline_componentStack_2453 = createWorkInProgress(instance, JSCompiler_object_inline_componentStack_2453) : (JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_message_2450, renderLanes, null), JSCompiler_object_inline_componentStack_2453.flags |= 2), JSCompiler_object_inline_componentStack_2453.return = workInProgress, JSCompiler_object_inline_stack_2452.return = workInProgress, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress.child = JSCompiler_object_inline_stack_2452, JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_componentStack_2453 = workInProgress.child, JSCompiler_object_inline_message_2450 = current.child.memoizedState, null === JSCompiler_object_inline_message_2450 ? JSCompiler_object_inline_message_2450 = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp = JSCompiler_object_inline_message_2450.cachePool, null !== JSCompiler_temp ? (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent !== instance ? {
        parent: instance,
        pool: instance
      } : JSCompiler_temp) : JSCompiler_temp = getSuspendedCache(), JSCompiler_object_inline_message_2450 = {
        baseLanes: JSCompiler_object_inline_message_2450.baseLanes | renderLanes,
        cachePool: JSCompiler_temp
      }), JSCompiler_object_inline_componentStack_2453.memoizedState = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2451, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
      pushPrimaryTreeSuspenseHandler(workInProgress);
      renderLanes = current.child;
      current = renderLanes.sibling;
      renderLanes = createWorkInProgress(renderLanes, {
        mode: "visible",
        children: JSCompiler_object_inline_stack_2452.children
      });
      renderLanes.return = workInProgress;
      renderLanes.sibling = null;
      null !== current && (JSCompiler_object_inline_digest_2451 = workInProgress.deletions, null === JSCompiler_object_inline_digest_2451 ? (workInProgress.deletions = [current], workInProgress.flags |= 16) : JSCompiler_object_inline_digest_2451.push(current));
      workInProgress.child = renderLanes;
      workInProgress.memoizedState = null;
      return renderLanes;
    }
    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber({
        mode: "visible",
        children: primaryChildren
      }, workInProgress.mode);
      primaryChildren.return = workInProgress;
      return workInProgress.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiber(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      offscreenProps.stateNode = {
        _visibility: OffscreenVisible,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      };
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {
      reconcileChildFibers(workInProgress, current.child, null, renderLanes);
      current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);
      current.flags |= 2;
      workInProgress.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
      fiber.lanes |= renderLanes;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
    }
    function validateSuspenseListNestedChild(childSlot, index) {
      var isAnArray = isArrayImpl(childSlot);
      childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
      return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", isAnArray, index, isAnArray), !1) : !0;
    }
    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
      var renderState = workInProgress.memoizedState;
      null === renderState ? workInProgress.memoizedState = {
        isBackwards: isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail: tail,
        tailMode: tailMode
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
    }
    function updateSuspenseListComponent(current, workInProgress, renderLanes) {
      var nextProps = workInProgress.pendingProps,
        revealOrder = nextProps.revealOrder,
        tailMode = nextProps.tail;
      nextProps = nextProps.children;
      if (void 0 !== revealOrder && "forwards" !== revealOrder && "backwards" !== revealOrder && "together" !== revealOrder && !didWarnAboutRevealOrder[revealOrder]) if (didWarnAboutRevealOrder[revealOrder] = !0, "string" === typeof revealOrder) switch (revealOrder.toLowerCase()) {
        case "together":
        case "forwards":
        case "backwards":
          console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
          break;
        case "forward":
        case "backward":
          console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
          break;
        default:
          console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
      } else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
      void 0 === tailMode || didWarnAboutTailOptions[tailMode] || ("collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[tailMode] = !0, console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode)) : "forwards" !== revealOrder && "backwards" !== revealOrder && (didWarnAboutTailOptions[tailMode] = !0, console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode)));
      a: if (("forwards" === revealOrder || "backwards" === revealOrder) && void 0 !== nextProps && null !== nextProps && !1 !== nextProps) if (isArrayImpl(nextProps)) for (var i = 0; i < nextProps.length; i++) {
        if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
      } else if (i = getIteratorFn(nextProps), "function" === typeof i) {
        if (i = i.call(nextProps)) for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
          if (!validateSuspenseListNestedChild(step.value, _i)) break a;
          _i++;
        }
      } else console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
      reconcileChildren(current, workInProgress, nextProps, renderLanes);
      nextProps = suspenseStackCursor.current;
      if (0 !== (nextProps & ForceSuspenseFallback)) nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128;else {
        if (null !== current && 0 !== (current.flags & 128)) a: for (current = workInProgress.child; null !== current;) {
          if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);else if (null !== current.child) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress) break a;
          for (; null === current.sibling;) {
            if (null === current.return || current.return === workInProgress) break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
        nextProps &= SubtreeSuspenseContextMask;
      }
      push(suspenseStackCursor, nextProps, workInProgress);
      switch (revealOrder) {
        case "forwards":
          renderLanes = workInProgress.child;
          for (revealOrder = null; null !== renderLanes;) current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;
          renderLanes = revealOrder;
          null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);
          initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);
          break;
        case "backwards":
          renderLanes = null;
          revealOrder = workInProgress.child;
          for (workInProgress.child = null; null !== revealOrder;) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes;
            renderLanes = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);
          break;
        case "together":
          initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
          break;
        default:
          workInProgress.memoizedState = null;
      }
      return workInProgress.child;
    }
    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
      null !== current && (workInProgress.dependencies = current.dependencies);
      profilerStartTime = -1;
      workInProgressRootSkippedLanes |= workInProgress.lanes;
      if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {
        if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;
      } else return null;
      if (null !== current && workInProgress.child !== current.child) throw Error("Resuming work not yet implemented.");
      if (null !== workInProgress.child) {
        current = workInProgress.child;
        renderLanes = createWorkInProgress(current, current.pendingProps);
        workInProgress.child = renderLanes;
        for (renderLanes.return = workInProgress; null !== current.sibling;) current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;
        renderLanes.sibling = null;
      }
      return workInProgress.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes) {
      if (0 !== (current.lanes & renderLanes)) return !0;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? !0 : !1;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {
      switch (workInProgress.tag) {
        case 3:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress);
          break;
        case 4:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);
          break;
        case 12:
          0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);
          workInProgress.flags |= 2048;
          var stateNode = workInProgress.stateNode;
          stateNode.effectDuration = -0;
          stateNode.passiveEffectDuration = -0;
          break;
        case 13:
          stateNode = workInProgress.memoizedState;
          if (null !== stateNode) {
            if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;
            if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);
            pushPrimaryTreeSuspenseHandler(workInProgress);
            current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          stateNode = 0 !== (renderLanes & workInProgress.childLanes);
          stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));
          if (didSuspendBefore) {
            if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);
            workInProgress.flags |= 128;
          }
          didSuspendBefore = workInProgress.memoizedState;
          null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);
          if (stateNode) break;else return null;
        case 22:
        case 23:
          return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);
        case 24:
          pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    function beginWork(current, workInProgress, renderLanes) {
      if (workInProgress._debugNeedsRemount && null !== current) {
        renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);
        renderLanes._debugStack = workInProgress._debugStack;
        renderLanes._debugTask = workInProgress._debugTask;
        var returnFiber = workInProgress.return;
        if (null === returnFiber) throw Error("Cannot swap the root fiber.");
        current.alternate = null;
        workInProgress.alternate = null;
        renderLanes.index = workInProgress.index;
        renderLanes.sibling = workInProgress.sibling;
        renderLanes.return = workInProgress.return;
        renderLanes.ref = workInProgress.ref;
        renderLanes._debugInfo = workInProgress._debugInfo;
        if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;else {
          var prevSibling = returnFiber.child;
          if (null === prevSibling) throw Error("Expected parent to have a child.");
          for (; prevSibling.sibling !== workInProgress;) if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error("Expected to find the previous sibling.");
          prevSibling.sibling = renderLanes;
        }
        workInProgress = returnFiber.deletions;
        null === workInProgress ? (returnFiber.deletions = [current], returnFiber.flags |= 16) : workInProgress.push(current);
        renderLanes.flags |= 2;
        return renderLanes;
      }
      if (null !== current) {
        if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;else {
          if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);
          didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
        }
      } else {
        didReceiveUpdate = !1;
        if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);
        returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));
      }
      workInProgress.lanes = 0;
      switch (workInProgress.tag) {
        case 16:
          a: if (returnFiber = workInProgress.pendingProps, current = callLazyInitInDEV(workInProgress.elementType), workInProgress.type = current, "function" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));else {
            if (void 0 !== current && null !== current) if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
              workInProgress.tag = 11;
              workInProgress.type = current = resolveForwardRefForHotReloading(current);
              workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);
              break a;
            } else if (prevSibling === REACT_MEMO_TYPE) {
              workInProgress.tag = 14;
              workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);
              break a;
            }
            workInProgress = "";
            null !== current && "object" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = " Did you wrap a component in React.lazy() more than once?");
            current = getComponentNameFromType(current) || current;
            throw Error("Element type is invalid. Received a promise that resolves to: " + current + ". Lazy element type must resolve to a class or function." + workInProgress);
          }
          return workInProgress;
        case 0:
          return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
        case 1:
          return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);
        case 3:
          a: {
            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
            if (null === current) throw Error("Should have a current fiber. This is a bug in React.");
            returnFiber = workInProgress.pendingProps;
            var prevState = workInProgress.memoizedState;
            prevSibling = prevState.element;
            cloneUpdateQueue(current, workInProgress);
            processUpdateQueue(workInProgress, returnFiber, null, renderLanes);
            var nextState = workInProgress.memoizedState;
            returnFiber = nextState.cache;
            pushProvider(workInProgress, CacheContext, returnFiber);
            returnFiber !== prevState.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, !0);
            suspendIfUpdateReadFromEntangledAsyncAction();
            returnFiber = nextState.element;
            if (prevState.isDehydrated) {
              if (prevState = {
                element: returnFiber,
                isDehydrated: !1,
                cache: nextState.cache
              }, workInProgress.updateQueue.baseState = prevState, workInProgress.memoizedState = prevState, workInProgress.flags & 256) {
                workInProgress = mountHostRootWithoutHydrating(current, workInProgress, returnFiber, renderLanes);
                break a;
              } else if (returnFiber !== prevSibling) {
                prevSibling = createCapturedValueAtFiber(Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress);
                queueHydrationError(prevSibling);
                workInProgress = mountHostRootWithoutHydrating(current, workInProgress, returnFiber, renderLanes);
                break a;
              } else {
                current = workInProgress.stateNode.containerInfo;
                switch (current.nodeType) {
                  case 9:
                    current = current.body;
                    break;
                  default:
                    current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                }
                nextHydratableInstance = getNextHydratable(current.firstChild);
                hydrationParentFiber = workInProgress;
                isHydrating = !0;
                hydrationErrors = null;
                didSuspendOrErrorDEV = !1;
                hydrationDiffRootDEV = null;
                rootOrSingletonContext = !0;
                current = mountChildFibers(workInProgress, null, returnFiber, renderLanes);
                for (workInProgress.child = current; current;) current.flags = current.flags & -3 | 4096, current = current.sibling;
              }
            } else {
              resetHydrationState();
              if (returnFiber === prevSibling) {
                workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                break a;
              }
              reconcileChildren(current, workInProgress, returnFiber, renderLanes);
            }
            workInProgress = workInProgress.child;
          }
          return workInProgress;
        case 26:
          return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (current = workInProgress.type, renderLanes = workInProgress.pendingProps, returnFiber = requiredContext(rootInstanceStackCursor.current), returnFiber = getOwnerDocumentFromRootContainer(returnFiber).createElement(current), returnFiber[internalInstanceKey] = workInProgress, returnFiber[internalPropsKey] = renderLanes, setInitialProperties(returnFiber, current, renderLanes), markNodeAsHoistable(returnFiber), workInProgress.stateNode = returnFiber) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;
        case 27:
          return pushHostContext(workInProgress), null === current && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, returnFiber, prevSibling, !1), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(returnFiber, workInProgress.type, workInProgress.pendingProps, prevSibling), null !== prevSibling && (buildHydrationDiffNode(workInProgress, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(returnFiber.firstChild)) : nextHydratableInstance = prevSibling), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), markRef(current, workInProgress), null === current && (workInProgress.flags |= 4194304), workInProgress.child;
        case 5:
          return null === current && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(workInProgress.type, prevState.ancestorInfo), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(nextState, workInProgress.type, workInProgress.pendingProps, prevState), null !== prevState && (buildHydrationDiffNode(workInProgress, 0).serverProps = prevState)), hydrationParentFiber = workInProgress, nextHydratableInstance = getNextHydratable(nextState.firstChild), rootOrSingletonContext = !1, prevState = !0) : prevState = !1, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, prevState = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), HostTransitionContext._currentValue = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
        case 6:
          return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext(), returnFiber = renderLanes.ancestorInfo.current, current = null != returnFiber ? validateTextNesting(current, returnFiber.tag, renderLanes.ancestorInfo.implicitRootScope) : !0, renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;
        case 13:
          return updateSuspenseComponent(current, workInProgress, renderLanes);
        case 4:
          return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
        case 11:
          return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
        case 7:
          return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;
        case 8:
          return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
        case 12:
          return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
        case 10:
          return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), pushProvider(workInProgress, returnFiber, prevState), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;
        case 9:
          return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, "function" !== typeof returnFiber && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), markComponentRenderStopped(), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
        case 14:
          return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
        case 15:
          return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
        case 19:
          return updateSuspenseListComponent(current, workInProgress, renderLanes);
        case 31:
          return returnFiber = workInProgress.pendingProps, renderLanes = workInProgress.mode, returnFiber = {
            mode: returnFiber.mode,
            children: returnFiber.children
          }, null === current ? (current = mountWorkInProgressOffscreenFiber(returnFiber, renderLanes), current.ref = workInProgress.ref, workInProgress.child = current, current.return = workInProgress, workInProgress = current) : (current = createWorkInProgress(current.child, returnFiber), current.ref = workInProgress.ref, workInProgress.child = current, current.return = workInProgress, workInProgress = current), workInProgress;
        case 22:
          return updateOffscreenComponent(current, workInProgress, renderLanes);
        case 24:
          return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = prevState), workInProgress.memoizedState = {
            parent: returnFiber,
            cache: prevSibling
          }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, prevState = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
            parent: returnFiber,
            cache: returnFiber
          }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
        case 29:
          throw workInProgress.pendingProps;
      }
      throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function markUpdate(workInProgress) {
      workInProgress.flags |= 4;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
      if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded) workInProgress.flags &= -16777217;else if (workInProgress.flags |= 16777216, !preloadResource(resource)) {
        resource = suspenseHandlerStackCursor.current;
        if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary)) throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        workInProgress.flags |= 8192;
      }
    }
    function scheduleRetryEffect(workInProgress, retryQueue) {
      null !== retryQueue && (workInProgress.flags |= 4);
      workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating) switch (renderState.tailMode) {
        case "hidden":
          hasRenderedATailFallback = renderState.tail;
          for (var lastTailNode = null; null !== hasRenderedATailFallback;) null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
          null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
          break;
        case "collapsed":
          lastTailNode = renderState.tail;
          for (var _lastTailNode = null; null !== lastTailNode;) null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
          null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
      }
    }
    function bubbleProperties(completedWork) {
      var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child,
        newChildLanes = 0,
        subtreeFlags = 0;
      if (didBailout) {
        if ((completedWork.mode & ProfileMode) !== NoMode) {
          for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;) newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
          completedWork.treeBaseDuration = _treeBaseDuration;
        } else for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;) newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
      } else if ((completedWork.mode & ProfileMode) !== NoMode) {
        _treeBaseDuration = completedWork.actualDuration;
        _child2 = completedWork.selfBaseDuration;
        for (var child = completedWork.child; null !== child;) newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
        completedWork.actualDuration = _treeBaseDuration;
        completedWork.treeBaseDuration = _child2;
      } else for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;) newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress, renderLanes) {
      var newProps = workInProgress.pendingProps;
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress), null;
        case 1:
          return bubbleProperties(workInProgress), null;
        case 3:
          renderLanes = workInProgress.stateNode;
          newProps = null;
          null !== current && (newProps = current.memoizedState.cache);
          workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);
          popProvider(CacheContext, workInProgress);
          popHostContainer(workInProgress);
          renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);
          if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress);
          return null;
        case 26:
          return renderLanes = workInProgress.memoizedState, null === current ? (markUpdate(workInProgress), null !== renderLanes ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217)) : renderLanes ? renderLanes !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress), bubbleProperties(workInProgress), workInProgress.flags &= -16777217), null;
        case 27:
          popHostContext(workInProgress);
          renderLanes = requiredContext(rootInstanceStackCursor.current);
          var _type = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
            if (!newProps) {
              if (null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              bubbleProperties(workInProgress);
              return null;
            }
            current = getHostContext();
            popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(_type, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));
          }
          bubbleProperties(workInProgress);
          return null;
        case 5:
          popHostContext(workInProgress);
          renderLanes = workInProgress.type;
          if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
            if (!newProps) {
              if (null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              bubbleProperties(workInProgress);
              return null;
            }
            _type = getHostContext();
            if (popHydrationState(workInProgress)) prepareToHydrateHostInstance(workInProgress, _type);else {
              current = requiredContext(rootInstanceStackCursor.current);
              validateDOMNesting(renderLanes, _type.ancestorInfo);
              _type = _type.context;
              current = getOwnerDocumentFromRootContainer(current);
              switch (_type) {
                case HostContextNamespaceSvg:
                  current = current.createElementNS(SVG_NAMESPACE, renderLanes);
                  break;
                case HostContextNamespaceMath:
                  current = current.createElementNS(MATH_NAMESPACE, renderLanes);
                  break;
                default:
                  switch (renderLanes) {
                    case "svg":
                      current = current.createElementNS(SVG_NAMESPACE, renderLanes);
                      break;
                    case "math":
                      current = current.createElementNS(MATH_NAMESPACE, renderLanes);
                      break;
                    case "script":
                      current = current.createElement("div");
                      current.innerHTML = "<script>\x3c/script>";
                      current = current.removeChild(current.firstChild);
                      break;
                    case "select":
                      current = "string" === typeof newProps.is ? current.createElement("select", {
                        is: newProps.is
                      }) : current.createElement("select");
                      newProps.multiple ? current.multiple = !0 : newProps.size && (current.size = newProps.size);
                      break;
                    default:
                      current = "string" === typeof newProps.is ? current.createElement(renderLanes, {
                        is: newProps.is
                      }) : current.createElement(renderLanes), -1 === renderLanes.indexOf("-") && (renderLanes !== renderLanes.toLowerCase() && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", renderLanes), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(current) || hasOwnProperty.call(warnedUnknownTags, renderLanes) || (warnedUnknownTags[renderLanes] = !0, console.error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", renderLanes)));
                  }
              }
              current[internalInstanceKey] = workInProgress;
              current[internalPropsKey] = newProps;
              a: for (_type = workInProgress.child; null !== _type;) {
                if (5 === _type.tag || 6 === _type.tag) current.appendChild(_type.stateNode);else if (4 !== _type.tag && 27 !== _type.tag && null !== _type.child) {
                  _type.child.return = _type;
                  _type = _type.child;
                  continue;
                }
                if (_type === workInProgress) break a;
                for (; null === _type.sibling;) {
                  if (null === _type.return || _type.return === workInProgress) break a;
                  _type = _type.return;
                }
                _type.sibling.return = _type.return;
                _type = _type.sibling;
              }
              workInProgress.stateNode = current;
              a: switch (setInitialProperties(current, renderLanes, newProps), renderLanes) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  current = !!newProps.autoFocus;
                  break a;
                case "img":
                  current = !0;
                  break a;
                default:
                  current = !1;
              }
              current && markUpdate(workInProgress);
            }
          }
          bubbleProperties(workInProgress);
          workInProgress.flags &= -16777217;
          return null;
        case 6:
          if (current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
            if ("string" !== typeof newProps && null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            current = requiredContext(rootInstanceStackCursor.current);
            renderLanes = getHostContext();
            if (popHydrationState(workInProgress)) {
              current = workInProgress.stateNode;
              renderLanes = workInProgress.memoizedProps;
              _type = !didSuspendOrErrorDEV;
              newProps = null;
              var returnFiber = hydrationParentFiber;
              if (null !== returnFiber) switch (returnFiber.tag) {
                case 3:
                  _type && (_type = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== _type && (buildHydrationDiffNode(workInProgress, 0).serverProps = _type));
                  break;
                case 27:
                case 5:
                  newProps = returnFiber.memoizedProps, _type && (_type = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== _type && (buildHydrationDiffNode(workInProgress, 0).serverProps = _type));
              }
              current[internalInstanceKey] = workInProgress;
              current = current.nodeValue === renderLanes || null !== newProps && !0 === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes) ? !0 : !1;
              current || throwOnHydrationMismatch(workInProgress);
            } else _type = renderLanes.ancestorInfo.current, null != _type && validateTextNesting(newProps, _type.tag, renderLanes.ancestorInfo.implicitRootScope), current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps), current[internalInstanceKey] = workInProgress, workInProgress.stateNode = current;
          }
          bubbleProperties(workInProgress);
          return null;
        case 13:
          newProps = workInProgress.memoizedState;
          if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
            _type = popHydrationState(workInProgress);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!_type) throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                _type = workInProgress.memoizedState;
                _type = null !== _type ? _type.dehydrated : null;
                if (!_type) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
                _type[internalInstanceKey] = workInProgress;
                bubbleProperties(workInProgress);
                (workInProgress.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress.child, null !== _type && (workInProgress.treeBaseDuration -= _type.treeBaseDuration));
              } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress.child, null !== _type && (workInProgress.treeBaseDuration -= _type.treeBaseDuration));
              _type = !1;
            } else _type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = _type), _type = !0;
            if (!_type) {
              if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;
              popSuspenseHandler(workInProgress);
              return null;
            }
          }
          popSuspenseHandler(workInProgress);
          if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress;
          renderLanes = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          renderLanes && (newProps = workInProgress.child, _type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (_type = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== _type && (newProps.flags |= 2048));
          renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);
          scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
          bubbleProperties(workInProgress);
          (workInProgress.mode & ProfileMode) !== NoMode && renderLanes && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));
          return null;
        case 4:
          return popHostContainer(workInProgress), null === current && listenToAllSupportedEvents(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;
        case 10:
          return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;
        case 19:
          pop(suspenseStackCursor, workInProgress);
          _type = workInProgress.memoizedState;
          if (null === _type) return bubbleProperties(workInProgress), null;
          newProps = 0 !== (workInProgress.flags & 128);
          returnFiber = _type.rendering;
          if (null === returnFiber) {
            if (newProps) cutOffTailIfNeeded(_type, !1);else {
              if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for (current = workInProgress.child; null !== current;) {
                returnFiber = findFirstSuspended(current);
                if (null !== returnFiber) {
                  workInProgress.flags |= 128;
                  cutOffTailIfNeeded(_type, !1);
                  current = returnFiber.updateQueue;
                  workInProgress.updateQueue = current;
                  scheduleRetryEffect(workInProgress, current);
                  workInProgress.subtreeFlags = 0;
                  current = renderLanes;
                  for (renderLanes = workInProgress.child; null !== renderLanes;) resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;
                  push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);
                  return workInProgress.child;
                }
                current = current.sibling;
              }
              null !== _type.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(_type, !1), workInProgress.lanes = 4194304);
            }
          } else {
            if (!newProps) if (current = findFirstSuspended(returnFiber), null !== current) {
              if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(_type, !0), null === _type.tail && "hidden" === _type.tailMode && !returnFiber.alternate && !isHydrating) return bubbleProperties(workInProgress), null;
            } else 2 * now$1() - _type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(_type, !1), workInProgress.lanes = 4194304);
            _type.isBackwards ? (returnFiber.sibling = workInProgress.child, workInProgress.child = returnFiber) : (current = _type.last, null !== current ? current.sibling = returnFiber : workInProgress.child = returnFiber, _type.last = returnFiber);
          }
          if (null !== _type.tail) return current = _type.tail, _type.rendering = current, _type.tail = current.sibling, _type.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = newProps ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), current;
          bubbleProperties(workInProgress);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;
        case 24:
          return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function unwindWork(current, workInProgress) {
      popTreeContext(workInProgress);
      switch (workInProgress.tag) {
        case 1:
          return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
        case 3:
          return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress), null;
        case 13:
          popSuspenseHandler(workInProgress);
          current = workInProgress.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress.alternate) throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            resetHydrationState();
          }
          current = workInProgress.flags;
          return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
        case 19:
          return pop(suspenseStackCursor, workInProgress), null;
        case 4:
          return popHostContainer(workInProgress), null;
        case 10:
          return popProvider(workInProgress.type, workInProgress), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
        case 24:
          return popProvider(CacheContext, workInProgress), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext, interruptedWork);
          popHostContainer(interruptedWork);
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor, interruptedWork);
          break;
        case 10:
          popProvider(interruptedWork.type, interruptedWork);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext(interruptedWork);
          null !== current && pop(resumedCache, interruptedWork);
          break;
        case 24:
          popProvider(CacheContext, interruptedWork);
      }
    }
    function shouldProfile(current) {
      return (current.mode & ProfileMode) !== NoMode;
    }
    function commitHookLayoutEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
              var hookName = void 0;
              hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
              var addendum = void 0;
              addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
              runWithFiberInDEV(finishedWork, function (n, a) {
                console.error("%s must not return anything besides a function, which is used for clean-up.%s", n, a);
              }, hookName, addendum);
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
      try {
        var updateQueue = finishedWork.updateQueue,
          lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst,
                destroy = inst.destroy;
              void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = finishedWork, runWithFiberInDEV(lastEffect, callDestroyInDEV, lastEffect, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
        try {
          runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
      return instance.getSnapshotBeforeUpdate(prevProps, prevState);
    }
    function commitClassSnapshot(finishedWork, current) {
      var prevProps = current.memoizedProps,
        prevState = current.memoizedState;
      current = finishedWork.stateNode;
      finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), current.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
      try {
        var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);
        var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);
        prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
        void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function () {
          console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
        }));
        current.__reactInternalSnapshotBeforeUpdate = snapshot;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
      instance.state = current.memoizedState;
      shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);
    }
    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (null !== ref) {
        switch (finishedWork.tag) {
          case 26:
          case 27:
          case 5:
            var instanceToUse = finishedWork.stateNode;
            break;
          case 30:
            instanceToUse = finishedWork.stateNode;
            break;
          default:
            instanceToUse = finishedWork.stateNode;
        }
        if ("function" === typeof ref) {
          if (shouldProfile(finishedWork)) try {
            startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
          } finally {
            recordEffectDuration();
          } else finishedWork.refCleanup = ref(instanceToUse);
        } else "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork)), ref.current = instanceToUse;
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        runWithFiberInDEV(current, commitAttachRef, current);
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref,
        refCleanup = current.refCleanup;
      if (null !== ref) if ("function" === typeof refCleanup) try {
        if (shouldProfile(current)) try {
          startEffectTimer(), runWithFiberInDEV(current, refCleanup);
        } finally {
          recordEffectDuration(current);
        } else runWithFiberInDEV(current, refCleanup);
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      } finally {
        current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
      } else if ("function" === typeof ref) try {
        if (shouldProfile(current)) try {
          startEffectTimer(), runWithFiberInDEV(current, ref, null);
        } finally {
          recordEffectDuration(current);
        } else runWithFiberInDEV(current, ref, null);
      } catch (error$7) {
        captureCommitPhaseError(current, nearestMountedAncestor, error$7);
      } else ref.current = null;
    }
    function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {
      var _finishedWork$memoize = finishedWork.memoizedProps,
        id = _finishedWork$memoize.id,
        onCommit = _finishedWork$memoize.onCommit;
      _finishedWork$memoize = _finishedWork$memoize.onRender;
      current = null === current ? "mount" : "update";
      currentUpdateIsNested && (current = "nested-update");
      "function" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);
      "function" === typeof onCommit && onCommit(finishedWork.memoizedProps.id, current, effectDuration, commitStartTime);
    }
    function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {
      var _finishedWork$memoize2 = finishedWork.memoizedProps;
      finishedWork = _finishedWork$memoize2.id;
      _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
      current = null === current ? "mount" : "update";
      currentUpdateIsNested && (current = "nested-update");
      "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);
    }
    function commitHostMount(finishedWork) {
      var type = finishedWork.type,
        props = finishedWork.memoizedProps,
        instance = finishedWork.stateNode;
      try {
        runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
    }
    function getHostSibling(fiber) {
      a: for (;;) {
        for (; null === fiber.sibling;) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;) {
          if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;else fiber.child.return = fiber, fiber = fiber.child;
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag) node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node)) for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag) node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node)) for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
    function commitPlacement(finishedWork) {
      for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber;) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (null == hostParentFiber) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      switch (hostParentFiber.tag) {
        case 27:
          hostParentFiber = hostParentFiber.stateNode;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, parentFiber, hostParentFiber);
          break;
        case 5:
          parentFiber = hostParentFiber.stateNode;
          hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
          hostParentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, hostParentFiber, parentFiber);
          break;
        case 3:
        case 4:
          hostParentFiber = hostParentFiber.stateNode.containerInfo;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, hostParentFiber);
          break;
        default:
          throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var singleton = finishedWork.stateNode,
        props = finishedWork.memoizedProps;
      try {
        runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, singleton, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitBeforeMutationEffects(root, firstChild) {
      root = root.containerInfo;
      eventsEnabled = _enabled;
      root = getActiveElementDeep(root);
      if (hasSelectionCapabilities(root)) {
        if ("selectionStart" in root) var JSCompiler_temp = {
          start: root.selectionStart,
          end: root.selectionEnd
        };else a: {
          JSCompiler_temp = (JSCompiler_temp = root.ownerDocument) && JSCompiler_temp.defaultView || window;
          var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
          if (selection && 0 !== selection.rangeCount) {
            JSCompiler_temp = selection.anchorNode;
            var anchorOffset = selection.anchorOffset,
              focusNode = selection.focusNode;
            selection = selection.focusOffset;
            try {
              JSCompiler_temp.nodeType, focusNode.nodeType;
            } catch (e$2) {
              JSCompiler_temp = null;
              break a;
            }
            var length = 0,
              start = -1,
              end = -1,
              indexWithinAnchor = 0,
              indexWithinFocus = 0,
              node = root,
              parentNode = null;
            b: for (;;) {
              for (var next;;) {
                node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                3 === node.nodeType && (length += node.nodeValue.length);
                if (null === (next = node.firstChild)) break;
                parentNode = node;
                node = next;
              }
              for (;;) {
                if (node === root) break b;
                parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                if (null !== (next = node.nextSibling)) break;
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
            JSCompiler_temp = -1 === start || -1 === end ? null : {
              start: start,
              end: end
            };
          } else JSCompiler_temp = null;
        }
        JSCompiler_temp = JSCompiler_temp || {
          start: 0,
          end: 0
        };
      } else JSCompiler_temp = null;
      selectionInformation = {
        focusedElem: root,
        selectionRange: JSCompiler_temp
      };
      _enabled = !1;
      for (nextEffect = firstChild; null !== nextEffect;) if (firstChild = nextEffect, root = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root) root.return = firstChild, nextEffect = root;else for (; null !== nextEffect;) {
        root = firstChild = nextEffect;
        JSCompiler_temp = root.alternate;
        anchorOffset = root.flags;
        switch (root.tag) {
          case 0:
            break;
          case 11:
          case 15:
            break;
          case 1:
            0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root, JSCompiler_temp);
            break;
          case 3:
            if (0 !== (anchorOffset & 1024)) if (root = root.stateNode.containerInfo, JSCompiler_temp = root.nodeType, 9 === JSCompiler_temp) clearContainerSparingly(root);else if (1 === JSCompiler_temp) switch (root.nodeName) {
              case "HEAD":
              case "HTML":
              case "BODY":
                clearContainerSparingly(root);
                break;
              default:
                root.textContent = "";
            }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if (0 !== (anchorOffset & 1024)) throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        root = firstChild.sibling;
        if (null !== root) {
          root.return = firstChild.return;
          nextEffect = root;
          break;
        }
        nextEffect = firstChild.return;
      }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);else {
            var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);
            current = current.memoizedState;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
            shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);
          }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          current = pushNestedEffectDurations();
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
            prevProps = null;
            if (null !== finishedWork.child) switch (finishedWork.child.tag) {
              case 27:
              case 5:
                prevProps = finishedWork.child.stateNode;
                break;
              case 1:
                prevProps = finishedWork.child.stateNode;
            }
            try {
              runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          finishedRoot.effectDuration += popNestedEffectDurations(current);
          break;
        case 27:
          null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(null, finishedWork), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
          break;
        case 22:
          flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!flags) {
            current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber._debugOwner = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child; null !== parent;) commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
        injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
      } catch (err) {
        hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
      }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent,
            prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = !1);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          runWithFiberInDEV(deletedFiber, releaseSingletonInstance, deletedFiber.stateNode);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent) if (hostParentIsContainer) try {
            runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
          } else try {
            runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
          }
          break;
        case 18:
          null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot, deletedFiber.stateNode), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = !0;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 21:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 22:
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {
        runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
        default:
          throw Error("Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React.");
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function (wakeable) {
        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          if (isDevToolsPresent) if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);else throw Error("Expected finished root and lanes to be set. This is a bug in React.");
          wakeable.then(retry, retry);
        }
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
        var root = root$jscomp$0,
          returnFiber = parentFiber,
          deletedFiber = deletions[i],
          parent = returnFiber;
        a: for (; null !== parent;) {
          switch (parent.tag) {
            case 27:
              if (isSingletonScope(parent.type)) {
                hostParent = parent.stateNode;
                hostParentIsContainer = !1;
                break a;
              }
              break;
            case 5:
              hostParent = parent.stateNode;
              hostParentIsContainer = !1;
              break a;
            case 3:
            case 4:
              hostParent = parent.stateNode.containerInfo;
              hostParentIsContainer = !0;
              break a;
          }
          parent = parent.return;
        }
        if (null === hostParent) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
        hostParent = null;
        hostParentIsContainer = !1;
        root = deletedFiber;
        returnFiber = root.alternate;
        null !== returnFiber && (returnFiber.return = null);
        root.return = null;
      }
      if (parentFiber.subtreeFlags & 13878) for (parentFiber = parentFiber.child; null !== parentFiber;) commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    function commitMutationEffectsOnFiber(finishedWork, root) {
      var current = finishedWork.alternate,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (flags & 4) if (root = null !== current ? current.memoizedState : null, flags = finishedWork.memoizedState, null === current) {
            if (null === flags) {
              if (null === finishedWork.stateNode) {
                a: {
                  flags = finishedWork.type;
                  current = finishedWork.memoizedProps;
                  root = hoistableRoot.ownerDocument || hoistableRoot;
                  b: switch (flags) {
                    case "title":
                      hoistableRoot = root.getElementsByTagName("title")[0];
                      if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute("itemprop")) hoistableRoot = root.createElement(flags), root.head.insertBefore(hoistableRoot, root.querySelector("head > title"));
                      setInitialProperties(hoistableRoot, flags, current);
                      hoistableRoot[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(hoistableRoot);
                      flags = hoistableRoot;
                      break a;
                    case "link":
                      var maybeNodes = getHydratableHoistableCache("link", "href", root).get(flags + (current.href || ""));
                      if (maybeNodes) for (var i = 0; i < maybeNodes.length; i++) if (hoistableRoot = maybeNodes[i], hoistableRoot.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && hoistableRoot.getAttribute("rel") === (null == current.rel ? null : current.rel) && hoistableRoot.getAttribute("title") === (null == current.title ? null : current.title) && hoistableRoot.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                        maybeNodes.splice(i, 1);
                        break b;
                      }
                      hoistableRoot = root.createElement(flags);
                      setInitialProperties(hoistableRoot, flags, current);
                      root.head.appendChild(hoistableRoot);
                      break;
                    case "meta":
                      if (maybeNodes = getHydratableHoistableCache("meta", "content", root).get(flags + (current.content || ""))) for (i = 0; i < maybeNodes.length; i++) if (hoistableRoot = maybeNodes[i], checkAttributeStringCoercion(current.content, "content"), hoistableRoot.getAttribute("content") === (null == current.content ? null : "" + current.content) && hoistableRoot.getAttribute("name") === (null == current.name ? null : current.name) && hoistableRoot.getAttribute("property") === (null == current.property ? null : current.property) && hoistableRoot.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && hoistableRoot.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                        maybeNodes.splice(i, 1);
                        break b;
                      }
                      hoistableRoot = root.createElement(flags);
                      setInitialProperties(hoistableRoot, flags, current);
                      root.head.appendChild(hoistableRoot);
                      break;
                    default:
                      throw Error('getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.');
                  }
                  hoistableRoot[internalInstanceKey] = finishedWork;
                  markNodeAsHoistable(hoistableRoot);
                  flags = hoistableRoot;
                }
                finishedWork.stateNode = flags;
              } else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
            } else finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);
          } else root !== flags ? (null === root ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : root.count--, null === flags ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
          break;
        case 27:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          null !== current && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
          break;
        case 5:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            root = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, resetTextContent, root);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));
          flags & 1024 && (needsFormReset = !0, "form" !== finishedWork.type && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
          break;
        case 6:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode) throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            flags = finishedWork.memoizedProps;
            current = null !== current ? current.memoizedProps : flags;
            root = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          hoistableRoot = pushNestedEffectDurations();
          tagCaches = null;
          maybeNodes = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root.containerInfo);
          recursivelyTraverseMutationEffects(root, finishedWork);
          currentHoistableRoot = maybeNodes;
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && null !== current && current.memoizedState.isDehydrated) try {
            runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));
          root.effectDuration += popNestedEffectDurations(hoistableRoot);
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          flags = pushNestedEffectDurations();
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
          break;
        case 13:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          hoistableRoot = null !== finishedWork.memoizedState;
          var wasHidden = null !== current && null !== current.memoizedState,
            prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          commitReconciliationEffects(finishedWork);
          if (flags & 8192) a: for (root = finishedWork.stateNode, root._visibility = hoistableRoot ? root._visibility & ~OffscreenVisible : root._visibility | OffscreenVisible, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root = finishedWork;;) {
            if (5 === root.tag || 26 === root.tag) {
              if (null === current) {
                wasHidden = current = root;
                try {
                  maybeNodes = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, maybeNodes) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if (6 === root.tag) {
              if (null === current) {
                wasHidden = root;
                try {
                  i = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, i) : runWithFiberInDEV(wasHidden, unhideTextInstance, i, wasHidden.memoizedProps);
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {
              root.child.return = root;
              root = root.child;
              continue;
            }
            if (root === finishedWork) break a;
            for (; null === root.sibling;) {
              if (null === root.return || root.return === finishedWork) break a;
              current === root && (current = null);
              root = root.return;
            }
            current === root && (current = null);
            root.sibling.return = root.return;
            root = root.sibling;
          }
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024) for (parentFiber = parentFiber.child; null !== parentFiber;) {
        var fiber = parentFiber;
        recursivelyResetForms(fiber);
        5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseLayoutEffects(root, parentFiber) {
      if (parentFiber.subtreeFlags & 8772) for (parentFiber = parentFiber.child; null !== parentFiber;) commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function disappearLayoutEffects(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 27:
          runWithFiberInDEV(finishedWork, releaseSingletonInstance, finishedWork.stateNode);
        case 26:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 30:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber;) disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
    }
    function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          commitHookLayoutEffects(finishedWork, Layout);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          current = finishedWork.stateNode;
          "function" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);
          current = finishedWork.updateQueue;
          if (null !== current) {
            finishedRoot = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
          commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (includeWorkInProgressEffects && flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
            includeWorkInProgressEffects = finishedWork.stateNode;
            includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 30:
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
      }
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber;) reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {
      if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
          break;
        case 1:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          break;
        case 3:
          var prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));
          finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
          break;
        case 12:
          if (flags & 2048) {
            flags = pushNestedEffectDurations();
            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          break;
        case 13:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          break;
        case 23:
          break;
        case 22:
          prevEffectDuration = finishedWork.stateNode;
          var _current = finishedWork.alternate;
          null !== finishedWork.memoizedState ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (prevEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));
          flags & 2048 && commitOffscreenPassiveMountEffects(_current, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
      for (parentFiber = parentFiber.child; null !== parentFiber;) reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
    }
    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
          commitHookPassiveMountEffects(finishedWork, Passive);
          break;
        case 23:
          break;
        case 22:
          var _instance2 = finishedWork.stateNode;
          null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));
          includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
      if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) {
        var finishedRoot = finishedRoot$jscomp$0,
          finishedWork = parentFiber,
          flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 22:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
            break;
          case 24:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyAccumulateSuspenseyCommit(parentFiber) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag) for (parentFiber = parentFiber.child; null !== parentFiber;) accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(fiber);
          fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(fiber);
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
          recursivelyAccumulateSuspenseyCommit(fiber);
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(fiber);
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
        previousFiber.child = null;
        do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber; while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i];
          nextEffect = childToDelete;
          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
        }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);
          break;
        case 3:
          var prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
          break;
        case 12:
          prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
          break;
        case 22:
          prevEffectDuration = finishedWork.stateNode;
          null !== finishedWork.memoizedState && prevEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i];
          nextEffect = childToDelete;
          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
        }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber;) disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
    }
    function disconnectPassiveEffect(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (; null !== nextEffect;) {
        var fiber = nextEffect,
          current = fiber;
        switch (current.tag) {
          case 0:
          case 11:
          case 15:
            commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);
            break;
          case 23:
          case 22:
            null !== current.memoizedState && null !== current.memoizedState.cachePool && (current = current.memoizedState.cachePool.pool, null != current && retainCache(current));
            break;
          case 24:
            releaseCache(current.memoizedState.cache);
        }
        current = fiber.child;
        if (null !== current) current.return = fiber, nextEffect = current;else a: for (fiber = deletedSubtreeRoot; null !== nextEffect;) {
          current = nextEffect;
          var sibling = current.sibling,
            returnFiber = current.return;
          detachFiberAfterEffects(current);
          if (current === fiber) {
            nextEffect = null;
            break a;
          }
          if (null !== sibling) {
            sibling.return = returnFiber;
            nextEffect = sibling;
            break a;
          }
          nextEffect = returnFiber;
        }
      }
    }
    function onCommitRoot() {
      commitHooks.forEach(function (commitHook) {
        return commitHook();
      });
    }
    function isConcurrentActEnvironment() {
      var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
      isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error("The current testing environment is not configured to support act(...)");
      return isReactActEnvironmentGlobal;
    }
    function requestUpdateLane(fiber) {
      if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
      var transition = ReactSharedInternals.T;
      return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
      var suspenseHandler = suspenseHandlerStackCursor.current;
      null !== suspenseHandler && (suspenseHandler.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root, fiber, lane) {
      isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
      isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);
      if (root === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
      markRootUpdated$1(root, lane);
      if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {
        if (isRendering) switch (fiber.tag) {
          case 0:
          case 11:
          case 15:
            root = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
            didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", fiber, root, root));
            break;
          case 1:
            didWarnAboutUpdateInRender || (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), didWarnAboutUpdateInRender = !0);
        }
      } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);
    }
    function performWorkOnRoot(root, lanes, forceSync) {
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Should not already be working.");
      var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes),
        exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0),
        renderWasConcurrent = shouldTimeSlice;
      do {
        if (exitStatus === RootInProgress) {
          workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, !1);
          break;
        } else {
          forceSync = root.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
            exitStatus = renderRootSync(root, lanes, !1);
            renderWasConcurrent = !1;
            continue;
          }
          if (exitStatus === RootErrored) {
            renderWasConcurrent = lanes;
            if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
            if (0 !== errorRetryLanes) {
              lanes = errorRetryLanes;
              a: {
                exitStatus = root;
                var errorRetryLanes$jscomp$0 = errorRetryLanes;
                errorRetryLanes = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);
                errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, !1);
                if (errorRetryLanes$jscomp$0 !== RootErrored) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                    exitStatus = RootSuspendedWithDelay;
                    break a;
                  }
                  exitStatus = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = errorRetryLanes;
                  null !== exitStatus && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = exitStatus : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, exitStatus));
                }
                exitStatus = errorRetryLanes$jscomp$0;
              }
              renderWasConcurrent = !1;
              if (exitStatus !== RootErrored) continue;
            }
          }
          if (exitStatus === RootFatalErrored) {
            prepareFreshStack(root, 0);
            markRootSuspended(root, lanes, 0, !0);
            break;
          }
          a: {
            shouldTimeSlice = root;
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored:
                throw Error("Root did not complete. This is a bug in React.");
              case RootSuspendedWithDelay:
                if ((lanes & 4194048) !== lanes) break;
              case RootSuspendedAtTheShell:
                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                break a;
              case RootErrored:
                workInProgressRootRecoverableErrors = null;
                break;
              case RootSuspended:
              case RootCompleted:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (null !== ReactSharedInternals.actQueue) commitRoot(shouldTimeSlice, forceSync, lanes, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes);else {
              if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, exitStatus, THROTTLED_COMMIT, renderStartTime, 0), renderWasConcurrent);
                break a;
              }
              commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, exitStatus, IMMEDIATE_COMMIT, renderStartTime, 0);
            }
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root);
    }
    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root.timeoutHandle = noTimeout;
      suspendedCommitReason = finishedWork.subtreeFlags;
      if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) if (suspendedState = {
        stylesheets: null,
        count: 0,
        unsuspend: noop
      }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
        root.cancelPendingCommit = suspendedCommitReason(commitRoot.bind(null, root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));
        markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
        return;
      }
      commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork;;) {
        var tag = node.tag;
        if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for (var i = 0; i < tag.length; i++) {
          var check = tag[i],
            getSnapshot = check.getSnapshot;
          check = check.value;
          try {
            if (!objectIs(getSnapshot(), check)) return !1;
          } catch (error) {
            return !1;
          }
        }
        tag = node.child;
        if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;else {
          if (node === finishedWork) break;
          for (; null === node.sibling;) {
            if (null === node.return || node.return === finishedWork) return !0;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return !0;
    }
    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root.suspendedLanes |= suspendedLanes;
      root.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes;) {
        var index = 31 - clz32(lanes),
          lane = 1 << index;
        didAttemptEntireTree[index] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
        for (; null !== interruptedWork;) unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function prepareFreshStack(root, lanes) {
      var timeoutHandle = root.timeoutHandle;
      timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
      timeoutHandle = root.cancelPendingCommit;
      null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());
      resetWorkInProgressStack();
      workInProgressRoot = root;
      workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = NotSuspended;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = !1;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      workInProgressRootDidAttachPingListener = !1;
      workInProgressRootExitStatus = RootInProgress;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root.entangledLanes;
      if (0 !== allEntangledLanes) for (root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;) {
        var index = 31 - clz32(allEntangledLanes),
          lane = 1 << index;
        lanes |= root[index];
        allEntangledLanes &= ~lane;
      }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      lanes = getCurrentTime();
      1e3 < lanes - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = lanes);
      ReactStrictModeWarnings.discardPendingWarnings();
      return timeoutHandle;
    }
    function handleThrow(root, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      ReactSharedInternals.getCurrentStack = null;
      isRendering = !1;
      current = null;
      thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
      workInProgressThrownValue = thrownValue;
      var erroredWork = workInProgress;
      if (null === erroredWork) workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));else switch (erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason) {
        case SuspendedOnError:
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
          break;
        case SuspendedOnData:
        case SuspendedOnAction:
        case SuspendedOnImmediate:
        case SuspendedOnDeprecatedThrowPromise:
        case SuspendedAndReadyToContinue:
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);
      }
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = RootSuspendedWithDelay;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);
      0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
    }
    function renderRootSync(root, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        prepareFreshStack(root, lanes);
      }
      markRenderStarted(lanes);
      lanes = !1;
      memoizedUpdaters = workInProgressRootExitStatus;
      a: do try {
        if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
          var unitOfWork = workInProgress,
            thrownValue = workInProgressThrownValue;
          switch (workInProgressSuspendedReason) {
            case SuspendedOnHydration:
              resetWorkInProgressStack();
              memoizedUpdaters = RootSuspendedAtTheShell;
              break a;
            case SuspendedOnImmediate:
            case SuspendedOnData:
            case SuspendedOnAction:
            case SuspendedOnDeprecatedThrowPromise:
              null === suspenseHandlerStackCursor.current && (lanes = !0);
              var reason = workInProgressSuspendedReason;
              workInProgressSuspendedReason = NotSuspended;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
              if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                memoizedUpdaters = RootInProgress;
                break a;
              }
              break;
            default:
              reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
          }
        }
        workLoopSync();
        memoizedUpdaters = workInProgressRootExitStatus;
        break;
      } catch (thrownValue$8) {
        handleThrow(root, thrownValue$8);
      } while (1);
      lanes && root.shellSuspendCounter++;
      resetContextDependencies();
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      markRenderStopped();
      null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return memoizedUpdaters;
    }
    function workLoopSync() {
      for (; null !== workInProgress;) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(),
        prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root, lanes);
        }
        workInProgressTransitions = null;
        workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
        prepareFreshStack(root, lanes);
      } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
      markRenderStarted(lanes);
      a: do try {
        if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
          case SuspendedOnError:
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);
            break;
          case SuspendedOnData:
          case SuspendedOnAction:
            if (isThenableResolved(memoizedUpdaters)) {
              workInProgressSuspendedReason = NotSuspended;
              workInProgressThrownValue = null;
              replaySuspendedUnitOfWork(lanes);
              break;
            }
            lanes = function () {
              workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
              ensureRootIsScheduled(root);
            };
            memoizedUpdaters.then(lanes, lanes);
            break a;
          case SuspendedOnImmediate:
            workInProgressSuspendedReason = SuspendedAndReadyToContinue;
            break a;
          case SuspendedOnInstance:
            workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
            break a;
          case SuspendedAndReadyToContinue:
            isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));
            break;
          case SuspendedOnInstanceAndReadyToContinue:
            var resource = null;
            switch (workInProgress.tag) {
              case 26:
                resource = workInProgress.memoizedState;
              case 5:
              case 27:
                var hostFiber = workInProgress;
                if (resource ? preloadResource(resource) : 1) {
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  var sibling = hostFiber.sibling;
                  if (null !== sibling) workInProgress = sibling;else {
                    var returnFiber = hostFiber.return;
                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                  }
                  break b;
                }
                break;
              default:
                console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
            }
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);
            break;
          case SuspendedOnDeprecatedThrowPromise:
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);
            break;
          case SuspendedOnHydration:
            resetWorkInProgressStack();
            workInProgressRootExitStatus = RootSuspendedAtTheShell;
            break a;
          default:
            throw Error("Unexpected SuspendedReason. This is a bug in React.");
        }
        null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
        break;
      } catch (thrownValue$9) {
        handleThrow(root, thrownValue$9);
      } while (1);
      resetContextDependencies();
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress) return null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;
      markRenderStopped();
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (; null !== workInProgress && !shouldYield();) performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var current = unitOfWork.alternate;
      (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function replayBeginWork(unitOfWork) {
      var current = unitOfWork.alternate,
        isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
      isProfilingMode && startProfilerTimer(unitOfWork);
      switch (unitOfWork.tag) {
        case 15:
        case 0:
          current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);
          break;
        case 11:
          current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);
          break;
        case 5:
          resetHooksOnUnwind(unitOfWork);
        default:
          unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);
      }
      isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
      return current;
    }
    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
      resetContextDependencies();
      resetHooksOnUnwind(unitOfWork);
      thenableState = null;
      thenableIndexCounter = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
          workInProgressRootExitStatus = RootFatalErrored;
          logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = RootFatalErrored;
        logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || suspendedReason === SuspendedOnError) root = !0;else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
          return;
        }
        var current = completedWork.alternate;
        unitOfWork = completedWork.return;
        startProfilerTimer(completedWork);
        current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);
        (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
        if (null !== current) {
          workInProgress = current;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
          next = unitOfWork.actualDuration;
          for (var child = unitOfWork.child; null !== child;) next += child.actualDuration, child = child.sibling;
          unitOfWork.actualDuration = next;
        }
        next = unitOfWork.return;
        null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = RootSuspendedAtTheShell;
      workInProgress = null;
    }
    function commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
      root.cancelPendingCommit = null;
      do flushPendingEffects(); while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
      ReactStrictModeWarnings.flushLegacyContextWarning();
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Should not already be working.");
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(lanes);
      if (null === finishedWork) markCommitStopped();else {
        0 === lanes && console.error("finishedLanes should not be empty during a commit. This is a bug in React.");
        if (finishedWork === root.current) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(root, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
        root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root.callbackNode = null, root.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function () {
          flushPassiveEffects(!0);
          return null;
        })) : (root.callbackNode = null, root.callbackPriority = 0);
        commitStartTime = now();
        recoverableErrors = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          spawnedLane = executionContext;
          executionContext |= CommitContext;
          try {
            commitBeforeMutationEffects(root, finishedWork, lanes);
          } finally {
            executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
          }
        }
        pendingEffectsStatus = PENDING_MUTATION_PHASE;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var root = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          lanes = pendingEffectsLanes,
          rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            inProgressLanes = lanes;
            inProgressRoot = root;
            commitMutationEffectsOnFiber(finishedWork, root);
            inProgressRoot = inProgressLanes = null;
            lanes = selectionInformation;
            var curFocusedElem = getActiveElementDeep(root.containerInfo),
              priorFocusedElem = lanes.focusedElem,
              priorSelectionRange = lanes.selectionRange;
            if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(priorFocusedElem.ownerDocument.documentElement, priorFocusedElem)) {
              if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                var start = priorSelectionRange.start,
                  end = priorSelectionRange.end;
                void 0 === end && (end = start);
                if ("selectionStart" in priorFocusedElem) priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(end, priorFocusedElem.value.length);else {
                  var doc = priorFocusedElem.ownerDocument || document,
                    win = doc && doc.defaultView || window;
                  if (win.getSelection) {
                    var selection = win.getSelection(),
                      length = priorFocusedElem.textContent.length,
                      start$jscomp$0 = Math.min(priorSelectionRange.start, length),
                      end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                    !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                    var startMarker = getNodeForCharacterOffset(priorFocusedElem, start$jscomp$0),
                      endMarker = getNodeForCharacterOffset(priorFocusedElem, end$jscomp$0);
                    if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                      var range = doc.createRange();
                      range.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                    }
                  }
                }
              }
              doc = [];
              for (selection = priorFocusedElem; selection = selection.parentNode;) 1 === selection.nodeType && doc.push({
                element: selection,
                left: selection.scrollLeft,
                top: selection.scrollTop
              });
              "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
              for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                var info = doc[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled = !!eventsEnabled;
            selectionInformation = eventsEnabled = null;
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
          }
        }
        root.current = finishedWork;
        pendingEffectsStatus = PENDING_LAYOUT_PHASE;
      }
    }
    function flushLayoutEffects() {
      if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var root = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          lanes = pendingEffectsLanes,
          rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
        if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(lanes), inProgressLanes = lanes, inProgressRoot = root, commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork), inProgressRoot = inProgressLanes = null, null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped();
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
          }
        }
        pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
      }
    }
    function flushSpawnedWork() {
      if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        requestPaint();
        var root = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          lanes = pendingEffectsLanes,
          recoverableErrors = pendingRecoverableErrors,
          rootDidHavePassiveEffects = 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
        rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root, root.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
        var remainingLanes = root.pendingLanes;
        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
        rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root);
        rootDidHavePassiveEffects = lanesToEventPriority(lanes);
        finishedWork = finishedWork.stateNode;
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
          var didError = 128 === (finishedWork.current.flags & 128);
          switch (rootDidHavePassiveEffects) {
            case DiscreteEventPriority:
              var schedulerPriority = ImmediatePriority;
              break;
            case ContinuousEventPriority:
              schedulerPriority = UserBlockingPriority;
              break;
            case DefaultEventPriority:
              schedulerPriority = NormalPriority$1;
              break;
            case IdleEventPriority:
              schedulerPriority = IdlePriority;
              break;
            default:
              schedulerPriority = NormalPriority$1;
          }
          injectedHook.onCommitFiberRoot(rendererID, finishedWork, schedulerPriority, didError);
        } catch (err) {
          hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
        }
        isDevToolsPresent && root.memoizedUpdaters.clear();
        onCommitRoot();
        if (null !== recoverableErrors) {
          didError = ReactSharedInternals.T;
          schedulerPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          ReactSharedInternals.T = null;
          try {
            var onRecoverableError = root.onRecoverableError;
            for (finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++) {
              var recoverableError = recoverableErrors[finishedWork],
                errorInfo = makeErrorInfo(recoverableError.stack);
              runWithFiberInDEV(recoverableError.source, onRecoverableError, recoverableError.value, errorInfo);
            }
          } finally {
            ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
          }
        }
        0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
        ensureRootIsScheduled(root);
        remainingLanes = root.pendingLanes;
        0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;
        flushSyncWorkAcrossRoots_impl(0, !1);
        markCommitStopped();
      }
    }
    function makeErrorInfo(componentStack) {
      componentStack = {
        componentStack: componentStack
      };
      Object.defineProperty(componentStack, "digest", {
        get: function () {
          console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');
        }
      });
      return componentStack;
    }
    function releaseRootPooledCache(root, remainingLanes) {
      0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPendingEffects(wasDelayedCommit) {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects(wasDelayedCommit);
    }
    function flushPassiveEffects() {
      if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return !1;
      var root = pendingEffectsRoot,
        remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes),
        priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
      renderPriority = ReactSharedInternals.T;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = priority;
        ReactSharedInternals.T = null;
        priority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root$jscomp$0 = pendingEffectsRoot,
          lanes = pendingEffectsLanes;
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Cannot flush passive effects while already rendering.");
        isFlushingPassiveEffects = !0;
        didScheduleUpdateDuringPassiveEffects = !1;
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
        var prevExecutionContext = executionContext;
        executionContext |= CommitContext;
        commitPassiveUnmountOnFiber(root$jscomp$0.current);
        commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();
        commitDoubleInvokeEffectsInDEV(root$jscomp$0);
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, !1);
        didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;
        didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;
        if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
          injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
        } catch (err) {
          hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
        }
        var stateNode = root$jscomp$0.current.stateNode;
        stateNode.effectDuration = 0;
        stateNode.passiveEffectDuration = 0;
        return !0;
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      isRunningInsertionEffect = !1;
      if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);else {
        for (; null !== nearestMountedAncestor;) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
            return;
          }
          if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              return;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
        console.error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error);
      }
    }
    function attachPingListener(root, wakeable, lanes) {
      var pingCache = root.pingCache;
      if (null === pingCache) {
        pingCache = root.pingCache = new PossiblyWeakMap();
        var threadIDs = new Set();
        pingCache.set(wakeable, threadIDs);
      } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));
    }
    function pingSuspendedRoot(root, wakeable, pingedLanes) {
      var pingCache = root.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root.pingedLanes |= root.suspendedLanes & pingedLanes;
      root.warmLanes &= ~pingedLanes;
      isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act");
      workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState,
        retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
      if (0 !== (parentFiber.subtreeFlags & 67117056)) for (parentFiber = parentFiber.child; null !== parentFiber;) {
        var root = root$jscomp$0,
          fiber = parentFiber,
          isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
        isStrictModeFiber = isInStrictMode || isStrictModeFiber;
        22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & NoStrictPassiveEffectsMode) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));
        parentFiber = parentFiber.sibling;
      }
    }
    function doubleInvokeEffectsOnFiber(root, fiber) {
      var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;
      setIsStrictModeForDevtools(!0);
      try {
        disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, !1, 0);
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    function commitDoubleInvokeEffectsInDEV(root) {
      var doubleInvokeEffects = !0;
      root.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = !1);
      recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);
    }
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
      if ((executionContext & RenderContext) === NoContext) {
        var tag = fiber.tag;
        if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
          tag = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (null !== didWarnStateUpdateForNotYetMountedComponent) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
            didWarnStateUpdateForNotYetMountedComponent.add(tag);
          } else didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);
          runWithFiberInDEV(fiber, function () {
            console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          });
        }
      }
    }
    function restorePendingUpdaters(root, lanes) {
      isDevToolsPresent && root.memoizedUpdaters.forEach(function (schedulingFiber) {
        addFiberToLanesMap(root, schedulingFiber, lanes);
      });
    }
    function scheduleCallback$1(priorityLevel, callback) {
      var actQueue = ReactSharedInternals.actQueue;
      return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
    }
    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
      isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function () {
        console.error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
      });
    }
    function ensureRootIsScheduled(root) {
      root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
      mightHavePendingSyncWork = !0;
      null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = !0;
        do {
          var didPerformSomeWork = !1;
          for (var root = firstScheduledRoot; null !== root;) {
            if (!onlyLegacy) if (0 !== syncTransitionLanes) {
              var pendingLanes = root.pendingLanes;
              if (0 === pendingLanes) var nextLanes = 0;else {
                var suspendedLanes = root.suspendedLanes,
                  pingedLanes = root.pingedLanes;
                nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
              }
              0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));
            } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));
            root = root.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = !1;
      }
    }
    function processRootScheduleInImmediateTask() {
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
      for (var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;) {
        var next = root.next,
          nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
        if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;
        root = next;
      }
      flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
    }
    function scheduleTaskForRootDuringMicrotask(root, currentTime) {
      for (var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;) {
        var index = 31 - clz32(lanes),
          lane = 1 << index,
          expirationTime = expirationTimes[index];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout);
      pingedLanes = root.callbackNode;
      if (0 === suspendedLanes || root === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
      if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode) cancelCallback(pingedLanes);else return currentTime;
        switch (lanesToEventPriority(suspendedLanes)) {
          case DiscreteEventPriority:
          case ContinuousEventPriority:
            suspendedLanes = UserBlockingPriority;
            break;
          case DefaultEventPriority:
            suspendedLanes = NormalPriority$1;
            break;
          case IdleEventPriority:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
        null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root.callbackPriority = currentTime;
        root.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && cancelCallback(pingedLanes);
      root.callbackPriority = 2;
      root.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root, didTimeout) {
      nestedUpdateScheduled = currentUpdateIsNested = !1;
      if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return root.callbackNode = null, root.callbackPriority = 0, null;
      var originalCallbackNode = root.callbackNode;
      if (flushPendingEffects(!0) && root.callbackNode !== originalCallbackNode) return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, null !== root.cancelPendingCommit || root.timeoutHandle !== noTimeout);
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root, now$1());
      return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
    }
    function performSyncWorkOnRoot(root, lanes) {
      if (flushPendingEffects()) return null;
      currentUpdateIsNested = nestedUpdateScheduled;
      nestedUpdateScheduled = !1;
      performWorkOnRoot(root, lanes, !0);
    }
    function cancelCallback(callbackNode) {
      callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
    }
    function scheduleImmediateRootScheduleTask() {
      null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function () {
        processRootScheduleInMicrotask();
        return null;
      });
      scheduleMicrotask(function () {
        (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();
      });
    }
    function requestTransitionLane() {
      0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp) return null;
      if ("function" === typeof actionProp) return actionProp;
      checkAttributeStringCoercion(actionProp, "action");
      return sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action),
          submitter = nativeEvent.submitter;
        submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
        var event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
        dispatchQueue.push({
          event: event,
          listeners: [{
            instance: null,
            listener: function () {
              if (nativeEvent.defaultPrevented) {
                if (0 !== currentEventTransitionLane) {
                  var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget),
                    pendingState = {
                      pending: !0,
                      data: formData,
                      method: nativeEventTarget.method,
                      action: action
                    };
                  Object.freeze(pendingState);
                  startHostTransition(maybeTargetInst, pendingState, null, formData);
                }
              } else "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), pendingState = {
                pending: !0,
                data: formData,
                method: nativeEventTarget.method,
                action: action
              }, Object.freeze(pendingState), startHostTransition(maybeTargetInst, pendingState, action, formData));
            },
            currentTarget: nativeEventTarget
          }]
        });
      }
    }
    function executeDispatch(event, listener, currentTarget) {
      event.currentTarget = currentTarget;
      try {
        listener(event);
      } catch (error) {
        reportGlobalError(error);
      }
      event.currentTarget = null;
    }
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i = 0; i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i];
        a: {
          var previousInstance = void 0,
            event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          if (eventSystemFlags) for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
            var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
              instance = _dispatchListeners$i.instance,
              currentTarget = _dispatchListeners$i.currentTarget;
            _dispatchListeners$i = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped()) break a;
            null !== instance ? runWithFiberInDEV(instance, executeDispatch, event, _dispatchListeners$i, currentTarget) : executeDispatch(event, _dispatchListeners$i, currentTarget);
            previousInstance = instance;
          } else for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
            _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
            instance = _dispatchListeners$i.instance;
            currentTarget = _dispatchListeners$i.currentTarget;
            _dispatchListeners$i = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped()) break a;
            null !== instance ? runWithFiberInDEV(instance, executeDispatch, event, _dispatchListeners$i, currentTarget) : executeDispatch(event, _dispatchListeners$i, currentTarget);
            previousInstance = instance;
          }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      nonDelegatedEvents.has(domEventName) || console.error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
      var listenerSet = targetElement[internalEventHandlersKey];
      void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = new Set());
      var listenerSetKey = domEventName + "__bubble";
      listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, !1), listenerSet.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
    }
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = !0;
        allNativeEvents.forEach(function (domEventName) {
          "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, !1, rootContainerElement), listenToNativeEvent(domEventName, !0, rootContainerElement));
        });
        var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = !0, listenToNativeEvent("selectionchange", !1, ownerDocument));
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case DiscreteEventPriority:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case ContinuousEventPriority:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = !0);
      isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        capture: !0,
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !0) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
      var ancestorInst = targetInst$jscomp$0;
      if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0) a: for (;;) {
        if (null === targetInst$jscomp$0) return;
        var nodeTag = targetInst$jscomp$0.tag;
        if (3 === nodeTag || 4 === nodeTag) {
          var container = targetInst$jscomp$0.stateNode.containerInfo;
          if (container === targetContainer) break;
          if (4 === nodeTag) for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag;) {
            var grandTag = nodeTag.tag;
            if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer) return;
            nodeTag = nodeTag.return;
          }
          for (; null !== container;) {
            nodeTag = getClosestInstanceFromNode(container);
            if (null === nodeTag) return;
            grandTag = nodeTag.tag;
            if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
              targetInst$jscomp$0 = ancestorInst = nodeTag;
              continue a;
            }
            container = container.parentNode;
          }
        }
        targetInst$jscomp$0 = targetInst$jscomp$0.return;
      }
      batchedUpdates$1(function () {
        var targetInst = ancestorInst,
          nativeEventTarget = getEventTarget(nativeEvent),
          dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent,
              reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4),
              accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName),
              reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
            inCapturePhase = [];
            for (var instance = targetInst, lastHostComponent; null !== instance;) {
              var _instance2 = instance;
              lastHostComponent = _instance2.stateNode;
              _instance2 = _instance2.tag;
              5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(createDispatchListener(instance, _instance2, lastHostComponent)));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
              event: reactName,
              listeners: inCapturePhase
            }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName = "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
            if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey])) break a;
            if (SyntheticEventCtor || reactName) {
              reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
              if (SyntheticEventCtor) {
                if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase)) reactEventType = null;
              } else SyntheticEventCtor = null, reactEventType = targetInst;
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance2 = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if ("pointerout" === domEventName || "pointerover" === domEventName) inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(_instance2, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance2 = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                accumulateTargetOnly = _instance2;
                if (SyntheticEventCtor && reactEventType) b: {
                  inCapturePhase = SyntheticEventCtor;
                  reactEventName = reactEventType;
                  instance = 0;
                  for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent)) instance++;
                  lastHostComponent = 0;
                  for (_instance2 = reactEventName; _instance2; _instance2 = getParent(_instance2)) lastHostComponent++;
                  for (; 0 < instance - lastHostComponent;) inCapturePhase = getParent(inCapturePhase), instance--;
                  for (; 0 < lastHostComponent - instance;) reactEventName = getParent(reactEventName), lastHostComponent--;
                  for (; instance--;) {
                    if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate) break b;
                    inCapturePhase = getParent(inCapturePhase);
                    reactEventName = getParent(reactEventName);
                  }
                  inCapturePhase = null;
                } else inCapturePhase = null;
                null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, !1);
                null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, !0);
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
            if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type) var getTargetInstFunc = getTargetInstForChangeEvent;else if (isTextInputElement(reactName)) {
              if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
            if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
              createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);
              break a;
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable) activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = !1;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
          var fallbackData;
          if (canUseCompositionEvent) b: {
            switch (domEventName) {
              case "compositionstart":
                var eventType = "onCompositionStart";
                break b;
              case "compositionend":
                eventType = "onCompositionEnd";
                break b;
              case "compositionupdate":
                eventType = "onCompositionUpdate";
                break b;
            }
            eventType = void 0;
          } else isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
          eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = !0)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
            event: eventType,
            listeners: handleEventFunc
          }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
          if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent)) eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
            event: handleEventFunc,
            listeners: eventType
          }), handleEventFunc.data = fallbackData);
          extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance: instance,
        listener: listener,
        currentTarget: currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber;) {
        var _instance3 = targetFiber,
          stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(createDispatchListener(targetFiber, _instance3, stateNode)), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(createDispatchListener(targetFiber, _instance3, stateNode)));
        if (3 === targetFiber.tag) return listeners;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    function getParent(inst) {
      if (null === inst) return null;
      do inst = inst.return; while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = []; null !== target && target !== common;) {
        var _instance4 = target,
          alternate = _instance4.alternate,
          stateNode = _instance4.stateNode;
        _instance4 = _instance4.tag;
        if (null !== alternate && alternate === common) break;
        5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(createDispatchListener(target, stateNode, alternate))));
        target = target.return;
      }
      0 !== listeners.length && dispatchQueue.push({
        event: event,
        listeners: listeners
      });
    }
    function validatePropertiesInDevelopment(type, props) {
      validateProperties$2(type, props);
      "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = !0, "select" === type && props.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
      var eventRegistry = {
        registrationNameDependencies: registrationNameDependencies,
        possibleRegistrationNames: possibleRegistrationNames
      };
      isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
      props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
    }
    function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
      serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
    }
    function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
      attributeNames.forEach(function (attributeName) {
        serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
      });
    }
    function warnForInvalidEventListener(registrationName, listener) {
      !1 === listener ? console.error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName) : console.error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
    }
    function normalizeHTML(parent, html) {
      parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName) : parent.ownerDocument.createElement(parent.tagName);
      parent.innerHTML = html;
      return parent.innerHTML;
    }
    function normalizeMarkupForTextOrAttribute(markup) {
      willCoercionThrow(markup) && (console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName(markup)), testStringCoercion(markup));
      return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
    }
    function noop$1() {}
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          if ("string" === typeof value) validateTextNesting(value, tag, !1), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);else if ("number" === typeof value || "bigint" === typeof value) validateTextNesting("" + value, tag, !1), "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            "src" === key ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key);
            domElement.removeAttribute(key);
            break;
          }
          if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          null != value && ("form" === tag ? "formAction" === key ? console.error("You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>.") : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.")), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."))) : "input" === tag || "button" === tag ? "action" === key ? console.error("You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>.") : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = !0, console.error('Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.')), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.")), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."))) : (didWarnFormActionType = !0, console.error('A button can only specify a formAction along with type="submit" or no type.')) : (didWarnFormActionType = !0, console.error('An input can only specify a formAction along with type="submit" or type="image".')) : "action" === key ? console.error("You can only pass the action prop to <form>.") : console.error("You can only pass the formAction prop to <input> or <button>."));
          if ("function" === typeof value) {
            domElement.setAttribute(key, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
            break;
          } else "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(domElement, tag, "formEncType", props.formEncType, props, null), setProp(domElement, tag, "formMethod", props.formMethod, props, null), setProp(domElement, tag, "formTarget", props.formTarget, props, null)) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
          if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
          break;
        case "onScroll":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          checkAttributeStringCoercion(value, key);
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
          break;
        case "inert":
          "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", key));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          !0 === value ? domElement.setAttribute(key, "") : !1 !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:actuate", value);
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:arcrole", value);
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:role", value);
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:show", value);
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:title", value);
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:type", value);
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:base", value);
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:lang", value);
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:space", value);
          break;
        case "is":
          null != prevValue && console.error('Cannot update the "is" prop after it has been initialized.');
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = !0, console.error("The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.", value));
        default:
          !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
      }
    }
    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "onClick":
          null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (registrationNameDependencies.hasOwnProperty(key)) null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);else a: {
            if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
              "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
              domElement.addEventListener(tag, value, props);
              break a;
            }
            key in domElement ? domElement[key] = value : !0 === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
          }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      validatePropertiesInDevelopment(tag, props);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = !1,
            hasSrcSet = !1,
            propKey;
          for (propKey in props) if (props.hasOwnProperty(propKey)) {
            var propValue = props[propKey];
            if (null != propValue) switch (propKey) {
              case "src":
                hasSrc = !0;
                break;
              case "srcSet":
                hasSrcSet = !0;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                setProp(domElement, tag, propKey, propValue, props, null);
            }
          }
          hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = propKey = propValue = hasSrcSet = null,
            checked = null,
            defaultChecked = null;
          for (hasSrc in props) if (props.hasOwnProperty(hasSrc)) {
            var _propValue = props[hasSrc];
            if (null != _propValue) switch (hasSrc) {
              case "name":
                hasSrcSet = _propValue;
                break;
              case "type":
                propValue = _propValue;
                break;
              case "checked":
                checked = _propValue;
                break;
              case "defaultChecked":
                defaultChecked = _propValue;
                break;
              case "value":
                propKey = _propValue;
                break;
              case "defaultValue":
                defaultValue = _propValue;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != _propValue) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                break;
              default:
                setProp(domElement, tag, hasSrc, _propValue, props, null);
            }
          }
          validateInputProps(domElement, props);
          initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, !1);
          track(domElement);
          return;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props) if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue)) switch (hasSrcSet) {
            case "value":
              propKey = defaultValue;
              break;
            case "defaultValue":
              propValue = defaultValue;
              break;
            case "multiple":
              hasSrc = defaultValue;
            default:
              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
          }
          validateSelectProps(domElement, props);
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag ? updateOptions(domElement, !!hasSrc, tag, !1) : null != props && updateOptions(domElement, !!hasSrc, props, !0);
          return;
        case "textarea":
          checkControlledValueProps("textarea", props);
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props) if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue)) switch (propValue) {
            case "value":
              hasSrc = defaultValue;
              break;
            case "defaultValue":
              hasSrcSet = defaultValue;
              break;
            case "children":
              propKey = defaultValue;
              break;
            case "dangerouslySetInnerHTML":
              if (null != defaultValue) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              break;
            default:
              setProp(domElement, tag, propValue, defaultValue, props, null);
          }
          validateTextareaProps(domElement, props);
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          track(domElement);
          return;
        case "option":
          validateOptionProps(domElement, props);
          for (checked in props) if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc)) switch (checked) {
            case "selected":
              domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
              break;
            default:
              setProp(domElement, tag, checked, hasSrc, props, null);
          }
          return;
        case "dialog":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++) listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props) if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc)) switch (defaultChecked) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
          }
          return;
        default:
          if (isCustomElement(tag)) {
            for (_propValue in props) props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(domElement, tag, _propValue, hasSrc, props, void 0));
            return;
          }
      }
      for (defaultValue in props) props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      validatePropertiesInDevelopment(tag, nextProps);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null,
            type = null,
            value = null,
            defaultValue = null,
            lastDefaultValue = null,
            checked = null,
            defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp) switch (propKey) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                lastDefaultValue = lastProp;
              default:
                nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
            }
          }
          for (var _propKey8 in nextProps) {
            var propKey = nextProps[_propKey8];
            lastProp = lastProps[_propKey8];
            if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp)) switch (_propKey8) {
              case "type":
                type = propKey;
                break;
              case "name":
                name = propKey;
                break;
              case "checked":
                checked = propKey;
                break;
              case "defaultChecked":
                defaultChecked = propKey;
                break;
              case "value":
                value = propKey;
                break;
              case "defaultValue":
                defaultValue = propKey;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propKey) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                break;
              default:
                propKey !== lastProp && setProp(domElement, tag, _propKey8, propKey, nextProps, lastProp);
            }
          }
          tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
          nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
          tag || !nextProps || didWarnUncontrolledToControlled || (console.error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnUncontrolledToControlled = !0);
          !tag || nextProps || didWarnControlledToUncontrolled || (console.error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnControlledToUncontrolled = !0);
          updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
          return;
        case "select":
          propKey = value = defaultValue = _propKey8 = null;
          for (type in lastProps) if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue) switch (type) {
            case "value":
              break;
            case "multiple":
              propKey = lastDefaultValue;
            default:
              nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
          }
          for (name in nextProps) if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue)) switch (name) {
            case "value":
              _propKey8 = type;
              break;
            case "defaultValue":
              defaultValue = type;
              break;
            case "multiple":
              value = type;
            default:
              type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
          }
          nextProps = defaultValue;
          tag = value;
          lastProps = propKey;
          null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, !1) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, !0) : updateOptions(domElement, !!tag, tag ? [] : "", !1));
          return;
        case "textarea":
          propKey = _propKey8 = null;
          for (defaultValue in lastProps) if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue)) switch (defaultValue) {
            case "value":
              break;
            case "children":
              break;
            default:
              setProp(domElement, tag, defaultValue, null, nextProps, name);
          }
          for (value in nextProps) if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type)) switch (value) {
            case "value":
              _propKey8 = name;
              break;
            case "defaultValue":
              propKey = name;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (null != name) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              break;
            default:
              name !== type && setProp(domElement, tag, value, name, nextProps, type);
          }
          updateTextarea(domElement, _propKey8, propKey);
          return;
        case "option":
          for (var _propKey13 in lastProps) if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13)) switch (_propKey13) {
            case "selected":
              domElement.selected = !1;
              break;
            default:
              setProp(domElement, tag, _propKey13, null, nextProps, _propKey8);
          }
          for (lastDefaultValue in nextProps) if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey)) switch (lastDefaultValue) {
            case "selected":
              domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
              break;
            default:
              setProp(domElement, tag, lastDefaultValue, _propKey8, nextProps, propKey);
          }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var _propKey15 in lastProps) _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(domElement, tag, _propKey15, null, nextProps, _propKey8);
          for (checked in nextProps) if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey)) switch (checked) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != _propKey8) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              break;
            default:
              setProp(domElement, tag, checked, _propKey8, nextProps, propKey);
          }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var _propKey17 in lastProps) _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(domElement, tag, _propKey17, void 0, nextProps, _propKey8);
            for (defaultChecked in nextProps) _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(domElement, tag, defaultChecked, _propKey8, nextProps, propKey);
            return;
          }
      }
      for (var _propKey19 in lastProps) _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
      for (lastProp in nextProps) _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
    }
    function getPropNameFromAttributeName(attrName) {
      switch (attrName) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return attrName;
      }
    }
    function getStylesObjectFromElement(domElement) {
      var serverValueInObjectForm = {};
      domElement = domElement.style;
      for (var i = 0; i < domElement.length; i++) {
        var styleName = domElement[i];
        serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
      }
      return serverValueInObjectForm;
    }
    function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
      if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0) console.error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");else {
        var clientValue;
        var delimiter = clientValue = "",
          styleName;
        for (styleName in value$jscomp$0) if (value$jscomp$0.hasOwnProperty(styleName)) {
          var value = value$jscomp$0[styleName];
          null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
        }
        clientValue = clientValue || null;
        value$jscomp$0 = domElement.getAttribute("style");
        value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
      }
    }
    function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          return;
      } else if (null != value) switch (typeof value) {
        case "function":
        case "symbol":
        case "boolean":
          break;
        default:
          if (checkAttributeStringCoercion(value, propKey), domElement === "" + value) return;
      }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) {
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        if (!value) return;
      } else switch (typeof value) {
        case "function":
        case "symbol":
          break;
        default:
          if (value) return;
      }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
          return;
      } else if (null != value) switch (typeof value) {
        case "function":
        case "symbol":
          break;
        default:
          if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value) return;
      }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          return;
        default:
          if (isNaN(value)) return;
      } else if (null != value) switch (typeof value) {
        case "function":
        case "symbol":
        case "boolean":
          break;
        default:
          if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value)) return;
      }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (null === domElement) switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          return;
      } else if (null != value) switch (typeof value) {
        case "function":
        case "symbol":
        case "boolean":
          break;
        default:
          if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName) return;
      }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function diffHydratedProperties(domElement, tag, props, hostContext) {
      for (var serverDifferences = {}, extraAttributes = new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++) switch (attributes[i].name.toLowerCase()) {
        case "value":
          break;
        case "checked":
          break;
        case "selected":
          break;
        default:
          extraAttributes.add(attributes[i].name);
      }
      if (isCustomElement(tag)) for (var propKey in props) {
        if (props.hasOwnProperty(propKey)) {
          var value = props[propKey];
          if (null != value) if (registrationNameDependencies.hasOwnProperty(propKey)) "function" !== typeof value && warnForInvalidEventListener(propKey, value);else if (!0 !== props.suppressHydrationWarning) switch (propKey) {
            case "children":
              "string" !== typeof value && "number" !== typeof value || warnForPropDifference("children", domElement.textContent, value, serverDifferences);
              continue;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              continue;
            case "dangerouslySetInnerHTML":
              attributes = domElement.innerHTML;
              value = value ? value.__html : void 0;
              null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(propKey, attributes, value, serverDifferences));
              continue;
            case "style":
              extraAttributes.delete(propKey);
              diffHydratedStyles(domElement, value, serverDifferences);
              continue;
            case "offsetParent":
            case "offsetTop":
            case "offsetLeft":
            case "offsetWidth":
            case "offsetHeight":
            case "isContentEditable":
            case "outerText":
            case "outerHTML":
              extraAttributes.delete(propKey.toLowerCase());
              console.error("Assignment to read-only property will result in a no-op: `%s`", propKey);
              continue;
            case "className":
              extraAttributes.delete("class");
              attributes = getValueForAttributeOnCustomComponent(domElement, "class", value);
              warnForPropDifference("className", attributes, value, serverDifferences);
              continue;
            default:
              hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(domElement, propKey, value), warnForPropDifference(propKey, attributes, value, serverDifferences);
          }
        }
      } else for (value in props) if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) if (registrationNameDependencies.hasOwnProperty(value)) "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);else if (!0 !== props.suppressHydrationWarning) switch (value) {
        case "children":
          "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference("children", domElement.textContent, propKey, serverDifferences);
          continue;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "value":
        case "checked":
        case "selected":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          continue;
        case "dangerouslySetInnerHTML":
          attributes = domElement.innerHTML;
          propKey = propKey ? propKey.__html : void 0;
          null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = {
            __html: attributes
          }));
          continue;
        case "className":
          hydrateAttribute(domElement, value, "class", propKey, extraAttributes, serverDifferences);
          continue;
        case "tabIndex":
          hydrateAttribute(domElement, value, "tabindex", propKey, extraAttributes, serverDifferences);
          continue;
        case "style":
          extraAttributes.delete(value);
          diffHydratedStyles(domElement, propKey, serverDifferences);
          continue;
        case "multiple":
          extraAttributes.delete(value);
          warnForPropDifference(value, domElement.multiple, propKey, serverDifferences);
          continue;
        case "muted":
          extraAttributes.delete(value);
          warnForPropDifference(value, domElement.muted, propKey, serverDifferences);
          continue;
        case "autoFocus":
          extraAttributes.delete("autofocus");
          warnForPropDifference(value, domElement.autofocus, propKey, serverDifferences);
          continue;
        case "data":
          if ("object" !== tag) {
            extraAttributes.delete(value);
            attributes = domElement.getAttribute("data");
            warnForPropDifference(value, attributes, propKey, serverDifferences);
            continue;
          }
        case "src":
        case "href":
          if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
            "src" === value ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value);
            continue;
          }
          hydrateSanitizedAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
          continue;
        case "action":
        case "formAction":
          attributes = domElement.getAttribute(value);
          if ("function" === typeof propKey) {
            extraAttributes.delete(value.toLowerCase());
            "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
            continue;
          } else if (attributes === EXPECTED_FORM_ACTION_URL) {
            extraAttributes.delete(value.toLowerCase());
            warnForPropDifference(value, "function", propKey, serverDifferences);
            continue;
          }
          hydrateSanitizedAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkHref":
          hydrateSanitizedAttribute(domElement, value, "xlink:href", propKey, extraAttributes, serverDifferences);
          continue;
        case "contentEditable":
          hydrateBooleanishAttribute(domElement, value, "contenteditable", propKey, extraAttributes, serverDifferences);
          continue;
        case "spellCheck":
          hydrateBooleanishAttribute(domElement, value, "spellcheck", propKey, extraAttributes, serverDifferences);
          continue;
        case "draggable":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          hydrateBooleanishAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
          continue;
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          hydrateBooleanAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);
          continue;
        case "capture":
        case "download":
          a: {
            i = domElement;
            var attributeName = attributes = value,
              serverDifferences$jscomp$0 = serverDifferences;
            extraAttributes.delete(attributeName);
            i = i.getAttribute(attributeName);
            if (null === i) switch (typeof propKey) {
              case "undefined":
              case "function":
              case "symbol":
                break a;
              default:
                if (!1 === propKey) break a;
            } else if (null != propKey) switch (typeof propKey) {
              case "function":
              case "symbol":
                break;
              case "boolean":
                if (!0 === propKey && "" === i) break a;
                break;
              default:
                if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey) break a;
            }
            warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);
          }
          continue;
        case "cols":
        case "rows":
        case "size":
        case "span":
          a: {
            i = domElement;
            attributeName = attributes = value;
            serverDifferences$jscomp$0 = serverDifferences;
            extraAttributes.delete(attributeName);
            i = i.getAttribute(attributeName);
            if (null === i) switch (typeof propKey) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                break a;
              default:
                if (isNaN(propKey) || 1 > propKey) break a;
            } else if (null != propKey) switch (typeof propKey) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)) break a;
            }
            warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);
          }
          continue;
        case "rowSpan":
          hydrateNumericAttribute(domElement, value, "rowspan", propKey, extraAttributes, serverDifferences);
          continue;
        case "start":
          hydrateNumericAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
          continue;
        case "xHeight":
          hydrateAttribute(domElement, value, "x-height", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkActuate":
          hydrateAttribute(domElement, value, "xlink:actuate", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkArcrole":
          hydrateAttribute(domElement, value, "xlink:arcrole", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkRole":
          hydrateAttribute(domElement, value, "xlink:role", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkShow":
          hydrateAttribute(domElement, value, "xlink:show", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkTitle":
          hydrateAttribute(domElement, value, "xlink:title", propKey, extraAttributes, serverDifferences);
          continue;
        case "xlinkType":
          hydrateAttribute(domElement, value, "xlink:type", propKey, extraAttributes, serverDifferences);
          continue;
        case "xmlBase":
          hydrateAttribute(domElement, value, "xml:base", propKey, extraAttributes, serverDifferences);
          continue;
        case "xmlLang":
          hydrateAttribute(domElement, value, "xml:lang", propKey, extraAttributes, serverDifferences);
          continue;
        case "xmlSpace":
          hydrateAttribute(domElement, value, "xml:space", propKey, extraAttributes, serverDifferences);
          continue;
        case "inert":
          "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", value));
          hydrateBooleanAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
          continue;
        default:
          if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
            i = getAttributeAlias(value);
            attributes = !1;
            hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(attributeName) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = !0, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
            a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0)) {
              if (attributeName.hasAttribute(serverDifferences$jscomp$0)) attributeName = attributeName.getAttribute(serverDifferences$jscomp$0), checkAttributeStringCoercion(i, serverDifferences$jscomp$0), i = attributeName === "" + i ? i : attributeName;else {
                switch (typeof i) {
                  case "function":
                  case "symbol":
                    break a;
                  case "boolean":
                    if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName) break a;
                }
                i = void 0 === i ? void 0 : null;
              }
            } else i = void 0;
            attributes || warnForPropDifference(value, i, propKey, serverDifferences);
          }
      }
      0 < extraAttributes.size && !0 !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
      return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
    }
    function propNamesListJoin(list, combinator) {
      switch (list.length) {
        case 0:
          return "";
        case 1:
          return list[0];
        case 2:
          return list[0] + " " + combinator + " " + list[1];
        default:
          return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
      }
    }
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case SVG_NAMESPACE:
          return HostContextNamespaceSvg;
        case MATH_NAMESPACE:
          return HostContextNamespaceMath;
        default:
          return HostContextNamespaceNone;
      }
    }
    function getChildHostContextProd(parentNamespace, type) {
      if (parentNamespace === HostContextNamespaceNone) switch (type) {
        case "svg":
          return HostContextNamespaceSvg;
        case "math":
          return HostContextNamespaceMath;
        default:
          return HostContextNamespaceNone;
      }
      return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
      return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
    }
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return !1;
        currentPopstateTransitionEvent = event;
        return !0;
      }
      currentPopstateTransitionEvent = null;
      return !1;
    }
    function handleErrorInNextTick(error) {
      setTimeout(function () {
        throw error;
      });
    }
    function commitMount(domElement, type, newProps) {
      switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          newProps.autoFocus && domElement.focus();
          break;
        case "img":
          newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
      }
    }
    function commitUpdate(domElement, type, oldProps, newProps) {
      updateProperties(domElement, type, oldProps, newProps);
      domElement[internalPropsKey] = newProps;
    }
    function resetTextContent(domElement) {
      setTextContent(domElement, "");
    }
    function commitTextUpdate(textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    }
    function isSingletonScope(type) {
      return "head" === type;
    }
    function removeChild(parentInstance, child) {
      parentInstance.removeChild(child);
    }
    function removeChildFromContainer(container, child) {
      (9 === container.nodeType ? container.body : "HTML" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);
    }
    function clearSuspenseBoundary(parentInstance, suspenseInstance) {
      var node = suspenseInstance,
        possiblePreambleContribution = 0,
        depth = 0;
      do {
        var nextNode = node.nextSibling;
        parentInstance.removeChild(node);
        if (nextNode && 8 === nextNode.nodeType) {
          if (node = nextNode.data, node === SUSPENSE_END_DATA) {
            if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
              node = possiblePreambleContribution;
              var ownerDocument = parentInstance.ownerDocument;
              node & PREAMBLE_CONTRIBUTION_HTML && releaseSingletonInstance(ownerDocument.documentElement);
              node & PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(ownerDocument.body);
              if (node & PREAMBLE_CONTRIBUTION_HEAD) for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument;) {
                var nextNode$jscomp$0 = ownerDocument.nextSibling,
                  nodeName = ownerDocument.nodeName;
                ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
                ownerDocument = nextNode$jscomp$0;
              }
            }
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(suspenseInstance);
              return;
            }
            depth--;
          } else node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_FALLBACK_START_DATA ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
        } else possiblePreambleContribution = 0;
        node = nextNode;
      } while (node);
      retryIfBlockedOn(suspenseInstance);
    }
    function hideInstance(instance) {
      instance = instance.style;
      "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
    }
    function hideTextInstance(textInstance) {
      textInstance.nodeValue = "";
    }
    function unhideInstance(instance, props) {
      props = props[STYLE];
      props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
      instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
    }
    function unhideTextInstance(textInstance, text) {
      textInstance.nodeValue = text;
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode;) {
        var node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node.rel.toLowerCase()) continue;
        }
        container.removeChild(node);
      }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType;) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type)) break;
        } else if (!inRootOrSingleton) {
          if ("input" === type && "hidden" === instance.type) {
            checkAttributeStringCoercion(anyProps.name, "name");
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if ("hidden" === anyProps.type && instance.getAttribute("name") === name) return instance;
          } else return instance;
        } else if (!instance[internalHoistableMarker]) switch (type) {
          case "meta":
            if (!instance.hasAttribute("itemprop")) break;
            return instance;
          case "link":
            name = instance.getAttribute("rel");
            if ("stylesheet" === name && instance.hasAttribute("data-precedence")) break;else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title)) break;
            return instance;
          case "style":
            if (instance.hasAttribute("data-precedence")) break;
            return instance;
          case "script":
            name = instance.getAttribute("src");
            if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop")) break;
            return instance;
          default:
            return instance;
        }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType;) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton) return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function isSuspenseInstanceFallback(instance) {
      return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE;
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument;
      if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE) callback();else {
        var listener = function () {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        };
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    function getNextHydratable(node) {
      for (; null != node; node = node.nextSibling) {
        var nodeType = node.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node.data;
          if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING) break;
          if (nodeType === SUSPENSE_END_DATA) return null;
        }
      }
      return node;
    }
    function describeHydratableInstanceForDevWarnings(instance) {
      if (1 === instance.nodeType) {
        for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++) {
          var attr = attributes[i];
          serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
        }
        return {
          type: JSCompiler_temp_const,
          props: serverDifferences
        };
      }
      return 8 === instance.nodeType ? {
        type: "Suspense",
        props: {}
      } : instance.nodeValue;
    }
    function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
      return null === parentProps || !0 !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
    }
    function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
      suspenseInstance = suspenseInstance.nextSibling;
      for (var depth = 0; suspenseInstance;) {
        if (8 === suspenseInstance.nodeType) {
          var data = suspenseInstance.data;
          if (data === SUSPENSE_END_DATA) {
            if (0 === depth) return getNextHydratable(suspenseInstance.nextSibling);
            depth--;
          } else data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA || depth++;
        }
        suspenseInstance = suspenseInstance.nextSibling;
      }
      return null;
    }
    function getParentSuspenseInstance(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance;) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
            if (0 === depth) return targetInstance;
            depth--;
          } else data === SUSPENSE_END_DATA && depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function commitHydratedContainer(container) {
      retryIfBlockedOn(container);
    }
    function commitHydratedSuspenseInstance(suspenseInstance) {
      retryIfBlockedOn(suspenseInstance);
    }
    function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
      validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type) throw Error("React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        case "head":
          type = props.head;
          if (!type) throw Error("React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        case "body":
          type = props.body;
          if (!type) throw Error("React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        default:
          throw Error("resolveSingletonInstance was called with an element type that is not supported. This is a bug in React.");
      }
    }
    function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
      if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
        var tagName = instance.tagName.toLowerCase();
        console.error("You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.", tagName, tagName, tagName);
      }
      switch (type) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error("acquireSingletonInstance was called with an element type that is not supported. This is a bug in React.");
      }
      for (tagName = instance.attributes; tagName.length;) instance.removeAttributeNode(tagName[0]);
      setInitialProperties(instance, type, props);
      instance[internalInstanceKey] = internalInstanceHandle;
      instance[internalPropsKey] = props;
    }
    function releaseSingletonInstance(instance) {
      for (var attributes = instance.attributes; attributes.length;) instance.removeAttributeNode(attributes[0]);
      detachDeletedInstance(instance);
    }
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
    }
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = {
          rel: rel,
          crossOrigin: crossOrigin,
          href: href
        }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
      }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
      var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
      if (!resourceRoot) throw Error('"resourceRoot" was expected to exist. This is a bug in React.');
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, currentProps.set(pendingProps, currentResource)), currentResource) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
          };
        case "link":
          if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
            type = getStyleKey(pendingProps.href);
            var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles,
              _resource = _styles.get(type);
            if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: {
                loading: NotLoaded,
                preload: null
              }
            }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(getStylesheetSelectorFromKey(type))) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
              var preloadProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              };
              preloadPropsMap.set(type, preloadProps);
              _styles || preloadStylesheet(resourceRoot, type, preloadProps, _resource.state);
            }
            if (currentProps && null === currentResource) throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error("Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps);
            return _resource;
          }
          if (currentProps && null !== currentResource) throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error("Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps);
          return null;
        case "script":
          return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, currentProps.set(pendingProps, currentResource)), currentResource) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
          };
        default:
          throw Error('getResource encountered a type it did not expect: "' + type + '". this is a bug in React.');
      }
    }
    function describeLinkForResourceErrorDEV(props) {
      var describedProps = 0,
        description = "<link";
      "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
      "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
      "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
      Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
      return description + " />";
    }
    function getStyleKey(href) {
      return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
      ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function () {
        return state.loading |= Loaded;
      }), key.addEventListener("error", function () {
        return state.loading |= Errored;
      }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance) switch (resource.type) {
        case "style":
          var instance = hoistableRoot.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]');
          if (instance) return resource.instance = instance, markNodeAsHoistable(instance), instance;
          var styleProps = assign({}, props, {
            "data-href": props.href,
            "data-precedence": props.precedence,
            href: null,
            precedence: null
          });
          instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
          markNodeAsHoistable(instance);
          setInitialProperties(instance, "style", styleProps);
          insertStylesheet(instance, props.precedence, hoistableRoot);
          return resource.instance = instance;
        case "stylesheet":
          styleProps = getStyleKey(props.href);
          var _instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));
          if (_instance) return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
          instance = stylesheetPropsFromRawProps(props);
          (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
          _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
          markNodeAsHoistable(_instance);
          var linkInstance = _instance;
          linkInstance._p = new Promise(function (resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(_instance, "link", instance);
          resource.state.loading |= Inserted;
          insertStylesheet(_instance, props.precedence, hoistableRoot);
          return resource.instance = _instance;
        case "script":
          _instance = getScriptKey(props.src);
          if (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(_instance))) return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
          instance = props;
          if (styleProps = preloadPropsMap.get(_instance)) instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          styleProps = hoistableRoot.createElement("script");
          markNodeAsHoistable(styleProps);
          setInitialProperties(styleProps, "link", instance);
          hoistableRoot.head.appendChild(styleProps);
          return resource.instance = styleProps;
        case "void":
          return null;
        default:
          throw Error('acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.');
      } else "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root) {
      for (var nodes = root.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.dataset.precedence === precedence) prior = node;else if (prior !== last) break;
      }
      prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root.nodeType ? root.head : root, precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
    }
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache = new Map();
        var caches = tagCaches = new Map();
        caches.set(ownerDocument, cache);
      } else caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = new Map(), caches.set(ownerDocument, cache));
      if (cache.has(type)) return cache;
      cache.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node = ownerDocument[caches];
        if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
          var nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache.get(nodeKey);
          existing ? existing.push(node) : cache.set(nodeKey, [node]);
        }
      }
      return cache;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(instance, "title" === type ? hoistableRoot.querySelector("head > title") : null);
    }
    function isHostHoistableType(type, props, hostContext) {
      var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
      if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp) return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error("Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.", type, type), !1;
      switch (type) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
            outsideHostContainerContext && console.error('Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.');
            break;
          }
          return !0;
        case "link":
          if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
            if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
              type = props.href;
              var onError = props.onError,
                disabled = props.disabled;
              hostContext = [];
              props.onLoad && hostContext.push("`onLoad`");
              onError && hostContext.push("`onError`");
              null != disabled && hostContext.push("`disabled`");
              onError = propNamesListJoin(hostContext, "and");
              onError += 1 === hostContext.length ? " prop" : " props";
              disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
              hostContext.length && console.error('React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', type, disabled, onError);
            }
            outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error("Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag") : (props.onError || props.onLoad) && console.error("Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."));
            break;
          }
          switch (props.rel) {
            case "stylesheet":
              return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error('Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'), "string" === typeof type && null == props;
            default:
              return !0;
          }
        case "script":
          type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
          if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
            outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error("Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>.") : console.error("Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>.") : console.error('Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'));
            break;
          }
          return !0;
        case "noscript":
        case "template":
          outsideHostContainerContext && console.error("Cannot render <%s> outside the main document. Try moving it into the root <head> tag.", type);
      }
      return !1;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? !1 : !0;
    }
    function noop() {}
    function suspendResource(hoistableRoot, resource, props) {
      if (null === suspendedState) throw Error("Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.");
      var state = suspendedState;
      if ("stylesheet" === resource.type && ("string" !== typeof props.media || !1 !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href),
            instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
            resource.state.loading |= Inserted;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function (resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state.stylesheets && (state.stylesheets = new Map());
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
      }
    }
    function waitForCommitToBeReady() {
      if (null === suspendedState) throw Error("Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.");
      var state = suspendedState;
      state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count ? function (commit) {
        var stylesheetTimer = setTimeout(function () {
          state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4);
        state.unsuspend = commit;
        return function () {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
        };
      } : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count) if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);else if (this.unsuspend) {
        var unsuspend = this.unsuspend;
        this.unsuspend = null;
        unsuspend();
      }
    }
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      null !== state.unsuspend && (state.count++, precedencesByRoot = new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root, resource) {
      if (!(resource.state.loading & Inserted)) {
        var precedences = precedencesByRoot.get(root);
        if (precedences) var last = precedences.get(LAST_PRECEDENCE);else {
          precedences = new Map();
          precedencesByRoot.set(root, precedences);
          for (var nodes = root.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media")) precedences.set(node.dataset.precedence, node), last = node;
          }
          last && precedences.set(LAST_PRECEDENCE, last);
        }
        nodes = resource.instance;
        node = nodes.getAttribute("data-precedence");
        i = precedences.get(node) || last;
        i === last && precedences.set(LAST_PRECEDENCE, nodes);
        precedences.set(node, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root = 9 === root.nodeType ? root.head : root, root.insertBefore(nodes, root.firstChild));
        resource.state.loading |= Inserted;
      }
    }
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = noTimeout;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map();
      this.passiveEffectDuration = this.effectDuration = -0;
      this.memoizedUpdaters = new Set();
      containerInfo = this.pendingUpdatersLaneMap = [];
      for (tag = 0; 31 > tag; tag++) containerInfo.push(new Set());
      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
      containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);
      tag = ConcurrentMode;
      !0 === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
      isDevToolsPresent && (tag |= ProfileMode);
      isStrictMode = createFiber(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      retainCache(tag);
      containerInfo.pooledCache = tag;
      retainCache(tag);
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot) try {
        injectedHook.onScheduleFiberRoot(rendererID, container, element);
      } catch (err) {
        hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
      }
      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
      isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown"));
      container = createUpdate(lane);
      container.payload = {
        element: element
      };
      callback = void 0 === callback ? null : callback;
      null !== callback && ("function" !== typeof callback && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback), container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag) {
        var root = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    function getCurrentFiberForDevTools() {
      return current;
    }
    function getLaneLabelMap() {
      for (var map = new Map(), lane = 1, index = 0; 31 > index; index++) {
        var label = getLabelForLane(lane);
        map.set(lane, label);
        lane *= 2;
      }
      return map;
    }
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn) dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) nativeEvent.stopPropagation();else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
          for (; null !== blockedOn;) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber) switch (fiber.tag) {
              case 3:
                fiber = fiber.stateNode;
                if (fiber.current.memoizedState.isDehydrated) {
                  var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                  if (0 !== lanes) {
                    var root = fiber;
                    root.pendingLanes |= 2;
                    for (root.entangledLanes |= 2; lanes;) {
                      var lane = 1 << 31 - clz32(lanes);
                      root.entanglements[1] |= lane;
                      lanes &= ~lane;
                    }
                    ensureRootIsScheduled(fiber);
                    (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));
                  }
                }
                break;
              case 13:
                root = enqueueConcurrentRenderForLane(fiber, 2), null !== root && scheduleUpdateOnFiber(root, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
            }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated) return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return DiscreteEventPriority;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ContinuousEventPriority;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return DiscreteEventPriority;
            case UserBlockingPriority:
              return ContinuousEventPriority;
            case NormalPriority$1:
            case LowPriority:
              return DefaultEventPriority;
            case IdlePriority:
              return IdleEventPriority;
            default:
              return DefaultEventPriority;
          }
        default:
          return DefaultEventPriority;
      }
    }
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent) return existingQueuedEvent = {
        blockedOn: blockedOn,
        domEventName: domEventName,
        eventSystemFlags: eventSystemFlags,
        nativeEvent: nativeEvent,
        targetContainers: [targetContainer]
      }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin":
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
        case "dragenter":
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
        case "mouseover":
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
          return !0;
        case "gotpointercapture":
          return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), !0;
      }
      return !1;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted) if (targetInst = nearestMounted.tag, 13 === targetInst) {
          if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
            queuedTarget.blockedOn = targetInst;
            runWithPriority(queuedTarget.priority, function () {
              if (13 === nearestMounted.tag) {
                var lane = requestUpdateLane(nearestMounted);
                lane = getBumpedLaneForHydrationByLane(lane);
                var root = enqueueConcurrentRenderForLane(nearestMounted, lane);
                null !== root && scheduleUpdateOnFiber(root, nearestMounted, lane);
                markRetryLaneIfNotHydrated(nearestMounted, lane);
              }
            });
            return;
          }
        } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
          queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
          return;
        }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return !1;
      for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length;) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn),
            event = nativeEventClone;
          null !== currentReplayingEvent && console.error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
          currentReplayingEvent = event;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          null === currentReplayingEvent && console.error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
          currentReplayingEvent = null;
        } else return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, !1;
        targetContainers.shift();
      }
      return !0;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = !1;
      null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
      null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
      null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = !0, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
    }
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function () {
        lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
        for (var i = 0; i < formReplayingQueue.length; i += 3) {
          var form = formReplayingQueue[i],
            submitterOrAction = formReplayingQueue[i + 1],
            formData = formReplayingQueue[i + 2];
          if ("function" !== typeof submitterOrAction) if (null === findInstanceBlockingTarget(submitterOrAction || form)) continue;else break;
          var formInst = getInstanceFromNode(form);
          null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
            pending: !0,
            data: formData,
            method: form.method,
            action: submitterOrAction
          }, Object.freeze(form), startHostTransition(formInst, form, submitterOrAction, formData));
        }
      }));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
        var queuedTarget = queuedExplicitHydrationTargets[i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn);) attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i) for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
        var form = i[queuedTarget],
          submitterOrAction = i[queuedTarget + 1],
          formProps = form[internalPropsKey] || null;
        if ("function" === typeof submitterOrAction) formProps || scheduleReplayQueueIfNeeded(i);else if (formProps) {
          var action = null;
          if (submitterOrAction && submitterOrAction.hasAttribute("formAction")) {
            if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null) action = formProps.formAction;else {
              if (null !== findInstanceBlockingTarget(form)) continue;
            }
          } else action = formProps.action;
          "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
          scheduleReplayQueueIfNeeded(i);
        }
      }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function warnIfReactDOMContainerInDEV(container) {
      container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : console.error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Scheduler = require(_dependencyMap[0], "scheduler"),
      React = require(_dependencyMap[1], "react"),
      ReactDOM = require(_dependencyMap[2], "react-dom"),
      assign = Object.assign,
      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
      REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    Symbol.for("react.view_transition");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      isArrayImpl = Array.isArray,
      ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      NotPending = Object.freeze({
        pending: !1,
        data: null,
        method: null,
        action: null
      }),
      valueStack = [];
    var fiberStack = [];
    var index$jscomp$0 = -1,
      contextStackCursor = createCursor(null),
      contextFiberStackCursor = createCursor(null),
      rootInstanceStackCursor = createCursor(null),
      hostTransitionProviderCursor = createCursor(null),
      hasOwnProperty = Object.prototype.hasOwnProperty,
      scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
      cancelCallback$1 = Scheduler.unstable_cancelCallback,
      shouldYield = Scheduler.unstable_shouldYield,
      requestPaint = Scheduler.unstable_requestPaint,
      now$1 = Scheduler.unstable_now,
      getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
      ImmediatePriority = Scheduler.unstable_ImmediatePriority,
      UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
      NormalPriority$1 = Scheduler.unstable_NormalPriority,
      LowPriority = Scheduler.unstable_LowPriority,
      IdlePriority = Scheduler.unstable_IdlePriority,
      log$1 = Scheduler.log,
      unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
      rendererID = null,
      injectedHook = null,
      injectedProfilingHooks = null,
      hasLoggedError = !1,
      isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__,
      clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
      log = Math.log,
      LN2 = Math.LN2,
      nextTransitionLane = 256,
      nextRetryLane = 4194304,
      DiscreteEventPriority = 2,
      ContinuousEventPriority = 8,
      DefaultEventPriority = 32,
      IdleEventPriority = 268435456,
      randomKey = Math.random().toString(36).slice(2),
      internalInstanceKey = "__reactFiber$" + randomKey,
      internalPropsKey = "__reactProps$" + randomKey,
      internalContainerInstanceKey = "__reactContainer$" + randomKey,
      internalEventHandlersKey = "__reactEvents$" + randomKey,
      internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
      internalEventHandlesSetKey = "__reactHandles$" + randomKey,
      internalRootNodeResourcesKey = "__reactResources$" + randomKey,
      internalHoistableMarker = "__reactMarker$" + randomKey,
      allNativeEvents = new Set(),
      registrationNameDependencies = {},
      possibleRegistrationNames = {},
      hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      },
      VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
      illegalAttributeNameCache = {},
      validatedAttributeNameCache = {},
      disabledDepth = 0,
      prevLog,
      prevInfo,
      prevWarn,
      prevError,
      prevGroup,
      prevGroupCollapsed,
      prevGroupEnd;
    disabledLog.__reactDisabledLog = !0;
    var prefix,
      suffix,
      reentry = !1;
    var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
    var current = null,
      isRendering = !1,
      escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g,
      didWarnValueDefaultValue$1 = !1,
      didWarnCheckedDefaultChecked = !1,
      didWarnSelectedSetOnOption = !1,
      didWarnInvalidChild = !1,
      didWarnInvalidInnerHTML = !1;
    var didWarnValueDefaultValue = !1;
    var valuePropNames = ["value", "defaultValue"],
      didWarnValDefaultVal = !1,
      needsEscaping = /["'&<>\n\t]|^\s|\s$/,
      specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(" "),
      inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(" "),
      buttonScopeTags = inScopeTags.concat(["button"]),
      impliedEndTags = "dd dt li option optgroup p rp rt".split(" "),
      emptyAncestorInfoDev = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null,
        containerTagInScope: null,
        implicitRootScope: !1
      },
      didWarn = {},
      shorthandToLonghand = {
        animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(" "),
        background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(" "),
        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
        border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(" "),
        borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
        borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
        borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
        borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
        borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
        borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
        borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
        borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
        borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
        borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
        columns: ["columnCount", "columnWidth"],
        flex: ["flexBasis", "flexGrow", "flexShrink"],
        flexFlow: ["flexDirection", "flexWrap"],
        font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(" "),
        fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(" "),
        gap: ["columnGap", "rowGap"],
        grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(" "),
        gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
        gridColumn: ["gridColumnEnd", "gridColumnStart"],
        gridColumnGap: ["columnGap"],
        gridGap: ["columnGap", "rowGap"],
        gridRow: ["gridRowEnd", "gridRowStart"],
        gridRowGap: ["rowGap"],
        gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
        marker: ["markerEnd", "markerMid", "markerStart"],
        mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(" "),
        maskPosition: ["maskPositionX", "maskPositionY"],
        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
        overflow: ["overflowX", "overflowY"],
        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
        placeContent: ["alignContent", "justifyContent"],
        placeItems: ["alignItems", "justifyItems"],
        placeSelf: ["alignSelf", "justifySelf"],
        textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
        transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
        wordWrap: ["overflowWrap"]
      },
      uppercasePattern = /([A-Z])/g,
      msPattern$1 = /^ms-/,
      badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,
      msPattern = /^-ms-/,
      hyphenPattern = /-(.)/g,
      badStyleValueWithSemicolonPattern = /;\s*$/,
      warnedStyleNames = {},
      warnedStyleValues = {},
      warnedForNaNValue = !1,
      warnedForInfinityValue = !1,
      unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")),
      MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML",
      SVG_NAMESPACE = "http://www.w3.org/2000/svg",
      aliases = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]),
      possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        fetchpriority: "fetchPriority",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        inert: "inert",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        popover: "popover",
        popovertarget: "popoverTarget",
        popovertargetaction: "popoverTargetAction",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        transformorigin: "transformOrigin",
        "transform-origin": "transformOrigin",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      },
      ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      },
      warnedProperties$1 = {},
      rARIA$1 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
      rARIACamel$1 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
      didWarnValueNull = !1,
      warnedProperties = {},
      EVENT_NAME_REGEX = /^on./,
      INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,
      rARIA = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
      rARIACamel = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
      isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i,
      currentReplayingEvent = null,
      restoreTarget = null,
      restoreQueue = null,
      isInsideEventHandler = !1,
      canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
      passiveBrowserEventsSupported = !1;
    if (canUseDOM) try {
      var options$jscomp$0 = {};
      Object.defineProperty(options$jscomp$0, "passive", {
        get: function () {
          passiveBrowserEventsSupported = !0;
        }
      });
      window.addEventListener("test", options$jscomp$0, options$jscomp$0);
      window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
    } catch (e) {
      passiveBrowserEventsSupported = !1;
    }
    var root = null,
      startText = null,
      fallbackText = null,
      EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function (event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      },
      SyntheticEvent = createSyntheticEvent(EventInterface),
      UIEventInterface = assign({}, EventInterface, {
        view: 0,
        detail: 0
      }),
      SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
      lastMovementX,
      lastMovementY,
      lastMouseEvent,
      MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function (event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function (event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function (event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      }),
      SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
      DragEventInterface = assign({}, MouseEventInterface, {
        dataTransfer: 0
      }),
      SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
      FocusEventInterface = assign({}, UIEventInterface, {
        relatedTarget: 0
      }),
      SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
      AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }),
      SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
      ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function (event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      }),
      SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
      CompositionEventInterface = assign({}, EventInterface, {
        data: 0
      }),
      SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
      SyntheticInputEvent = SyntheticCompositionEvent,
      normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      },
      translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      },
      modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      },
      KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function (nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function (event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function (event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function (event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      }),
      SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
      PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }),
      SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
      TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      }),
      SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
      TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }),
      SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
      WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function (event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function (event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }),
      SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
      ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      }),
      SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
      END_KEYCODES = [9, 13, 27, 32],
      START_KEYCODE = 229,
      canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
      documentMode = null;
    canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
      useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode),
      SPACEBAR_CODE = 32,
      SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE),
      hasSpaceKeypress = !1,
      isComposing = !1,
      supportedInputTypes = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
      },
      activeElement$1 = null,
      activeElementInst$1 = null,
      isInputEventSupported = !1;
    canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
    var objectIs = "function" === typeof Object.is ? Object.is : is,
      skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode,
      activeElement = null,
      activeElementInst = null,
      lastSelection = null,
      mouseDown = !1,
      vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      },
      prefixedEventNames = {},
      style = {};
    canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
    var ANIMATION_END = getVendorPrefixedEventName("animationend"),
      ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
      ANIMATION_START = getVendorPrefixedEventName("animationstart"),
      TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
      TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
      TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
      TRANSITION_END = getVendorPrefixedEventName("transitionend"),
      topLevelEventsToReactNames = new Map(),
      simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    simpleEventPluginEvents.push("scrollEnd");
    var CapturedStacks = new WeakMap(),
      OffscreenVisible = 1,
      OffscreenPassiveEffectsConnected = 2,
      concurrentQueues = [],
      concurrentQueuesIndex = 0,
      concurrentlyUpdatedLanes = 0,
      emptyContextObject = {};
    Object.freeze(emptyContextObject);
    var resolveFamily = null,
      failedBoundaries = null,
      NoMode = 0,
      ConcurrentMode = 1,
      ProfileMode = 2,
      StrictLegacyMode = 8,
      StrictEffectsMode = 16,
      NoStrictPassiveEffectsMode = 64;
    var hasBadMapPolyfill = !1;
    try {
      var nonExtensibleObject = Object.preventExtensions({});
      new Map([[nonExtensibleObject, null]]);
      new Set([nonExtensibleObject]);
    } catch (e$3) {
      hasBadMapPolyfill = !0;
    }
    var forkStack = [],
      forkStackIndex = 0,
      treeForkProvider = null,
      treeForkCount = 0,
      idStack = [],
      idStackIndex = 0,
      treeContextProvider = null,
      treeContextId = 1,
      treeContextOverflow = "",
      hydrationParentFiber = null,
      nextHydratableInstance = null,
      isHydrating = !1,
      didSuspendOrErrorDEV = !1,
      hydrationDiffRootDEV = null,
      hydrationErrors = null,
      rootOrSingletonContext = !1,
      HydrationMismatchException = Error("Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."),
      lastResetTime = 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var localPerformance = performance;
      var getCurrentTime = function () {
        return localPerformance.now();
      };
    } else {
      var localDate = Date;
      getCurrentTime = function () {
        return localDate.now();
      };
    }
    var valueCursor = createCursor(null);
    var rendererCursorDEV = createCursor(null);
    var rendererSigil = {};
    var currentlyRenderingFiber$1 = null,
      lastContextDependency = null,
      isDisallowedContextReadInDEV = !1,
      AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function () {
        var listeners = [],
          signal = this.signal = {
            aborted: !1,
            addEventListener: function (type, listener) {
              listeners.push(listener);
            }
          };
        this.abort = function () {
          signal.aborted = !0;
          listeners.forEach(function (listener) {
            return listener();
          });
        };
      },
      scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
      NormalPriority = Scheduler.unstable_NormalPriority,
      CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
        _currentRenderer: null,
        _currentRenderer2: null
      },
      now = Scheduler.unstable_now,
      renderStartTime = -0,
      commitStartTime = -0,
      profilerStartTime = -1.1,
      profilerEffectDuration = -0,
      currentUpdateIsNested = !1,
      nestedUpdateScheduled = !1,
      currentEntangledListeners = null,
      currentEntangledPendingCount = 0,
      currentEntangledLane = 0,
      currentEntangledActionThenable = null,
      prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function (transition, returnValue) {
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null),
      ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function () {},
        flushPendingUnsafeLifecycleWarnings: function () {},
        recordLegacyContextWarning: function () {},
        flushLegacyContextWarning: function () {},
        discardPendingWarnings: function () {}
      },
      pendingComponentWillMountWarnings = [],
      pendingUNSAFE_ComponentWillMountWarnings = [],
      pendingComponentWillReceivePropsWarnings = [],
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [],
      pendingComponentWillUpdateWarnings = [],
      pendingUNSAFE_ComponentWillUpdateWarnings = [],
      didWarnAboutUnsafeLifecycles = new Set();
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
      didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
      var componentWillMountUniqueNames = new Set();
      0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function (fiber) {
        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillMountWarnings = []);
      var UNSAFE_componentWillMountUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillMountWarnings = []);
      var componentWillReceivePropsUniqueNames = new Set();
      0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillReceivePropsWarnings = []);
      var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {
        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
      var componentWillUpdateUniqueNames = new Set();
      0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function (fiber) {
        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillUpdateWarnings = []);
      var UNSAFE_componentWillUpdateUniqueNames = new Set();
      0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
      if (0 < UNSAFE_componentWillMountUniqueNames.size) {
        var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
        console.error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
      }
      0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s", sortedNames));
      0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", sortedNames));
      0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn("componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
      0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
      0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn("componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
    };
    var pendingLegacyContextWarning = new Map(),
      didWarnAboutLegacyContext = new Set();
    ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
      var strictRoot = null;
      for (var node = fiber; null !== node;) node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
      null === strictRoot ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function () {
      pendingLegacyContextWarning.forEach(function (fiberArray) {
        if (0 !== fiberArray.length) {
          var firstFiber = fiberArray[0],
            uniqueNames = new Set();
          fiberArray.forEach(function (fiber) {
            uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutLegacyContext.add(fiber.type);
          });
          var sortedNames = setToSortedString(uniqueNames);
          runWithFiberInDEV(firstFiber, function () {
            console.error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context", sortedNames);
          });
        }
      });
    };
    ReactStrictModeWarnings.discardPendingWarnings = function () {
      pendingComponentWillMountWarnings = [];
      pendingUNSAFE_ComponentWillMountWarnings = [];
      pendingComponentWillReceivePropsWarnings = [];
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
      pendingComponentWillUpdateWarnings = [];
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
      pendingLegacyContextWarning = new Map();
    };
    var SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."),
      SuspenseyCommitException = Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."),
      SuspenseActionException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."),
      noopSuspenseyCommitThenable = {
        then: function () {
          console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.');
        }
      },
      suspendedThenable = null,
      needsToResetSuspendedThenableDEV = !1,
      NoFlags = 0,
      HasEffect = 1,
      Insertion = 2,
      Layout = 4,
      Passive = 8,
      UpdateState = 0,
      ReplaceState = 1,
      ForceUpdate = 2,
      CaptureUpdate = 3,
      hasForceUpdate = !1;
    var didWarnUpdateInsideUpdate = !1;
    var currentlyProcessingQueue = null;
    var didReadFromEntangledAsyncAction = !1,
      currentTreeHiddenStackCursor = createCursor(null),
      prevEntangledRenderLanesCursor = createCursor(0),
      didWarnUncachedGetSnapshot;
    var didWarnAboutMismatchedHooksForComponent = new Set();
    var didWarnAboutUseWrappedInTryCatch = new Set();
    var didWarnAboutAsyncClientComponent = new Set();
    var didWarnAboutUseFormState = new Set();
    var renderLanes = 0,
      currentlyRenderingFiber = null,
      currentHook = null,
      workInProgressHook = null,
      didScheduleRenderPhaseUpdate = !1,
      didScheduleRenderPhaseUpdateDuringThisPass = !1,
      shouldDoubleInvokeUserFnsInHooksDEV = !1,
      localIdCounter = 0,
      thenableIndexCounter$1 = 0,
      thenableState$1 = null,
      globalClientIdCounter = 0,
      RE_RENDER_LIMIT = 25,
      currentHookNameInDev = null,
      hookTypesDev = null,
      hookTypesUpdateIndexDev = -1,
      ignorePreviousDependencies = !1,
      ContextOnlyDispatcher = {
        readContext: readContext,
        use: use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      },
      HooksDispatcherOnMountInDEV = null,
      HooksDispatcherOnMountWithHookTypesInDEV = null,
      HooksDispatcherOnUpdateInDEV = null,
      HooksDispatcherOnRerenderInDEV = null,
      InvalidNestedHooksDispatcherOnMountInDEV = null,
      InvalidNestedHooksDispatcherOnUpdateInDEV = null,
      InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    HooksDispatcherOnMountInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(createDeps);
        return mountEffect(create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        mountHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function (action, initialState) {
        currentHookNameInDev = "useFormState";
        mountHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useActionState: function (action, initialState) {
        currentHookNameInDev = "useActionState";
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function (passthrough) {
        currentHookNameInDev = "useOptimistic";
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      }
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        return mountEffect(create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return mountId();
      },
      useActionState: function (action, initialState) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return mountActionState(action, initialState);
      },
      useFormState: function (action, initialState) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function (passthrough) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return mountRefresh();
      }
    };
    HooksDispatcherOnUpdateInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return updateActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    HooksDispatcherOnRerenderInDEV = {
      readContext: function (context) {
        return readContext(context);
      },
      use: use,
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return rerenderActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEffect(create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function (initialValue) {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function (initialState) {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function (action, initialState) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useActionState: function (action, initialState) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function (passthrough) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      }
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
      readContext: function (context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function (usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function (callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function (context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function (create, createDeps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, createDeps);
      },
      useImperativeHandle: function (ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function (create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function (create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function (reducer, initialArg, init) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function () {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function () {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function () {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function (value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function () {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function () {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function (action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useActionState: function (action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function (passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useMemoCache: function (size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useCacheRefresh: function () {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      }
    };
    var callComponent = {
        "react-stack-bottom-frame": function (Component, props, secondArg) {
          var wasRendering = isRendering;
          isRendering = !0;
          try {
            return Component(props, secondArg);
          } finally {
            isRendering = wasRendering;
          }
        }
      },
      callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent),
      callRender = {
        "react-stack-bottom-frame": function (instance) {
          var wasRendering = isRendering;
          isRendering = !0;
          try {
            return instance.render();
          } finally {
            isRendering = wasRendering;
          }
        }
      },
      callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender),
      callComponentDidMount = {
        "react-stack-bottom-frame": function (finishedWork, instance) {
          try {
            instance.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      },
      callComponentDidMountInDEV = callComponentDidMount["react-stack-bottom-frame"].bind(callComponentDidMount),
      callComponentDidUpdate = {
        "react-stack-bottom-frame": function (finishedWork, instance, prevProps, prevState, snapshot) {
          try {
            instance.componentDidUpdate(prevProps, prevState, snapshot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      },
      callComponentDidUpdateInDEV = callComponentDidUpdate["react-stack-bottom-frame"].bind(callComponentDidUpdate),
      callComponentDidCatch = {
        "react-stack-bottom-frame": function (instance, errorInfo) {
          var stack = errorInfo.stack;
          instance.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        }
      },
      callComponentDidCatchInDEV = callComponentDidCatch["react-stack-bottom-frame"].bind(callComponentDidCatch),
      callComponentWillUnmount = {
        "react-stack-bottom-frame": function (current, nearestMountedAncestor, instance) {
          try {
            instance.componentWillUnmount();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
      },
      callComponentWillUnmountInDEV = callComponentWillUnmount["react-stack-bottom-frame"].bind(callComponentWillUnmount),
      callCreate = {
        "react-stack-bottom-frame": function (effect) {
          null != effect.resourceKind && console.error("Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s", effect.resourceKind);
          var create = effect.create;
          effect = effect.inst;
          create = create();
          return effect.destroy = create;
        }
      },
      callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate),
      callDestroy = {
        "react-stack-bottom-frame": function (current, nearestMountedAncestor, destroy) {
          try {
            destroy();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          }
        }
      },
      callDestroyInDEV = callDestroy["react-stack-bottom-frame"].bind(callDestroy),
      callLazyInit = {
        "react-stack-bottom-frame": function (lazy) {
          var init = lazy._init;
          return init(lazy._payload);
        }
      },
      callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit),
      thenableState = null,
      thenableIndexCounter = 0,
      currentDebugInfo = null,
      didWarnAboutMaps;
    var didWarnAboutGenerators = didWarnAboutMaps = !1;
    var ownerHasKeyUseWarning = {};
    var ownerHasFunctionTypeWarning = {};
    var ownerHasSymbolTypeWarning = {};
    warnForMissingKey = function (returnFiber, workInProgress, child) {
      if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
        if ("object" !== typeof child._store) throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        child._store.validated = 1;
        var componentName = getComponentNameFromFiber(returnFiber),
          componentKey = componentName || "null";
        if (!ownerHasKeyUseWarning[componentKey]) {
          ownerHasKeyUseWarning[componentKey] = !0;
          child = child._owner;
          returnFiber = returnFiber._debugOwner;
          var currentComponentErrorInfo = "";
          returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
          currentComponentErrorInfo || componentName && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName + ">.");
          var childOwnerAppendix = "";
          null != child && returnFiber !== child && (componentName = null, "number" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = " It was passed a child from " + componentName + "."));
          runWithFiberInDEV(workInProgress, function () {
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);
          });
        }
      }
    };
    var reconcileChildFibers = createChildReconciler(!0),
      mountChildFibers = createChildReconciler(!1),
      suspenseHandlerStackCursor = createCursor(null),
      shellBoundary = null,
      SubtreeSuspenseContextMask = 1,
      ForceSuspenseFallback = 2,
      suspenseStackCursor = createCursor(0),
      fakeInternalInstance = {};
    var didWarnAboutStateAssignmentForComponent = new Set();
    var didWarnAboutUninitializedState = new Set();
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
    var didWarnAboutDirectlyAssigningPropsToState = new Set();
    var didWarnAboutUndefinedDerivedState = new Set();
    var didWarnAboutContextTypes$1 = new Set();
    var didWarnAboutChildContextTypes = new Set();
    var didWarnAboutInvalidateContextType = new Set();
    var didWarnOnInvalidCallback = new Set();
    Object.freeze(fakeInternalInstance);
    var classComponentUpdater = {
        enqueueSetState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          markStateUpdateScheduled(inst, lane);
        },
        enqueueReplaceState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.tag = ReplaceState;
          update.payload = payload;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
          markStateUpdateScheduled(inst, lane);
        },
        enqueueForceUpdate: function (inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(inst),
            update = createUpdate(lane);
          update.tag = ForceUpdate;
          void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
        }
      },
      reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error: error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      },
      componentName = null,
      errorBoundaryName = null,
      SelectiveHydrationException = Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."),
      didReceiveUpdate = !1;
    var didWarnAboutBadClass = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutContextTypes = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = !1;
    var didWarnAboutRevealOrder = {};
    var didWarnAboutTailOptions = {};
    var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      },
      hasWarnedAboutUsingNoValuePropOnContextProvider = !1,
      didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
    var offscreenSubtreeIsHidden = !1,
      offscreenSubtreeWasHidden = !1,
      needsFormReset = !1,
      PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
      nextEffect = null,
      inProgressLanes = null,
      inProgressRoot = null,
      hostParent = null,
      hostParentIsContainer = !1,
      currentHoistableRoot = null,
      suspenseyCommitFlag = 8192,
      DefaultAsyncDispatcher = {
        getCacheForType: function (resourceType) {
          var cache = readContext(CacheContext),
            cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        },
        getOwner: function () {
          return current;
        }
      };
    if ("function" === typeof Symbol && Symbol.for) {
      var symbolFor = Symbol.for;
      symbolFor("selector.component");
      symbolFor("selector.has_pseudo_class");
      symbolFor("selector.role");
      symbolFor("selector.test_id");
      symbolFor("selector.text");
    }
    var commitHooks = [],
      PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
      NoContext = 0,
      RenderContext = 2,
      CommitContext = 4,
      RootInProgress = 0,
      RootFatalErrored = 1,
      RootErrored = 2,
      RootSuspended = 3,
      RootSuspendedWithDelay = 4,
      RootSuspendedAtTheShell = 6,
      RootCompleted = 5,
      executionContext = NoContext,
      workInProgressRoot = null,
      workInProgress = null,
      workInProgressRootRenderLanes = 0,
      NotSuspended = 0,
      SuspendedOnError = 1,
      SuspendedOnData = 2,
      SuspendedOnImmediate = 3,
      SuspendedOnInstance = 4,
      SuspendedOnInstanceAndReadyToContinue = 5,
      SuspendedOnDeprecatedThrowPromise = 6,
      SuspendedAndReadyToContinue = 7,
      SuspendedOnHydration = 8,
      SuspendedOnAction = 9,
      workInProgressSuspendedReason = NotSuspended,
      workInProgressThrownValue = null,
      workInProgressRootDidSkipSuspendedSiblings = !1,
      workInProgressRootIsPrerendering = !1,
      workInProgressRootDidAttachPingListener = !1,
      entangledRenderLanes = 0,
      workInProgressRootExitStatus = RootInProgress,
      workInProgressRootSkippedLanes = 0,
      workInProgressRootInterleavedUpdatedLanes = 0,
      workInProgressRootPingedLanes = 0,
      workInProgressDeferredLane = 0,
      workInProgressSuspendedRetryLanes = 0,
      workInProgressRootConcurrentErrors = null,
      workInProgressRootRecoverableErrors = null,
      workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
      globalMostRecentFallbackTime = 0,
      FALLBACK_THROTTLE_MS = 300,
      workInProgressRootRenderTargetTime = Infinity,
      RENDER_TIMEOUT_MS = 500,
      workInProgressTransitions = null,
      legacyErrorBoundariesThatAlreadyFailed = null,
      IMMEDIATE_COMMIT = 0,
      SUSPENDED_COMMIT = 1,
      THROTTLED_COMMIT = 2,
      NO_PENDING_EFFECTS = 0,
      PENDING_MUTATION_PHASE = 1,
      PENDING_LAYOUT_PHASE = 2,
      PENDING_AFTER_MUTATION_PHASE = 3,
      PENDING_SPAWNED_WORK = 4,
      PENDING_PASSIVE_PHASE = 5,
      pendingEffectsStatus = 0,
      pendingEffectsRoot = null,
      pendingFinishedWork = null,
      pendingEffectsLanes = 0,
      pendingEffectsRemainingLanes = 0,
      pendingPassiveTransitions = null,
      pendingRecoverableErrors = null,
      NESTED_UPDATE_LIMIT = 50,
      nestedUpdateCount = 0,
      rootWithNestedUpdates = null,
      isFlushingPassiveEffects = !1,
      didScheduleUpdateDuringPassiveEffects = !1,
      NESTED_PASSIVE_UPDATE_LIMIT = 50,
      nestedPassiveUpdateCount = 0,
      rootWithPassiveNestedUpdates = null,
      isRunningInsertionEffect = !1,
      didWarnStateUpdateForNotYetMountedComponent = null,
      didWarnAboutUpdateInRender = !1;
    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();
    var fakeActCallbackNode$1 = {},
      firstScheduledRoot = null,
      lastScheduledRoot = null,
      didScheduleMicrotask = !1,
      didScheduleMicrotask_act = !1,
      mightHavePendingSyncWork = !1,
      isFlushingWork = !1,
      currentEventTransitionLane = 0,
      fakeActCallbackNode = {};
    (function () {
      for (var i = 0; i < simpleEventPluginEvents.length; i++) {
        var eventName = simpleEventPluginEvents[i],
          domEventName = eventName.toLowerCase();
        eventName = eventName[0].toUpperCase() + eventName.slice(1);
        registerSimpleEvent(domEventName, "on" + eventName);
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    })();
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
      nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)),
      listeningMarker = "_reactListening" + Math.random().toString(36).slice(2),
      didWarnControlledToUncontrolled = !1,
      didWarnUncontrolledToControlled = !1,
      didWarnFormActionType = !1,
      didWarnFormActionName = !1,
      didWarnFormActionTarget = !1,
      didWarnFormActionMethod = !1,
      didWarnPopoverTargetObject = !1;
    var didWarnForNewBooleanPropsWithEmptyValue = {};
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
      NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g,
      xlinkNamespace = "http://www.w3.org/1999/xlink",
      xmlNamespace = "http://www.w3.org/XML/1998/namespace",
      EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')",
      SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning",
      SUSPENSE_START_DATA = "$",
      SUSPENSE_END_DATA = "/$",
      SUSPENSE_PENDING_START_DATA = "$?",
      SUSPENSE_FALLBACK_START_DATA = "$!",
      PREAMBLE_CONTRIBUTION_HTML = 1,
      PREAMBLE_CONTRIBUTION_BODY = 2,
      PREAMBLE_CONTRIBUTION_HEAD = 4,
      FORM_STATE_IS_MATCHING = "F!",
      FORM_STATE_IS_NOT_MATCHING = "F",
      DOCUMENT_READY_STATE_COMPLETE = "complete",
      STYLE = "style",
      HostContextNamespaceNone = 0,
      HostContextNamespaceSvg = 1,
      HostContextNamespaceMath = 2,
      eventsEnabled = null,
      selectionInformation = null,
      warnedUnknownTags = {
        dialog: !0,
        webview: !0
      },
      currentPopstateTransitionEvent = null,
      scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
      cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
      noTimeout = -1,
      localPromise = "function" === typeof Promise ? Promise : void 0,
      scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function (callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout,
      previousHydratableOnEnteringScopedSingleton = null,
      NotLoaded = 0,
      Loaded = 1,
      Errored = 2,
      Settled = 3,
      Inserted = 4,
      preloadPropsMap = new Map(),
      preconnectsSet = new Set(),
      previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: function () {
        var previousWasRendering = previousDispatcher.f(),
          wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      },
      r: function (form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      },
      D: function (href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      },
      C: function (href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      },
      L: function (href, as, options) {
        previousDispatcher.L(href, as, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign({
            rel: "preload",
            href: "image" === as && options && options.imageSrcSet ? void 0 : href,
            as: as
          }, options), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      },
      m: function (href, options) {
        previousDispatcher.m(href, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options && "string" === typeof options.as ? options.as : "script",
            preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]',
            key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({
            rel: "modulepreload",
            href: href
          }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key))) return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      },
      X: function (src, options) {
        previousDispatcher.X(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
            src: src,
            async: !0
          }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      },
      S: function (href, precedence, options) {
        previousDispatcher.S(href, precedence, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
            key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = {
              loading: NotLoaded,
              preload: null
            };
            if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) state.loading = Loaded | Inserted;else {
              href = assign({
                rel: "stylesheet",
                href: href,
                "data-precedence": precedence
              }, options);
              (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function (resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function () {
                state.loading |= Loaded;
              });
              link.addEventListener("error", function () {
                state.loading |= Errored;
              });
              state.loading |= Inserted;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state: state
            };
            styles.set(key, resource);
          }
        }
      },
      M: function (src, options) {
        previousDispatcher.M(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
            src: src,
            async: !0,
            type: "module"
          }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
    };
    var globalDocument = "undefined" === typeof document ? null : document,
      tagCaches = null,
      suspendedState = null,
      LAST_PRECEDENCE = null,
      precedencesByRoot = null,
      NotPendingTransition = NotPending,
      HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: NotPendingTransition,
        _currentValue2: NotPendingTransition,
        _threadCount: 0
      },
      badgeFormat = "%c%s%c ",
      badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
      resetStyle = "",
      pad = " ",
      bind = Function.prototype.bind;
    var didWarnAboutNestedUpdates = !1;
    var overrideHookState = null,
      overrideHookStateDeletePath = null,
      overrideHookStateRenamePath = null,
      overrideProps = null,
      overridePropsDeletePath = null,
      overridePropsRenamePath = null,
      scheduleUpdate = null,
      setErrorHandler = null,
      setSuspenseHandler = null;
    overrideHookState = function (fiber, id, path, value) {
      id = findHook(fiber, id);
      null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateDeletePath = function (fiber, id, path) {
      id = findHook(fiber, id);
      null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
      id = findHook(fiber, id);
      null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
    };
    overrideProps = function (fiber, path, value) {
      fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsDeletePath = function (fiber, path) {
      fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      null !== path && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsRenamePath = function (fiber, oldPath, newPath) {
      fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      oldPath = enqueueConcurrentRenderForLane(fiber, 2);
      null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
    };
    scheduleUpdate = function (fiber) {
      var root = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root && scheduleUpdateOnFiber(root, fiber, 2);
    };
    setErrorHandler = function (newShouldErrorImpl) {
      shouldErrorImpl = newShouldErrorImpl;
    };
    setSuspenseHandler = function (newShouldSuspendImpl) {
      shouldSuspendImpl = newShouldSuspendImpl;
    };
    var _enabled = !0,
      return_targetInst = null,
      hasScheduledReplayAttempt = !1,
      queuedFocus = null,
      queuedDrag = null,
      queuedMouse = null,
      queuedPointers = new Map(),
      queuedPointerCaptures = new Map(),
      queuedExplicitHydrationTargets = [],
      discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "),
      lastScheduledReplayQueue = null;
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function (children) {
      var root = this._internalRoot;
      if (null === root) throw Error("Cannot update an unmounted root.");
      var args = arguments;
      "function" === typeof args[1] ? console.error("does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : isValidContainer(args[1]) ? console.error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : "undefined" !== typeof args[1] && console.error("You passed a second argument to root.render(...) but it only accepts one argument.");
      args = children;
      var current = root.current,
        lane = requestUpdateLane(current);
      updateContainerImpl(current, lane, args, root, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function () {
      var args = arguments;
      "function" === typeof args[0] && console.error("does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      args = this._internalRoot;
      if (null !== args) {
        this._internalRoot = null;
        var container = args.containerInfo;
        (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
        updateContainerImpl(args.current, 2, null, args, null, null);
        flushSyncWork$1();
        container[internalContainerInstanceKey] = null;
      }
    };
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = {
          blockedOn: null,
          target: target,
          priority: updatePriority
        };
        for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++);
        queuedExplicitHydrationTargets.splice(i, 0, target);
        0 === i && attemptExplicitHydrationTarget(target);
      }
    };
    (function () {
      var isomorphicReactPackageVersion = React.version;
      if ("19.1.0" !== isomorphicReactPackageVersion) throw Error('Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.1.0\nLearn more: https://react.dev/warnings/version-mismatch"));
    })();
    "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills");
    ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render) throw Error("Unable to find node on an unmounted component.");
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error("Argument appears to not be a ReactComponent. Keys: " + componentOrElement);
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
      componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    if (!function () {
      var internals = {
        bundleType: 1,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.1.0"
      };
      internals.overrideHookState = overrideHookState;
      internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
      internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
      internals.overrideProps = overrideProps;
      internals.overridePropsDeletePath = overridePropsDeletePath;
      internals.overridePropsRenamePath = overridePropsRenamePath;
      internals.scheduleUpdate = scheduleUpdate;
      internals.setErrorHandler = setErrorHandler;
      internals.setSuspenseHandler = setSuspenseHandler;
      internals.scheduleRefresh = scheduleRefresh;
      internals.scheduleRoot = scheduleRoot;
      internals.setRefreshHandler = setRefreshHandler;
      internals.getCurrentFiber = getCurrentFiberForDevTools;
      internals.getLaneLabelMap = getLaneLabelMap;
      internals.injectProfilingHooks = injectProfilingHooks;
      return injectInternals(internals);
    }() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
      var protocol = window.location.protocol;
      /^(https?|file):$/.test(protocol) && console.info("%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""), "font-weight:bold");
    }
    exports.createRoot = function (container, options) {
      if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      var isStrictMode = !1,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError,
        transitionCallbacks = null;
      null !== options && void 0 !== options && (options.hydrate ? console.warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"), !0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
      options = createFiberRoot(container, 1, !1, null, null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);
      container[internalContainerInstanceKey] = options.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options);
    };
    exports.hydrateRoot = function (container, initialChildren, options) {
      if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      void 0 === initialChildren && console.error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var isStrictMode = !1,
        identifierPrefix = "",
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError,
        transitionCallbacks = null,
        formState = null;
      null !== options && void 0 !== options && (!0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
      initialChildren = createFiberRoot(container, 1, !0, initialChildren, null != options ? options : null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);
      initialChildren.context = getContextForSubtree(null);
      options = initialChildren.current;
      isStrictMode = requestUpdateLane(options);
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options, identifierPrefix, isStrictMode);
      options = isStrictMode;
      initialChildren.current.lanes = options;
      markRootUpdated$1(initialChildren, options);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    exports.version = "19.1.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
},28,[29,9,31],"node_modules/react-dom/cjs/react-dom-client.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/scheduler.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/scheduler.development.js");
  }
},29,[10,30],"node_modules/scheduler/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function performWorkUntilDeadline() {
      needsPaint = !1;
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = !0;
        try {
          a: {
            isHostCallbackScheduled = !1;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = !0;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                    currentTime = exports.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = !0;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = !0;else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                  hasMoreWork = !1;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1;
        }
      }
    }
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a: for (; 0 < index;) {
        var parentIndex = index - 1 >>> 1,
          parent = heap[parentIndex];
        if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0],
        last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;) {
          var leftIndex = 2 * (index + 1) - 1,
            left = heap[leftIndex],
            rightIndex = leftIndex + 1,
            right = heap[rightIndex];
          if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;else break a;
        }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return 0 !== diff ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer;) {
        if (null === timer.callback) pop(timerQueue);else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = !1;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = !0, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());else {
        var firstTimer = peek(timerQueue);
        null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
    }
    function shouldYieldToHost() {
      return needsPaint ? !0 : exports.unstable_now() - startTime < frameInterval ? !1 : !0;
    }
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function () {
        callback(exports.unstable_now());
      }, ms);
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var localPerformance = performance;
      exports.unstable_now = function () {
        return localPerformance.now();
      };
    } else {
      var localDate = Date,
        initialTime = localDate.now();
      exports.unstable_now = function () {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [],
      timerQueue = [],
      taskIdCounter = 1,
      currentTask = null,
      currentPriorityLevel = 3,
      isPerformingWork = !1,
      isHostCallbackScheduled = !1,
      isHostTimeoutScheduled = !1,
      needsPaint = !1,
      localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
      localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
      localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null,
      isMessageLoopRunning = !1,
      taskTimeoutID = -1,
      frameInterval = 5,
      startTime = -1;
    if ("function" === typeof localSetImmediate) var schedulePerformWorkUntilDeadline = function () {
      localSetImmediate(performWorkUntilDeadline);
    };else if ("undefined" !== typeof MessageChannel) {
      var channel = new MessageChannel(),
        port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function () {
        port.postMessage(null);
      };
    } else schedulePerformWorkUntilDeadline = function () {
      localSetTimeout(performWorkUntilDeadline, 0);
    };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function (task) {
      task.callback = null;
    };
    exports.unstable_forceFrameRate = function (fps) {
      0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function () {
      return currentPriorityLevel;
    };
    exports.unstable_next = function (eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_requestPaint = function () {
      needsPaint = !0;
    };
    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function (priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback: callback,
        priorityLevel: priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function (callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function () {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
},30,[],"node_modules/scheduler/cjs/scheduler.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
      return;
    }
    if (process.env.NODE_ENV !== 'production') {
      // This branch is unreachable because this function is only called
      // in production, but the condition is true only in development.
      // Therefore if the branch is still here, dead code elimination wasn't
      // properly applied.
      // Don't change the message. React DevTools relies on it. Also make sure
      // this message doesn't occur elsewhere in this function, or it will cause
      // a false positive.
      throw new Error('^_^');
    }
    try {
      // Verify that the code above has been dead code eliminated (DCE'd).
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      // DevTools shouldn't crash React, no matter what.
      // We should still report in case we break this code.
      console.error(err);
    }
  }
  if (process.env.NODE_ENV === 'production') {
    // DCE check should happen before ReactDOM bundle executes so that
    // DevTools can report bad minification during injection.
    checkDCE();
    module.exports = require(_dependencyMap[0], "./cjs/react-dom.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-dom.development.js");
  }
},31,[10,32],"node_modules/react-dom/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function noop() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      JSCompiler_inline_result && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"), testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children: children,
        containerInfo: containerInfo,
        implementation: implementation
      };
    }
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input) return "use-credentials" === input ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
      return dispatcher;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = require(_dependencyMap[0], "react"),
      Internals = {
        d: {
          f: noop,
          r: function () {
            throw Error("Invalid form element. requestFormReset must be passed a form that was rendered by React.");
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      },
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports.createPortal = function (children, container) {
      var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType) throw Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function (fn) {
      var previousTransition = ReactSharedInternals.T,
        previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
      }
    };
    exports.preconnect = function (href, options) {
      "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error("ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.", getValueDescriptorExpectingEnumForWarning(options)) : null != options && "string" !== typeof options.crossOrigin && console.error("ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.", getValueDescriptorExpectingObjectForWarning(options.crossOrigin)) : console.error("ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    exports.prefetchDNS = function (href) {
      if ("string" !== typeof href || !href) console.error("ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));else if (1 < arguments.length) {
        var options = arguments[1];
        "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options)) : console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options));
      }
      "string" === typeof href && Internals.d.D(href);
    };
    exports.preinit = function (href, options) {
      "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error("ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.", getValueDescriptorExpectingEnumForWarning(options)) : "style" !== options.as && "script" !== options.as && console.error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".', getValueDescriptorExpectingEnumForWarning(options.as)) : console.error("ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      if ("string" === typeof href && options && "string" === typeof options.as) {
        var as = options.as,
          crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
          integrity = "string" === typeof options.integrity ? options.integrity : void 0,
          fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
        "style" === as ? Internals.d.S(href, "string" === typeof options.precedence ? options.precedence : void 0, {
          crossOrigin: crossOrigin,
          integrity: integrity,
          fetchPriority: fetchPriority
        }) : "script" === as && Internals.d.X(href, {
          crossOrigin: crossOrigin,
          integrity: integrity,
          fetchPriority: fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    };
    exports.preinitModule = function (href, options) {
      var encountered = "";
      "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
      if (encountered) console.error("ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s", encountered);else switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
        case "script":
          break;
        default:
          encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error('ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)', encountered, href);
      }
      if ("string" === typeof href) if ("object" === typeof options && null !== options) {
        if (null == options.as || "script" === options.as) encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.M(href, {
          crossOrigin: encountered,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      } else null == options && Internals.d.M(href);
    };
    exports.preload = function (href, options) {
      var encountered = "";
      "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s', encountered);
      if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
        encountered = options.as;
        var crossOrigin = getCrossOriginStringAs(encountered, options.crossOrigin);
        Internals.d.L(href, encountered, {
          crossOrigin: crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
          imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    exports.preloadModule = function (href, options) {
      var encountered = "";
      "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s', encountered);
      "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.m(href, {
        as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
        crossOrigin: encountered,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0
      })) : Internals.d.m(href));
    };
    exports.requestFormReset = function (form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function (fn, a) {
      return fn(a);
    };
    exports.useFormState = function (action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function () {
      return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.1.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
},32,[9],"node_modules/react-dom/cjs/react-dom.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react-jsx-dev-runtime.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-jsx-dev-runtime.development.js");
  }
},33,[10,34],"node_modules/react/jsx-dev-runtime.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-jsx-dev-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_CONTEXT_TYPE:
          return (type.displayName || "Context") + ".Provider";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x) {}
      }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE) return "<>";
      if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
      self = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
        enumerable: !1,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", {
        enumerable: !1,
        value: null
      });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
      var children = config.children;
      if (void 0 !== children) if (isStaticChildren) {
        if (isArrayImpl(children)) {
          for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++) validateChildKeys(children[isStaticChildren]);
          Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
      } else validateChildKeys(children);
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function (k) {
          return "key" !== k;
        });
        isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
      }
      children = null;
      void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config) "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
      return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
      "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = require(_dependencyMap[0], "react"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      isArrayImpl = Array.isArray,
      createTask = console.createTask ? console.createTask : function () {
        return null;
      };
    React = {
      "react-stack-bottom-frame": function (callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function (type, config, maybeKey, isStaticChildren, source, self) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
  }();
},34,[9],"node_modules/react/cjs/react-jsx-dev-runtime.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\ErrorOverlay.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  exports.LogBoxInspectorContainer = LogBoxInspectorContainer;
  exports.LogBoxInspector = LogBoxInspector;
  exports.ErrorOverlayBody = ErrorOverlayBody;
  exports.ErrorOverlayBodyContents = ErrorOverlayBodyContents;
  var _react = require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsScrollView = require(_dependencyMap[1], "react-native-web/dist/exports/ScrollView");
  var ScrollView = _interopDefault(_reactNativeWebDistExportsScrollView);
  var _reactNativeWebDistExportsView = require(_dependencyMap[2], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _DataLogBoxData = require(_dependencyMap[4], "./Data/LogBoxData");
  var LogBoxData = _interopNamespace(_DataLogBoxData);
  var _DataLogContext = require(_dependencyMap[5], "./Data/LogContext");
  var _UILogBoxStyle = require(_dependencyMap[6], "./UI/LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_UILogBoxStyle);
  var _overlayLogBoxInspectorCodeFrame = require(_dependencyMap[7], "./overlay/LogBoxInspectorCodeFrame");
  var _overlayLogBoxInspectorFooter = require(_dependencyMap[8], "./overlay/LogBoxInspectorFooter");
  var _overlayLogBoxInspectorHeader = require(_dependencyMap[9], "./overlay/LogBoxInspectorHeader");
  var _overlayLogBoxInspectorMessageHeader = require(_dependencyMap[10], "./overlay/LogBoxInspectorMessageHeader");
  var _overlayLogBoxInspectorStackFrames = require(_dependencyMap[11], "./overlay/LogBoxInspectorStackFrames");
  var _reactJsxDevRuntime = require(_dependencyMap[12], "react/jsx-dev-runtime");
  const HEADER_TITLE_MAP = {
    warn: 'Console Warning',
    error: 'Console Error',
    fatal: 'Uncaught Error',
    syntax: 'Syntax Error',
    static: 'Server Error',
    component: 'Render Error'
  };
  function LogBoxInspectorContainer() {
    const {
      selectedLogIndex,
      logs
    } = (0, _DataLogContext.useLogs)();
    const log = logs[selectedLogIndex];
    if (log == null) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(LogBoxInspector, {
      log: log,
      selectedLogIndex: selectedLogIndex,
      logs: logs
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 10
    }, this);
  }
  function LogBoxInspector({
    log,
    selectedLogIndex,
    logs
  }) {
    const onDismiss = (0, _react.useCallback)(() => {
      // Here we handle the cases when the log is dismissed and it
      // was either the last log, or when the current index
      // is now outside the bounds of the log array.
      const logsArray = Array.from(logs);
      if (selectedLogIndex != null) {
        if (logsArray.length - 1 <= 0) {
          LogBoxData.setSelectedLog(-1);
        } else if (selectedLogIndex >= logsArray.length - 1) {
          LogBoxData.setSelectedLog(selectedLogIndex - 1);
        }
        LogBoxData.dismiss(logsArray[selectedLogIndex]);
      }
    }, [selectedLogIndex]);
    const onMinimize = (0, _react.useCallback)(() => {
      LogBoxData.setSelectedLog(-1);
    }, []);
    const onChangeSelectedIndex = (0, _react.useCallback)(index => {
      LogBoxData.setSelectedLog(index);
    }, []);
    (0, _react.useEffect)(() => {
      if (log) {
        LogBoxData.symbolicateLogNow('stack', log);
        LogBoxData.symbolicateLogNow('component', log);
      }
    }, [log]);
    (0, _react.useEffect)(() => {
      // Optimistically symbolicate the last and next logs.
      if (logs.length > 1) {
        const selected = selectedLogIndex;
        const lastIndex = logs.length - 1;
        const prevIndex = selected - 1 < 0 ? lastIndex : selected - 1;
        const nextIndex = selected + 1 > lastIndex ? 0 : selected + 1;
        for (const type of ['component', 'stack']) {
          LogBoxData.symbolicateLogLazy(type, logs[prevIndex]);
          LogBoxData.symbolicateLogLazy(type, logs[nextIndex]);
        }
      }
    }, [logs, selectedLogIndex]);
    const _handleRetry = (0, _react.useCallback)(type => {
      LogBoxData.retrySymbolicateLogNow(type, log);
    }, [log]);
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: styles.container,
      children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_overlayLogBoxInspectorHeader.LogBoxInspectorHeader, {
        onSelectIndex: onChangeSelectedIndex,
        level: log.level
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 102,
        columnNumber: 7
      }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ErrorOverlayBody, {
        onRetry: _handleRetry
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 103,
        columnNumber: 7
      }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_overlayLogBoxInspectorFooter.LogBoxInspectorFooter, {
        onDismiss: onDismiss,
        onMinimize: onMinimize
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 104,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 101,
      columnNumber: 5
    }, this);
  }
  function ErrorOverlayBody({
    onRetry
  }) {
    const log = (0, _DataLogContext.useSelectedLog)();
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ErrorOverlayBodyContents, {
      log: log,
      onRetry: onRetry
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 111,
      columnNumber: 10
    }, this);
  }
  function ErrorOverlayBodyContents({
    log,
    onRetry
  }) {
    const [collapsed, setCollapsed] = (0, _react.useState)(true);
    (0, _react.useEffect)(() => {
      setCollapsed(true);
    }, [log]);
    const headerTitle = HEADER_TITLE_MAP[log.isComponentError ? 'component' : log.level] ?? log.type;
    const header = /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_overlayLogBoxInspectorMessageHeader.LogBoxInspectorMessageHeader, {
      collapsed: collapsed,
      onPress: () => setCollapsed(!collapsed),
      message: log.message,
      level: log.level,
      title: headerTitle
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 130,
      columnNumber: 5
    }, this);

    // Hide useless React stack.
    const needsStack = !log.message.content.match(/(Expected server HTML to contain a matching|Text content did not match\.)/);
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_reactJsxDevRuntime.Fragment, {
      children: [collapsed && header, /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ScrollView.default, {
        style: styles.scrollBody,
        children: [!collapsed && header, /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_overlayLogBoxInspectorCodeFrame.LogBoxInspectorCodeFrame, {
          codeFrame: log.codeFrame
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 150,
          columnNumber: 9
        }, this), needsStack && /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_overlayLogBoxInspectorStackFrames.LogBoxInspectorStackFrames, {
          type: "stack"
          // eslint-disable-next-line react/jsx-no-bind
          ,
          onRetry: onRetry.bind(onRetry, 'stack')
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 152,
          columnNumber: 11
        }, this), !!log?.componentStack?.length && /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_overlayLogBoxInspectorStackFrames.LogBoxInspectorStackFrames, {
          type: "component"
          // eslint-disable-next-line react/jsx-no-bind
          ,
          onRetry: onRetry.bind(onRetry, 'component')
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 159,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 147,
        columnNumber: 7
      }, this)]
    }, void 0, true);
  }
  const styles = StyleSheet.default.create({
    scrollBody: {
      backgroundColor: LogBoxStyle.getBackgroundColor(1),
      flex: 1
    },
    container: {
      top: 0,
      left: 0,
      bottom: 0,
      right: 0,
      zIndex: 999,
      flex: 1,
      // @ts-expect-error: fixed is not in the RN types but it works on web
      position: 'fixed'
    }
  });
  var _default = LogBoxData.withSubscription(LogBoxInspectorContainer);
},35,[9,36,110,55,8,21,136,137,153,154,162,164,33],"node_modules/@expo/metro-runtime/src/error-overlay/ErrorOverlay.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersExtends = require(_dependencyMap[1], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _Dimensions = require(_dependencyMap[3], "../Dimensions");
  var Dimensions = _interopDefault(_Dimensions);
  var _modulesDismissKeyboard = require(_dependencyMap[4], "../../modules/dismissKeyboard");
  var dismissKeyboard = _interopDefault(_modulesDismissKeyboard);
  var _fbjsLibInvariant = require(_dependencyMap[5], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _modulesMergeRefs = require(_dependencyMap[6], "../../modules/mergeRefs");
  var mergeRefs = _interopDefault(_modulesMergeRefs);
  var _Platform = require(_dependencyMap[7], "../Platform");
  var Platform = _interopDefault(_Platform);
  var _ScrollViewBase = require(_dependencyMap[8], "./ScrollViewBase");
  var ScrollViewBase = _interopDefault(_ScrollViewBase);
  var _StyleSheet = require(_dependencyMap[9], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _modulesTextInputState = require(_dependencyMap[10], "../../modules/TextInputState");
  var TextInputState = _interopDefault(_modulesTextInputState);
  var _UIManager = require(_dependencyMap[11], "../UIManager");
  var UIManager = _interopDefault(_UIManager);
  var _View = require(_dependencyMap[12], "../View");
  var View = _interopDefault(_View);
  var _react = require(_dependencyMap[13], "react");
  var React = _interopDefault(_react);
  var _fbjsLibWarning = require(_dependencyMap[14], "fbjs/lib/warning");
  var warning = _interopDefault(_fbjsLibWarning);
  var _excluded = ["contentContainerStyle", "horizontal", "onContentSizeChange", "refreshControl", "stickyHeaderIndices", "pagingEnabled", "forwardedRef", "keyboardDismissMode", "onScroll", "centerContent"];
  var emptyObject = {};
  var IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;
  class ScrollView extends React.default.Component {
    constructor() {
      super(...arguments);
      this._scrollNodeRef = null;
      this._innerViewRef = null;
      this.isTouching = false;
      this.lastMomentumScrollBeginTime = 0;
      this.lastMomentumScrollEndTime = 0;
      this.observedScrollSinceBecomingResponder = false;
      this.becameResponderWhileAnimating = false;
      this.scrollResponderHandleScrollShouldSetResponder = () => {
        return this.isTouching;
      };
      this.scrollResponderHandleStartShouldSetResponderCapture = e => {
        // First see if we want to eat taps while the keyboard is up
        // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
        // if (!this.props.keyboardShouldPersistTaps &&
        //   currentlyFocusedTextInput != null &&
        //   e.target !== currentlyFocusedTextInput) {
        //   return true;
        // }
        return this.scrollResponderIsAnimating();
      };
      this.scrollResponderHandleTerminationRequest = () => {
        return !this.observedScrollSinceBecomingResponder;
      };
      this.scrollResponderHandleTouchEnd = e => {
        var nativeEvent = e.nativeEvent;
        this.isTouching = nativeEvent.touches.length !== 0;
        this.props.onTouchEnd && this.props.onTouchEnd(e);
      };
      this.scrollResponderHandleResponderRelease = e => {
        this.props.onResponderRelease && this.props.onResponderRelease(e);

        // By default scroll views will unfocus a textField
        // if another touch occurs outside of it
        var currentlyFocusedTextInput = TextInputState.default.currentlyFocusedField();
        if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.observedScrollSinceBecomingResponder && !this.becameResponderWhileAnimating) {
          this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);
          TextInputState.default.blurTextInput(currentlyFocusedTextInput);
        }
      };
      this.scrollResponderHandleScroll = e => {
        this.observedScrollSinceBecomingResponder = true;
        this.props.onScroll && this.props.onScroll(e);
      };
      this.scrollResponderHandleResponderGrant = e => {
        this.observedScrollSinceBecomingResponder = false;
        this.props.onResponderGrant && this.props.onResponderGrant(e);
        this.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
      };
      this.scrollResponderHandleScrollBeginDrag = e => {
        this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
      };
      this.scrollResponderHandleScrollEndDrag = e => {
        this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
      };
      this.scrollResponderHandleMomentumScrollBegin = e => {
        this.lastMomentumScrollBeginTime = Date.now();
        this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
      };
      this.scrollResponderHandleMomentumScrollEnd = e => {
        this.lastMomentumScrollEndTime = Date.now();
        this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
      };
      this.scrollResponderHandleTouchStart = e => {
        this.isTouching = true;
        this.props.onTouchStart && this.props.onTouchStart(e);
      };
      this.scrollResponderHandleTouchMove = e => {
        this.props.onTouchMove && this.props.onTouchMove(e);
      };
      this.scrollResponderIsAnimating = () => {
        var now = Date.now();
        var timeSinceLastMomentumScrollEnd = now - this.lastMomentumScrollEndTime;
        var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.lastMomentumScrollEndTime < this.lastMomentumScrollBeginTime;
        return isAnimating;
      };
      this.scrollResponderScrollTo = (x, y, animated) => {
        if (typeof x === 'number') {
          console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');
        } else {
          var _ref = x || emptyObject;
          x = _ref.x;
          y = _ref.y;
          animated = _ref.animated;
        }
        var node = this.getScrollableNode();
        var left = x || 0;
        var top = y || 0;
        if (node != null) {
          if (typeof node.scroll === 'function') {
            node.scroll({
              top,
              left,
              behavior: !animated ? 'auto' : 'smooth'
            });
          } else {
            node.scrollLeft = left;
            node.scrollTop = top;
          }
        }
      };
      this.scrollResponderZoomTo = (rect, animated) => {
        if (Platform.default.OS !== 'ios') {
          (0, invariant.default)('zoomToRect is not implemented');
        }
      };
      this.scrollResponderScrollNativeHandleToKeyboard = (nodeHandle, additionalOffset, preventNegativeScrollOffset) => {
        this.additionalScrollOffset = additionalOffset || 0;
        this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;
        UIManager.default.measureLayout(nodeHandle, this.getInnerViewNode(), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);
      };
      this.scrollResponderInputMeasureAndScrollToKeyboard = (left, top, width, height) => {
        var keyboardScreenY = Dimensions.default.get('window').height;
        if (this.keyboardWillOpenTo) {
          keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;
        }
        var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;

        // By default, this can scroll with negative offset, pulling the content
        // down so that the target component's bottom meets the keyboard's top.
        // If requested otherwise, cap the offset at 0 minimum to avoid content
        // shifting down.
        if (this.preventNegativeScrollOffset) {
          scrollOffsetY = Math.max(0, scrollOffsetY);
        }
        this.scrollResponderScrollTo({
          x: 0,
          y: scrollOffsetY,
          animated: true
        });
        this.additionalOffset = 0;
        this.preventNegativeScrollOffset = false;
      };
      this.scrollResponderKeyboardWillShow = e => {
        this.keyboardWillOpenTo = e;
        this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);
      };
      this.scrollResponderKeyboardWillHide = e => {
        this.keyboardWillOpenTo = null;
        this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);
      };
      this.scrollResponderKeyboardDidShow = e => {
        // TODO(7693961): The event for DidShow is not available on iOS yet.
        // Use the one from WillShow and do not assign.
        if (e) {
          this.keyboardWillOpenTo = e;
        }
        this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);
      };
      this.scrollResponderKeyboardDidHide = e => {
        this.keyboardWillOpenTo = null;
        this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);
      };
      this.flashScrollIndicators = () => {
        this.scrollResponderFlashScrollIndicators();
      };
      this.getScrollResponder = () => {
        return this;
      };
      this.getScrollableNode = () => {
        return this._scrollNodeRef;
      };
      this.getInnerViewRef = () => {
        return this._innerViewRef;
      };
      this.getInnerViewNode = () => {
        return this._innerViewRef;
      };
      this.getNativeScrollRef = () => {
        return this._scrollNodeRef;
      };
      this.scrollTo = (y, x, animated) => {
        if (typeof y === 'number') {
          console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.');
        } else {
          var _ref2 = y || emptyObject;
          x = _ref2.x;
          y = _ref2.y;
          animated = _ref2.animated;
        }
        this.scrollResponderScrollTo({
          x: x || 0,
          y: y || 0,
          animated: animated !== false
        });
      };
      this.scrollToEnd = options => {
        // Default to true
        var animated = (options && options.animated) !== false;
        var horizontal = this.props.horizontal;
        var scrollResponderNode = this.getScrollableNode();
        var x = horizontal ? scrollResponderNode.scrollWidth : 0;
        var y = horizontal ? 0 : scrollResponderNode.scrollHeight;
        this.scrollResponderScrollTo({
          x,
          y,
          animated
        });
      };
      this._handleContentOnLayout = e => {
        var _e$nativeEvent$layout = e.nativeEvent.layout,
          width = _e$nativeEvent$layout.width,
          height = _e$nativeEvent$layout.height;
        this.props.onContentSizeChange(width, height);
      };
      this._handleScroll = e => {
        if (process.env.NODE_ENV !== 'production') {
          if (this.props.onScroll && this.props.scrollEventThrottle == null) {
            console.log('You specified `onScroll` on a <ScrollView> but not ' + '`scrollEventThrottle`. You will only receive one event. ' + 'Using `16` you get all the events but be aware that it may ' + "cause frame drops, use a bigger number if you don't need as " + 'much precision.');
          }
        }
        if (this.props.keyboardDismissMode === 'on-drag') {
          (0, dismissKeyboard.default)();
        }
        this.scrollResponderHandleScroll(e);
      };
      this._setInnerViewRef = node => {
        this._innerViewRef = node;
      };
      this._setScrollNodeRef = node => {
        this._scrollNodeRef = node;
        // ScrollView needs to add more methods to the hostNode in addition to those
        // added by `usePlatformMethods`. This is temporarily until an API like
        // `ScrollView.scrollTo(hostNode, { x, y })` is added to React Native.
        if (node != null) {
          node.getScrollResponder = this.getScrollResponder;
          node.getInnerViewNode = this.getInnerViewNode;
          node.getInnerViewRef = this.getInnerViewRef;
          node.getNativeScrollRef = this.getNativeScrollRef;
          node.getScrollableNode = this.getScrollableNode;
          node.scrollTo = this.scrollTo;
          node.scrollToEnd = this.scrollToEnd;
          node.flashScrollIndicators = this.flashScrollIndicators;
          node.scrollResponderZoomTo = this.scrollResponderZoomTo;
          node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard;
        }
        var ref = (0, mergeRefs.default)(this.props.forwardedRef);
        ref(node);
      };
    }
    /**
     * ------------------------------------------------------
     * START SCROLLRESPONDER
     * ------------------------------------------------------
     */
    // Reset to false every time becomes responder. This is used to:
    // - Determine if the scroll view has been scrolled and therefore should
    // refuse to give up its responder lock.
    // - Determine if releasing should dismiss the keyboard when we are in
    // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).
    /**
     * Invoke this from an `onScroll` event.
     */
    /**
     * Merely touch starting is not sufficient for a scroll view to become the
     * responder. Being the "responder" means that the very next touch move/end
     * event will result in an action/movement.
     *
     * Invoke this from an `onStartShouldSetResponder` event.
     *
     * `onStartShouldSetResponder` is used when the next move/end will trigger
     * some UI movement/action, but when you want to yield priority to views
     * nested inside of the view.
     *
     * There may be some cases where scroll views actually should return `true`
     * from `onStartShouldSetResponder`: Any time we are detecting a standard tap
     * that gives priority to nested views.
     *
     * - If a single tap on the scroll view triggers an action such as
     *   recentering a map style view yet wants to give priority to interaction
     *   views inside (such as dropped pins or labels), then we would return true
     *   from this method when there is a single touch.
     *
     * - Similar to the previous case, if a two finger "tap" should trigger a
     *   zoom, we would check the `touches` count, and if `>= 2`, we would return
     *   true.
     *
     */
    scrollResponderHandleStartShouldSetResponder() {
      return false;
    }

    /**
     * There are times when the scroll view wants to become the responder
     * (meaning respond to the next immediate `touchStart/touchEnd`), in a way
     * that *doesn't* give priority to nested views (hence the capture phase):
     *
     * - Currently animating.
     * - Tapping anywhere that is not the focused input, while the keyboard is
     *   up (which should dismiss the keyboard).
     *
     * Invoke this from an `onStartShouldSetResponderCapture` event.
     */

    /**
     * Invoke this from an `onResponderReject` event.
     *
     * Some other element is not yielding its role as responder. Normally, we'd
     * just disable the `UIScrollView`, but a touch has already began on it, the
     * `UIScrollView` will not accept being disabled after that. The easiest
     * solution for now is to accept the limitation of disallowing this
     * altogether. To improve this, find a way to disable the `UIScrollView` after
     * a touch has already started.
     */
    scrollResponderHandleResponderReject() {
      (0, warning.default)(false, "ScrollView doesn't take rejection well - scrolls anyway");
    }

    /**
     * We will allow the scroll view to give up its lock iff it acquired the lock
     * during an animation. This is a very useful default that happens to satisfy
     * many common user experiences.
     *
     * - Stop a scroll on the left edge, then turn that into an outer view's
     *   backswipe.
     * - Stop a scroll mid-bounce at the top, continue pulling to have the outer
     *   view dismiss.
     * - However, without catching the scroll view mid-bounce (while it is
     *   motionless), if you drag far enough for the scroll view to become
     *   responder (and therefore drag the scroll view a bit), any backswipe
     *   navigation of a swipe gesture higher in the view hierarchy, should be
     *   rejected.
     */

    /**
     * Invoke this from an `onTouchEnd` event.
     *
     * @param {SyntheticEvent} e Event.
     */

    /**
     * Invoke this from an `onResponderRelease` event.
     */

    /**
     * Invoke this from an `onResponderGrant` event.
     */

    /**
     * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll
     * animation, and there's not an easy way to distinguish a drag vs. stopping
     * momentum.
     *
     * Invoke this from an `onScrollBeginDrag` event.
     */

    /**
     * Invoke this from an `onScrollEndDrag` event.
     */

    /**
     * Invoke this from an `onMomentumScrollBegin` event.
     */

    /**
     * Invoke this from an `onMomentumScrollEnd` event.
     */

    /**
     * Invoke this from an `onTouchStart` event.
     *
     * Since we know that the `SimpleEventPlugin` occurs later in the plugin
     * order, after `ResponderEventPlugin`, we can detect that we were *not*
     * permitted to be the responder (presumably because a contained view became
     * responder). The `onResponderReject` won't fire in that case - it only
     * fires when a *current* responder rejects our request.
     *
     * @param {SyntheticEvent} e Touch Start event.
     */

    /**
     * Invoke this from an `onTouchMove` event.
     *
     * Since we know that the `SimpleEventPlugin` occurs later in the plugin
     * order, after `ResponderEventPlugin`, we can detect that we were *not*
     * permitted to be the responder (presumably because a contained view became
     * responder). The `onResponderReject` won't fire in that case - it only
     * fires when a *current* responder rejects our request.
     *
     * @param {SyntheticEvent} e Touch Start event.
     */

    /**
     * A helper function for this class that lets us quickly determine if the
     * view is currently animating. This is particularly useful to know when
     * a touch has just started or ended.
     */

    /**
     * A helper function to scroll to a specific point in the scrollview.
     * This is currently used to help focus on child textviews, but can also
     * be used to quickly scroll to any element we want to focus. Syntax:
     *
     * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */

    /**
     * A helper function to zoom to a specific rect in the scrollview. The argument has the shape
     * {x: number; y: number; width: number; height: number; animated: boolean = true}
     *
     * @platform ios
     */

    /**
     * Displays the scroll indicators momentarily.
     */
    scrollResponderFlashScrollIndicators() {}

    /**
     * This method should be used as the callback to onFocus in a TextInputs'
     * parent view. Note that any module using this mixin needs to return
     * the parent view's ref in getScrollViewRef() in order to use this method.
     * @param {any} nodeHandle The TextInput node handle
     * @param {number} additionalOffset The scroll view's top "contentInset".
     *        Default is 0.
     * @param {bool} preventNegativeScrolling Whether to allow pulling the content
     *        down to make it meet the keyboard's top. Default is false.
     */

    /**
     * The calculations performed here assume the scroll view takes up the entire
     * screen - even if has some content inset. We then measure the offsets of the
     * keyboard, and compensate both for the scroll view's "contentInset".
     *
     * @param {number} left Position of input w.r.t. table view.
     * @param {number} top Position of input w.r.t. table view.
     * @param {number} width Width of the text input.
     * @param {number} height Height of the text input.
     */

    scrollResponderTextInputFocusError(e) {
      console.error('Error measuring text field: ', e);
    }

    /**
     * Warning, this may be called several times for a single keyboard opening.
     * It's best to store the information in this method and then take any action
     * at a later point (either in `keyboardDidShow` or other).
     *
     * Here's the order that events occur in:
     * - focus
     * - willShow {startCoordinates, endCoordinates} several times
     * - didShow several times
     * - blur
     * - willHide {startCoordinates, endCoordinates} several times
     * - didHide several times
     *
     * The `ScrollResponder` providesModule callbacks for each of these events.
     * Even though any user could have easily listened to keyboard events
     * themselves, using these `props` callbacks ensures that ordering of events
     * is consistent - and not dependent on the order that the keyboard events are
     * subscribed to. This matters when telling the scroll view to scroll to where
     * the keyboard is headed - the scroll responder better have been notified of
     * the keyboard destination before being instructed to scroll to where the
     * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything
     * will work.
     *
     * WARNING: These callbacks will fire even if a keyboard is displayed in a
     * different navigation pane. Filter out the events to determine if they are
     * relevant to you. (For example, only if you receive these callbacks after
     * you had explicitly focused a node etc).
     */

    /**
     * ------------------------------------------------------
     * END SCROLLRESPONDER
     * ------------------------------------------------------
     */

    /**
     * Returns a reference to the underlying scroll responder, which supports
     * operations like `scrollTo`. All ScrollView-like components should
     * implement this method so that they can be composed while providing access
     * to the underlying scroll responder's methods.
     */

    /**
     * Scrolls to a given x, y offset, either immediately or with a smooth animation.
     * Syntax:
     *
     * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */

    /**
     * If this is a vertical ScrollView scrolls to the bottom.
     * If this is a horizontal ScrollView scrolls to the right.
     *
     * Use `scrollToEnd({ animated: true })` for smooth animated scrolling,
     * `scrollToEnd({ animated: false })` for immediate scrolling.
     * If no options are passed, `animated` defaults to true.
     */

    render() {
      var _this$props = this.props,
        contentContainerStyle = _this$props.contentContainerStyle,
        horizontal = _this$props.horizontal,
        onContentSizeChange = _this$props.onContentSizeChange,
        refreshControl = _this$props.refreshControl,
        stickyHeaderIndices = _this$props.stickyHeaderIndices,
        pagingEnabled = _this$props.pagingEnabled,
        forwardedRef = _this$props.forwardedRef,
        keyboardDismissMode = _this$props.keyboardDismissMode,
        onScroll = _this$props.onScroll,
        centerContent = _this$props.centerContent,
        other = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      if (process.env.NODE_ENV !== 'production' && this.props.style) {
        var style = StyleSheet.default.flatten(this.props.style);
        var childLayoutProps = ['alignItems', 'justifyContent'].filter(prop => style && style[prop] !== undefined);
        (0, invariant.default)(childLayoutProps.length === 0, "ScrollView child layout (" + JSON.stringify(childLayoutProps) + ") " + 'must be applied through the contentContainerStyle prop.');
      }
      var contentSizeChangeProps = {};
      if (onContentSizeChange) {
        contentSizeChangeProps = {
          onLayout: this._handleContentOnLayout
        };
      }
      var hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices);
      var children = hasStickyHeaderIndices || pagingEnabled ? React.default.Children.map(this.props.children, (child, i) => {
        var isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;
        if (child != null && (isSticky || pagingEnabled)) {
          return /*#__PURE__*/React.default.createElement(View.default, {
            style: [isSticky && styles.stickyHeader, pagingEnabled && styles.pagingEnabledChild]
          }, child);
        } else {
          return child;
        }
      }) : this.props.children;
      var contentContainer = /*#__PURE__*/React.default.createElement(View.default, (0, _extends.default)({}, contentSizeChangeProps, {
        children: children,
        collapsable: false,
        ref: this._setInnerViewRef,
        style: [horizontal && styles.contentContainerHorizontal, centerContent && styles.contentContainerCenterContent, contentContainerStyle]
      }));
      var baseStyle = horizontal ? styles.baseHorizontal : styles.baseVertical;
      var pagingEnabledStyle = horizontal ? styles.pagingEnabledHorizontal : styles.pagingEnabledVertical;
      var props = (0, _objectSpread.default)((0, _objectSpread.default)({}, other), {}, {
        style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],
        onTouchStart: this.scrollResponderHandleTouchStart,
        onTouchMove: this.scrollResponderHandleTouchMove,
        onTouchEnd: this.scrollResponderHandleTouchEnd,
        onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,
        onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,
        onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,
        onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,
        onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,
        onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,
        onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,
        onScroll: this._handleScroll,
        onResponderGrant: this.scrollResponderHandleResponderGrant,
        onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,
        onResponderTerminate: this.scrollResponderHandleTerminate,
        onResponderRelease: this.scrollResponderHandleResponderRelease,
        onResponderReject: this.scrollResponderHandleResponderReject
      });
      var ScrollViewClass = ScrollViewBase.default;
      (0, invariant.default)(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');
      var scrollView = /*#__PURE__*/React.default.createElement(ScrollViewClass, (0, _extends.default)({}, props, {
        ref: this._setScrollNodeRef
      }), contentContainer);
      if (refreshControl) {
        return /*#__PURE__*/React.default.cloneElement(refreshControl, {
          style: props.style
        }, scrollView);
      }
      return scrollView;
    }
  }
  var commonStyle = {
    flexGrow: 1,
    flexShrink: 1,
    // Enable hardware compositing in modern browsers.
    // Creates a new layer with its own backing surface that can significantly
    // improve scroll performance.
    transform: 'translateZ(0)',
    // iOS native scrolling
    WebkitOverflowScrolling: 'touch'
  };
  var styles = StyleSheet.default.create({
    baseVertical: (0, _objectSpread.default)((0, _objectSpread.default)({}, commonStyle), {}, {
      flexDirection: 'column',
      overflowX: 'hidden',
      overflowY: 'auto'
    }),
    baseHorizontal: (0, _objectSpread.default)((0, _objectSpread.default)({}, commonStyle), {}, {
      flexDirection: 'row',
      overflowX: 'auto',
      overflowY: 'hidden'
    }),
    contentContainerHorizontal: {
      flexDirection: 'row'
    },
    contentContainerCenterContent: {
      justifyContent: 'center',
      flexGrow: 1
    },
    stickyHeader: {
      position: 'sticky',
      top: 0,
      zIndex: 10
    },
    pagingEnabledHorizontal: {
      scrollSnapType: 'x mandatory'
    },
    pagingEnabledVertical: {
      scrollSnapType: 'y mandatory'
    },
    pagingEnabledChild: {
      scrollSnapAlign: 'start'
    }
  });
  var ForwardedScrollView = /*#__PURE__*/React.default.forwardRef((props, forwardedRef) => {
    return /*#__PURE__*/React.default.createElement(ScrollView, (0, _extends.default)({}, props, {
      forwardedRef: forwardedRef
    }));
  });
  ForwardedScrollView.displayName = 'ScrollView';
  var _default = ForwardedScrollView;
},36,[37,42,43,44,46,17,53,14,54,55,47,48,110,9,134],"node_modules/react-native-web/dist/exports/ScrollView/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _objectSpread2;
    }
  });
  var _definePropertyJs = require(_dependencyMap[0], "./defineProperty.js");
  var defineProperty = _interopDefault(_definePropertyJs);
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        (0, defineProperty.default)(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
},37,[38],"node_modules/@babel/runtime/helpers/esm/objectSpread2.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _defineProperty;
    }
  });
  var _toPropertyKeyJs = require(_dependencyMap[0], "./toPropertyKey.js");
  var toPropertyKey = _interopDefault(_toPropertyKeyJs);
  function _defineProperty(e, r, t) {
    return (r = (0, toPropertyKey.default)(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
},38,[39],"node_modules/@babel/runtime/helpers/esm/defineProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return toPropertyKey;
    }
  });
  var _typeofJs = require(_dependencyMap[0], "./typeof.js");
  var _typeof = _interopDefault(_typeofJs);
  var _toPrimitiveJs = require(_dependencyMap[1], "./toPrimitive.js");
  var toPrimitive = _interopDefault(_toPrimitiveJs);
  function toPropertyKey(t) {
    var i = (0, toPrimitive.default)(t, "string");
    return "symbol" == (0, _typeof.default)(i) ? i : i + "";
  }
},39,[40,41],"node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _typeof;
    }
  });
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
},40,[],"node_modules/@babel/runtime/helpers/esm/typeof.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return toPrimitive;
    }
  });
  var _typeofJs = require(_dependencyMap[0], "./typeof.js");
  var _typeof = _interopDefault(_typeofJs);
  function toPrimitive(t, r) {
    if ("object" != (0, _typeof.default)(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != (0, _typeof.default)(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
},41,[40],"node_modules/@babel/runtime/helpers/esm/toPrimitive.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _extends;
    }
  });
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
},42,[],"node_modules/@babel/runtime/helpers/esm/extends.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _objectWithoutPropertiesLoose;
    }
  });
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
},43,[],"node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return Dimensions;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _modulesCanUseDom = require(_dependencyMap[1], "../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  var dimensions = {
    window: {
      fontScale: 1,
      height: 0,
      scale: 1,
      width: 0
    },
    screen: {
      fontScale: 1,
      height: 0,
      scale: 1,
      width: 0
    }
  };
  var listeners = {};
  var shouldInit = canUseDOM.default;
  function update() {
    if (!canUseDOM.default) {
      return;
    }
    var win = window;
    var height;
    var width;

    /**
     * iOS does not update viewport dimensions on keyboard open/close.
     * window.visualViewport(https://developer.mozilla.org/en-US/docs/Web/API/VisualViewport)
     * is used instead of document.documentElement.clientHeight (which remains as a fallback)
     */
    if (win.visualViewport) {
      var visualViewport = win.visualViewport;
      /**
       * We are multiplying by scale because height and width from visual viewport
       * also react to pinch zoom, and become smaller when zoomed. But it is not desired
       * behaviour, since originally documentElement client height and width were used,
       * and they do not react to pinch zoom.
       */
      height = Math.round(visualViewport.height * visualViewport.scale);
      width = Math.round(visualViewport.width * visualViewport.scale);
    } else {
      var docEl = win.document.documentElement;
      height = docEl.clientHeight;
      width = docEl.clientWidth;
    }
    dimensions.window = {
      fontScale: 1,
      height,
      scale: win.devicePixelRatio || 1,
      width
    };
    dimensions.screen = {
      fontScale: 1,
      height: win.screen.height,
      scale: win.devicePixelRatio || 1,
      width: win.screen.width
    };
  }
  function handleResize() {
    update();
    if (Array.isArray(listeners['change'])) {
      listeners['change'].forEach(handler => handler(dimensions));
    }
  }
  class Dimensions {
    static get(dimension) {
      if (shouldInit) {
        shouldInit = false;
        update();
      }
      (0, invariant.default)(dimensions[dimension], "No dimension set for key " + dimension);
      return dimensions[dimension];
    }
    static set(initialDimensions) {
      if (initialDimensions) {
        if (canUseDOM.default) {
          (0, invariant.default)(false, 'Dimensions cannot be set in the browser');
        } else {
          if (initialDimensions.screen != null) {
            dimensions.screen = initialDimensions.screen;
          }
          if (initialDimensions.window != null) {
            dimensions.window = initialDimensions.window;
          }
        }
      }
    }
    static addEventListener(type, handler) {
      listeners[type] = listeners[type] || [];
      listeners[type].push(handler);
      return {
        remove: () => {
          this.removeEventListener(type, handler);
        }
      };
    }
    static removeEventListener(type, handler) {
      if (Array.isArray(listeners[type])) {
        listeners[type] = listeners[type].filter(_handler => _handler !== handler);
      }
    }
  }
  if (canUseDOM.default) {
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', handleResize, false);
    } else {
      window.addEventListener('resize', handleResize, false);
    }
  }
},44,[17,45],"node_modules/react-native-web/dist/exports/Dimensions/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  var _default = canUseDOM;
},45,[],"node_modules/react-native-web/dist/modules/canUseDom/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _TextInputState = require(_dependencyMap[0], "../TextInputState");
  var TextInputState = _interopDefault(_TextInputState);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var dismissKeyboard = () => {
    TextInputState.default.blurTextInput(TextInputState.default.currentlyFocusedField());
  };
  var _default = dismissKeyboard;
},46,[47],"node_modules/react-native-web/dist/modules/dismissKeyboard/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _exportsUIManager = require(_dependencyMap[0], "../../exports/UIManager");
  var UIManager = _interopDefault(_exportsUIManager);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * This class is responsible for coordinating the "focused"
   * state for TextInputs. All calls relating to the keyboard
   * should be funneled through here
   */
  var TextInputState = {
    /**
     * Internal state
     */
    _currentlyFocusedNode: null,
    /**
     * Returns the ID of the currently focused text field, if one exists
     * If no text field is focused it returns null
     */
    currentlyFocusedField() {
      if (document.activeElement !== this._currentlyFocusedNode) {
        this._currentlyFocusedNode = null;
      }
      return this._currentlyFocusedNode;
    },
    /**
     * @param {Object} TextInputID id of the text field to focus
     * Focuses the specified text field
     * noop if the text field was already focused
     */
    focusTextInput(textFieldNode) {
      if (textFieldNode !== null) {
        this._currentlyFocusedNode = textFieldNode;
        if (document.activeElement !== textFieldNode) {
          UIManager.default.focus(textFieldNode);
        }
      }
    },
    /**
     * @param {Object} textFieldNode id of the text field to focus
     * Unfocuses the specified text field
     * noop if it wasn't focused
     */
    blurTextInput(textFieldNode) {
      if (textFieldNode !== null) {
        this._currentlyFocusedNode = null;
        if (document.activeElement === textFieldNode) {
          UIManager.default.blur(textFieldNode);
        }
      }
    }
  };
  var _default = TextInputState;
},47,[48],"node_modules/react-native-web/dist/modules/TextInputState/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesGetBoundingClientRect = require(_dependencyMap[0], "../../modules/getBoundingClientRect");
  var getBoundingClientRect = _interopDefault(_modulesGetBoundingClientRect);
  var _modulesSetValueForStyles = require(_dependencyMap[1], "../../modules/setValueForStyles");
  var setValueForStyles = _interopDefault(_modulesSetValueForStyles);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var getRect = node => {
    var height = node.offsetHeight;
    var width = node.offsetWidth;
    var left = node.offsetLeft;
    var top = node.offsetTop;
    node = node.offsetParent;
    while (node && node.nodeType === 1 /* Node.ELEMENT_NODE */) {
      left += node.offsetLeft + node.clientLeft - node.scrollLeft;
      top += node.offsetTop + node.clientTop - node.scrollTop;
      node = node.offsetParent;
    }
    top -= window.scrollY;
    left -= window.scrollX;
    return {
      width,
      height,
      top,
      left
    };
  };
  var measureLayout = (node, relativeToNativeNode, callback) => {
    var relativeNode = relativeToNativeNode || node && node.parentNode;
    if (node && relativeNode) {
      setTimeout(() => {
        if (node.isConnected && relativeNode.isConnected) {
          var relativeRect = getRect(relativeNode);
          var _getRect = getRect(node),
            height = _getRect.height,
            left = _getRect.left,
            top = _getRect.top,
            width = _getRect.width;
          var x = left - relativeRect.left;
          var y = top - relativeRect.top;
          callback(x, y, width, height, left, top);
        }
      }, 0);
    }
  };
  var elementsToIgnore = {
    A: true,
    BODY: true,
    INPUT: true,
    SELECT: true,
    TEXTAREA: true
  };
  var UIManager = {
    blur(node) {
      try {
        node.blur();
      } catch (err) {}
    },
    focus(node) {
      try {
        var name = node.nodeName;
        // A tabIndex of -1 allows element to be programmatically focused but
        // prevents keyboard focus. We don't want to set the tabindex value on
        // elements that should not prevent keyboard focus.
        if (node.getAttribute('tabIndex') == null && node.isContentEditable !== true && elementsToIgnore[name] == null) {
          node.setAttribute('tabIndex', '-1');
        }
        node.focus();
      } catch (err) {}
    },
    measure(node, callback) {
      measureLayout(node, null, callback);
    },
    measureInWindow(node, callback) {
      if (node) {
        setTimeout(() => {
          var _getBoundingClientRec = (0, getBoundingClientRect.default)(node),
            height = _getBoundingClientRec.height,
            left = _getBoundingClientRec.left,
            top = _getBoundingClientRec.top,
            width = _getBoundingClientRec.width;
          callback(left, top, width, height);
        }, 0);
      }
    },
    measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
      measureLayout(node, relativeToNativeNode, onSuccess);
    },
    updateView(node, props) {
      for (var prop in props) {
        if (!Object.prototype.hasOwnProperty.call(props, prop)) {
          continue;
        }
        var value = props[prop];
        switch (prop) {
          case 'style':
            {
              (0, setValueForStyles.default)(node, value);
              break;
            }
          case 'class':
          case 'className':
            {
              node.setAttribute('class', value);
              break;
            }
          case 'text':
          case 'value':
            // native platforms use `text` prop to replace text input value
            node.value = value;
            break;
          default:
            node.setAttribute(prop, value);
        }
      }
    },
    configureNextLayoutAnimation(config, onAnimationDidEnd) {
      onAnimationDidEnd();
    },
    // mocks
    setLayoutAnimationEnabledExperimental() {}
  };
  var _default = UIManager;
},48,[49,50],"node_modules/react-native-web/dist/exports/UIManager/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var getBoundingClientRect = node => {
    if (node != null) {
      var isElement = node.nodeType === 1; /* Node.ELEMENT_NODE */
      if (isElement && typeof node.getBoundingClientRect === 'function') {
        return node.getBoundingClientRect();
      }
    }
  };
  var _default = getBoundingClientRect;
},49,[],"node_modules/react-native-web/dist/modules/getBoundingClientRect/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _dangerousStyleValue = require(_dependencyMap[0], "./dangerousStyleValue");
  var dangerousStyleValue = _interopDefault(_dangerousStyleValue);
  /* eslint-disable */

  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * From React 16.3.0
   * 
   */

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  function setValueForStyles(node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var isCustomProperty = styleName.indexOf('--') === 0;
      var styleValue = (0, dangerousStyleValue.default)(styleName, styles[styleName], isCustomProperty);
      if (styleName === 'float') {
        styleName = 'cssFloat';
      }
      if (isCustomProperty) {
        style.setProperty(styleName, styleValue);
      } else {
        style[styleName] = styleValue;
      }
    }
  }
  var _default = setValueForStyles;
},50,[51],"node_modules/react-native-web/dist/modules/setValueForStyles/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _unitlessNumbers = require(_dependencyMap[0], "../unitlessNumbers");
  var isUnitlessNumber = _interopDefault(_unitlessNumbers);
  /* eslint-disable */

  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * From React 16.0.0
   * 
   */

  /**
   * Convert a value into the proper css writable value. The style name `name`
   * should be logical (no hyphens), as specified
   * in `CSSProperty.isUnitlessNumber`.
   *
   * @param {string} name CSS property name such as `topMargin`.
   * @param {*} value CSS property value such as `10px`.
   * @return {string} Normalized style value with dimensions applied.
   */
  function dangerousStyleValue(name, value, isCustomProperty) {
    // Note that we've removed escapeTextForBrowser() calls here since the
    // whole string will be escaped when the attribute is injected into
    // the markup. If you provide unsafe user data here they can inject
    // arbitrary CSS which may be problematic (I couldn't repro this):
    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
    // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
    // This is not an XSS hole but instead a potential CSS injection issue
    // which has lead to a greater discussion about how we're going to
    // trust URLs moving forward. See #2115901

    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }
    if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.default.hasOwnProperty(name) && isUnitlessNumber.default[name])) {
      return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
    }
    return ('' + value).trim();
  }
  var _default = dangerousStyleValue;
},51,[52],"node_modules/react-native-web/dist/modules/setValueForStyles/dangerousStyleValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var unitlessNumbers = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexOrder: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    fontWeight: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowGap: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnGap: true,
    gridColumnStart: true,
    lineClamp: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true,
    // transform types
    scale: true,
    scaleX: true,
    scaleY: true,
    scaleZ: true,
    // RN properties
    shadowOpacity: true
  };

  /**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */
  var prefixes = ['ms', 'Moz', 'O', 'Webkit'];
  var prefixKey = (prefix, key) => {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  };
  Object.keys(unitlessNumbers).forEach(prop => {
    prefixes.forEach(prefix => {
      unitlessNumbers[prefixKey(prefix, prop)] = unitlessNumbers[prop];
    });
  });
  var _default = unitlessNumbers;
},52,[],"node_modules/react-native-web/dist/modules/unitlessNumbers/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return mergeRefs;
    }
  });
  require(_dependencyMap[0], "react");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function mergeRefs() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return function forwardRef(node) {
      args.forEach(ref => {
        if (ref == null) {
          return;
        }
        if (typeof ref === 'function') {
          ref(node);
          return;
        }
        if (typeof ref === 'object') {
          ref.current = node;
          return;
        }
        console.error("mergeRefs cannot handle Refs of type boolean, number or string, received ref " + String(ref));
      });
    };
  }
},53,[9],"node_modules/react-native-web/dist/modules/mergeRefs/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[3], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[4], "../View");
  var View = _interopDefault(_View);
  var _modulesUseMergeRefs = require(_dependencyMap[5], "../../modules/useMergeRefs");
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _excluded = ["onScroll", "onTouchMove", "onWheel", "scrollEnabled", "scrollEventThrottle", "showsHorizontalScrollIndicator", "showsVerticalScrollIndicator", "style"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function normalizeScrollEvent(e) {
    return {
      nativeEvent: {
        contentOffset: {
          get x() {
            return e.target.scrollLeft;
          },
          get y() {
            return e.target.scrollTop;
          }
        },
        contentSize: {
          get height() {
            return e.target.scrollHeight;
          },
          get width() {
            return e.target.scrollWidth;
          }
        },
        layoutMeasurement: {
          get height() {
            return e.target.offsetHeight;
          },
          get width() {
            return e.target.offsetWidth;
          }
        }
      },
      timeStamp: Date.now()
    };
  }
  function shouldEmitScrollEvent(lastTick, eventThrottle) {
    var timeSinceLastTick = Date.now() - lastTick;
    return eventThrottle > 0 && timeSinceLastTick >= eventThrottle;
  }

  /**
   * Encapsulates the Web-specific scroll throttling and disabling logic
   */
  var ScrollViewBase = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var onScroll = props.onScroll,
      onTouchMove = props.onTouchMove,
      onWheel = props.onWheel,
      _props$scrollEnabled = props.scrollEnabled,
      scrollEnabled = _props$scrollEnabled === void 0 ? true : _props$scrollEnabled,
      _props$scrollEventThr = props.scrollEventThrottle,
      scrollEventThrottle = _props$scrollEventThr === void 0 ? 0 : _props$scrollEventThr,
      showsHorizontalScrollIndicator = props.showsHorizontalScrollIndicator,
      showsVerticalScrollIndicator = props.showsVerticalScrollIndicator,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var scrollState = React.useRef({
      isScrolling: false,
      scrollLastTick: 0
    });
    var scrollTimeout = React.useRef(null);
    var scrollRef = React.useRef(null);
    function createPreventableScrollHandler(handler) {
      return e => {
        if (scrollEnabled) {
          if (handler) {
            handler(e);
          }
        }
      };
    }
    function handleScroll(e) {
      e.stopPropagation();
      if (e.target === scrollRef.current) {
        e.persist();
        // A scroll happened, so the scroll resets the scrollend timeout.
        if (scrollTimeout.current != null) {
          clearTimeout(scrollTimeout.current);
        }
        scrollTimeout.current = setTimeout(() => {
          handleScrollEnd(e);
        }, 100);
        if (scrollState.current.isScrolling) {
          // Scroll last tick may have changed, check if we need to notify
          if (shouldEmitScrollEvent(scrollState.current.scrollLastTick, scrollEventThrottle)) {
            handleScrollTick(e);
          }
        } else {
          // Weren't scrolling, so we must have just started
          handleScrollStart(e);
        }
      }
    }
    function handleScrollStart(e) {
      scrollState.current.isScrolling = true;
      handleScrollTick(e);
    }
    function handleScrollTick(e) {
      scrollState.current.scrollLastTick = Date.now();
      if (onScroll) {
        onScroll(normalizeScrollEvent(e));
      }
    }
    function handleScrollEnd(e) {
      scrollState.current.isScrolling = false;
      if (onScroll) {
        onScroll(normalizeScrollEvent(e));
      }
    }
    var hideScrollbar = showsHorizontalScrollIndicator === false || showsVerticalScrollIndicator === false;
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, {
      onScroll: handleScroll,
      onTouchMove: createPreventableScrollHandler(onTouchMove),
      onWheel: createPreventableScrollHandler(onWheel),
      ref: (0, useMergeRefs.default)(scrollRef, forwardedRef),
      style: [style, !scrollEnabled && styles.scrollDisabled, hideScrollbar && styles.hideScrollbar]
    }));
  });

  // Chrome doesn't support e.preventDefault in this case; touch-action must be
  // used to disable scrolling.
  // https://developers.google.com/web/updates/2017/01/scrolling-intervention
  var styles = StyleSheet.default.create({
    scrollDisabled: {
      overflowX: 'hidden',
      overflowY: 'hidden',
      touchAction: 'none'
    },
    hideScrollbar: {
      scrollbarWidth: 'none'
    }
  });
  var _default = ScrollViewBase;
},54,[42,43,9,55,110,123],"node_modules/react-native-web/dist/exports/ScrollView/ScrollViewBase.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _compiler = require(_dependencyMap[2], "./compiler");
  var _dom = require(_dependencyMap[3], "./dom");
  var _styleqTransformLocalizeStyle = require(_dependencyMap[4], "styleq/transform-localize-style");
  var _preprocess = require(_dependencyMap[5], "./preprocess");
  var _styleq = require(_dependencyMap[6], "styleq");
  var _validate = require(_dependencyMap[7], "./validate");
  var _modulesCanUseDom = require(_dependencyMap[8], "../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  var _excluded = ["writingDirection"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var staticStyleMap = new WeakMap();
  var sheet = (0, _dom.createSheet)();
  var defaultPreprocessOptions = {
    shadow: true,
    textShadow: true
  };
  function customStyleq(styles, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options,
      writingDirection = _options.writingDirection,
      preprocessOptions = (0, _objectWithoutPropertiesLoose.default)(_options, _excluded);
    var isRTL = writingDirection === 'rtl';
    return _styleq.styleq.factory({
      transform(style) {
        var compiledStyle = staticStyleMap.get(style);
        if (compiledStyle != null) {
          return (0, _styleqTransformLocalizeStyle.localizeStyle)(compiledStyle, isRTL);
        }
        return (0, _preprocess.preprocess)(style, (0, _objectSpread.default)((0, _objectSpread.default)({}, defaultPreprocessOptions), preprocessOptions));
      }
    })(styles);
  }
  function insertRules(compiledOrderedRules) {
    compiledOrderedRules.forEach(_ref => {
      var rules = _ref[0],
        order = _ref[1];
      if (sheet != null) {
        rules.forEach(rule => {
          sheet.insert(rule, order);
        });
      }
    });
  }
  function compileAndInsertAtomic(style) {
    var _atomic = (0, _compiler.atomic)((0, _preprocess.preprocess)(style, defaultPreprocessOptions)),
      compiledStyle = _atomic[0],
      compiledOrderedRules = _atomic[1];
    insertRules(compiledOrderedRules);
    return compiledStyle;
  }
  function compileAndInsertReset(style, key) {
    var _classic = (0, _compiler.classic)(style, key),
      compiledStyle = _classic[0],
      compiledOrderedRules = _classic[1];
    insertRules(compiledOrderedRules);
    return compiledStyle;
  }

  /* ----- API ----- */

  var absoluteFillObject = {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  var absoluteFill = create({
    x: (0, _objectSpread.default)({}, absoluteFillObject)
  }).x;

  /**
   * create
   */
  function create(styles) {
    Object.keys(styles).forEach(key => {
      var styleObj = styles[key];
      // Only compile at runtime if the style is not already compiled
      if (styleObj != null && styleObj.$$css !== true) {
        var compiledStyles;
        if (key.indexOf('$raw') > -1) {
          compiledStyles = compileAndInsertReset(styleObj, key.split('$raw')[0]);
        } else {
          if (process.env.NODE_ENV !== 'production') {
            (0, _validate.validate)(styleObj);
            styles[key] = Object.freeze(styleObj);
          }
          compiledStyles = compileAndInsertAtomic(styleObj);
        }
        staticStyleMap.set(styleObj, compiledStyles);
      }
    });
    return styles;
  }

  /**
   * compose
   */
  function compose(style1, style2) {
    if (process.env.NODE_ENV !== 'production') {
      /* eslint-disable prefer-rest-params */
      var len = arguments.length;
      if (len > 2) {
        var readableStyles = [...arguments].map(a => flatten(a));
        throw new Error("StyleSheet.compose() only accepts 2 arguments, received " + len + ": " + JSON.stringify(readableStyles));
      }
      /* eslint-enable prefer-rest-params */
      /*
      console.warn(
        'StyleSheet.compose(a, b) is deprecated; use array syntax, i.e., [a,b].'
      );
      */
    }
    return [style1, style2];
  }

  /**
   * flatten
   */
  function flatten() {
    for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
      styles[_key] = arguments[_key];
    }
    var flatArray = styles.flat(Infinity);
    var result = {};
    for (var i = 0; i < flatArray.length; i++) {
      var style = flatArray[i];
      if (style != null && typeof style === 'object') {
        // $FlowFixMe
        Object.assign(result, style);
      }
    }
    return result;
  }

  /**
   * getSheet
   */
  function getSheet() {
    return {
      id: sheet.id,
      textContent: sheet.getTextContent()
    };
  }

  /**
   * resolve
   */

  function StyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }
    var isRTL = options.writingDirection === 'rtl';
    var styleProps = customStyleq(styles, options);
    if (Array.isArray(styleProps) && styleProps[1] != null) {
      styleProps[1] = (0, _compiler.inline)(styleProps[1], isRTL);
    }
    return styleProps;
  }
  StyleSheet.absoluteFill = absoluteFill;
  StyleSheet.absoluteFillObject = absoluteFillObject;
  StyleSheet.create = create;
  StyleSheet.compose = compose;
  StyleSheet.flatten = flatten;
  StyleSheet.getSheet = getSheet;
  // `hairlineWidth` is not implemented using screen density as browsers may
  // round sub-pixel values down to `0`, causing the line not to be rendered.
  StyleSheet.hairlineWidth = 1;
  if (canUseDOM.default && window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {
    window.__REACT_DEVTOOLS_GLOBAL_HOOK__.resolveRNStyle = StyleSheet.flatten;
  }
  var stylesheet = StyleSheet;
  var _default = stylesheet;
},55,[37,43,56,96,99,101,103,104,45],"node_modules/react-native-web/dist/exports/StyleSheet/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.atomic = atomic;
  exports.classic = classic;
  exports.inline = inline;
  exports.stringifyValueWithProperty = stringifyValueWithProperty;
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _createReactDOMStyle = require(_dependencyMap[2], "./createReactDOMStyle");
  var createReactDOMStyle = _interopDefault(_createReactDOMStyle);
  var _hash = require(_dependencyMap[3], "./hash");
  var hash = _interopDefault(_hash);
  var _hyphenateStyleName = require(_dependencyMap[4], "./hyphenateStyleName");
  var hyphenateStyleName = _interopDefault(_hyphenateStyleName);
  var _normalizeValueWithProperty = require(_dependencyMap[5], "./normalizeValueWithProperty");
  var normalizeValueWithProperty = _interopDefault(_normalizeValueWithProperty);
  var _modulesPrefixStyles = require(_dependencyMap[6], "../../../modules/prefixStyles");
  var prefixStyles = _interopDefault(_modulesPrefixStyles);
  var _excluded = ["animationKeyframes"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var cache = new Map();
  var emptyObject = {};
  var classicGroup = 1;
  var atomicGroup = 3;
  var customGroup = {
    borderColor: 2,
    borderRadius: 2,
    borderStyle: 2,
    borderWidth: 2,
    display: 2,
    flex: 2,
    inset: 2,
    margin: 2,
    overflow: 2,
    overscrollBehavior: 2,
    padding: 2,
    insetBlock: 2.1,
    insetInline: 2.1,
    marginInline: 2.1,
    marginBlock: 2.1,
    paddingInline: 2.1,
    paddingBlock: 2.1,
    borderBlockStartColor: 2.2,
    borderBlockStartStyle: 2.2,
    borderBlockStartWidth: 2.2,
    borderBlockEndColor: 2.2,
    borderBlockEndStyle: 2.2,
    borderBlockEndWidth: 2.2,
    borderInlineStartColor: 2.2,
    borderInlineStartStyle: 2.2,
    borderInlineStartWidth: 2.2,
    borderInlineEndColor: 2.2,
    borderInlineEndStyle: 2.2,
    borderInlineEndWidth: 2.2,
    borderEndStartRadius: 2.2,
    borderEndEndRadius: 2.2,
    borderStartStartRadius: 2.2,
    borderStartEndRadius: 2.2,
    insetBlockEnd: 2.2,
    insetBlockStart: 2.2,
    insetInlineEnd: 2.2,
    insetInlineStart: 2.2,
    marginBlockStart: 2.2,
    marginBlockEnd: 2.2,
    marginInlineStart: 2.2,
    marginInlineEnd: 2.2,
    paddingBlockStart: 2.2,
    paddingBlockEnd: 2.2,
    paddingInlineStart: 2.2,
    paddingInlineEnd: 2.2
  };
  var borderTopLeftRadius = 'borderTopLeftRadius';
  var borderTopRightRadius = 'borderTopRightRadius';
  var borderBottomLeftRadius = 'borderBottomLeftRadius';
  var borderBottomRightRadius = 'borderBottomRightRadius';
  var borderLeftColor = 'borderLeftColor';
  var borderLeftStyle = 'borderLeftStyle';
  var borderLeftWidth = 'borderLeftWidth';
  var borderRightColor = 'borderRightColor';
  var borderRightStyle = 'borderRightStyle';
  var borderRightWidth = 'borderRightWidth';
  var right = 'right';
  var marginLeft = 'marginLeft';
  var marginRight = 'marginRight';
  var paddingLeft = 'paddingLeft';
  var paddingRight = 'paddingRight';
  var left = 'left';

  // Map of LTR property names to their BiDi equivalent.
  var PROPERTIES_FLIP = {
    [borderTopLeftRadius]: borderTopRightRadius,
    [borderTopRightRadius]: borderTopLeftRadius,
    [borderBottomLeftRadius]: borderBottomRightRadius,
    [borderBottomRightRadius]: borderBottomLeftRadius,
    [borderLeftColor]: borderRightColor,
    [borderLeftStyle]: borderRightStyle,
    [borderLeftWidth]: borderRightWidth,
    [borderRightColor]: borderLeftColor,
    [borderRightStyle]: borderLeftStyle,
    [borderRightWidth]: borderLeftWidth,
    [left]: right,
    [marginLeft]: marginRight,
    [marginRight]: marginLeft,
    [paddingLeft]: paddingRight,
    [paddingRight]: paddingLeft,
    [right]: left
  };

  // Map of I18N property names to their LTR equivalent.
  var PROPERTIES_I18N = {
    borderStartStartRadius: borderTopLeftRadius,
    borderStartEndRadius: borderTopRightRadius,
    borderEndStartRadius: borderBottomLeftRadius,
    borderEndEndRadius: borderBottomRightRadius,
    borderInlineStartColor: borderLeftColor,
    borderInlineStartStyle: borderLeftStyle,
    borderInlineStartWidth: borderLeftWidth,
    borderInlineEndColor: borderRightColor,
    borderInlineEndStyle: borderRightStyle,
    borderInlineEndWidth: borderRightWidth,
    insetInlineEnd: right,
    insetInlineStart: left,
    marginInlineStart: marginLeft,
    marginInlineEnd: marginRight,
    paddingInlineStart: paddingLeft,
    paddingInlineEnd: paddingRight
  };
  var PROPERTIES_VALUE = ['clear', 'float', 'textAlign'];
  function atomic(style) {
    var compiledStyle = {
      $$css: true
    };
    var compiledRules = [];
    function atomicCompile(srcProp, prop, value) {
      var valueString = stringifyValueWithProperty(value, prop);
      var cacheKey = prop + valueString;
      var cachedResult = cache.get(cacheKey);
      var identifier;
      if (cachedResult != null) {
        identifier = cachedResult[0];
        compiledRules.push(cachedResult[1]);
      } else {
        var v = srcProp !== prop ? cacheKey : valueString;
        identifier = createIdentifier('r', srcProp, v);
        var order = customGroup[srcProp] || atomicGroup;
        var rules = createAtomicRules(identifier, prop, value);
        var orderedRules = [rules, order];
        compiledRules.push(orderedRules);
        cache.set(cacheKey, [identifier, orderedRules]);
      }
      return identifier;
    }
    Object.keys(style).sort().forEach(srcProp => {
      var value = style[srcProp];
      if (value != null) {
        var localizeableValue;
        // BiDi flip values
        if (PROPERTIES_VALUE.indexOf(srcProp) > -1) {
          var _left = atomicCompile(srcProp, srcProp, 'left');
          var _right = atomicCompile(srcProp, srcProp, 'right');
          if (value === 'start') {
            localizeableValue = [_left, _right];
          } else if (value === 'end') {
            localizeableValue = [_right, _left];
          }
        }
        // BiDi flip properties
        var propPolyfill = PROPERTIES_I18N[srcProp];
        if (propPolyfill != null) {
          var ltr = atomicCompile(srcProp, propPolyfill, value);
          var rtl = atomicCompile(srcProp, PROPERTIES_FLIP[propPolyfill], value);
          localizeableValue = [ltr, rtl];
        }
        // BiDi flip transitionProperty value
        if (srcProp === 'transitionProperty') {
          var values = Array.isArray(value) ? value : [value];
          var polyfillIndices = [];
          for (var i = 0; i < values.length; i++) {
            var val = values[i];
            if (typeof val === 'string' && PROPERTIES_I18N[val] != null) {
              polyfillIndices.push(i);
            }
          }
          if (polyfillIndices.length > 0) {
            var ltrPolyfillValues = [...values];
            var rtlPolyfillValues = [...values];
            polyfillIndices.forEach(i => {
              var ltrVal = ltrPolyfillValues[i];
              if (typeof ltrVal === 'string') {
                var ltrPolyfill = PROPERTIES_I18N[ltrVal];
                var rtlPolyfill = PROPERTIES_FLIP[ltrPolyfill];
                ltrPolyfillValues[i] = ltrPolyfill;
                rtlPolyfillValues[i] = rtlPolyfill;
                var _ltr = atomicCompile(srcProp, srcProp, ltrPolyfillValues);
                var _rtl = atomicCompile(srcProp, srcProp, rtlPolyfillValues);
                localizeableValue = [_ltr, _rtl];
              }
            });
          }
        }
        if (localizeableValue == null) {
          localizeableValue = atomicCompile(srcProp, srcProp, value);
        } else {
          compiledStyle['$$css$localize'] = true;
        }
        compiledStyle[srcProp] = localizeableValue;
      }
    });
    return [compiledStyle, compiledRules];
  }

  /**
   * Compile simple style object to classic CSS rules.
   * No support for 'placeholderTextColor', 'scrollbarWidth', or 'pointerEvents'.
   */
  function classic(style, name) {
    var compiledStyle = {
      $$css: true
    };
    var compiledRules = [];
    var animationKeyframes = style.animationKeyframes,
      rest = (0, _objectWithoutPropertiesLoose.default)(style, _excluded);
    var identifier = createIdentifier('css', name, JSON.stringify(style));
    var selector = "." + identifier;
    var animationName;
    if (animationKeyframes != null) {
      var _processKeyframesValu = processKeyframesValue(animationKeyframes),
        animationNames = _processKeyframesValu[0],
        keyframesRules = _processKeyframesValu[1];
      animationName = animationNames.join(',');
      compiledRules.push(...keyframesRules);
    }
    var block = createDeclarationBlock((0, _objectSpread.default)((0, _objectSpread.default)({}, rest), {}, {
      animationName
    }));
    compiledRules.push("" + selector + block);
    compiledStyle[identifier] = identifier;
    return [compiledStyle, [[compiledRules, classicGroup]]];
  }

  /**
   * Compile simple style object to inline DOM styles.
   * No support for 'animationKeyframes', 'placeholderTextColor', 'scrollbarWidth', or 'pointerEvents'.
   */
  function inline(originalStyle, isRTL) {
    var style = originalStyle || emptyObject;
    var frozenProps = {};
    var nextStyle = {};
    var _loop = function _loop() {
      var originalValue = style[originalProp];
      var prop = originalProp;
      var value = originalValue;
      if (!Object.prototype.hasOwnProperty.call(style, originalProp) || originalValue == null) {
        return "continue";
      }

      // BiDi flip values
      if (PROPERTIES_VALUE.indexOf(originalProp) > -1) {
        if (originalValue === 'start') {
          value = isRTL ? 'right' : 'left';
        } else if (originalValue === 'end') {
          value = isRTL ? 'left' : 'right';
        }
      }
      // BiDi flip properties
      var propPolyfill = PROPERTIES_I18N[originalProp];
      if (propPolyfill != null) {
        prop = isRTL ? PROPERTIES_FLIP[propPolyfill] : propPolyfill;
      }
      // BiDi flip transitionProperty value
      if (originalProp === 'transitionProperty') {
        // $FlowFixMe
        var originalValues = Array.isArray(originalValue) ? originalValue : [originalValue];
        originalValues.forEach((val, i) => {
          if (typeof val === 'string') {
            var valuePolyfill = PROPERTIES_I18N[val];
            if (valuePolyfill != null) {
              originalValues[i] = isRTL ? PROPERTIES_FLIP[valuePolyfill] : valuePolyfill;
              value = originalValues.join(' ');
            }
          }
        });
      }

      // Create finalized style
      if (!frozenProps[prop]) {
        nextStyle[prop] = value;
      }
      if (prop === originalProp) {
        frozenProps[prop] = true;
      }

      //    if (PROPERTIES_I18N.hasOwnProperty(originalProp)) {
      //    frozenProps[prop] = true;
      //}
    };
    for (var originalProp in style) {
      var _ret = _loop();
      if (_ret === "continue") continue;
    }
    return (0, createReactDOMStyle.default)(nextStyle, true);
  }

  /**
   * Create a value string that normalizes different input values with a common
   * output.
   */
  function stringifyValueWithProperty(value, property) {
    // e.g., 0 => '0px', 'black' => 'rgba(0,0,0,1)'
    var normalizedValue = (0, normalizeValueWithProperty.default)(value, property);
    return typeof normalizedValue !== 'string' ? JSON.stringify(normalizedValue || '') : normalizedValue;
  }

  /**
   * Create the Atomic CSS rules needed for a given StyleSheet rule.
   * Translates StyleSheet declarations to CSS.
   */
  function createAtomicRules(identifier, property, value) {
    var rules = [];
    var selector = "." + identifier;

    // Handle non-standard properties and object values that require multiple
    // CSS rules to be created.
    switch (property) {
      case 'animationKeyframes':
        {
          var _processKeyframesValu2 = processKeyframesValue(value),
            animationNames = _processKeyframesValu2[0],
            keyframesRules = _processKeyframesValu2[1];
          var block = createDeclarationBlock({
            animationName: animationNames.join(',')
          });
          rules.push("" + selector + block, ...keyframesRules);
          break;
        }

      // Equivalent to using '::placeholder'
      case 'placeholderTextColor':
        {
          var _block = createDeclarationBlock({
            color: value,
            opacity: 1
          });
          rules.push(selector + "::-webkit-input-placeholder" + _block, selector + "::-moz-placeholder" + _block, selector + ":-ms-input-placeholder" + _block, selector + "::placeholder" + _block);
          break;
        }

      // Polyfill for additional 'pointer-events' values
      // See d13f78622b233a0afc0c7a200c0a0792c8ca9e58
      // See https://reactnative.dev/docs/view#pointerevents
      case 'pointerEvents':
        {
          var finalValue = value;
          if (value === 'auto') {
            finalValue = 'auto!important';
          } else if (value === 'none') {
            finalValue = 'none!important';
            var _block2 = createDeclarationBlock({
              pointerEvents: 'none'
            });
            rules.push(selector + ">* " + _block2);
          } else if (value === 'box-none') {
            finalValue = 'none!important';
            var _block3 = createDeclarationBlock({
              pointerEvents: 'auto'
            });
            rules.push(selector + ">* " + _block3);
          } else if (value === 'box-only') {
            finalValue = 'auto!important';
            var _block4 = createDeclarationBlock({
              pointerEvents: 'none'
            });
            rules.push(selector + ">* " + _block4);
          }
          var _block5 = createDeclarationBlock({
            pointerEvents: finalValue
          });
          rules.push("" + selector + _block5);
          break;
        }

      // Polyfill for draft spec
      // https://drafts.csswg.org/css-scrollbars-1/
      case 'scrollbarWidth':
        {
          if (value === 'none') {
            rules.push(selector + "::-webkit-scrollbar{display:none}");
          }
          var _block6 = createDeclarationBlock({
            scrollbarWidth: value
          });
          rules.push("" + selector + _block6);
          break;
        }
      default:
        {
          var _block7 = createDeclarationBlock({
            [property]: value
          });
          rules.push("" + selector + _block7);
          break;
        }
    }
    return rules;
  }

  /**
   * Creates a CSS declaration block from a StyleSheet object.
   */
  function createDeclarationBlock(style) {
    var domStyle = (0, prefixStyles.default)((0, createReactDOMStyle.default)(style));
    var declarationsString = Object.keys(domStyle).map(property => {
      var value = domStyle[property];
      var prop = (0, hyphenateStyleName.default)(property);
      // The prefixer may return an array of values:
      // { display: [ '-webkit-flex', 'flex' ] }
      // to represent "fallback" declarations
      // { display: -webkit-flex; display: flex; }
      if (Array.isArray(value)) {
        return value.map(v => prop + ":" + v).join(';');
      } else {
        return prop + ":" + value;
      }
    })
    // Once properties are hyphenated, this will put the vendor
    // prefixed and short-form properties first in the list.
    .sort().join(';');
    return "{" + declarationsString + ";}";
  }

  /**
   * An identifier is associated with a unique set of styles.
   */
  function createIdentifier(prefix, name, key) {
    var hashedString = (0, hash.default)(name + key);
    return process.env.NODE_ENV !== 'production' ? prefix + "-" + name + "-" + hashedString : prefix + "-" + hashedString;
  }

  /**
   * Create individual CSS keyframes rules.
   */
  function createKeyframes(keyframes) {
    var prefixes = ['-webkit-', ''];
    var identifier = createIdentifier('r', 'animation', JSON.stringify(keyframes));
    var steps = '{' + Object.keys(keyframes).map(stepName => {
      var rule = keyframes[stepName];
      var block = createDeclarationBlock(rule);
      return "" + stepName + block;
    }).join('') + '}';
    var rules = prefixes.map(prefix => {
      return "@" + prefix + "keyframes " + identifier + steps;
    });
    return [identifier, rules];
  }

  /**
   * Create CSS keyframes rules and names from a StyleSheet keyframes object.
   */
  function processKeyframesValue(keyframesValue) {
    if (typeof keyframesValue === 'number') {
      throw new Error("Invalid CSS keyframes type: " + typeof keyframesValue);
    }
    var animationNames = [];
    var rules = [];
    var value = Array.isArray(keyframesValue) ? keyframesValue : [keyframesValue];
    value.forEach(keyframes => {
      if (typeof keyframes === 'string') {
        // Support external animation libraries (identifiers only)
        animationNames.push(keyframes);
      } else {
        // Create rules for each of the keyframes
        var _createKeyframes = createKeyframes(keyframes),
          identifier = _createKeyframes[0],
          keyframesRules = _createKeyframes[1];
        animationNames.push(identifier);
        rules.push(...keyframesRules);
      }
    });
    return [animationNames, rules];
  }
},56,[37,43,57,64,65,58,66],"node_modules/react-native-web/dist/exports/StyleSheet/compiler/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _normalizeValueWithProperty = require(_dependencyMap[0], "./normalizeValueWithProperty");
  var normalizeValueWithProperty = _interopDefault(_normalizeValueWithProperty);
  var _modulesCanUseDom = require(_dependencyMap[1], "../../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * The browser implements the CSS cascade, where the order of properties is a
   * factor in determining which styles to paint. React Native is different. It
   * gives giving precedence to the more specific style property. For example,
   * the value of `paddingTop` takes precedence over that of `padding`.
   *
   * This module creates mutally exclusive style declarations by expanding all of
   * React Native's supported shortform properties (e.g. `padding`) to their
   * longfrom equivalents.
   */

  var emptyObject = {};
  var supportsCSS3TextDecoration = !canUseDOM.default || window.CSS != null && window.CSS.supports != null && (window.CSS.supports('text-decoration-line', 'none') || window.CSS.supports('-webkit-text-decoration-line', 'none'));
  var MONOSPACE_FONT_STACK = 'monospace,monospace';
  var SYSTEM_FONT_STACK = '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif';
  var STYLE_SHORT_FORM_EXPANSIONS = {
    borderColor: ['borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor'],
    borderBlockColor: ['borderTopColor', 'borderBottomColor'],
    borderInlineColor: ['borderRightColor', 'borderLeftColor'],
    borderRadius: ['borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius'],
    borderStyle: ['borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle'],
    borderBlockStyle: ['borderTopStyle', 'borderBottomStyle'],
    borderInlineStyle: ['borderRightStyle', 'borderLeftStyle'],
    borderWidth: ['borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth'],
    borderBlockWidth: ['borderTopWidth', 'borderBottomWidth'],
    borderInlineWidth: ['borderRightWidth', 'borderLeftWidth'],
    insetBlock: ['top', 'bottom'],
    insetInline: ['left', 'right'],
    marginBlock: ['marginTop', 'marginBottom'],
    marginInline: ['marginRight', 'marginLeft'],
    paddingBlock: ['paddingTop', 'paddingBottom'],
    paddingInline: ['paddingRight', 'paddingLeft'],
    overflow: ['overflowX', 'overflowY'],
    overscrollBehavior: ['overscrollBehaviorX', 'overscrollBehaviorY'],
    borderBlockStartColor: ['borderTopColor'],
    borderBlockStartStyle: ['borderTopStyle'],
    borderBlockStartWidth: ['borderTopWidth'],
    borderBlockEndColor: ['borderBottomColor'],
    borderBlockEndStyle: ['borderBottomStyle'],
    borderBlockEndWidth: ['borderBottomWidth'],
    //borderInlineStartColor: ['borderLeftColor'],
    //borderInlineStartStyle: ['borderLeftStyle'],
    //borderInlineStartWidth: ['borderLeftWidth'],
    //borderInlineEndColor: ['borderRightColor'],
    //borderInlineEndStyle: ['borderRightStyle'],
    //borderInlineEndWidth: ['borderRightWidth'],
    borderEndStartRadius: ['borderBottomLeftRadius'],
    borderEndEndRadius: ['borderBottomRightRadius'],
    borderStartStartRadius: ['borderTopLeftRadius'],
    borderStartEndRadius: ['borderTopRightRadius'],
    insetBlockEnd: ['bottom'],
    insetBlockStart: ['top'],
    //insetInlineEnd: ['right'],
    //insetInlineStart: ['left'],
    marginBlockStart: ['marginTop'],
    marginBlockEnd: ['marginBottom'],
    //marginInlineStart: ['marginLeft'],
    //marginInlineEnd: ['marginRight'],
    paddingBlockStart: ['paddingTop'],
    paddingBlockEnd: ['paddingBottom']
    //paddingInlineStart: ['marginLeft'],
    //paddingInlineEnd: ['marginRight'],
  };

  /**
   * Reducer
   */

  var createReactDOMStyle = (style, isInline) => {
    if (!style) {
      return emptyObject;
    }
    var resolvedStyle = {};
    var _loop = function _loop() {
      var value = style[prop];
      if (
      // Ignore everything with a null value
      value == null) {
        return "continue";
      }
      if (prop === 'backgroundClip') {
        // TODO: remove once this issue is fixed
        // https://github.com/rofrischmann/inline-style-prefixer/issues/159
        if (value === 'text') {
          resolvedStyle.backgroundClip = value;
          resolvedStyle.WebkitBackgroundClip = value;
        }
      } else if (prop === 'flex') {
        if (value === -1) {
          resolvedStyle.flexGrow = 0;
          resolvedStyle.flexShrink = 1;
          resolvedStyle.flexBasis = 'auto';
        } else {
          resolvedStyle.flex = value;
        }
      } else if (prop === 'font') {
        resolvedStyle[prop] = value.replace('System', SYSTEM_FONT_STACK);
      } else if (prop === 'fontFamily') {
        if (value.indexOf('System') > -1) {
          var stack = value.split(/,\s*/);
          stack[stack.indexOf('System')] = SYSTEM_FONT_STACK;
          resolvedStyle[prop] = stack.join(',');
        } else if (value === 'monospace') {
          resolvedStyle[prop] = MONOSPACE_FONT_STACK;
        } else {
          resolvedStyle[prop] = value;
        }
      } else if (prop === 'textDecorationLine') {
        // use 'text-decoration' for browsers that only support CSS2
        // text-decoration (e.g., IE, Edge)
        if (!supportsCSS3TextDecoration) {
          resolvedStyle.textDecoration = value;
        } else {
          resolvedStyle.textDecorationLine = value;
        }
      } else if (prop === 'writingDirection') {
        resolvedStyle.direction = value;
      } else {
        var _value = (0, normalizeValueWithProperty.default)(style[prop], prop);
        var longFormProperties = STYLE_SHORT_FORM_EXPANSIONS[prop];
        if (isInline && prop === 'inset') {
          if (style.insetInline == null) {
            resolvedStyle.left = _value;
            resolvedStyle.right = _value;
          }
          if (style.insetBlock == null) {
            resolvedStyle.top = _value;
            resolvedStyle.bottom = _value;
          }
        } else if (isInline && prop === 'margin') {
          if (style.marginInline == null) {
            resolvedStyle.marginLeft = _value;
            resolvedStyle.marginRight = _value;
          }
          if (style.marginBlock == null) {
            resolvedStyle.marginTop = _value;
            resolvedStyle.marginBottom = _value;
          }
        } else if (isInline && prop === 'padding') {
          if (style.paddingInline == null) {
            resolvedStyle.paddingLeft = _value;
            resolvedStyle.paddingRight = _value;
          }
          if (style.paddingBlock == null) {
            resolvedStyle.paddingTop = _value;
            resolvedStyle.paddingBottom = _value;
          }
        } else if (longFormProperties) {
          longFormProperties.forEach((longForm, i) => {
            // The value of any longform property in the original styles takes
            // precedence over the shortform's value.
            if (style[longForm] == null) {
              resolvedStyle[longForm] = _value;
            }
          });
        } else {
          resolvedStyle[prop] = _value;
        }
      }
    };
    for (var prop in style) {
      var _ret = _loop();
      if (_ret === "continue") continue;
    }
    return resolvedStyle;
  };
  var _default = createReactDOMStyle;
},57,[58,45],"node_modules/react-native-web/dist/exports/StyleSheet/compiler/createReactDOMStyle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return normalizeValueWithProperty;
    }
  });
  var _unitlessNumbers = require(_dependencyMap[0], "./unitlessNumbers");
  var unitlessNumbers = _interopDefault(_unitlessNumbers);
  var _normalizeColor = require(_dependencyMap[1], "./normalizeColor");
  var normalizeColor = _interopDefault(_normalizeColor);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var colorProps = {
    backgroundColor: true,
    borderColor: true,
    borderTopColor: true,
    borderRightColor: true,
    borderBottomColor: true,
    borderLeftColor: true,
    color: true,
    shadowColor: true,
    textDecorationColor: true,
    textShadowColor: true
  };
  function normalizeValueWithProperty(value, property) {
    var returnValue = value;
    if ((property == null || !unitlessNumbers.default[property]) && typeof value === 'number') {
      returnValue = value + "px";
    } else if (property != null && colorProps[property]) {
      returnValue = (0, normalizeColor.default)(value);
    }
    return returnValue;
  }
},58,[59,60],"node_modules/react-native-web/dist/exports/StyleSheet/compiler/normalizeValueWithProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var unitlessNumbers = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexOrder: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    fontWeight: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowGap: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnGap: true,
    gridColumnStart: true,
    lineClamp: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true,
    // transform types
    scale: true,
    scaleX: true,
    scaleY: true,
    scaleZ: true,
    // RN properties
    shadowOpacity: true
  };

  /**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */
  var prefixes = ['ms', 'Moz', 'O', 'Webkit'];
  var prefixKey = (prefix, key) => {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  };
  Object.keys(unitlessNumbers).forEach(prop => {
    prefixes.forEach(prefix => {
      unitlessNumbers[prefixKey(prefix, prop)] = unitlessNumbers[prop];
    });
  });
  var _default = unitlessNumbers;
},59,[],"node_modules/react-native-web/dist/exports/StyleSheet/compiler/unitlessNumbers.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesIsWebColor = require(_dependencyMap[0], "../../../modules/isWebColor");
  var isWebColor = _interopDefault(_modulesIsWebColor);
  var _exportsProcessColor = require(_dependencyMap[1], "../../../exports/processColor");
  var processColor = _interopDefault(_exportsProcessColor);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var normalizeColor = function normalizeColor(color, opacity) {
    if (opacity === void 0) {
      opacity = 1;
    }
    if (color == null) return;
    if (typeof color === 'string' && (0, isWebColor.default)(color)) {
      return color;
    }
    var colorInt = (0, processColor.default)(color);
    if (colorInt != null) {
      var r = colorInt >> 16 & 255;
      var g = colorInt >> 8 & 255;
      var b = colorInt & 255;
      var a = (colorInt >> 24 & 255) / 255;
      var alpha = (a * opacity).toFixed(2);
      return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
    }
  };
  var _default = normalizeColor;
},60,[61,62],"node_modules/react-native-web/dist/exports/StyleSheet/compiler/normalizeColor.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var isWebColor = color => color === 'currentcolor' || color === 'currentColor' || color === 'inherit' || color.indexOf('var(') === 0;
  var _default = isWebColor;
},61,[],"node_modules/react-native-web/dist/modules/isWebColor/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeNormalizeColors = require(_dependencyMap[0], "@react-native/normalize-colors");
  var normalizeColor = _interopDefault(_reactNativeNormalizeColors);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var processColor = color => {
    if (color === undefined || color === null) {
      return color;
    }

    // convert number and hex
    var int32Color = (0, normalizeColor.default)(color);
    if (int32Color === undefined || int32Color === null) {
      return undefined;
    }
    int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0;
    return int32Color;
  };
  var _default = processColor;
},62,[63],"node_modules/react-native-web/dist/exports/processColor/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  /* eslint no-bitwise: 0 */

  'use strict';

  function normalizeColor(color) {
    if (typeof color === 'number') {
      if (color >>> 0 === color && color >= 0 && color <= 0xffffffff) {
        return color;
      }
      return null;
    }
    if (typeof color !== 'string') {
      return null;
    }
    const matchers = getMatchers();
    let match;

    // Ordered based on occurrences on Facebook codebase
    if (match = matchers.hex6.exec(color)) {
      return parseInt(match[1] + 'ff', 16) >>> 0;
    }
    const colorFromKeyword = normalizeKeyword(color);
    if (colorFromKeyword != null) {
      return colorFromKeyword;
    }
    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 |
      // r
      parse255(match[2]) << 16 |
      // g
      parse255(match[3]) << 8 |
      // b
      0x000000ff) >>>
      // a
      0;
    }
    if (match = matchers.rgba.exec(color)) {
      // rgba(R G B / A) notation
      if (match[6] !== undefined) {
        return (parse255(match[6]) << 24 |
        // r
        parse255(match[7]) << 16 |
        // g
        parse255(match[8]) << 8 |
        // b
        parse1(match[9])) >>>
        // a
        0;
      }

      // rgba(R, G, B, A) notation
      return (parse255(match[2]) << 24 |
      // r
      parse255(match[3]) << 16 |
      // g
      parse255(match[4]) << 8 |
      // b
      parse1(match[5])) >>>
      // a
      0;
    }
    if (match = matchers.hex3.exec(color)) {
      return parseInt(match[1] + match[1] +
      // r
      match[2] + match[2] +
      // g
      match[3] + match[3] +
      // b
      'ff',
      // a
      16) >>> 0;
    }

    // https://drafts.csswg.org/css-color-4/#hex-notation
    if (match = matchers.hex8.exec(color)) {
      return parseInt(match[1], 16) >>> 0;
    }
    if (match = matchers.hex4.exec(color)) {
      return parseInt(match[1] + match[1] +
      // r
      match[2] + match[2] +
      // g
      match[3] + match[3] +
      // b
      match[4] + match[4],
      // a
      16) >>> 0;
    }
    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3]) // l
      ) | 0x000000ff) >>>
      // a
      0;
    }
    if (match = matchers.hsla.exec(color)) {
      // hsla(H S L / A) notation
      if (match[6] !== undefined) {
        return (hslToRgb(parse360(match[6]),
        // h
        parsePercentage(match[7]),
        // s
        parsePercentage(match[8]) // l
        ) | parse1(match[9])) >>>
        // a
        0;
      }

      // hsla(H, S, L, A) notation
      return (hslToRgb(parse360(match[2]),
      // h
      parsePercentage(match[3]),
      // s
      parsePercentage(match[4]) // l
      ) | parse1(match[5])) >>>
      // a
      0;
    }
    if (match = matchers.hwb.exec(color)) {
      return (hwbToRgb(parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // w
      parsePercentage(match[3]) // b
      ) | 0x000000ff) >>>
      // a
      0;
    }
    return null;
  }
  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }
  function hslToRgb(h, s, l) {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h + 1 / 3);
    const g = hue2rgb(p, q, h);
    const b = hue2rgb(p, q, h - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
  }
  function hwbToRgb(h, w, b) {
    if (w + b >= 1) {
      const gray = Math.round(w * 255 / (w + b));
      return gray << 24 | gray << 16 | gray << 8;
    }
    const red = hue2rgb(0, 1, h + 1 / 3) * (1 - w - b) + w;
    const green = hue2rgb(0, 1, h) * (1 - w - b) + w;
    const blue = hue2rgb(0, 1, h - 1 / 3) * (1 - w - b) + w;
    return Math.round(red * 255) << 24 | Math.round(green * 255) << 16 | Math.round(blue * 255) << 8;
  }
  const NUMBER = '[-+]?\\d*\\.?\\d+';
  const PERCENTAGE = NUMBER + '%';
  function call(...args) {
    return '\\(\\s*(' + args.join(')\\s*,?\\s*(') + ')\\s*\\)';
  }
  function callWithSlashSeparator(...args) {
    return '\\(\\s*(' + args.slice(0, args.length - 1).join(')\\s*,?\\s*(') + ')\\s*/\\s*(' + args[args.length - 1] + ')\\s*\\)';
  }
  function commaSeparatedCall(...args) {
    return '\\(\\s*(' + args.join(')\\s*,\\s*(') + ')\\s*\\)';
  }
  let cachedMatchers;
  function getMatchers() {
    if (cachedMatchers === undefined) {
      cachedMatchers = {
        rgb: new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER)),
        rgba: new RegExp('rgba(' + commaSeparatedCall(NUMBER, NUMBER, NUMBER, NUMBER) + '|' + callWithSlashSeparator(NUMBER, NUMBER, NUMBER, NUMBER) + ')'),
        hsl: new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hsla: new RegExp('hsla(' + commaSeparatedCall(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + '|' + callWithSlashSeparator(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + ')'),
        hwb: new RegExp('hwb' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#([0-9a-fA-F]{6})$/,
        hex8: /^#([0-9a-fA-F]{8})$/
      };
    }
    return cachedMatchers;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0) {
      return 0;
    }
    if (int > 255) {
      return 255;
    }
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0) {
      return 0;
    }
    if (num > 1) {
      return 255;
    }
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    // parseFloat conveniently ignores the final %
    const int = parseFloat(str);
    if (int < 0) {
      return 0;
    }
    if (int > 100) {
      return 1;
    }
    return int / 100;
  }
  function normalizeKeyword(name) {
    // prettier-ignore
    switch (name) {
      case 'transparent':
        return 0x00000000;
      // http://www.w3.org/TR/css3-color/#svg-color
      case 'aliceblue':
        return 0xf0f8ffff;
      case 'antiquewhite':
        return 0xfaebd7ff;
      case 'aqua':
        return 0x00ffffff;
      case 'aquamarine':
        return 0x7fffd4ff;
      case 'azure':
        return 0xf0ffffff;
      case 'beige':
        return 0xf5f5dcff;
      case 'bisque':
        return 0xffe4c4ff;
      case 'black':
        return 0x000000ff;
      case 'blanchedalmond':
        return 0xffebcdff;
      case 'blue':
        return 0x0000ffff;
      case 'blueviolet':
        return 0x8a2be2ff;
      case 'brown':
        return 0xa52a2aff;
      case 'burlywood':
        return 0xdeb887ff;
      case 'burntsienna':
        return 0xea7e5dff;
      case 'cadetblue':
        return 0x5f9ea0ff;
      case 'chartreuse':
        return 0x7fff00ff;
      case 'chocolate':
        return 0xd2691eff;
      case 'coral':
        return 0xff7f50ff;
      case 'cornflowerblue':
        return 0x6495edff;
      case 'cornsilk':
        return 0xfff8dcff;
      case 'crimson':
        return 0xdc143cff;
      case 'cyan':
        return 0x00ffffff;
      case 'darkblue':
        return 0x00008bff;
      case 'darkcyan':
        return 0x008b8bff;
      case 'darkgoldenrod':
        return 0xb8860bff;
      case 'darkgray':
        return 0xa9a9a9ff;
      case 'darkgreen':
        return 0x006400ff;
      case 'darkgrey':
        return 0xa9a9a9ff;
      case 'darkkhaki':
        return 0xbdb76bff;
      case 'darkmagenta':
        return 0x8b008bff;
      case 'darkolivegreen':
        return 0x556b2fff;
      case 'darkorange':
        return 0xff8c00ff;
      case 'darkorchid':
        return 0x9932ccff;
      case 'darkred':
        return 0x8b0000ff;
      case 'darksalmon':
        return 0xe9967aff;
      case 'darkseagreen':
        return 0x8fbc8fff;
      case 'darkslateblue':
        return 0x483d8bff;
      case 'darkslategray':
        return 0x2f4f4fff;
      case 'darkslategrey':
        return 0x2f4f4fff;
      case 'darkturquoise':
        return 0x00ced1ff;
      case 'darkviolet':
        return 0x9400d3ff;
      case 'deeppink':
        return 0xff1493ff;
      case 'deepskyblue':
        return 0x00bfffff;
      case 'dimgray':
        return 0x696969ff;
      case 'dimgrey':
        return 0x696969ff;
      case 'dodgerblue':
        return 0x1e90ffff;
      case 'firebrick':
        return 0xb22222ff;
      case 'floralwhite':
        return 0xfffaf0ff;
      case 'forestgreen':
        return 0x228b22ff;
      case 'fuchsia':
        return 0xff00ffff;
      case 'gainsboro':
        return 0xdcdcdcff;
      case 'ghostwhite':
        return 0xf8f8ffff;
      case 'gold':
        return 0xffd700ff;
      case 'goldenrod':
        return 0xdaa520ff;
      case 'gray':
        return 0x808080ff;
      case 'green':
        return 0x008000ff;
      case 'greenyellow':
        return 0xadff2fff;
      case 'grey':
        return 0x808080ff;
      case 'honeydew':
        return 0xf0fff0ff;
      case 'hotpink':
        return 0xff69b4ff;
      case 'indianred':
        return 0xcd5c5cff;
      case 'indigo':
        return 0x4b0082ff;
      case 'ivory':
        return 0xfffff0ff;
      case 'khaki':
        return 0xf0e68cff;
      case 'lavender':
        return 0xe6e6faff;
      case 'lavenderblush':
        return 0xfff0f5ff;
      case 'lawngreen':
        return 0x7cfc00ff;
      case 'lemonchiffon':
        return 0xfffacdff;
      case 'lightblue':
        return 0xadd8e6ff;
      case 'lightcoral':
        return 0xf08080ff;
      case 'lightcyan':
        return 0xe0ffffff;
      case 'lightgoldenrodyellow':
        return 0xfafad2ff;
      case 'lightgray':
        return 0xd3d3d3ff;
      case 'lightgreen':
        return 0x90ee90ff;
      case 'lightgrey':
        return 0xd3d3d3ff;
      case 'lightpink':
        return 0xffb6c1ff;
      case 'lightsalmon':
        return 0xffa07aff;
      case 'lightseagreen':
        return 0x20b2aaff;
      case 'lightskyblue':
        return 0x87cefaff;
      case 'lightslategray':
        return 0x778899ff;
      case 'lightslategrey':
        return 0x778899ff;
      case 'lightsteelblue':
        return 0xb0c4deff;
      case 'lightyellow':
        return 0xffffe0ff;
      case 'lime':
        return 0x00ff00ff;
      case 'limegreen':
        return 0x32cd32ff;
      case 'linen':
        return 0xfaf0e6ff;
      case 'magenta':
        return 0xff00ffff;
      case 'maroon':
        return 0x800000ff;
      case 'mediumaquamarine':
        return 0x66cdaaff;
      case 'mediumblue':
        return 0x0000cdff;
      case 'mediumorchid':
        return 0xba55d3ff;
      case 'mediumpurple':
        return 0x9370dbff;
      case 'mediumseagreen':
        return 0x3cb371ff;
      case 'mediumslateblue':
        return 0x7b68eeff;
      case 'mediumspringgreen':
        return 0x00fa9aff;
      case 'mediumturquoise':
        return 0x48d1ccff;
      case 'mediumvioletred':
        return 0xc71585ff;
      case 'midnightblue':
        return 0x191970ff;
      case 'mintcream':
        return 0xf5fffaff;
      case 'mistyrose':
        return 0xffe4e1ff;
      case 'moccasin':
        return 0xffe4b5ff;
      case 'navajowhite':
        return 0xffdeadff;
      case 'navy':
        return 0x000080ff;
      case 'oldlace':
        return 0xfdf5e6ff;
      case 'olive':
        return 0x808000ff;
      case 'olivedrab':
        return 0x6b8e23ff;
      case 'orange':
        return 0xffa500ff;
      case 'orangered':
        return 0xff4500ff;
      case 'orchid':
        return 0xda70d6ff;
      case 'palegoldenrod':
        return 0xeee8aaff;
      case 'palegreen':
        return 0x98fb98ff;
      case 'paleturquoise':
        return 0xafeeeeff;
      case 'palevioletred':
        return 0xdb7093ff;
      case 'papayawhip':
        return 0xffefd5ff;
      case 'peachpuff':
        return 0xffdab9ff;
      case 'peru':
        return 0xcd853fff;
      case 'pink':
        return 0xffc0cbff;
      case 'plum':
        return 0xdda0ddff;
      case 'powderblue':
        return 0xb0e0e6ff;
      case 'purple':
        return 0x800080ff;
      case 'rebeccapurple':
        return 0x663399ff;
      case 'red':
        return 0xff0000ff;
      case 'rosybrown':
        return 0xbc8f8fff;
      case 'royalblue':
        return 0x4169e1ff;
      case 'saddlebrown':
        return 0x8b4513ff;
      case 'salmon':
        return 0xfa8072ff;
      case 'sandybrown':
        return 0xf4a460ff;
      case 'seagreen':
        return 0x2e8b57ff;
      case 'seashell':
        return 0xfff5eeff;
      case 'sienna':
        return 0xa0522dff;
      case 'silver':
        return 0xc0c0c0ff;
      case 'skyblue':
        return 0x87ceebff;
      case 'slateblue':
        return 0x6a5acdff;
      case 'slategray':
        return 0x708090ff;
      case 'slategrey':
        return 0x708090ff;
      case 'snow':
        return 0xfffafaff;
      case 'springgreen':
        return 0x00ff7fff;
      case 'steelblue':
        return 0x4682b4ff;
      case 'tan':
        return 0xd2b48cff;
      case 'teal':
        return 0x008080ff;
      case 'thistle':
        return 0xd8bfd8ff;
      case 'tomato':
        return 0xff6347ff;
      case 'turquoise':
        return 0x40e0d0ff;
      case 'violet':
        return 0xee82eeff;
      case 'wheat':
        return 0xf5deb3ff;
      case 'white':
        return 0xffffffff;
      case 'whitesmoke':
        return 0xf5f5f5ff;
      case 'yellow':
        return 0xffff00ff;
      case 'yellowgreen':
        return 0x9acd32ff;
    }
    return null;
  }
  module.exports = normalizeColor;
},63,[],"node_modules/react-native-web/node_modules/@react-native/normalize-colors/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /* eslint-disable */

  /**
   * JS Implementation of MurmurHash2
   *
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *
   * @param {string} str ASCII only
   * @param {number} seed Positive integer only
   * @return {number} 32-bit positive integer hash
   *
   * 
   */

  function murmurhash2_32_gc(str, seed) {
    var l = str.length,
      h = seed ^ l,
      i = 0,
      k;
    while (l >= 4) {
      k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      k ^= k >>> 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
      l -= 4;
      ++i;
    }
    switch (l) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 0xff;
        h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    }
    h ^= h >>> 13;
    h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    h ^= h >>> 15;
    return h >>> 0;
  }
  var hash = str => murmurhash2_32_gc(str, 1).toString(36);
  var _default = hash;
},64,[],"node_modules/react-native-web/dist/exports/StyleSheet/compiler/hash.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var uppercasePattern = /[A-Z]/g;
  var msPattern = /^ms-/;
  var cache = {};
  function toHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  function hyphenateStyleName(name) {
    if (name in cache) {
      return cache[name];
    }
    var hName = name.replace(uppercasePattern, toHyphenLower);
    return cache[name] = msPattern.test(hName) ? '-' + hName : hName;
  }
  var _default = hyphenateStyleName;
},65,[],"node_modules/react-native-web/dist/exports/StyleSheet/compiler/hyphenateStyleName.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _inlineStylePrefixerLibCreatePrefixer = require(_dependencyMap[0], "inline-style-prefixer/lib/createPrefixer");
  var createPrefixer = _interopDefault(_inlineStylePrefixerLibCreatePrefixer);
  var _static = require(_dependencyMap[1], "./static");
  var staticData = _interopDefault(_static);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var prefixAll = (0, createPrefixer.default)(staticData.default);
  var _default = prefixAll;
},66,[67,73],"node_modules/react-native-web/dist/modules/prefixStyles/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createPrefixer;
  var _prefixProperty = require(_dependencyMap[0], "./utils/prefixProperty");
  var _prefixProperty2 = _interopRequireDefault(_prefixProperty);
  var _prefixValue = require(_dependencyMap[1], "./utils/prefixValue");
  var _prefixValue2 = _interopRequireDefault(_prefixValue);
  var _addNewValuesOnly = require(_dependencyMap[2], "./utils/addNewValuesOnly");
  var _addNewValuesOnly2 = _interopRequireDefault(_addNewValuesOnly);
  var _isObject = require(_dependencyMap[3], "./utils/isObject");
  var _isObject2 = _interopRequireDefault(_isObject);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function createPrefixer(_ref) {
    var prefixMap = _ref.prefixMap,
      plugins = _ref.plugins;
    return function prefix(style) {
      for (var property in style) {
        var value = style[property];

        // handle nested objects
        if ((0, _isObject2.default)(value)) {
          style[property] = prefix(value);
          // handle array values
        } else if (Array.isArray(value)) {
          var combinedValue = [];
          for (var i = 0, len = value.length; i < len; ++i) {
            var processedValue = (0, _prefixValue2.default)(plugins, property, value[i], style, prefixMap);
            (0, _addNewValuesOnly2.default)(combinedValue, processedValue || value[i]);
          }

          // only modify the value if it was touched
          // by any plugin to prevent unnecessary mutations
          if (combinedValue.length > 0) {
            style[property] = combinedValue;
          }
        } else {
          var _processedValue = (0, _prefixValue2.default)(plugins, property, value, style, prefixMap);

          // only modify the value if it was touched
          // by any plugin to prevent unnecessary mutations
          if (_processedValue) {
            style[property] = _processedValue;
          }
          style = (0, _prefixProperty2.default)(prefixMap, property, style);
        }
      }
      return style;
    };
  }
},67,[68,70,71,72],"node_modules/inline-style-prefixer/lib/createPrefixer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixProperty;
  var _capitalizeString = require(_dependencyMap[0], "./capitalizeString");
  var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function prefixProperty(prefixProperties, property, style) {
    var requiredPrefixes = prefixProperties[property];
    if (requiredPrefixes && style.hasOwnProperty(property)) {
      var capitalizedProperty = (0, _capitalizeString2.default)(property);
      for (var i = 0; i < requiredPrefixes.length; ++i) {
        var prefixedProperty = requiredPrefixes[i] + capitalizedProperty;
        if (!style[prefixedProperty]) {
          style[prefixedProperty] = style[property];
        }
      }
    }
    return style;
  }
},68,[69],"node_modules/inline-style-prefixer/lib/utils/prefixProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = capitalizeString;
  function capitalizeString(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
},69,[],"node_modules/inline-style-prefixer/lib/utils/capitalizeString.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixValue;
  function prefixValue(plugins, property, value, style, metaData) {
    for (var i = 0, len = plugins.length; i < len; ++i) {
      var processedValue = plugins[i](property, value, style, metaData);

      // we can stop processing if a value is returned
      // as all plugin criteria are unique
      if (processedValue) {
        return processedValue;
      }
    }
  }
},70,[],"node_modules/inline-style-prefixer/lib/utils/prefixValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addNewValuesOnly;
  function addIfNew(list, value) {
    if (list.indexOf(value) === -1) {
      list.push(value);
    }
  }
  function addNewValuesOnly(list, values) {
    if (Array.isArray(values)) {
      for (var i = 0, len = values.length; i < len; ++i) {
        addIfNew(list, values[i]);
      }
    } else {
      addIfNew(list, values);
    }
  }
},71,[],"node_modules/inline-style-prefixer/lib/utils/addNewValuesOnly.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isObject;
  function isObject(value) {
    return value instanceof Object && !Array.isArray(value);
  }
},72,[],"node_modules/inline-style-prefixer/lib/utils/isObject.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _inlineStylePrefixerLibPluginsCrossFade = require(_dependencyMap[0], "inline-style-prefixer/lib/plugins/crossFade");
  var crossFade = _interopDefault(_inlineStylePrefixerLibPluginsCrossFade);
  var _inlineStylePrefixerLibPluginsImageSet = require(_dependencyMap[1], "inline-style-prefixer/lib/plugins/imageSet");
  var imageSet = _interopDefault(_inlineStylePrefixerLibPluginsImageSet);
  var _inlineStylePrefixerLibPluginsLogical = require(_dependencyMap[2], "inline-style-prefixer/lib/plugins/logical");
  var logical = _interopDefault(_inlineStylePrefixerLibPluginsLogical);
  var _inlineStylePrefixerLibPluginsPosition = require(_dependencyMap[3], "inline-style-prefixer/lib/plugins/position");
  var position = _interopDefault(_inlineStylePrefixerLibPluginsPosition);
  var _inlineStylePrefixerLibPluginsSizing = require(_dependencyMap[4], "inline-style-prefixer/lib/plugins/sizing");
  var sizing = _interopDefault(_inlineStylePrefixerLibPluginsSizing);
  var _inlineStylePrefixerLibPluginsTransition = require(_dependencyMap[5], "inline-style-prefixer/lib/plugins/transition");
  var transition = _interopDefault(_inlineStylePrefixerLibPluginsTransition);
  var w = ['Webkit'];
  var m = ['Moz'];
  var wm = ['Webkit', 'Moz'];
  var wms = ['Webkit', 'ms'];
  var wmms = ['Webkit', 'Moz', 'ms'];
  var _default = {
    plugins: [crossFade.default, imageSet.default, logical.default, position.default, sizing.default, transition.default],
    prefixMap: {
      appearance: wmms,
      userSelect: wm,
      textEmphasisPosition: wms,
      textEmphasis: wms,
      textEmphasisStyle: wms,
      textEmphasisColor: wms,
      boxDecorationBreak: wms,
      clipPath: w,
      maskImage: wms,
      maskMode: wms,
      maskRepeat: wms,
      maskPosition: wms,
      maskClip: wms,
      maskOrigin: wms,
      maskSize: wms,
      maskComposite: wms,
      mask: wms,
      maskBorderSource: wms,
      maskBorderMode: wms,
      maskBorderSlice: wms,
      maskBorderWidth: wms,
      maskBorderOutset: wms,
      maskBorderRepeat: wms,
      maskBorder: wms,
      maskType: wms,
      textDecorationStyle: w,
      textDecorationSkip: w,
      textDecorationLine: w,
      textDecorationColor: w,
      filter: w,
      breakAfter: w,
      breakBefore: w,
      breakInside: w,
      columnCount: w,
      columnFill: w,
      columnGap: w,
      columnRule: w,
      columnRuleColor: w,
      columnRuleStyle: w,
      columnRuleWidth: w,
      columns: w,
      columnSpan: w,
      columnWidth: w,
      backdropFilter: w,
      hyphens: w,
      flowInto: w,
      flowFrom: w,
      regionFragment: w,
      textOrientation: w,
      tabSize: m,
      fontKerning: w,
      textSizeAdjust: w
    }
  };
},73,[74,89,91,92,93,94],"node_modules/react-native-web/dist/modules/prefixStyles/static.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = crossFade;
  var _cssInJsUtils = require(_dependencyMap[0], "css-in-js-utils");
  var CROSS_FADE_REGEX = /cross-fade\(/g;
  // http://caniuse.com/#search=cross-fade
  var prefixes = ['-webkit-', ''];
  function crossFade(property, value) {
    if (typeof value === 'string' && !(0, _cssInJsUtils.isPrefixedValue)(value) && value.indexOf('cross-fade(') !== -1) {
      return prefixes.map(function (prefix) {
        return value.replace(CROSS_FADE_REGEX, prefix + 'cross-fade(');
      });
    }
  }
},74,[75],"node_modules/inline-style-prefixer/lib/plugins/crossFade.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "assignStyle", {
    enumerable: true,
    get: function () {
      return assignStyle.default;
    }
  });
  Object.defineProperty(exports, "camelCaseProperty", {
    enumerable: true,
    get: function () {
      return camelCaseProperty.default;
    }
  });
  Object.defineProperty(exports, "cssifyDeclaration", {
    enumerable: true,
    get: function () {
      return cssifyDeclaration.default;
    }
  });
  Object.defineProperty(exports, "cssifyObject", {
    enumerable: true,
    get: function () {
      return cssifyObject.default;
    }
  });
  Object.defineProperty(exports, "hyphenateProperty", {
    enumerable: true,
    get: function () {
      return hyphenateProperty.default;
    }
  });
  Object.defineProperty(exports, "isPrefixedProperty", {
    enumerable: true,
    get: function () {
      return isPrefixedProperty.default;
    }
  });
  Object.defineProperty(exports, "isPrefixedValue", {
    enumerable: true,
    get: function () {
      return isPrefixedValue.default;
    }
  });
  Object.defineProperty(exports, "isUnitlessProperty", {
    enumerable: true,
    get: function () {
      return isUnitlessProperty.default;
    }
  });
  Object.defineProperty(exports, "normalizeProperty", {
    enumerable: true,
    get: function () {
      return normalizeProperty.default;
    }
  });
  Object.defineProperty(exports, "resolveArrayValue", {
    enumerable: true,
    get: function () {
      return resolveArrayValue.default;
    }
  });
  Object.defineProperty(exports, "unprefixProperty", {
    enumerable: true,
    get: function () {
      return unprefixProperty.default;
    }
  });
  Object.defineProperty(exports, "unprefixValue", {
    enumerable: true,
    get: function () {
      return unprefixValue.default;
    }
  });
  var _assignStyle = require(_dependencyMap[0], "./assignStyle");
  var assignStyle = _interopDefault(_assignStyle);
  var _camelCaseProperty = require(_dependencyMap[1], "./camelCaseProperty");
  var camelCaseProperty = _interopDefault(_camelCaseProperty);
  var _cssifyDeclaration = require(_dependencyMap[2], "./cssifyDeclaration");
  var cssifyDeclaration = _interopDefault(_cssifyDeclaration);
  var _cssifyObject = require(_dependencyMap[3], "./cssifyObject");
  var cssifyObject = _interopDefault(_cssifyObject);
  var _hyphenateProperty = require(_dependencyMap[4], "./hyphenateProperty");
  var hyphenateProperty = _interopDefault(_hyphenateProperty);
  var _isPrefixedProperty = require(_dependencyMap[5], "./isPrefixedProperty");
  var isPrefixedProperty = _interopDefault(_isPrefixedProperty);
  var _isPrefixedValue = require(_dependencyMap[6], "./isPrefixedValue");
  var isPrefixedValue = _interopDefault(_isPrefixedValue);
  var _isUnitlessProperty = require(_dependencyMap[7], "./isUnitlessProperty");
  var isUnitlessProperty = _interopDefault(_isUnitlessProperty);
  var _normalizeProperty = require(_dependencyMap[8], "./normalizeProperty");
  var normalizeProperty = _interopDefault(_normalizeProperty);
  var _resolveArrayValue = require(_dependencyMap[9], "./resolveArrayValue");
  var resolveArrayValue = _interopDefault(_resolveArrayValue);
  var _unprefixProperty = require(_dependencyMap[10], "./unprefixProperty");
  var unprefixProperty = _interopDefault(_unprefixProperty);
  var _unprefixValue = require(_dependencyMap[11], "./unprefixValue");
  var unprefixValue = _interopDefault(_unprefixValue);
},75,[76,77,78,81,79,82,83,84,85,87,86,88],"node_modules/css-in-js-utils/es/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return assignStyle;
    }
  });
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }
    return _typeof(obj);
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function filterUniqueArray(arr) {
    return arr.filter(function (val, index) {
      return arr.lastIndexOf(val) === index;
    });
  }
  function assignStyle(base) {
    for (var i = 0, len = arguments.length <= 1 ? 0 : arguments.length - 1; i < len; ++i) {
      var style = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
      for (var property in style) {
        var value = style[property];
        var baseValue = base[property];
        if (baseValue && value) {
          if (Array.isArray(baseValue)) {
            base[property] = filterUniqueArray(baseValue.concat(value));
            continue;
          }
          if (Array.isArray(value)) {
            base[property] = filterUniqueArray([baseValue].concat(_toConsumableArray(value)));
            continue;
          }
          if (_typeof(value) === 'object') {
            base[property] = assignStyle({}, baseValue, value);
            continue;
          }
        }
        base[property] = value;
      }
    }
    return base;
  }
},76,[],"node_modules/css-in-js-utils/es/assignStyle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return camelCaseProperty;
    }
  });
  var DASH = /-([a-z])/g;
  var MS = /^Ms/g;
  var cache = {};
  function toUpper(match) {
    return match[1].toUpperCase();
  }
  function camelCaseProperty(property) {
    if (cache.hasOwnProperty(property)) {
      return cache[property];
    }
    var camelProp = property.replace(DASH, toUpper).replace(MS, 'ms');
    cache[property] = camelProp;
    return camelProp;
  }
},77,[],"node_modules/css-in-js-utils/es/camelCaseProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return cssifyDeclaration;
    }
  });
  var _hyphenateProperty = require(_dependencyMap[0], "./hyphenateProperty");
  var hyphenateProperty = _interopDefault(_hyphenateProperty);
  function cssifyDeclaration(property, value) {
    return (0, hyphenateProperty.default)(property) + ':' + value;
  }
},78,[79],"node_modules/css-in-js-utils/es/cssifyDeclaration.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return hyphenateProperty;
    }
  });
  var _hyphenateStyleName = require(_dependencyMap[0], "hyphenate-style-name");
  var hyphenateStyleName = _interopDefault(_hyphenateStyleName);
  function hyphenateProperty(property) {
    return (0, hyphenateStyleName.default)(property);
  }
},79,[80],"node_modules/css-in-js-utils/es/hyphenateProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /* eslint-disable no-var, prefer-template */
  var uppercasePattern = /[A-Z]/g;
  var msPattern = /^ms-/;
  var cache = {};
  function toHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  function hyphenateStyleName(name) {
    if (cache.hasOwnProperty(name)) {
      return cache[name];
    }
    var hName = name.replace(uppercasePattern, toHyphenLower);
    return cache[name] = msPattern.test(hName) ? '-' + hName : hName;
  }
  var _default = hyphenateStyleName;
},80,[],"node_modules/hyphenate-style-name/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return cssifyObject;
    }
  });
  var _cssifyDeclaration = require(_dependencyMap[0], "./cssifyDeclaration");
  var cssifyDeclaration = _interopDefault(_cssifyDeclaration);
  function cssifyObject(style) {
    var css = '';
    for (var property in style) {
      var value = style[property];
      if (typeof value !== 'string' && typeof value !== 'number') {
        continue;
      } // prevents the semicolon after
      // the last rule declaration

      if (css) {
        css += ';';
      }
      css += (0, cssifyDeclaration.default)(property, value);
    }
    return css;
  }
},81,[78],"node_modules/css-in-js-utils/es/cssifyObject.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return isPrefixedProperty;
    }
  });
  var RE = /^(Webkit|Moz|O|ms)/;
  function isPrefixedProperty(property) {
    return RE.test(property);
  }
},82,[],"node_modules/css-in-js-utils/es/isPrefixedProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return isPrefixedValue;
    }
  });
  var RE = /-webkit-|-moz-|-ms-/;
  function isPrefixedValue(value) {
    return typeof value === 'string' && RE.test(value);
  }
},83,[],"node_modules/css-in-js-utils/es/isPrefixedValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return isUnitlessProperty;
    }
  });
  var _hyphenateProperty = require(_dependencyMap[0], "./hyphenateProperty");
  var hyphenateProperty = _interopDefault(_hyphenateProperty);
  var unitlessProperties = {
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    fontWeight: true,
    lineHeight: true,
    opacity: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related properties
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  var prefixedUnitlessProperties = ['animationIterationCount', 'boxFlex', 'boxFlexGroup', 'boxOrdinalGroup', 'columnCount', 'flex', 'flexGrow', 'flexPositive', 'flexShrink', 'flexNegative', 'flexOrder', 'gridColumn', 'gridColumnEnd', 'gridColumnStart', 'gridRow', 'gridRowEnd', 'gridRowStart', 'lineClamp', 'order'];
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
  function getPrefixedProperty(prefix, property) {
    return prefix + property.charAt(0).toUpperCase() + property.slice(1);
  } // add all prefixed properties to the unitless properties

  for (var i = 0, len = prefixedUnitlessProperties.length; i < len; ++i) {
    var property = prefixedUnitlessProperties[i];
    unitlessProperties[property] = true;
    for (var j = 0, jLen = prefixes.length; j < jLen; ++j) {
      unitlessProperties[getPrefixedProperty(prefixes[j], property)] = true;
    }
  } // add all hypenated properties as well

  for (var _property in unitlessProperties) {
    unitlessProperties[(0, hyphenateProperty.default)(_property)] = true;
  }
  function isUnitlessProperty(property) {
    return unitlessProperties.hasOwnProperty(property);
  }
},84,[79],"node_modules/css-in-js-utils/es/isUnitlessProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return normalizeProperty;
    }
  });
  var _camelCaseProperty = require(_dependencyMap[0], "./camelCaseProperty");
  var camelCaseProperty = _interopDefault(_camelCaseProperty);
  var _unprefixProperty = require(_dependencyMap[1], "./unprefixProperty");
  var unprefixProperty = _interopDefault(_unprefixProperty);
  function normalizeProperty(property) {
    return (0, unprefixProperty.default)((0, camelCaseProperty.default)(property));
  }
},85,[77,86],"node_modules/css-in-js-utils/es/normalizeProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return unprefixProperty;
    }
  });
  var RE = /^(ms|Webkit|Moz|O)/;
  function unprefixProperty(property) {
    var propertyWithoutPrefix = property.replace(RE, '');
    return propertyWithoutPrefix.charAt(0).toLowerCase() + propertyWithoutPrefix.slice(1);
  }
},86,[],"node_modules/css-in-js-utils/es/unprefixProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return resolveArrayValue;
    }
  });
  var _hyphenateProperty = require(_dependencyMap[0], "./hyphenateProperty");
  var hyphenateProperty = _interopDefault(_hyphenateProperty);
  function resolveArrayValue(property, value) {
    return value.join(';' + (0, hyphenateProperty.default)(property) + ':');
  }
},87,[79],"node_modules/css-in-js-utils/es/resolveArrayValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return unprefixValue;
    }
  });
  var RE = /(-ms-|-webkit-|-moz-|-o-)/g;
  function unprefixValue(value) {
    if (typeof value === 'string') {
      return value.replace(RE, '');
    }
    return value;
  }
},88,[],"node_modules/css-in-js-utils/es/unprefixValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = imageSet;
  var _isPrefixedValue = require(_dependencyMap[0], "css-in-js-utils/lib/isPrefixedValue");
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  // http://caniuse.com/#feat=css-image-set
  var prefixes = ['-webkit-', ''];
  function imageSet(property, value) {
    if (typeof value === 'string' && !(0, _isPrefixedValue2.default)(value) && value.indexOf('image-set(') > -1) {
      return prefixes.map(function (prefix) {
        return value.replace(/image-set\(/g, prefix + 'image-set(');
      });
    }
  }
},89,[90],"node_modules/inline-style-prefixer/lib/plugins/imageSet.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = isPrefixedValue;
  var RE = /-webkit-|-moz-|-ms-/;
  function isPrefixedValue(value) {
    return typeof value === 'string' && RE.test(value);
  }
},90,[],"node_modules/css-in-js-utils/lib/isPrefixedValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = logical;
  var alternativeProps = {
    marginBlockStart: ['WebkitMarginBefore'],
    marginBlockEnd: ['WebkitMarginAfter'],
    marginInlineStart: ['WebkitMarginStart', 'MozMarginStart'],
    marginInlineEnd: ['WebkitMarginEnd', 'MozMarginEnd'],
    paddingBlockStart: ['WebkitPaddingBefore'],
    paddingBlockEnd: ['WebkitPaddingAfter'],
    paddingInlineStart: ['WebkitPaddingStart', 'MozPaddingStart'],
    paddingInlineEnd: ['WebkitPaddingEnd', 'MozPaddingEnd'],
    borderBlockStart: ['WebkitBorderBefore'],
    borderBlockStartColor: ['WebkitBorderBeforeColor'],
    borderBlockStartStyle: ['WebkitBorderBeforeStyle'],
    borderBlockStartWidth: ['WebkitBorderBeforeWidth'],
    borderBlockEnd: ['WebkitBorderAfter'],
    borderBlockEndColor: ['WebkitBorderAfterColor'],
    borderBlockEndStyle: ['WebkitBorderAfterStyle'],
    borderBlockEndWidth: ['WebkitBorderAfterWidth'],
    borderInlineStart: ['WebkitBorderStart', 'MozBorderStart'],
    borderInlineStartColor: ['WebkitBorderStartColor', 'MozBorderStartColor'],
    borderInlineStartStyle: ['WebkitBorderStartStyle', 'MozBorderStartStyle'],
    borderInlineStartWidth: ['WebkitBorderStartWidth', 'MozBorderStartWidth'],
    borderInlineEnd: ['WebkitBorderEnd', 'MozBorderEnd'],
    borderInlineEndColor: ['WebkitBorderEndColor', 'MozBorderEndColor'],
    borderInlineEndStyle: ['WebkitBorderEndStyle', 'MozBorderEndStyle'],
    borderInlineEndWidth: ['WebkitBorderEndWidth', 'MozBorderEndWidth']
  };
  function logical(property, value, style) {
    if (Object.prototype.hasOwnProperty.call(alternativeProps, property)) {
      var alternativePropList = alternativeProps[property];
      for (var i = 0, len = alternativePropList.length; i < len; ++i) {
        style[alternativePropList[i]] = value;
      }
    }
  }
},91,[],"node_modules/inline-style-prefixer/lib/plugins/logical.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = position;
  function position(property, value) {
    if (property === 'position' && value === 'sticky') {
      return ['-webkit-sticky', 'sticky'];
    }
  }
},92,[],"node_modules/inline-style-prefixer/lib/plugins/position.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = sizing;
  var prefixes = ['-webkit-', '-moz-', ''];
  var properties = {
    maxHeight: true,
    maxWidth: true,
    width: true,
    height: true,
    columnWidth: true,
    minWidth: true,
    minHeight: true
  };
  var values = {
    'min-content': true,
    'max-content': true,
    'fill-available': true,
    'fit-content': true,
    'contain-floats': true
  };
  function sizing(property, value) {
    if (properties.hasOwnProperty(property) && values.hasOwnProperty(value)) {
      return prefixes.map(function (prefix) {
        return prefix + value;
      });
    }
  }
},93,[],"node_modules/inline-style-prefixer/lib/plugins/sizing.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = transition;
  var _hyphenateProperty = require(_dependencyMap[0], "css-in-js-utils/lib/hyphenateProperty");
  var _hyphenateProperty2 = _interopRequireDefault(_hyphenateProperty);
  var _isPrefixedValue = require(_dependencyMap[1], "css-in-js-utils/lib/isPrefixedValue");
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  var _capitalizeString = require(_dependencyMap[2], "../utils/capitalizeString");
  var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var properties = {
    transition: true,
    transitionProperty: true,
    WebkitTransition: true,
    WebkitTransitionProperty: true,
    MozTransition: true,
    MozTransitionProperty: true
  };
  var prefixMapping = {
    Webkit: '-webkit-',
    Moz: '-moz-',
    ms: '-ms-'
  };
  function prefixValue(value, propertyPrefixMap) {
    if ((0, _isPrefixedValue2.default)(value)) {
      return value;
    }

    // only split multi values, not cubic beziers
    var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);
    for (var i = 0, len = multipleValues.length; i < len; ++i) {
      var singleValue = multipleValues[i];
      var values = [singleValue];
      for (var property in propertyPrefixMap) {
        var dashCaseProperty = (0, _hyphenateProperty2.default)(property);
        if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== 'order') {
          var prefixes = propertyPrefixMap[property];
          for (var j = 0, pLen = prefixes.length; j < pLen; ++j) {
            // join all prefixes and create a new value
            values.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes[j]] + dashCaseProperty));
          }
        }
      }
      multipleValues[i] = values.join(',');
    }
    return multipleValues.join(',');
  }
  function transition(property, value, style, propertyPrefixMap) {
    // also check for already prefixed transitions
    if (typeof value === 'string' && properties.hasOwnProperty(property)) {
      var outputValue = prefixValue(value, propertyPrefixMap);
      // if the property is already prefixed
      var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
        return !/-moz-|-ms-/.test(val);
      }).join(',');
      if (property.indexOf('Webkit') > -1) {
        return webkitOutput;
      }
      var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
        return !/-webkit-|-ms-/.test(val);
      }).join(',');
      if (property.indexOf('Moz') > -1) {
        return mozOutput;
      }
      style['Webkit' + (0, _capitalizeString2.default)(property)] = webkitOutput;
      style['Moz' + (0, _capitalizeString2.default)(property)] = mozOutput;
      return outputValue;
    }
  }
},94,[95,90,69],"node_modules/inline-style-prefixer/lib/plugins/transition.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = hyphenateProperty;
  var _hyphenateStyleName = require(_dependencyMap[0], "hyphenate-style-name");
  var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  function hyphenateProperty(property) {
    return (0, _hyphenateStyleName2["default"])(property);
  }
},95,[80],"node_modules/css-in-js-utils/lib/hyphenateProperty.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.createSheet = createSheet;
  var _modulesCanUseDom = require(_dependencyMap[0], "../../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  var _createCSSStyleSheet = require(_dependencyMap[1], "./createCSSStyleSheet");
  var createCSSStyleSheet = _interopDefault(_createCSSStyleSheet);
  var _createOrderedCSSStyleSheet = require(_dependencyMap[2], "./createOrderedCSSStyleSheet");
  var createOrderedCSSStyleSheet = _interopDefault(_createOrderedCSSStyleSheet);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var defaultId = 'react-native-stylesheet';
  var roots = new WeakMap();
  var sheets = [];
  var initialRules = [
  // minimal top-level reset
  'html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:rgba(0,0,0,0);}', 'body{margin:0;}',
  // minimal form pseudo-element reset
  'button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0;}', 'input::-webkit-search-cancel-button,input::-webkit-search-decoration,input::-webkit-search-results-button,input::-webkit-search-results-decoration{display:none;}'];
  function createSheet(root, id) {
    if (id === void 0) {
      id = defaultId;
    }
    var sheet;
    if (canUseDOM.default) {
      var rootNode = root != null ? root.getRootNode() : document;
      // Create the initial style sheet
      if (sheets.length === 0) {
        sheet = (0, createOrderedCSSStyleSheet.default)((0, createCSSStyleSheet.default)(id));
        initialRules.forEach(rule => {
          sheet.insert(rule, 0);
        });
        roots.set(rootNode, sheets.length);
        sheets.push(sheet);
      } else {
        var index = roots.get(rootNode);
        if (index == null) {
          var initialSheet = sheets[0];
          // If we're creating a new sheet, populate it with existing styles
          var textContent = initialSheet != null ? initialSheet.getTextContent() : '';
          // Cast rootNode to 'any' because Flow types for getRootNode are wrong
          sheet = (0, createOrderedCSSStyleSheet.default)((0, createCSSStyleSheet.default)(id, rootNode, textContent));
          roots.set(rootNode, sheets.length);
          sheets.push(sheet);
        } else {
          sheet = sheets[index];
        }
      }
    } else {
      // Create the initial style sheet
      if (sheets.length === 0) {
        sheet = (0, createOrderedCSSStyleSheet.default)((0, createCSSStyleSheet.default)(id));
        initialRules.forEach(rule => {
          sheet.insert(rule, 0);
        });
        sheets.push(sheet);
      } else {
        sheet = sheets[0];
      }
    }
    return {
      getTextContent() {
        return sheet.getTextContent();
      },
      id,
      insert(cssText, groupValue) {
        sheets.forEach(s => {
          s.insert(cssText, groupValue);
        });
      }
    };
  }
},96,[45,97,98],"node_modules/react-native-web/dist/exports/StyleSheet/dom/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return createCSSStyleSheet;
    }
  });
  var _modulesCanUseDom = require(_dependencyMap[0], "../../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  // $FlowFixMe: HTMLStyleElement is incorrectly typed - https://github.com/facebook/flow/issues/2696
  function createCSSStyleSheet(id, rootNode, textContent) {
    if (canUseDOM.default) {
      var root = rootNode != null ? rootNode : document;
      var element = root.getElementById(id);
      if (element == null) {
        element = document.createElement('style');
        element.setAttribute('id', id);
        if (typeof textContent === 'string') {
          element.appendChild(document.createTextNode(textContent));
        }
        if (root instanceof ShadowRoot) {
          root.insertBefore(element, root.firstChild);
        } else {
          var head = root.head;
          if (head) {
            head.insertBefore(element, head.firstChild);
          }
        }
      }
      // $FlowFixMe: HTMLElement is incorrectly typed
      return element.sheet;
    } else {
      return null;
    }
  }
},97,[45],"node_modules/react-native-web/dist/exports/StyleSheet/dom/createCSSStyleSheet.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return createOrderedCSSStyleSheet;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var slice = Array.prototype.slice;

  /**
   * Order-based insertion of CSS.
   *
   * Each rule is associated with a numerically defined group.
   * Groups are ordered within the style sheet according to their number, with the
   * lowest first.
   *
   * Groups are implemented using marker rules. The selector of the first rule of
   * each group is used only to encode the group number for hydration. An
   * alternative implementation could rely on CSSMediaRule, allowing groups to be
   * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is
   * broken.
   * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule
   * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674
   */
  function createOrderedCSSStyleSheet(sheet) {
    var groups = {};
    var selectors = {};

    /**
     * Hydrate approximate record from any existing rules in the sheet.
     */
    if (sheet != null) {
      var group;
      slice.call(sheet.cssRules).forEach((cssRule, i) => {
        var cssText = cssRule.cssText;
        // Create record of existing selectors and rules
        if (cssText.indexOf('stylesheet-group') > -1) {
          group = decodeGroupRule(cssRule);
          groups[group] = {
            start: i,
            rules: [cssText]
          };
        } else {
          var selectorText = getSelectorText(cssText);
          if (selectorText != null) {
            selectors[selectorText] = true;
            groups[group].rules.push(cssText);
          }
        }
      });
    }
    function sheetInsert(sheet, group, text) {
      var orderedGroups = getOrderedGroups(groups);
      var groupIndex = orderedGroups.indexOf(group);
      var nextGroupIndex = groupIndex + 1;
      var nextGroup = orderedGroups[nextGroupIndex];
      // Insert rule before the next group, or at the end of the stylesheet
      var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start : sheet.cssRules.length;
      var isInserted = insertRuleAt(sheet, text, position);
      if (isInserted) {
        // Set the starting index of the new group
        if (groups[group].start == null) {
          groups[group].start = position;
        }
        // Increment the starting index of all subsequent groups
        for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {
          var groupNumber = orderedGroups[i];
          var previousStart = groups[groupNumber].start || 0;
          groups[groupNumber].start = previousStart + 1;
        }
      }
      return isInserted;
    }
    var OrderedCSSStyleSheet = {
      /**
       * The textContent of the style sheet.
       */
      getTextContent() {
        return getOrderedGroups(groups).map(group => {
          var rules = groups[group].rules;
          // Sorting provides deterministic order of styles in group for
          // build-time extraction of the style sheet.
          var marker = rules.shift();
          rules.sort();
          rules.unshift(marker);
          return rules.join('\n');
        }).join('\n');
      },
      /**
       * Insert a rule into the style sheet
       */
      insert(cssText, groupValue) {
        var group = Number(groupValue);

        // Create a new group.
        if (groups[group] == null) {
          var markerRule = encodeGroupRule(group);
          // Create the internal record.
          groups[group] = {
            start: null,
            rules: [markerRule]
          };
          // Update CSSOM.
          if (sheet != null) {
            sheetInsert(sheet, group, markerRule);
          }
        }

        // selectorText is more reliable than cssText for insertion checks. The
        // browser excludes vendor-prefixed properties and rewrites certain values
        // making cssText more likely to be different from what was inserted.
        var selectorText = getSelectorText(cssText);
        if (selectorText != null && selectors[selectorText] == null) {
          // Update the internal records.
          selectors[selectorText] = true;
          groups[group].rules.push(cssText);
          // Update CSSOM.
          if (sheet != null) {
            var isInserted = sheetInsert(sheet, group, cssText);
            if (!isInserted) {
              // Revert internal record change if a rule was rejected (e.g.,
              // unrecognized pseudo-selector)
              groups[group].rules.pop();
            }
          }
        }
      }
    };
    return OrderedCSSStyleSheet;
  }

  /**
   * Helper functions
   */

  function encodeGroupRule(group) {
    return "[stylesheet-group=\"" + group + "\"]{}";
  }
  var groupPattern = /["']/g;
  function decodeGroupRule(cssRule) {
    return Number(cssRule.selectorText.split(groupPattern)[1]);
  }
  function getOrderedGroups(obj) {
    return Object.keys(obj).map(Number).sort((a, b) => a > b ? 1 : -1);
  }
  var selectorPattern = /\s*([,])\s*/g;
  function getSelectorText(cssText) {
    var selector = cssText.split('{')[0].trim();
    return selector !== '' ? selector.replace(selectorPattern, '$1') : null;
  }
  function insertRuleAt(root, cssText, position) {
    try {
      // $FlowFixMe: Flow is missing CSSOM types needed to type 'root'.
      root.insertRule(cssText, position);
      return true;
    } catch (e) {
      // JSDOM doesn't support `CSSSMediaRule#insertRule`.
      // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.
      return false;
    }
  }
},98,[],"node_modules/react-native-web/dist/exports/StyleSheet/dom/createOrderedCSSStyleSheet.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  module.exports = require(_dependencyMap[0], "./dist/transform-localize-style");
},99,[100],"node_modules/styleq/transform-localize-style.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.localizeStyle = localizeStyle;
  var cache = new WeakMap();
  var markerProp = '$$css$localize';
  /**
   * The compiler polyfills logical properties and values, generating a class
   * name for both writing directions. The style objects are annotated by
   * the compiler as needing this runtime transform. The results are memoized.
   *
   * { '$$css$localize': true, float: [ 'float-left', 'float-right' ] }
   * => { float: 'float-left' }
   */

  function compileStyle(style, isRTL) {
    // Create a new compiled style for styleq
    var compiledStyle = {};
    for (var prop in style) {
      if (prop !== markerProp) {
        var value = style[prop];
        if (Array.isArray(value)) {
          compiledStyle[prop] = isRTL ? value[1] : value[0];
        } else {
          compiledStyle[prop] = value;
        }
      }
    }
    return compiledStyle;
  }
  function localizeStyle(style, isRTL) {
    if (style[markerProp] != null) {
      var compiledStyleIndex = isRTL ? 1 : 0; // Check the cache in case we've already seen this object

      if (cache.has(style)) {
        var _cachedStyles = cache.get(style);
        var _compiledStyle = _cachedStyles[compiledStyleIndex];
        if (_compiledStyle == null) {
          // Update the missing cache entry
          _compiledStyle = compileStyle(style, isRTL);
          _cachedStyles[compiledStyleIndex] = _compiledStyle;
          cache.set(style, _cachedStyles);
        }
        return _compiledStyle;
      } // Create a new compiled style for styleq

      var compiledStyle = compileStyle(style, isRTL);
      var cachedStyles = new Array(2);
      cachedStyles[compiledStyleIndex] = compiledStyle;
      cache.set(style, cachedStyles);
      return compiledStyle;
    }
    return style;
  }
},100,[],"node_modules/styleq/dist/transform-localize-style.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "createBoxShadowValue", {
    enumerable: true,
    get: function () {
      return createBoxShadowValue;
    }
  });
  Object.defineProperty(exports, "createTextShadowValue", {
    enumerable: true,
    get: function () {
      return createTextShadowValue;
    }
  });
  Object.defineProperty(exports, "createBoxShadowArrayValue", {
    enumerable: true,
    get: function () {
      return createBoxShadowArrayValue;
    }
  });
  Object.defineProperty(exports, "createTransformValue", {
    enumerable: true,
    get: function () {
      return createTransformValue;
    }
  });
  Object.defineProperty(exports, "createTransformOriginValue", {
    enumerable: true,
    get: function () {
      return createTransformOriginValue;
    }
  });
  Object.defineProperty(exports, "preprocess", {
    enumerable: true,
    get: function () {
      return preprocess;
    }
  });
  var _compilerNormalizeColor = require(_dependencyMap[0], "./compiler/normalizeColor");
  var normalizeColor = _interopDefault(_compilerNormalizeColor);
  var _compilerNormalizeValueWithProperty = require(_dependencyMap[1], "./compiler/normalizeValueWithProperty");
  var normalizeValueWithProperty = _interopDefault(_compilerNormalizeValueWithProperty);
  var _modulesWarnOnce = require(_dependencyMap[2], "../../modules/warnOnce");
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyObject = {};

  /**
   * Shadows
   */

  var defaultOffset = {
    height: 0,
    width: 0
  };
  var createBoxShadowValue = style => {
    var shadowColor = style.shadowColor,
      shadowOffset = style.shadowOffset,
      shadowOpacity = style.shadowOpacity,
      shadowRadius = style.shadowRadius;
    var _ref = shadowOffset || defaultOffset,
      height = _ref.height,
      width = _ref.width;
    var offsetX = (0, normalizeValueWithProperty.default)(width);
    var offsetY = (0, normalizeValueWithProperty.default)(height);
    var blurRadius = (0, normalizeValueWithProperty.default)(shadowRadius || 0);
    var color = (0, normalizeColor.default)(shadowColor || 'black', shadowOpacity);
    if (color != null && offsetX != null && offsetY != null && blurRadius != null) {
      return offsetX + " " + offsetY + " " + blurRadius + " " + color;
    }
  };
  var createTextShadowValue = style => {
    var textShadowColor = style.textShadowColor,
      textShadowOffset = style.textShadowOffset,
      textShadowRadius = style.textShadowRadius;
    var _ref2 = textShadowOffset || defaultOffset,
      height = _ref2.height,
      width = _ref2.width;
    var radius = textShadowRadius || 0;
    var offsetX = (0, normalizeValueWithProperty.default)(width);
    var offsetY = (0, normalizeValueWithProperty.default)(height);
    var blurRadius = (0, normalizeValueWithProperty.default)(radius);
    var color = (0, normalizeValueWithProperty.default)(textShadowColor, 'textShadowColor');
    if (color && (height !== 0 || width !== 0 || radius !== 0) && offsetX != null && offsetY != null && blurRadius != null) {
      return offsetX + " " + offsetY + " " + blurRadius + " " + color;
    }
  };

  // { offsetX: 1, offsetY: 2, blurRadius: 3, spreadDistance: 4, color: 'rgba(255, 0, 0)', inset: true }
  // => 'rgba(255, 0, 0) 1px 2px 3px 4px inset'
  var mapBoxShadow = boxShadow => {
    if (typeof boxShadow === 'string') {
      return boxShadow;
    }
    var offsetX = (0, normalizeValueWithProperty.default)(boxShadow.offsetX) || 0;
    var offsetY = (0, normalizeValueWithProperty.default)(boxShadow.offsetY) || 0;
    var blurRadius = (0, normalizeValueWithProperty.default)(boxShadow.blurRadius) || 0;
    var spreadDistance = (0, normalizeValueWithProperty.default)(boxShadow.spreadDistance) || 0;
    var color = (0, normalizeColor.default)(boxShadow.color) || 'black';
    var position = boxShadow.inset ? 'inset ' : '';
    return "" + position + offsetX + " " + offsetY + " " + blurRadius + " " + spreadDistance + " " + color;
  };
  var createBoxShadowArrayValue = value => {
    return value.map(mapBoxShadow).join(', ');
  };

  // { scale: 2 } => 'scale(2)'
  // { translateX: 20 } => 'translateX(20px)'
  // { matrix: [1,2,3,4,5,6] } => 'matrix(1,2,3,4,5,6)'
  var mapTransform = transform => {
    var type = Object.keys(transform)[0];
    var value = transform[type];
    if (type === 'matrix' || type === 'matrix3d') {
      return type + "(" + value.join(',') + ")";
    } else {
      var normalizedValue = (0, normalizeValueWithProperty.default)(value, type);
      return type + "(" + normalizedValue + ")";
    }
  };
  var createTransformValue = value => {
    return value.map(mapTransform).join(' ');
  };

  // [2, '30%', 10] => '2px 30% 10px'
  var createTransformOriginValue = value => {
    return value.map(v => (0, normalizeValueWithProperty.default)(v)).join(' ');
  };
  var PROPERTIES_STANDARD = {
    borderBottomEndRadius: 'borderEndEndRadius',
    borderBottomStartRadius: 'borderEndStartRadius',
    borderTopEndRadius: 'borderStartEndRadius',
    borderTopStartRadius: 'borderStartStartRadius',
    borderEndColor: 'borderInlineEndColor',
    borderEndStyle: 'borderInlineEndStyle',
    borderEndWidth: 'borderInlineEndWidth',
    borderStartColor: 'borderInlineStartColor',
    borderStartStyle: 'borderInlineStartStyle',
    borderStartWidth: 'borderInlineStartWidth',
    end: 'insetInlineEnd',
    marginEnd: 'marginInlineEnd',
    marginHorizontal: 'marginInline',
    marginStart: 'marginInlineStart',
    marginVertical: 'marginBlock',
    paddingEnd: 'paddingInlineEnd',
    paddingHorizontal: 'paddingInline',
    paddingStart: 'paddingInlineStart',
    paddingVertical: 'paddingBlock',
    start: 'insetInlineStart'
  };
  var ignoredProps = {
    elevation: true,
    overlayColor: true,
    resizeMode: true,
    tintColor: true
  };

  /**
   * Preprocess styles
   */
  var preprocess = function preprocess(originalStyle, options) {
    if (options === void 0) {
      options = {};
    }
    var style = originalStyle || emptyObject;
    var nextStyle = {};

    // Convert shadow styles
    if (options.shadow === true, style.shadowColor != null || style.shadowOffset != null || style.shadowOpacity != null || style.shadowRadius != null) {
      (0, _modulesWarnOnce.warnOnce)('shadowStyles', "\"shadow*\" style props are deprecated. Use \"boxShadow\".");
      var boxShadowValue = createBoxShadowValue(style);
      if (boxShadowValue != null) {
        nextStyle.boxShadow = boxShadowValue;
      }
    }

    // Convert text shadow styles
    if (options.textShadow === true, style.textShadowColor != null || style.textShadowOffset != null || style.textShadowRadius != null) {
      (0, _modulesWarnOnce.warnOnce)('textShadowStyles', "\"textShadow*\" style props are deprecated. Use \"textShadow\".");
      var textShadowValue = createTextShadowValue(style);
      if (textShadowValue != null && nextStyle.textShadow == null) {
        var textShadow = style.textShadow;
        var value = textShadow ? textShadow + ", " + textShadowValue : textShadowValue;
        nextStyle.textShadow = value;
      }
    }
    for (var originalProp in style) {
      if (
      // Ignore some React Native styles
      ignoredProps[originalProp] != null || originalProp === 'shadowColor' || originalProp === 'shadowOffset' || originalProp === 'shadowOpacity' || originalProp === 'shadowRadius' || originalProp === 'textShadowColor' || originalProp === 'textShadowOffset' || originalProp === 'textShadowRadius') {
        continue;
      }
      var originalValue = style[originalProp];
      var prop = PROPERTIES_STANDARD[originalProp] || originalProp;
      var _value = originalValue;
      if (!Object.prototype.hasOwnProperty.call(style, originalProp) || prop !== originalProp && style[prop] != null) {
        continue;
      }
      if (prop === 'aspectRatio' && typeof _value === 'number') {
        nextStyle[prop] = _value.toString();
      } else if (prop === 'boxShadow') {
        if (Array.isArray(_value)) {
          _value = createBoxShadowArrayValue(_value);
        }
        var boxShadow = nextStyle.boxShadow;
        nextStyle.boxShadow = boxShadow ? _value + ", " + boxShadow : _value;
      } else if (prop === 'fontVariant') {
        if (Array.isArray(_value) && _value.length > 0) {
          /*
          warnOnce(
            'fontVariant',
            '"fontVariant" style array value is deprecated. Use space-separated values.'
          );
          */
          _value = _value.join(' ');
        }
        nextStyle[prop] = _value;
      } else if (prop === 'textAlignVertical') {
        /*
        warnOnce(
          'textAlignVertical',
          '"textAlignVertical" style is deprecated. Use "verticalAlign".'
        );
        */
        if (style.verticalAlign == null) {
          nextStyle.verticalAlign = _value === 'center' ? 'middle' : _value;
        }
      } else if (prop === 'transform') {
        if (Array.isArray(_value)) {
          _value = createTransformValue(_value);
        }
        nextStyle.transform = _value;
      } else if (prop === 'transformOrigin') {
        if (Array.isArray(_value)) {
          _value = createTransformOriginValue(_value);
        }
        nextStyle.transformOrigin = _value;
      } else {
        nextStyle[prop] = _value;
      }
    }

    // $FlowIgnore
    return nextStyle;
  };
  var _default = preprocess;
},101,[60,58,102],"node_modules/react-native-web/dist/exports/StyleSheet/preprocess.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.warnOnce = warnOnce;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var warnedKeys = {};

  /**
   * A simple function that prints a warning message once per session.
   *
   * @param {string} key - The key used to ensure the message is printed once.
   *                       This should be unique to the callsite.
   * @param {string} message - The message to print
   */
  function warnOnce(key, message) {
    if (process.env.NODE_ENV !== 'production') {
      if (warnedKeys[key]) {
        return;
      }
      console.warn(message);
      warnedKeys[key] = true;
    }
  }
},102,[],"node_modules/react-native-web/dist/modules/warnOnce/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.styleq = void 0;
  var cache = new WeakMap();
  var compiledKey = '$$css';
  function createStyleq(options) {
    var disableCache;
    var disableMix;
    var transform;
    if (options != null) {
      disableCache = options.disableCache === true;
      disableMix = options.disableMix === true;
      transform = options.transform;
    }
    return function styleq() {
      // Keep track of property commits to the className
      var definedProperties = []; // The className and inline style to build up

      var className = '';
      var inlineStyle = null; // The current position in the cache graph

      var nextCache = disableCache ? null : cache; // This way of creating an array from arguments is fastest

      var styles = new Array(arguments.length);
      for (var i = 0; i < arguments.length; i++) {
        styles[i] = arguments[i];
      } // Iterate over styles from last to first

      while (styles.length > 0) {
        var possibleStyle = styles.pop(); // Skip empty items

        if (possibleStyle == null || possibleStyle === false) {
          continue;
        } // Push nested styles back onto the stack to be processed

        if (Array.isArray(possibleStyle)) {
          for (var _i = 0; _i < possibleStyle.length; _i++) {
            styles.push(possibleStyle[_i]);
          }
          continue;
        } // Process an individual style object

        var style = transform != null ? transform(possibleStyle) : possibleStyle;
        if (style.$$css) {
          // Build up the class names defined by this object
          var classNameChunk = ''; // Check the cache to see if we've already done this work

          if (nextCache != null && nextCache.has(style)) {
            // Cache: read
            var cacheEntry = nextCache.get(style);
            if (cacheEntry != null) {
              classNameChunk = cacheEntry[0]; // $FlowIgnore

              definedProperties.push.apply(definedProperties, cacheEntry[1]);
              nextCache = cacheEntry[2];
            }
          } // Update the chunks with data from this object
          else {
            // The properties defined by this object
            var definedPropertiesChunk = [];
            for (var prop in style) {
              var value = style[prop];
              if (prop === compiledKey) continue; // Each property value is used as an HTML class name
              // { 'debug.string': 'debug.string', opacity: 's-jskmnoqp' }

              if (typeof value === 'string' || value === null) {
                // Only add to chunks if this property hasn't already been seen
                if (!definedProperties.includes(prop)) {
                  definedProperties.push(prop);
                  if (nextCache != null) {
                    definedPropertiesChunk.push(prop);
                  }
                  if (typeof value === 'string') {
                    classNameChunk += classNameChunk ? ' ' + value : value;
                  }
                }
              } // If we encounter a value that isn't a string or `null`
              else {
                console.error("styleq: ".concat(prop, " typeof ").concat(String(value), " is not \"string\" or \"null\"."));
              }
            } // Cache: write

            if (nextCache != null) {
              // Create the next WeakMap for this sequence of styles
              var weakMap = new WeakMap();
              nextCache.set(style, [classNameChunk, definedPropertiesChunk, weakMap]);
              nextCache = weakMap;
            }
          } // Order of classes in chunks matches property-iteration order of style
          // object. Order of chunks matches passed order of styles from first to
          // last (which we iterate over in reverse).

          if (classNameChunk) {
            className = className ? classNameChunk + ' ' + className : classNameChunk;
          }
        } // ----- DYNAMIC: Process inline style object -----
        else {
          if (disableMix) {
            if (inlineStyle == null) {
              inlineStyle = {};
            }
            inlineStyle = Object.assign({}, style, inlineStyle);
          } else {
            var subStyle = null;
            for (var _prop in style) {
              var _value = style[_prop];
              if (_value !== undefined) {
                if (!definedProperties.includes(_prop)) {
                  if (_value != null) {
                    if (inlineStyle == null) {
                      inlineStyle = {};
                    }
                    if (subStyle == null) {
                      subStyle = {};
                    }
                    subStyle[_prop] = _value;
                  }
                  definedProperties.push(_prop); // Cache is unnecessary overhead if results can't be reused.

                  nextCache = null;
                }
              }
            }
            if (subStyle != null) {
              inlineStyle = Object.assign(subStyle, inlineStyle);
            }
          }
        }
      }
      var styleProps = [className, inlineStyle];
      return styleProps;
    };
  }
  var styleq = createStyleq();
  exports.styleq = styleq;
  styleq.factory = createStyleq;
},103,[],"node_modules/styleq/dist/styleq.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.validate = validate;
  var _postcssValueParser = require(_dependencyMap[0], "postcss-value-parser");
  var valueParser = _interopDefault(_postcssValueParser);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var invalidShortforms = {
    background: true,
    borderBottom: true,
    borderLeft: true,
    borderRight: true,
    borderTop: true,
    font: true,
    grid: true,
    outline: true,
    textDecoration: true
  };
  var invalidMultiValueShortforms = {
    flex: true,
    margin: true,
    padding: true,
    borderColor: true,
    borderRadius: true,
    borderStyle: true,
    borderWidth: true,
    inset: true,
    insetBlock: true,
    insetInline: true,
    marginBlock: true,
    marginInline: true,
    marginHorizontal: true,
    marginVertical: true,
    paddingBlock: true,
    paddingInline: true,
    paddingHorizontal: true,
    paddingVertical: true,
    overflow: true,
    overscrollBehavior: true,
    backgroundPosition: true
  };
  function error(message) {
    console.error(message);
  }
  function validate(obj) {
    for (var k in obj) {
      var prop = k.trim();
      var value = obj[prop];
      var isInvalid = false;
      if (value === null) {
        continue;
      }
      if (typeof value === 'string' && value.indexOf('!important') > -1) {
        error("Invalid style declaration \"" + prop + ":" + value + "\". Values cannot include \"!important\"");
        isInvalid = true;
      } else {
        var suggestion = '';
        if (prop === 'animation' || prop === 'animationName') {
          suggestion = 'Did you mean "animationKeyframes"?';
          isInvalid = true;
        } else if (prop === 'direction') {
          suggestion = 'Did you mean "writingDirection"?';
          isInvalid = true;
        } else if (invalidShortforms[prop]) {
          suggestion = 'Please use long-form properties.';
          isInvalid = true;
        } else if (invalidMultiValueShortforms[prop]) {
          if (typeof value === 'string' && (0, valueParser.default)(value).nodes.length > 1) {
            suggestion = "Value is \"" + value + "\" but only single values are supported.";
            isInvalid = true;
          }
        }
        if (suggestion !== '') {
          error("Invalid style property of \"" + prop + "\". " + suggestion);
        }
      }
      if (isInvalid) {
        delete obj[k];
      }
    }
  }
},104,[105],"node_modules/react-native-web/dist/exports/StyleSheet/validate.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var parse = require(_dependencyMap[0], "./parse");
  var walk = require(_dependencyMap[1], "./walk");
  var stringify = require(_dependencyMap[2], "./stringify");
  function ValueParser(value) {
    if (this instanceof ValueParser) {
      this.nodes = parse(value);
      return this;
    }
    return new ValueParser(value);
  }
  ValueParser.prototype.toString = function () {
    return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
  };
  ValueParser.prototype.walk = function (cb, bubble) {
    walk(this.nodes, cb, bubble);
    return this;
  };
  ValueParser.unit = require(_dependencyMap[3], "./unit");
  ValueParser.walk = walk;
  ValueParser.stringify = stringify;
  module.exports = ValueParser;
},105,[106,107,108,109],"node_modules/postcss-value-parser/lib/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var openParentheses = "(".charCodeAt(0);
  var closeParentheses = ")".charCodeAt(0);
  var singleQuote = "'".charCodeAt(0);
  var doubleQuote = '"'.charCodeAt(0);
  var backslash = "\\".charCodeAt(0);
  var slash = "/".charCodeAt(0);
  var comma = ",".charCodeAt(0);
  var colon = ":".charCodeAt(0);
  var star = "*".charCodeAt(0);
  var uLower = "u".charCodeAt(0);
  var uUpper = "U".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var isUnicodeRange = /^[a-f0-9?-]+$/i;
  module.exports = function (input) {
    var tokens = [];
    var value = input;
    var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
    var pos = 0;
    var code = value.charCodeAt(pos);
    var max = value.length;
    var stack = [{
      nodes: tokens
    }];
    var balanced = 0;
    var parent;
    var name = "";
    var before = "";
    var after = "";
    while (pos < max) {
      // Whitespaces
      if (code <= 32) {
        next = pos;
        do {
          next += 1;
          code = value.charCodeAt(next);
        } while (code <= 32);
        token = value.slice(pos, next);
        prev = tokens[tokens.length - 1];
        if (code === closeParentheses && balanced) {
          after = token;
        } else if (prev && prev.type === "div") {
          prev.after = token;
          prev.sourceEndIndex += token.length;
        } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
          before = token;
        } else {
          tokens.push({
            type: "space",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        }
        pos = next;

        // Quotes
      } else if (code === singleQuote || code === doubleQuote) {
        next = pos;
        quote = code === singleQuote ? "'" : '"';
        token = {
          type: "string",
          sourceIndex: pos,
          quote: quote
        };
        do {
          escape = false;
          next = value.indexOf(quote, next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += quote;
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        token.value = value.slice(pos + 1, next);
        token.sourceEndIndex = token.unclosed ? next : next + 1;
        tokens.push(token);
        pos = next + 1;
        code = value.charCodeAt(pos);

        // Comments
      } else if (code === slash && value.charCodeAt(pos + 1) === star) {
        next = value.indexOf("*/", pos);
        token = {
          type: "comment",
          sourceIndex: pos,
          sourceEndIndex: next + 2
        };
        if (next === -1) {
          token.unclosed = true;
          next = value.length;
          token.sourceEndIndex = next;
        }
        token.value = value.slice(pos + 2, next);
        tokens.push(token);
        pos = next + 2;
        code = value.charCodeAt(pos);

        // Operation within calc
      } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
        token = value[pos];
        tokens.push({
          type: "word",
          sourceIndex: pos - before.length,
          sourceEndIndex: pos + token.length,
          value: token
        });
        pos += 1;
        code = value.charCodeAt(pos);

        // Dividers
      } else if (code === slash || code === comma || code === colon) {
        token = value[pos];
        tokens.push({
          type: "div",
          sourceIndex: pos - before.length,
          sourceEndIndex: pos + token.length,
          value: token,
          before: before,
          after: ""
        });
        before = "";
        pos += 1;
        code = value.charCodeAt(pos);

        // Open parentheses
      } else if (openParentheses === code) {
        // Whitespaces after open parentheses
        next = pos;
        do {
          next += 1;
          code = value.charCodeAt(next);
        } while (code <= 32);
        parenthesesOpenPos = pos;
        token = {
          type: "function",
          sourceIndex: pos - name.length,
          value: name,
          before: value.slice(parenthesesOpenPos + 1, next)
        };
        pos = next;
        if (name === "url" && code !== singleQuote && code !== doubleQuote) {
          next -= 1;
          do {
            escape = false;
            next = value.indexOf(")", next + 1);
            if (~next) {
              escapePos = next;
              while (value.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape = !escape;
              }
            } else {
              value += ")";
              next = value.length - 1;
              token.unclosed = true;
            }
          } while (escape);
          // Whitespaces before closed
          whitespacePos = next;
          do {
            whitespacePos -= 1;
            code = value.charCodeAt(whitespacePos);
          } while (code <= 32);
          if (parenthesesOpenPos < whitespacePos) {
            if (pos !== whitespacePos + 1) {
              token.nodes = [{
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: whitespacePos + 1,
                value: value.slice(pos, whitespacePos + 1)
              }];
            } else {
              token.nodes = [];
            }
            if (token.unclosed && whitespacePos + 1 !== next) {
              token.after = "";
              token.nodes.push({
                type: "space",
                sourceIndex: whitespacePos + 1,
                sourceEndIndex: next,
                value: value.slice(whitespacePos + 1, next)
              });
            } else {
              token.after = value.slice(whitespacePos + 1, next);
              token.sourceEndIndex = next;
            }
          } else {
            token.after = "";
            token.nodes = [];
          }
          pos = next + 1;
          token.sourceEndIndex = token.unclosed ? next : pos;
          code = value.charCodeAt(pos);
          tokens.push(token);
        } else {
          balanced += 1;
          token.after = "";
          token.sourceEndIndex = pos + 1;
          tokens.push(token);
          stack.push(token);
          tokens = token.nodes = [];
          parent = token;
        }
        name = "";

        // Close parentheses
      } else if (closeParentheses === code && balanced) {
        pos += 1;
        code = value.charCodeAt(pos);
        parent.after = after;
        parent.sourceEndIndex += after.length;
        after = "";
        balanced -= 1;
        stack[stack.length - 1].sourceEndIndex = pos;
        stack.pop();
        parent = stack[balanced];
        tokens = parent.nodes;

        // Words
      } else {
        next = pos;
        do {
          if (code === backslash) {
            next += 1;
          }
          next += 1;
          code = value.charCodeAt(next);
        } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
        token = value.slice(pos, next);
        if (openParentheses === code) {
          name = token;
        } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
          tokens.push({
            type: "unicode-range",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        } else {
          tokens.push({
            type: "word",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        }
        pos = next;
      }
    }
    for (pos = stack.length - 1; pos; pos -= 1) {
      stack[pos].unclosed = true;
      stack[pos].sourceEndIndex = value.length;
    }
    return stack[0].nodes;
  };
},106,[],"node_modules/postcss-value-parser/lib/parse.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = function walk(nodes, cb, bubble) {
    var i, max, node, result;
    for (i = 0, max = nodes.length; i < max; i += 1) {
      node = nodes[i];
      if (!bubble) {
        result = cb(node, i, nodes);
      }
      if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
        walk(node.nodes, cb, bubble);
      }
      if (bubble) {
        cb(node, i, nodes);
      }
    }
  };
},107,[],"node_modules/postcss-value-parser/lib/walk.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stringifyNode(node, custom) {
    var type = node.type;
    var value = node.value;
    var buf;
    var customResult;
    if (custom && (customResult = custom(node)) !== undefined) {
      return customResult;
    } else if (type === "word" || type === "space") {
      return value;
    } else if (type === "string") {
      buf = node.quote || "";
      return buf + value + (node.unclosed ? "" : buf);
    } else if (type === "comment") {
      return "/*" + value + (node.unclosed ? "" : "*/");
    } else if (type === "div") {
      return (node.before || "") + value + (node.after || "");
    } else if (Array.isArray(node.nodes)) {
      buf = stringify(node.nodes, custom);
      if (type !== "function") {
        return buf;
      }
      return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
    }
    return value;
  }
  function stringify(nodes, custom) {
    var result, i;
    if (Array.isArray(nodes)) {
      result = "";
      for (i = nodes.length - 1; ~i; i -= 1) {
        result = stringifyNode(nodes[i], custom) + result;
      }
      return result;
    }
    return stringifyNode(nodes, custom);
  }
  module.exports = stringify;
},108,[],"node_modules/postcss-value-parser/lib/stringify.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var minus = "-".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var dot = ".".charCodeAt(0);
  var exp = "e".charCodeAt(0);
  var EXP = "E".charCodeAt(0);

  // Check if three code points would start a number
  // https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
  function likeNumber(value) {
    var code = value.charCodeAt(0);
    var nextCode;
    if (code === plus || code === minus) {
      nextCode = value.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      var nextNextCode = value.charCodeAt(2);
      if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code === dot) {
      nextCode = value.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code >= 48 && code <= 57) {
      return true;
    }
    return false;
  }

  // Consume a number
  // https://www.w3.org/TR/css-syntax-3/#consume-number
  module.exports = function (value) {
    var pos = 0;
    var length = value.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length === 0 || !likeNumber(value)) {
      return false;
    }
    code = value.charCodeAt(pos);
    if (code === plus || code === minus) {
      pos++;
    }
    while (pos < length) {
      code = value.charCodeAt(pos);
      if (code < 48 || code > 57) {
        break;
      }
      pos += 1;
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
      pos += 2;
      while (pos < length) {
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    nextNextCode = value.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
      pos += nextCode === plus || nextCode === minus ? 3 : 2;
      while (pos < length) {
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    return {
      number: value.slice(0, pos),
      unit: value.slice(pos)
    };
  };
},109,[],"node_modules/postcss-value-parser/lib/unit.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[2], "../createElement");
  var createElement = _interopDefault(_createElement);
  var _modulesForwardedProps = require(_dependencyMap[3], "../../modules/forwardedProps");
  var forwardedProps = _interopNamespace(_modulesForwardedProps);
  var _modulesPick = require(_dependencyMap[4], "../../modules/pick");
  var pick = _interopDefault(_modulesPick);
  var _modulesUseElementLayout = require(_dependencyMap[5], "../../modules/useElementLayout");
  var useElementLayout = _interopDefault(_modulesUseElementLayout);
  var _modulesUseMergeRefs = require(_dependencyMap[6], "../../modules/useMergeRefs");
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePlatformMethods = require(_dependencyMap[7], "../../modules/usePlatformMethods");
  var usePlatformMethods = _interopDefault(_modulesUsePlatformMethods);
  var _modulesUseResponderEvents = require(_dependencyMap[8], "../../modules/useResponderEvents");
  var useResponderEvents = _interopDefault(_modulesUseResponderEvents);
  var _StyleSheet = require(_dependencyMap[9], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _TextTextAncestorContext = require(_dependencyMap[10], "../Text/TextAncestorContext");
  var TextAncestorContext = _interopDefault(_TextTextAncestorContext);
  var _modulesUseLocale = require(_dependencyMap[11], "../../modules/useLocale");
  var _excluded = ["hrefAttrs", "onLayout", "onMoveShouldSetResponder", "onMoveShouldSetResponderCapture", "onResponderEnd", "onResponderGrant", "onResponderMove", "onResponderReject", "onResponderRelease", "onResponderStart", "onResponderTerminate", "onResponderTerminationRequest", "onScrollShouldSetResponder", "onScrollShouldSetResponderCapture", "onSelectionChangeShouldSetResponder", "onSelectionChangeShouldSetResponderCapture", "onStartShouldSetResponder", "onStartShouldSetResponderCapture"];
  var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
    href: true,
    lang: true,
    onScroll: true,
    onWheel: true,
    pointerEvents: true
  });
  var pickProps = props => (0, pick.default)(props, forwardPropsList);
  var View = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var hrefAttrs = props.hrefAttrs,
      onLayout = props.onLayout,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    if (process.env.NODE_ENV !== 'production') {
      React.Children.toArray(props.children).forEach(item => {
        if (typeof item === 'string') {
          console.error("Unexpected text node: " + item + ". A text node cannot be a child of a <View>.");
        }
      });
    }
    var hasTextAncestor = React.useContext(TextAncestorContext.default);
    var hostRef = React.useRef(null);
    var _useLocaleContext = (0, _modulesUseLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;
    (0, useElementLayout.default)(hostRef, onLayout);
    (0, useResponderEvents.default)(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    var component = 'div';
    var langDirection = props.lang != null ? (0, _modulesUseLocale.getLocaleDirection)(props.lang) : null;
    var componentDirection = props.dir || langDirection;
    var writingDirection = componentDirection || contextDirection;
    var supportedProps = pickProps(rest);
    supportedProps.dir = componentDirection;
    supportedProps.style = [styles.view$raw, hasTextAncestor && styles.inline, props.style];
    if (props.href != null) {
      component = 'a';
      if (hrefAttrs != null) {
        var download = hrefAttrs.download,
          rel = hrefAttrs.rel,
          target = hrefAttrs.target;
        if (download != null) {
          supportedProps.download = download;
        }
        if (rel != null) {
          supportedProps.rel = rel;
        }
        if (typeof target === 'string') {
          supportedProps.target = target.charAt(0) !== '_' ? '_' + target : target;
        }
      }
    }
    var platformMethodsRef = (0, usePlatformMethods.default)(supportedProps);
    var setRef = (0, useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
    supportedProps.ref = setRef;
    return (0, createElement.default)(component, supportedProps, {
      writingDirection
    });
  });
  View.displayName = 'View';
  var styles = StyleSheet.default.create({
    view$raw: {
      alignContent: 'flex-start',
      alignItems: 'stretch',
      backgroundColor: 'transparent',
      border: '0 solid black',
      boxSizing: 'border-box',
      display: 'flex',
      flexBasis: 'auto',
      flexDirection: 'column',
      flexShrink: 0,
      listStyle: 'none',
      margin: 0,
      minHeight: 0,
      minWidth: 0,
      padding: 0,
      position: 'relative',
      textDecoration: 'none',
      zIndex: 0
    },
    inline: {
      display: 'inline-flex'
    }
  });
  var _default = View;
},110,[43,9,111,119,120,121,123,124,126,55,133,117],"node_modules/react-native-web/dist/exports/View/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesAccessibilityUtil = require(_dependencyMap[0], "../../modules/AccessibilityUtil");
  var AccessibilityUtil = _interopDefault(_modulesAccessibilityUtil);
  var _modulesCreateDOMProps = require(_dependencyMap[1], "../../modules/createDOMProps");
  var createDOMProps = _interopDefault(_modulesCreateDOMProps);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopDefault(_react);
  var _modulesUseLocale = require(_dependencyMap[3], "../../modules/useLocale");
  var createElement = (component, props, options) => {
    // Use equivalent platform elements where possible.
    var accessibilityComponent;
    if (component && component.constructor === String) {
      accessibilityComponent = AccessibilityUtil.default.propsToAccessibilityComponent(props);
    }
    var Component = accessibilityComponent || component;
    var domProps = (0, createDOMProps.default)(Component, props, options);
    var element = /*#__PURE__*/React.default.createElement(Component, domProps);

    // Update locale context if element's writing direction prop changes
    var elementWithLocaleProvider = domProps.dir ? /*#__PURE__*/React.default.createElement(_modulesUseLocale.LocaleProvider, {
      children: element,
      direction: domProps.dir,
      locale: domProps.lang
    }) : element;
    return elementWithLocaleProvider;
  };
  var _default = createElement;
},111,[112,116,9,117],"node_modules/react-native-web/dist/exports/createElement/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _isDisabled = require(_dependencyMap[0], "./isDisabled");
  var isDisabled = _interopDefault(_isDisabled);
  var _propsToAccessibilityComponent = require(_dependencyMap[1], "./propsToAccessibilityComponent");
  var propsToAccessibilityComponent = _interopDefault(_propsToAccessibilityComponent);
  var _propsToAriaRole = require(_dependencyMap[2], "./propsToAriaRole");
  var propsToAriaRole = _interopDefault(_propsToAriaRole);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var AccessibilityUtil = {
    isDisabled: isDisabled.default,
    propsToAccessibilityComponent: propsToAccessibilityComponent.default,
    propsToAriaRole: propsToAriaRole.default
  };
  var _default = AccessibilityUtil;
},112,[113,114,115],"node_modules/react-native-web/dist/modules/AccessibilityUtil/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var isDisabled = props => props.disabled || Array.isArray(props.accessibilityStates) && props.accessibilityStates.indexOf('disabled') > -1;
  var _default = isDisabled;
},113,[],"node_modules/react-native-web/dist/modules/AccessibilityUtil/isDisabled.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _propsToAriaRole = require(_dependencyMap[0], "./propsToAriaRole");
  var propsToAriaRole = _interopDefault(_propsToAriaRole);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var roleComponents = {
    article: 'article',
    banner: 'header',
    blockquote: 'blockquote',
    button: 'button',
    code: 'code',
    complementary: 'aside',
    contentinfo: 'footer',
    deletion: 'del',
    emphasis: 'em',
    figure: 'figure',
    insertion: 'ins',
    form: 'form',
    list: 'ul',
    listitem: 'li',
    main: 'main',
    navigation: 'nav',
    paragraph: 'p',
    region: 'section',
    strong: 'strong'
  };
  var emptyObject = {};
  var propsToAccessibilityComponent = function propsToAccessibilityComponent(props) {
    if (props === void 0) {
      props = emptyObject;
    }
    var roleProp = props.role || props.accessibilityRole;
    // special-case for "label" role which doesn't map to an ARIA role
    if (roleProp === 'label') {
      return 'label';
    }
    var role = (0, propsToAriaRole.default)(props);
    if (role) {
      if (role === 'heading') {
        var level = props.accessibilityLevel || props['aria-level'];
        if (level != null) {
          return "h" + level;
        }
        return 'h1';
      }
      return roleComponents[role];
    }
  };
  var _default = propsToAccessibilityComponent;
},114,[115],"node_modules/react-native-web/dist/modules/AccessibilityUtil/propsToAccessibilityComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var accessibilityRoleToWebRole = {
    adjustable: 'slider',
    button: 'button',
    header: 'heading',
    image: 'img',
    imagebutton: null,
    keyboardkey: null,
    label: null,
    link: 'link',
    none: 'presentation',
    search: 'search',
    summary: 'region',
    text: null
  };
  var propsToAriaRole = _ref => {
    var accessibilityRole = _ref.accessibilityRole,
      role = _ref.role;
    var _role = role || accessibilityRole;
    if (_role) {
      var inferredRole = accessibilityRoleToWebRole[_role];
      if (inferredRole !== null) {
        // ignore roles that don't map to web
        return inferredRole || _role;
      }
    }
  };
  var _default = propsToAriaRole;
},115,[],"node_modules/react-native-web/dist/modules/AccessibilityUtil/propsToAriaRole.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _AccessibilityUtil = require(_dependencyMap[2], "../AccessibilityUtil");
  var AccessibilityUtil = _interopDefault(_AccessibilityUtil);
  var _exportsStyleSheet = require(_dependencyMap[3], "../../exports/StyleSheet");
  var StyleSheet = _interopDefault(_exportsStyleSheet);
  var _warnOnce = require(_dependencyMap[4], "../warnOnce");
  var _excluded = ["aria-activedescendant", "accessibilityActiveDescendant", "aria-atomic", "accessibilityAtomic", "aria-autocomplete", "accessibilityAutoComplete", "aria-busy", "accessibilityBusy", "aria-checked", "accessibilityChecked", "aria-colcount", "accessibilityColumnCount", "aria-colindex", "accessibilityColumnIndex", "aria-colspan", "accessibilityColumnSpan", "aria-controls", "accessibilityControls", "aria-current", "accessibilityCurrent", "aria-describedby", "accessibilityDescribedBy", "aria-details", "accessibilityDetails", "aria-disabled", "accessibilityDisabled", "aria-errormessage", "accessibilityErrorMessage", "aria-expanded", "accessibilityExpanded", "aria-flowto", "accessibilityFlowTo", "aria-haspopup", "accessibilityHasPopup", "aria-hidden", "accessibilityHidden", "aria-invalid", "accessibilityInvalid", "aria-keyshortcuts", "accessibilityKeyShortcuts", "aria-label", "accessibilityLabel", "aria-labelledby", "accessibilityLabelledBy", "aria-level", "accessibilityLevel", "aria-live", "accessibilityLiveRegion", "aria-modal", "accessibilityModal", "aria-multiline", "accessibilityMultiline", "aria-multiselectable", "accessibilityMultiSelectable", "aria-orientation", "accessibilityOrientation", "aria-owns", "accessibilityOwns", "aria-placeholder", "accessibilityPlaceholder", "aria-posinset", "accessibilityPosInSet", "aria-pressed", "accessibilityPressed", "aria-readonly", "accessibilityReadOnly", "aria-required", "accessibilityRequired", "role", "accessibilityRole", "aria-roledescription", "accessibilityRoleDescription", "aria-rowcount", "accessibilityRowCount", "aria-rowindex", "accessibilityRowIndex", "aria-rowspan", "accessibilityRowSpan", "aria-selected", "accessibilitySelected", "aria-setsize", "accessibilitySetSize", "aria-sort", "accessibilitySort", "aria-valuemax", "accessibilityValueMax", "aria-valuemin", "accessibilityValueMin", "aria-valuenow", "accessibilityValueNow", "aria-valuetext", "accessibilityValueText", "dataSet", "focusable", "id", "nativeID", "pointerEvents", "style", "tabIndex", "testID"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyObject = {};
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var uppercasePattern = /[A-Z]/g;
  function toHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  function hyphenateString(str) {
    return str.replace(uppercasePattern, toHyphenLower);
  }
  function processIDRefList(idRefList) {
    return isArray(idRefList) ? idRefList.join(' ') : idRefList;
  }
  var pointerEventsStyles = StyleSheet.default.create({
    auto: {
      pointerEvents: 'auto'
    },
    'box-none': {
      pointerEvents: 'box-none'
    },
    'box-only': {
      pointerEvents: 'box-only'
    },
    none: {
      pointerEvents: 'none'
    }
  });
  var createDOMProps = (elementType, props, options) => {
    if (!props) {
      props = emptyObject;
    }
    var _props = props,
      ariaActiveDescendant = _props['aria-activedescendant'],
      accessibilityActiveDescendant = _props.accessibilityActiveDescendant,
      ariaAtomic = _props['aria-atomic'],
      accessibilityAtomic = _props.accessibilityAtomic,
      ariaAutoComplete = _props['aria-autocomplete'],
      accessibilityAutoComplete = _props.accessibilityAutoComplete,
      ariaBusy = _props['aria-busy'],
      accessibilityBusy = _props.accessibilityBusy,
      ariaChecked = _props['aria-checked'],
      accessibilityChecked = _props.accessibilityChecked,
      ariaColumnCount = _props['aria-colcount'],
      accessibilityColumnCount = _props.accessibilityColumnCount,
      ariaColumnIndex = _props['aria-colindex'],
      accessibilityColumnIndex = _props.accessibilityColumnIndex,
      ariaColumnSpan = _props['aria-colspan'],
      accessibilityColumnSpan = _props.accessibilityColumnSpan,
      ariaControls = _props['aria-controls'],
      accessibilityControls = _props.accessibilityControls,
      ariaCurrent = _props['aria-current'],
      accessibilityCurrent = _props.accessibilityCurrent,
      ariaDescribedBy = _props['aria-describedby'],
      accessibilityDescribedBy = _props.accessibilityDescribedBy,
      ariaDetails = _props['aria-details'],
      accessibilityDetails = _props.accessibilityDetails,
      ariaDisabled = _props['aria-disabled'],
      accessibilityDisabled = _props.accessibilityDisabled,
      ariaErrorMessage = _props['aria-errormessage'],
      accessibilityErrorMessage = _props.accessibilityErrorMessage,
      ariaExpanded = _props['aria-expanded'],
      accessibilityExpanded = _props.accessibilityExpanded,
      ariaFlowTo = _props['aria-flowto'],
      accessibilityFlowTo = _props.accessibilityFlowTo,
      ariaHasPopup = _props['aria-haspopup'],
      accessibilityHasPopup = _props.accessibilityHasPopup,
      ariaHidden = _props['aria-hidden'],
      accessibilityHidden = _props.accessibilityHidden,
      ariaInvalid = _props['aria-invalid'],
      accessibilityInvalid = _props.accessibilityInvalid,
      ariaKeyShortcuts = _props['aria-keyshortcuts'],
      accessibilityKeyShortcuts = _props.accessibilityKeyShortcuts,
      ariaLabel = _props['aria-label'],
      accessibilityLabel = _props.accessibilityLabel,
      ariaLabelledBy = _props['aria-labelledby'],
      accessibilityLabelledBy = _props.accessibilityLabelledBy,
      ariaLevel = _props['aria-level'],
      accessibilityLevel = _props.accessibilityLevel,
      ariaLive = _props['aria-live'],
      accessibilityLiveRegion = _props.accessibilityLiveRegion,
      ariaModal = _props['aria-modal'],
      accessibilityModal = _props.accessibilityModal,
      ariaMultiline = _props['aria-multiline'],
      accessibilityMultiline = _props.accessibilityMultiline,
      ariaMultiSelectable = _props['aria-multiselectable'],
      accessibilityMultiSelectable = _props.accessibilityMultiSelectable,
      ariaOrientation = _props['aria-orientation'],
      accessibilityOrientation = _props.accessibilityOrientation,
      ariaOwns = _props['aria-owns'],
      accessibilityOwns = _props.accessibilityOwns,
      ariaPlaceholder = _props['aria-placeholder'],
      accessibilityPlaceholder = _props.accessibilityPlaceholder,
      ariaPosInSet = _props['aria-posinset'],
      accessibilityPosInSet = _props.accessibilityPosInSet,
      ariaPressed = _props['aria-pressed'],
      accessibilityPressed = _props.accessibilityPressed,
      ariaReadOnly = _props['aria-readonly'],
      accessibilityReadOnly = _props.accessibilityReadOnly,
      ariaRequired = _props['aria-required'],
      accessibilityRequired = _props.accessibilityRequired,
      ariaRole = _props.role,
      accessibilityRole = _props.accessibilityRole,
      ariaRoleDescription = _props['aria-roledescription'],
      accessibilityRoleDescription = _props.accessibilityRoleDescription,
      ariaRowCount = _props['aria-rowcount'],
      accessibilityRowCount = _props.accessibilityRowCount,
      ariaRowIndex = _props['aria-rowindex'],
      accessibilityRowIndex = _props.accessibilityRowIndex,
      ariaRowSpan = _props['aria-rowspan'],
      accessibilityRowSpan = _props.accessibilityRowSpan,
      ariaSelected = _props['aria-selected'],
      accessibilitySelected = _props.accessibilitySelected,
      ariaSetSize = _props['aria-setsize'],
      accessibilitySetSize = _props.accessibilitySetSize,
      ariaSort = _props['aria-sort'],
      accessibilitySort = _props.accessibilitySort,
      ariaValueMax = _props['aria-valuemax'],
      accessibilityValueMax = _props.accessibilityValueMax,
      ariaValueMin = _props['aria-valuemin'],
      accessibilityValueMin = _props.accessibilityValueMin,
      ariaValueNow = _props['aria-valuenow'],
      accessibilityValueNow = _props.accessibilityValueNow,
      ariaValueText = _props['aria-valuetext'],
      accessibilityValueText = _props.accessibilityValueText,
      dataSet = _props.dataSet,
      focusable = _props.focusable,
      id = _props.id,
      nativeID = _props.nativeID,
      pointerEvents = _props.pointerEvents,
      style = _props.style,
      tabIndex = _props.tabIndex,
      testID = _props.testID,
      domProps = (0, _objectWithoutPropertiesLoose.default)(_props, _excluded);

    /*
    if (accessibilityDisabled != null) {
      warnOnce('accessibilityDisabled', `accessibilityDisabled is deprecated.`);
    }
    */
    var disabled = ariaDisabled || accessibilityDisabled;
    var role = AccessibilityUtil.default.propsToAriaRole(props);

    // ACCESSIBILITY
    /*
    if (accessibilityActiveDescendant != null) {
      warnOnce(
        'accessibilityActiveDescendant',
        `accessibilityActiveDescendant is deprecated. Use aria-activedescendant.`
      );
    }
    */
    var _ariaActiveDescendant = ariaActiveDescendant != null ? ariaActiveDescendant : accessibilityActiveDescendant;
    if (_ariaActiveDescendant != null) {
      domProps['aria-activedescendant'] = _ariaActiveDescendant;
    }

    /*
    if (accessibilityAtomic != null) {
      warnOnce(
        'accessibilityAtomic',
        `accessibilityAtomic is deprecated. Use aria-atomic.`
      );
    }
    */
    var _ariaAtomic = ariaAtomic != null ? ariaActiveDescendant : accessibilityAtomic;
    if (_ariaAtomic != null) {
      domProps['aria-atomic'] = _ariaAtomic;
    }

    /*
    if (accessibilityAutoComplete != null) {
      warnOnce(
        'accessibilityAutoComplete',
        `accessibilityAutoComplete is deprecated. Use aria-autocomplete.`
      );
    }
    */
    var _ariaAutoComplete = ariaAutoComplete != null ? ariaAutoComplete : accessibilityAutoComplete;
    if (_ariaAutoComplete != null) {
      domProps['aria-autocomplete'] = _ariaAutoComplete;
    }

    /*
    if (accessibilityBusy != null) {
      warnOnce(
        'accessibilityBusy',
        `accessibilityBusy is deprecated. Use aria-busy.`
      );
    }
    */
    var _ariaBusy = ariaBusy != null ? ariaBusy : accessibilityBusy;
    if (_ariaBusy != null) {
      domProps['aria-busy'] = _ariaBusy;
    }

    /*
    if (accessibilityChecked != null) {
      warnOnce(
        'accessibilityChecked',
        `accessibilityChecked is deprecated. Use aria-checked.`
      );
    }
    */
    var _ariaChecked = ariaChecked != null ? ariaChecked : accessibilityChecked;
    if (_ariaChecked != null) {
      domProps['aria-checked'] = _ariaChecked;
    }

    /*
    if (accessibilityColumnCount != null) {
      warnOnce(
        'accessibilityColumnCount',
        `accessibilityColumnCount is deprecated. Use aria-colcount.`
      );
    }
    */
    var _ariaColumnCount = ariaColumnCount != null ? ariaColumnCount : accessibilityColumnCount;
    if (_ariaColumnCount != null) {
      domProps['aria-colcount'] = _ariaColumnCount;
    }

    /*
    if (accessibilityColumnIndex != null) {
      warnOnce(
        'accessibilityColumnIndex',
        `accessibilityColumnIndex is deprecated. Use aria-colindex.`
      );
    }
    */
    var _ariaColumnIndex = ariaColumnIndex != null ? ariaColumnIndex : accessibilityColumnIndex;
    if (_ariaColumnIndex != null) {
      domProps['aria-colindex'] = _ariaColumnIndex;
    }

    /*
    if (accessibilityColumnSpan != null) {
      warnOnce(
        'accessibilityColumnSpan',
        `accessibilityColumnSpan is deprecated. Use aria-colspan.`
      );
    }
    */
    var _ariaColumnSpan = ariaColumnSpan != null ? ariaColumnSpan : accessibilityColumnSpan;
    if (_ariaColumnSpan != null) {
      domProps['aria-colspan'] = _ariaColumnSpan;
    }

    /*
    if (accessibilityControls != null) {
      warnOnce(
        'accessibilityControls',
        `accessibilityControls is deprecated. Use aria-controls.`
      );
    }
    */
    var _ariaControls = ariaControls != null ? ariaControls : accessibilityControls;
    if (_ariaControls != null) {
      domProps['aria-controls'] = processIDRefList(_ariaControls);
    }

    /*
    if (accessibilityCurrent != null) {
      warnOnce(
        'accessibilityCurrent',
        `accessibilityCurrent is deprecated. Use aria-current.`
      );
    }
    */
    var _ariaCurrent = ariaCurrent != null ? ariaCurrent : accessibilityCurrent;
    if (_ariaCurrent != null) {
      domProps['aria-current'] = _ariaCurrent;
    }

    /*
    if (accessibilityDescribedBy != null) {
      warnOnce(
        'accessibilityDescribedBy',
        `accessibilityDescribedBy is deprecated. Use aria-describedby.`
      );
    }
    */
    var _ariaDescribedBy = ariaDescribedBy != null ? ariaDescribedBy : accessibilityDescribedBy;
    if (_ariaDescribedBy != null) {
      domProps['aria-describedby'] = processIDRefList(_ariaDescribedBy);
    }

    /*
    if (accessibilityDetails != null) {
      warnOnce(
        'accessibilityDetails',
        `accessibilityDetails is deprecated. Use aria-details.`
      );
    }
    */
    var _ariaDetails = ariaDetails != null ? ariaDetails : accessibilityDetails;
    if (_ariaDetails != null) {
      domProps['aria-details'] = _ariaDetails;
    }
    if (disabled === true) {
      domProps['aria-disabled'] = true;
      // Enhance with native semantics
      if (elementType === 'button' || elementType === 'form' || elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        domProps.disabled = true;
      }
    }

    /*
    if (accessibilityErrorMessage != null) {
      warnOnce(
        'accessibilityErrorMessage',
        `accessibilityErrorMessage is deprecated. Use aria-errormessage.`
      );
    }
    */
    var _ariaErrorMessage = ariaErrorMessage != null ? ariaErrorMessage : accessibilityErrorMessage;
    if (_ariaErrorMessage != null) {
      domProps['aria-errormessage'] = _ariaErrorMessage;
    }

    /*
    if (accessibilityExpanded != null) {
      warnOnce(
        'accessibilityExpanded',
        `accessibilityExpanded is deprecated. Use aria-expanded.`
      );
    }
    */
    var _ariaExpanded = ariaExpanded != null ? ariaExpanded : accessibilityExpanded;
    if (_ariaExpanded != null) {
      domProps['aria-expanded'] = _ariaExpanded;
    }

    /*
    if (accessibilityFlowTo != null) {
      warnOnce(
        'accessibilityFlowTo',
        `accessibilityFlowTo is deprecated. Use aria-flowto.`
      );
    }
    */
    var _ariaFlowTo = ariaFlowTo != null ? ariaFlowTo : accessibilityFlowTo;
    if (_ariaFlowTo != null) {
      domProps['aria-flowto'] = processIDRefList(_ariaFlowTo);
    }

    /*
    if (accessibilityHasPopup != null) {
      warnOnce(
        'accessibilityHasPopup',
        `accessibilityHasPopup is deprecated. Use aria-haspopup.`
      );
    }
    */
    var _ariaHasPopup = ariaHasPopup != null ? ariaHasPopup : accessibilityHasPopup;
    if (_ariaHasPopup != null) {
      domProps['aria-haspopup'] = _ariaHasPopup;
    }

    /*
    if (accessibilityHidden != null) {
      warnOnce(
        'accessibilityHidden',
        `accessibilityHidden is deprecated. Use aria-hidden.`
      );
    }
    */
    var _ariaHidden = ariaHidden != null ? ariaHidden : accessibilityHidden;
    if (_ariaHidden === true) {
      domProps['aria-hidden'] = _ariaHidden;
    }

    /*
    if (accessibilityInvalid != null) {
      warnOnce(
        'accessibilityInvalid',
        `accessibilityInvalid is deprecated. Use aria-invalid.`
      );
    }
    */
    var _ariaInvalid = ariaInvalid != null ? ariaInvalid : accessibilityInvalid;
    if (_ariaInvalid != null) {
      domProps['aria-invalid'] = _ariaInvalid;
    }

    /*
    if (accessibilityKeyShortcuts != null) {
      warnOnce(
        'accessibilityKeyShortcuts',
        `accessibilityKeyShortcuts is deprecated. Use aria-keyshortcuts.`
      );
    }
    */
    var _ariaKeyShortcuts = ariaKeyShortcuts != null ? ariaKeyShortcuts : accessibilityKeyShortcuts;
    if (_ariaKeyShortcuts != null) {
      domProps['aria-keyshortcuts'] = processIDRefList(_ariaKeyShortcuts);
    }

    /*
    if (accessibilityLabel != null) {
      warnOnce(
        'accessibilityLabel',
        `accessibilityLabel is deprecated. Use aria-label.`
      );
    }
    */
    var _ariaLabel = ariaLabel != null ? ariaLabel : accessibilityLabel;
    if (_ariaLabel != null) {
      domProps['aria-label'] = _ariaLabel;
    }

    /*
    if (accessibilityLabelledBy != null) {
      warnOnce(
        'accessibilityLabelledBy',
        `accessibilityLabelledBy is deprecated. Use aria-labelledby.`
      );
    }
    */
    var _ariaLabelledBy = ariaLabelledBy != null ? ariaLabelledBy : accessibilityLabelledBy;
    if (_ariaLabelledBy != null) {
      domProps['aria-labelledby'] = processIDRefList(_ariaLabelledBy);
    }

    /*
    if (accessibilityLevel != null) {
      warnOnce(
        'accessibilityLevel',
        `accessibilityLevel is deprecated. Use aria-level.`
      );
    }
    */
    var _ariaLevel = ariaLevel != null ? ariaLevel : accessibilityLevel;
    if (_ariaLevel != null) {
      domProps['aria-level'] = _ariaLevel;
    }

    /*
    if (accessibilityLiveRegion != null) {
      warnOnce(
        'accessibilityLiveRegion',
        `accessibilityLiveRegion is deprecated. Use aria-live.`
      );
    }
    */
    var _ariaLive = ariaLive != null ? ariaLive : accessibilityLiveRegion;
    if (_ariaLive != null) {
      domProps['aria-live'] = _ariaLive === 'none' ? 'off' : _ariaLive;
    }

    /*
    if (accessibilityModal != null) {
      warnOnce(
        'accessibilityModal',
        `accessibilityModal is deprecated. Use aria-modal.`
      );
    }
    */
    var _ariaModal = ariaModal != null ? ariaModal : accessibilityModal;
    if (_ariaModal != null) {
      domProps['aria-modal'] = _ariaModal;
    }

    /*
    if (accessibilityMultiline != null) {
      warnOnce(
        'accessibilityMultiline',
        `accessibilityMultiline is deprecated. Use aria-multiline.`
      );
    }
    */
    var _ariaMultiline = ariaMultiline != null ? ariaMultiline : accessibilityMultiline;
    if (_ariaMultiline != null) {
      domProps['aria-multiline'] = _ariaMultiline;
    }

    /*
    if (accessibilityMultiSelectable != null) {
      warnOnce(
        'accessibilityMultiSelectable',
        `accessibilityMultiSelectable is deprecated. Use aria-multiselectable.`
      );
    }
    */
    var _ariaMultiSelectable = ariaMultiSelectable != null ? ariaMultiSelectable : accessibilityMultiSelectable;
    if (_ariaMultiSelectable != null) {
      domProps['aria-multiselectable'] = _ariaMultiSelectable;
    }

    /*
    if (accessibilityOrientation != null) {
      warnOnce(
        'accessibilityOrientation',
        `accessibilityOrientation is deprecated. Use aria-orientation.`
      );
    }
    */
    var _ariaOrientation = ariaOrientation != null ? ariaOrientation : accessibilityOrientation;
    if (_ariaOrientation != null) {
      domProps['aria-orientation'] = _ariaOrientation;
    }

    /*
    if (accessibilityOwns != null) {
      warnOnce(
        'accessibilityOwns',
        `accessibilityOwns is deprecated. Use aria-owns.`
      );
    }
    */
    var _ariaOwns = ariaOwns != null ? ariaOwns : accessibilityOwns;
    if (_ariaOwns != null) {
      domProps['aria-owns'] = processIDRefList(_ariaOwns);
    }

    /*
    if (accessibilityPlaceholder != null) {
      warnOnce(
        'accessibilityPlaceholder',
        `accessibilityPlaceholder is deprecated. Use aria-placeholder.`
      );
    }
    */
    var _ariaPlaceholder = ariaPlaceholder != null ? ariaPlaceholder : accessibilityPlaceholder;
    if (_ariaPlaceholder != null) {
      domProps['aria-placeholder'] = _ariaPlaceholder;
    }

    /*
    if (accessibilityPosInSet != null) {
      warnOnce(
        'accessibilityPosInSet',
        `accessibilityPosInSet is deprecated. Use aria-posinset.`
      );
    }
    */
    var _ariaPosInSet = ariaPosInSet != null ? ariaPosInSet : accessibilityPosInSet;
    if (_ariaPosInSet != null) {
      domProps['aria-posinset'] = _ariaPosInSet;
    }

    /*
    if (accessibilityPressed != null) {
      warnOnce(
        'accessibilityPressed',
        `accessibilityPressed is deprecated. Use aria-pressed.`
      );
    }
    */
    var _ariaPressed = ariaPressed != null ? ariaPressed : accessibilityPressed;
    if (_ariaPressed != null) {
      domProps['aria-pressed'] = _ariaPressed;
    }

    /*
    if (accessibilityReadOnly != null) {
      warnOnce(
        'accessibilityReadOnly',
        `accessibilityReadOnly is deprecated. Use aria-readonly.`
      );
    }
    */
    var _ariaReadOnly = ariaReadOnly != null ? ariaReadOnly : accessibilityReadOnly;
    if (_ariaReadOnly != null) {
      domProps['aria-readonly'] = _ariaReadOnly;
      // Enhance with native semantics
      if (elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        domProps.readOnly = true;
      }
    }

    /*
    if (accessibilityRequired != null) {
      warnOnce(
        'accessibilityRequired',
        `accessibilityRequired is deprecated. Use aria-required.`
      );
    }
    */
    var _ariaRequired = ariaRequired != null ? ariaRequired : accessibilityRequired;
    if (_ariaRequired != null) {
      domProps['aria-required'] = _ariaRequired;
      // Enhance with native semantics
      if (elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        domProps.required = accessibilityRequired;
      }
    }

    /*
    if (accessibilityRole != null) {
      warnOnce('accessibilityRole', `accessibilityRole is deprecated. Use role.`);
    }
    */
    if (role != null) {
      // 'presentation' synonym has wider browser support
      domProps['role'] = role === 'none' ? 'presentation' : role;
    }

    /*
    if (accessibilityRoleDescription != null) {
      warnOnce(
        'accessibilityRoleDescription',
        `accessibilityRoleDescription is deprecated. Use aria-roledescription.`
      );
    }
    */
    var _ariaRoleDescription = ariaRoleDescription != null ? ariaRoleDescription : accessibilityRoleDescription;
    if (_ariaRoleDescription != null) {
      domProps['aria-roledescription'] = _ariaRoleDescription;
    }

    /*
    if (accessibilityRowCount != null) {
      warnOnce(
        'accessibilityRowCount',
        `accessibilityRowCount is deprecated. Use aria-rowcount.`
      );
    }
    */
    var _ariaRowCount = ariaRowCount != null ? ariaRowCount : accessibilityRowCount;
    if (_ariaRowCount != null) {
      domProps['aria-rowcount'] = _ariaRowCount;
    }

    /*
    if (accessibilityRowIndex != null) {
      warnOnce(
        'accessibilityRowIndex',
        `accessibilityRowIndex is deprecated. Use aria-rowindex.`
      );
    }
    */
    var _ariaRowIndex = ariaRowIndex != null ? ariaRowIndex : accessibilityRowIndex;
    if (_ariaRowIndex != null) {
      domProps['aria-rowindex'] = _ariaRowIndex;
    }

    /*
    if (accessibilityRowSpan != null) {
      warnOnce(
        'accessibilityRowSpan',
        `accessibilityRowSpan is deprecated. Use aria-rowspan.`
      );
    }
    */
    var _ariaRowSpan = ariaRowSpan != null ? ariaRowSpan : accessibilityRowSpan;
    if (_ariaRowSpan != null) {
      domProps['aria-rowspan'] = _ariaRowSpan;
    }

    /*
    if (accessibilitySelected != null) {
      warnOnce(
        'accessibilitySelected',
        `accessibilitySelected is deprecated. Use aria-selected.`
      );
    }
    */
    var _ariaSelected = ariaSelected != null ? ariaSelected : accessibilitySelected;
    if (_ariaSelected != null) {
      domProps['aria-selected'] = _ariaSelected;
    }

    /*
    if (accessibilitySetSize != null) {
      warnOnce(
        'accessibilitySetSize',
        `accessibilitySetSize is deprecated. Use aria-setsize.`
      );
    }
    */
    var _ariaSetSize = ariaSetSize != null ? ariaSetSize : accessibilitySetSize;
    if (_ariaSetSize != null) {
      domProps['aria-setsize'] = _ariaSetSize;
    }

    /*
    if (accessibilitySort != null) {
      warnOnce(
        'accessibilitySort',
        `accessibilitySort is deprecated. Use aria-sort.`
      );
    }
    */
    var _ariaSort = ariaSort != null ? ariaSort : accessibilitySort;
    if (_ariaSort != null) {
      domProps['aria-sort'] = _ariaSort;
    }

    /*
    if (accessibilityValueMax != null) {
      warnOnce(
        'accessibilityValueMax',
        `accessibilityValueMax is deprecated. Use aria-valuemax.`
      );
    }
    */
    var _ariaValueMax = ariaValueMax != null ? ariaValueMax : accessibilityValueMax;
    if (_ariaValueMax != null) {
      domProps['aria-valuemax'] = _ariaValueMax;
    }

    /*
    if (accessibilityValueMin != null) {
      warnOnce(
        'accessibilityValueMin',
        `accessibilityValueMin is deprecated. Use aria-valuemin.`
      );
    }
    */
    var _ariaValueMin = ariaValueMin != null ? ariaValueMin : accessibilityValueMin;
    if (_ariaValueMin != null) {
      domProps['aria-valuemin'] = _ariaValueMin;
    }

    /*
    if (accessibilityValueNow != null) {
      warnOnce(
        'accessibilityValueNow',
        `accessibilityValueNow is deprecated. Use aria-valuenow.`
      );
    }
    */
    var _ariaValueNow = ariaValueNow != null ? ariaValueNow : accessibilityValueNow;
    if (_ariaValueNow != null) {
      domProps['aria-valuenow'] = _ariaValueNow;
    }

    /*
    if (accessibilityValueText != null) {
      warnOnce(
        'accessibilityValueText',
        `accessibilityValueText is deprecated. Use aria-valuetext.`
      );
    }
    */
    var _ariaValueText = ariaValueText != null ? ariaValueText : accessibilityValueText;
    if (_ariaValueText != null) {
      domProps['aria-valuetext'] = _ariaValueText;
    }

    // "dataSet" replaced with "data-*"
    if (dataSet != null) {
      for (var dataProp in dataSet) {
        if (hasOwnProperty.call(dataSet, dataProp)) {
          var dataName = hyphenateString(dataProp);
          var dataValue = dataSet[dataProp];
          if (dataValue != null) {
            domProps["data-" + dataName] = dataValue;
          }
        }
      }
    }

    // FOCUS
    if (tabIndex === 0 || tabIndex === '0' || tabIndex === -1 || tabIndex === '-1') {
      domProps.tabIndex = tabIndex;
    } else {
      /*
      if (focusable != null) {
        warnOnce('focusable', `focusable is deprecated.`);
      }
      */

      // "focusable" indicates that an element may be a keyboard tab-stop.
      if (focusable === false) {
        domProps.tabIndex = '-1';
      }
      if (
      // These native elements are keyboard focusable by default
      elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        if (focusable === false || accessibilityDisabled === true) {
          domProps.tabIndex = '-1';
        }
      } else if (
      // These roles are made keyboard focusable by default
      role === 'button' || role === 'checkbox' || role === 'link' || role === 'radio' || role === 'textbox' || role === 'switch') {
        if (focusable !== false) {
          domProps.tabIndex = '0';
        }
      } else {
        // Everything else must explicitly set the prop
        if (focusable === true) {
          domProps.tabIndex = '0';
        }
      }
    }

    // Resolve styles
    if (pointerEvents != null) {
      (0, _warnOnce.warnOnce)('pointerEvents', "props.pointerEvents is deprecated. Use style.pointerEvents");
    }
    var _StyleSheet = (0, StyleSheet.default)([style, pointerEvents && pointerEventsStyles[pointerEvents]], (0, _objectSpread.default)({
        writingDirection: 'ltr'
      }, options)),
      className = _StyleSheet[0],
      inlineStyle = _StyleSheet[1];
    if (className) {
      domProps.className = className;
    }
    if (inlineStyle) {
      domProps.style = inlineStyle;
    }

    // OTHER
    // Native element ID
    /*
    if (nativeID != null) {
      warnOnce('nativeID', `nativeID is deprecated. Use id.`);
    }
    */
    var _id = id != null ? id : nativeID;
    if (_id != null) {
      domProps.id = _id;
    }
    // Automated test IDs
    if (testID != null) {
      domProps['data-testid'] = testID;
    }
    if (domProps.type == null && elementType === 'button') {
      domProps.type = 'button';
    }
    return domProps;
  };
  var _default = createDOMProps;
},116,[37,43,112,55,102],"node_modules/react-native-web/dist/modules/createDOMProps/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.getLocaleDirection = getLocaleDirection;
  exports.LocaleProvider = LocaleProvider;
  exports.useLocaleContext = useLocaleContext;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopDefault(_react);
  var _isLocaleRTL = require(_dependencyMap[1], "./isLocaleRTL");
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var defaultLocale = {
    direction: 'ltr',
    locale: 'en-US'
  };
  var LocaleContext = /*#__PURE__*/(0, _react.createContext)(defaultLocale);
  function getLocaleDirection(locale) {
    return (0, _isLocaleRTL.isLocaleRTL)(locale) ? 'rtl' : 'ltr';
  }
  function LocaleProvider(props) {
    var direction = props.direction,
      locale = props.locale,
      children = props.children;
    var needsContext = direction || locale;
    return needsContext ? /*#__PURE__*/React.default.createElement(LocaleContext.Provider, {
      children: children,
      value: {
        direction: locale ? getLocaleDirection(locale) : direction,
        locale
      }
    }) : children;
  }
  function useLocaleContext() {
    return (0, _react.useContext)(LocaleContext);
  }
},117,[9,118],"node_modules/react-native-web/dist/modules/useLocale/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.isLocaleRTL = isLocaleRTL;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var rtlScripts = new Set(['Arab', 'Syrc', 'Samr', 'Mand', 'Thaa', 'Mend', 'Nkoo', 'Adlm', 'Rohg', 'Hebr']);
  var rtlLangs = new Set(['ae',
  // Avestan
  'ar',
  // Arabic
  'arc',
  // Aramaic
  'bcc',
  // Southern Balochi
  'bqi',
  // Bakthiari
  'ckb',
  // Sorani
  'dv',
  // Dhivehi
  'fa', 'far',
  // Persian
  'glk',
  // Gilaki
  'he', 'iw',
  // Hebrew
  'khw',
  // Khowar
  'ks',
  // Kashmiri
  'ku',
  // Kurdish
  'mzn',
  // Mazanderani
  'nqo',
  // N'Ko
  'pnb',
  // Western Punjabi
  'ps',
  // Pashto
  'sd',
  // Sindhi
  'ug',
  // Uyghur
  'ur',
  // Urdu
  'yi' // Yiddish
  ]);
  var cache = new Map();

  /**
   * Determine the writing direction of a locale
   */
  function isLocaleRTL(locale) {
    var cachedRTL = cache.get(locale);
    if (cachedRTL) {
      return cachedRTL;
    }
    var isRTL = false;
    // $FlowFixMe
    if (Intl.Locale) {
      try {
        // $FlowFixMe
        var script = new Intl.Locale(locale).maximize().script;
        isRTL = rtlScripts.has(script);
      } catch (_unused) {
        // RangeError: Incorrect locale information provided
        // Fallback to inferring from language
        var lang = locale.split('-')[0];
        isRTL = rtlLangs.has(lang);
      }
    } else {
      // Fallback to inferring from language
      var _lang = locale.split('-')[0];
      isRTL = rtlLangs.has(_lang);
    }
    cache.set(locale, isRTL);
    return isRTL;
  }
},118,[],"node_modules/react-native-web/dist/modules/useLocale/isLocaleRTL.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "defaultProps", {
    enumerable: true,
    get: function () {
      return defaultProps;
    }
  });
  Object.defineProperty(exports, "accessibilityProps", {
    enumerable: true,
    get: function () {
      return accessibilityProps;
    }
  });
  Object.defineProperty(exports, "clickProps", {
    enumerable: true,
    get: function () {
      return clickProps;
    }
  });
  Object.defineProperty(exports, "focusProps", {
    enumerable: true,
    get: function () {
      return focusProps;
    }
  });
  Object.defineProperty(exports, "keyboardProps", {
    enumerable: true,
    get: function () {
      return keyboardProps;
    }
  });
  Object.defineProperty(exports, "mouseProps", {
    enumerable: true,
    get: function () {
      return mouseProps;
    }
  });
  Object.defineProperty(exports, "touchProps", {
    enumerable: true,
    get: function () {
      return touchProps;
    }
  });
  Object.defineProperty(exports, "styleProps", {
    enumerable: true,
    get: function () {
      return styleProps;
    }
  });
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var defaultProps = {
    children: true,
    dataSet: true,
    dir: true,
    id: true,
    ref: true,
    suppressHydrationWarning: true,
    tabIndex: true,
    testID: true,
    // @deprecated
    focusable: true,
    nativeID: true
  };
  var accessibilityProps = {
    'aria-activedescendant': true,
    'aria-atomic': true,
    'aria-autocomplete': true,
    'aria-busy': true,
    'aria-checked': true,
    'aria-colcount': true,
    'aria-colindex': true,
    'aria-colspan': true,
    'aria-controls': true,
    'aria-current': true,
    'aria-describedby': true,
    'aria-details': true,
    'aria-disabled': true,
    'aria-errormessage': true,
    'aria-expanded': true,
    'aria-flowto': true,
    'aria-haspopup': true,
    'aria-hidden': true,
    'aria-invalid': true,
    'aria-keyshortcuts': true,
    'aria-label': true,
    'aria-labelledby': true,
    'aria-level': true,
    'aria-live': true,
    'aria-modal': true,
    'aria-multiline': true,
    'aria-multiselectable': true,
    'aria-orientation': true,
    'aria-owns': true,
    'aria-placeholder': true,
    'aria-posinset': true,
    'aria-pressed': true,
    'aria-readonly': true,
    'aria-required': true,
    inert: true,
    role: true,
    'aria-roledescription': true,
    'aria-rowcount': true,
    'aria-rowindex': true,
    'aria-rowspan': true,
    'aria-selected': true,
    'aria-setsize': true,
    'aria-sort': true,
    'aria-valuemax': true,
    'aria-valuemin': true,
    'aria-valuenow': true,
    'aria-valuetext': true,
    // @deprecated
    accessibilityActiveDescendant: true,
    accessibilityAtomic: true,
    accessibilityAutoComplete: true,
    accessibilityBusy: true,
    accessibilityChecked: true,
    accessibilityColumnCount: true,
    accessibilityColumnIndex: true,
    accessibilityColumnSpan: true,
    accessibilityControls: true,
    accessibilityCurrent: true,
    accessibilityDescribedBy: true,
    accessibilityDetails: true,
    accessibilityDisabled: true,
    accessibilityErrorMessage: true,
    accessibilityExpanded: true,
    accessibilityFlowTo: true,
    accessibilityHasPopup: true,
    accessibilityHidden: true,
    accessibilityInvalid: true,
    accessibilityKeyShortcuts: true,
    accessibilityLabel: true,
    accessibilityLabelledBy: true,
    accessibilityLevel: true,
    accessibilityLiveRegion: true,
    accessibilityModal: true,
    accessibilityMultiline: true,
    accessibilityMultiSelectable: true,
    accessibilityOrientation: true,
    accessibilityOwns: true,
    accessibilityPlaceholder: true,
    accessibilityPosInSet: true,
    accessibilityPressed: true,
    accessibilityReadOnly: true,
    accessibilityRequired: true,
    accessibilityRole: true,
    accessibilityRoleDescription: true,
    accessibilityRowCount: true,
    accessibilityRowIndex: true,
    accessibilityRowSpan: true,
    accessibilitySelected: true,
    accessibilitySetSize: true,
    accessibilitySort: true,
    accessibilityValueMax: true,
    accessibilityValueMin: true,
    accessibilityValueNow: true,
    accessibilityValueText: true
  };
  var clickProps = {
    onClick: true,
    onAuxClick: true,
    onContextMenu: true,
    onGotPointerCapture: true,
    onLostPointerCapture: true,
    onPointerCancel: true,
    onPointerDown: true,
    onPointerEnter: true,
    onPointerMove: true,
    onPointerLeave: true,
    onPointerOut: true,
    onPointerOver: true,
    onPointerUp: true
  };
  var focusProps = {
    onBlur: true,
    onFocus: true
  };
  var keyboardProps = {
    onKeyDown: true,
    onKeyDownCapture: true,
    onKeyUp: true,
    onKeyUpCapture: true
  };
  var mouseProps = {
    onMouseDown: true,
    onMouseEnter: true,
    onMouseLeave: true,
    onMouseMove: true,
    onMouseOver: true,
    onMouseOut: true,
    onMouseUp: true
  };
  var touchProps = {
    onTouchCancel: true,
    onTouchCancelCapture: true,
    onTouchEnd: true,
    onTouchEndCapture: true,
    onTouchMove: true,
    onTouchMoveCapture: true,
    onTouchStart: true,
    onTouchStartCapture: true
  };
  var styleProps = {
    style: true
  };
},119,[],"node_modules/react-native-web/dist/modules/forwardedProps/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return pick;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function pick(obj, list) {
    var nextObj = {};
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (list[key] === true) {
          nextObj[key] = obj[key];
        }
      }
    }
    return nextObj;
  }
},120,[],"node_modules/react-native-web/dist/modules/pick/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useElementLayout;
    }
  });
  var _useLayoutEffect = require(_dependencyMap[0], "../useLayoutEffect");
  var useLayoutEffect = _interopDefault(_useLayoutEffect);
  var _exportsUIManager = require(_dependencyMap[1], "../../exports/UIManager");
  var UIManager = _interopDefault(_exportsUIManager);
  var _canUseDom = require(_dependencyMap[2], "../canUseDom");
  var canUseDOM = _interopDefault(_canUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var DOM_LAYOUT_HANDLER_NAME = '__reactLayoutHandler';
  var didWarn = !canUseDOM.default;
  var resizeObserver = null;
  function getResizeObserver() {
    if (canUseDOM.default && typeof window.ResizeObserver !== 'undefined') {
      if (resizeObserver == null) {
        resizeObserver = new window.ResizeObserver(function (entries) {
          entries.forEach(entry => {
            var node = entry.target;
            var onLayout = node[DOM_LAYOUT_HANDLER_NAME];
            if (typeof onLayout === 'function') {
              // We still need to measure the view because browsers don't yet provide
              // border-box dimensions in the entry
              UIManager.default.measure(node, (x, y, width, height, left, top) => {
                var event = {
                  // $FlowFixMe
                  nativeEvent: {
                    layout: {
                      x,
                      y,
                      width,
                      height,
                      left,
                      top
                    }
                  },
                  timeStamp: Date.now()
                };
                Object.defineProperty(event.nativeEvent, 'target', {
                  enumerable: true,
                  get: () => entry.target
                });
                onLayout(event);
              });
            }
          });
        });
      }
    } else if (!didWarn) {
      if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {
        console.warn('onLayout relies on ResizeObserver which is not supported by your browser. ' + 'Please include a polyfill, e.g., https://github.com/que-etc/resize-observer-polyfill.');
        didWarn = true;
      }
    }
    return resizeObserver;
  }
  function useElementLayout(ref, onLayout) {
    var observer = getResizeObserver();
    (0, useLayoutEffect.default)(() => {
      var node = ref.current;
      if (node != null) {
        node[DOM_LAYOUT_HANDLER_NAME] = onLayout;
      }
    }, [ref, onLayout]);

    // Observing is done in a separate effect to avoid this effect running
    // when 'onLayout' changes.
    (0, useLayoutEffect.default)(() => {
      var node = ref.current;
      if (node != null && observer != null) {
        if (typeof node[DOM_LAYOUT_HANDLER_NAME] === 'function') {
          observer.observe(node);
        } else {
          observer.unobserve(node);
        }
      }
      return () => {
        if (node != null && observer != null) {
          observer.unobserve(node);
        }
      };
    }, [ref, observer]);
  }
},121,[122,48,45],"node_modules/react-native-web/dist/modules/useElementLayout/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var _canUseDom = require(_dependencyMap[1], "../canUseDom");
  var canUseDOM = _interopDefault(_canUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * useLayoutEffect throws an error on the server. On the few occasions where is
   * problematic, use this hook.
   *
   * 
   */

  var useLayoutEffectImpl = canUseDOM.default ? _react.useLayoutEffect : _react.useEffect;
  var _default = useLayoutEffectImpl;
},122,[9,45],"node_modules/react-native-web/dist/modules/useLayoutEffect/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useMergeRefs;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _mergeRefs = require(_dependencyMap[1], "../mergeRefs");
  var mergeRefs = _interopDefault(_mergeRefs);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function useMergeRefs() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return React.useMemo(() => (0, mergeRefs.default)(...args),
    // eslint-disable-next-line
    [...args]);
  }
},123,[9,53],"node_modules/react-native-web/dist/modules/useMergeRefs/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return usePlatformMethods;
    }
  });
  var _exportsUIManager = require(_dependencyMap[0], "../../exports/UIManager");
  var UIManager = _interopDefault(_exportsUIManager);
  var _useStable = require(_dependencyMap[1], "../useStable");
  var useStable = _interopDefault(_useStable);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Adds non-standard methods to the hode element. This is temporarily until an
   * API like `ReactNative.measure(hostRef, callback)` is added to React Native.
   */
  function usePlatformMethods(_ref) {
    var pointerEvents = _ref.pointerEvents,
      style = _ref.style;
    // Avoid creating a new ref on every render.
    var ref = (0, useStable.default)(() => hostNode => {
      if (hostNode != null) {
        hostNode.measure = callback => UIManager.default.measure(hostNode, callback);
        hostNode.measureLayout = (relativeToNode, success, failure) => UIManager.default.measureLayout(hostNode, relativeToNode, failure, success);
        hostNode.measureInWindow = callback => UIManager.default.measureInWindow(hostNode, callback);
      }
    });
    return ref;
  }
},124,[48,125],"node_modules/react-native-web/dist/modules/usePlatformMethods/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useStable;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var UNINITIALIZED = typeof Symbol === 'function' && typeof Symbol() === 'symbol' ? Symbol() : Object.freeze({});
  function useStable(getInitialValue) {
    var ref = React.useRef(UNINITIALIZED);
    if (ref.current === UNINITIALIZED) {
      ref.current = getInitialValue();
    }
    // $FlowFixMe (#64650789) Trouble refining types where `Symbol` is concerned.
    return ref.current;
  }
},125,[9],"node_modules/react-native-web/dist/modules/useStable/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useResponderEvents;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _ResponderSystem = require(_dependencyMap[1], "./ResponderSystem");
  var ResponderSystem = _interopNamespace(_ResponderSystem);
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Hook for integrating the Responder System into React
   *
   *   function SomeComponent({ onStartShouldSetResponder }) {
   *     const ref = useRef(null);
   *     useResponderEvents(ref, { onStartShouldSetResponder });
   *     return <div ref={ref} />
   *   }
   */

  var emptyObject = {};
  var idCounter = 0;
  function useStable(getInitialValue) {
    var ref = React.useRef(null);
    if (ref.current == null) {
      ref.current = getInitialValue();
    }
    return ref.current;
  }
  function useResponderEvents(hostRef, config) {
    if (config === void 0) {
      config = emptyObject;
    }
    var id = useStable(() => idCounter++);
    var isAttachedRef = React.useRef(false);

    // This is a separate effects so it doesn't run when the config changes.
    // On initial mount, attach global listeners if needed.
    // On unmount, remove node potentially attached to the Responder System.
    React.useEffect(() => {
      ResponderSystem.attachListeners();
      return () => {
        ResponderSystem.removeNode(id);
      };
    }, [id]);

    // Register and unregister with the Responder System as necessary
    React.useEffect(() => {
      var _config = config,
        onMoveShouldSetResponder = _config.onMoveShouldSetResponder,
        onMoveShouldSetResponderCapture = _config.onMoveShouldSetResponderCapture,
        onScrollShouldSetResponder = _config.onScrollShouldSetResponder,
        onScrollShouldSetResponderCapture = _config.onScrollShouldSetResponderCapture,
        onSelectionChangeShouldSetResponder = _config.onSelectionChangeShouldSetResponder,
        onSelectionChangeShouldSetResponderCapture = _config.onSelectionChangeShouldSetResponderCapture,
        onStartShouldSetResponder = _config.onStartShouldSetResponder,
        onStartShouldSetResponderCapture = _config.onStartShouldSetResponderCapture;
      var requiresResponderSystem = onMoveShouldSetResponder != null || onMoveShouldSetResponderCapture != null || onScrollShouldSetResponder != null || onScrollShouldSetResponderCapture != null || onSelectionChangeShouldSetResponder != null || onSelectionChangeShouldSetResponderCapture != null || onStartShouldSetResponder != null || onStartShouldSetResponderCapture != null;
      var node = hostRef.current;
      if (requiresResponderSystem) {
        ResponderSystem.addNode(id, node, config);
        isAttachedRef.current = true;
      } else if (isAttachedRef.current) {
        ResponderSystem.removeNode(id);
        isAttachedRef.current = false;
      }
    }, [config, hostRef, id]);
    React.useDebugValue({
      isResponder: hostRef.current === ResponderSystem.getResponderNode()
    });
    React.useDebugValue(config);
  }
},126,[9,127],"node_modules/react-native-web/dist/modules/useResponderEvents/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.attachListeners = attachListeners;
  exports.addNode = addNode;
  exports.removeNode = removeNode;
  exports.terminateResponder = terminateResponder;
  exports.getResponderNode = getResponderNode;
  var _createResponderEvent = require(_dependencyMap[0], "./createResponderEvent");
  var createResponderEvent = _interopDefault(_createResponderEvent);
  var _ResponderEventTypes = require(_dependencyMap[1], "./ResponderEventTypes");
  var _utils = require(_dependencyMap[2], "./utils");
  var _ResponderTouchHistoryStore = require(_dependencyMap[3], "./ResponderTouchHistoryStore");
  var _canUseDom = require(_dependencyMap[4], "../canUseDom");
  var canUseDOM = _interopDefault(_canUseDom);
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * RESPONDER EVENT SYSTEM
   *
   * A single, global "interaction lock" on views. For a view to be the "responder" means
   * that pointer interactions are exclusive to that view and none other. The "interaction
   * lock" can be transferred (only) to ancestors of the current "responder" as long as
   * pointers continue to be active.
   *
   * Responder being granted:
   *
   * A view can become the "responder" after the following events:
   *  * "pointerdown" (implemented using "touchstart", "mousedown")
   *  * "pointermove" (implemented using "touchmove", "mousemove")
   *  * "scroll" (while a pointer is down)
   *  * "selectionchange" (while a pointer is down)
   *
   * If nothing is already the "responder", the event propagates to (capture) and from
   * (bubble) the event target until a view returns `true` for
   * `on*ShouldSetResponder(Capture)`.
   *
   * If something is already the responder, the event propagates to (capture) and from
   * (bubble) the lowest common ancestor of the event target and the current "responder".
   * Then negotiation happens between the current "responder" and a view that wants to
   * become the "responder": see the timing diagram below.
   *
   * (NOTE: Scrolled views either automatically become the "responder" or release the
   * "interaction lock". A native scroll view that isn't built on top of the responder
   * system must result in the current "responder" being notified that it no longer has
   * the "interaction lock" - the native system has taken over.
   *
   * Responder being released:
   *
   * As soon as there are no more active pointers that *started* inside descendants
   * of the *current* "responder", an `onResponderRelease` event is dispatched to the
   * current "responder", and the responder lock is released.
   *
   * Typical sequence of events:
   *  * startShouldSetResponder
   *  * responderGrant/Reject
   *  * responderStart
   *  * responderMove
   *  * responderEnd
   *  * responderRelease
   */

  /*                                             Negotiation Performed
                                               +-----------------------+
                                              /                         \
  Process low level events to    +     Current Responder      +   wantsResponderID
  determine who to perform negot-|   (if any exists at all)   |
  iation/transition              | Otherwise just pass through|
  -------------------------------+----------------------------+------------------+
  Bubble to find first ID        |                            |
  to return true:wantsResponderID|                            |
                                 |                            |
       +--------------+          |                            |
       | onTouchStart |          |                            |
       +------+-------+    none  |                            |
              |            return|                            |
  +-----------v-------------+true| +------------------------+ |
  |onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+
  +-----------+-------------+    | +------------------------+ |          |
              |                  |                            | +--------+-------+
              | returned true for|       false:REJECT +-------->|onResponderReject
              | wantsResponderID |                    |       | +----------------+
              | (now attempt     | +------------------+-----+ |
              |  handoff)        | | onResponder            | |
              +------------------->|    TerminationRequest  | |
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |         true:GRANT +-------->|onResponderGrant|
                                 |                            | +--------+-------+
                                 | +------------------------+ |          |
                                 | | onResponderTerminate   |<-----------+
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |                    +-------->|onResponderStart|
                                 |                            | +----------------+
  Bubble to find first ID        |                            |
  to return true:wantsResponderID|                            |
                                 |                            |
       +-------------+           |                            |
       | onTouchMove |           |                            |
       +------+------+     none  |                            |
              |            return|                            |
  +-----------v-------------+true| +------------------------+ |
  |onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+
  +-----------+-------------+    | +------------------------+ |          |
              |                  |                            | +--------+-------+
              | returned true for|       false:REJECT +-------->|onResponderReject
              | wantsResponderID |                    |       | +----------------+
              | (now attempt     | +------------------+-----+ |
              |  handoff)        | |   onResponder          | |
              +------------------->|      TerminationRequest| |
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |         true:GRANT +-------->|onResponderGrant|
                                 |                            | +--------+-------+
                                 | +------------------------+ |          |
                                 | |   onResponderTerminate |<-----------+
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |                    +-------->|onResponderMove |
                                 |                            | +----------------+
                                 |                            |
                                 |                            |
        Some active touch started|                            |
        inside current responder | +------------------------+ |
        +------------------------->|      onResponderEnd    | |
        |                        | +------------------------+ |
    +---+---------+              |                            |
    | onTouchEnd  |              |                            |
    +---+---------+              |                            |
        |                        | +------------------------+ |
        +------------------------->|     onResponderEnd     | |
        No active touches started| +-----------+------------+ |
        inside current responder |             |              |
                                 |             v              |
                                 | +------------------------+ |
                                 | |    onResponderRelease  | |
                                 | +------------------------+ |
                                 |                            |
                                 +                            + */

  /* ------------ TYPES ------------ */

  var emptyObject = {};

  /* ------------ IMPLEMENTATION ------------ */

  var startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {
    bubbles: true
  }];
  var moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {
    bubbles: true
  }];
  var scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {
    bubbles: false
  }];
  var shouldSetResponderEvents = {
    touchstart: startRegistration,
    mousedown: startRegistration,
    touchmove: moveRegistration,
    mousemove: moveRegistration,
    scroll: scrollRegistration
  };
  var emptyResponder = {
    id: null,
    idPath: null,
    node: null
  };
  var responderListenersMap = new Map();
  var isEmulatingMouseEvents = false;
  var trackedTouchCount = 0;
  var currentResponder = {
    id: null,
    node: null,
    idPath: null
  };
  var responderTouchHistoryStore = new _ResponderTouchHistoryStore.ResponderTouchHistoryStore();
  function changeCurrentResponder(responder) {
    currentResponder = responder;
  }
  function getResponderConfig(id) {
    var config = responderListenersMap.get(id);
    return config != null ? config : emptyObject;
  }

  /**
   * Process native events
   *
   * A single event listener is used to manage the responder system.
   * All pointers are tracked in the ResponderTouchHistoryStore. Native events
   * are interpreted in terms of the Responder System and checked to see if
   * the responder should be transferred. Each host node that is attached to
   * the Responder System has an ID, which is used to look up its associated
   * callbacks.
   */
  function eventListener(domEvent) {
    var eventType = domEvent.type;
    var eventTarget = domEvent.target;

    /**
     * Manage emulated events and early bailout.
     * Since PointerEvent is not used yet (lack of support in older Safari), it's
     * necessary to manually manage the mess of browser touch/mouse events.
     * And bailout early for termination events when there is no active responder.
     */

    // Flag when browser may produce emulated events
    if (eventType === 'touchstart') {
      isEmulatingMouseEvents = true;
    }
    // Remove flag when browser will not produce emulated events
    if (eventType === 'touchmove' || trackedTouchCount > 1) {
      isEmulatingMouseEvents = false;
    }
    // Ignore various events in particular circumstances
    if (
    // Ignore browser emulated mouse events
    eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents ||
    // Ignore mousemove if a mousedown didn't occur first
    eventType === 'mousemove' && trackedTouchCount < 1) {
      return;
    }
    // Remove flag after emulated events are finished
    if (isEmulatingMouseEvents && eventType === 'mouseup') {
      if (trackedTouchCount === 0) {
        isEmulatingMouseEvents = false;
      }
      return;
    }
    var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);
    var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);
    var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);
    var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);
    var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);
    var responderEvent = (0, createResponderEvent.default)(domEvent, responderTouchHistoryStore);

    /**
     * Record the state of active pointers
     */

    if (isStartEvent || isMoveEvent || isEndEvent) {
      if (domEvent.touches) {
        trackedTouchCount = domEvent.touches.length;
      } else {
        if (isStartEvent) {
          trackedTouchCount = 1;
        } else if (isEndEvent) {
          trackedTouchCount = 0;
        }
      }
      responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);
    }

    /**
     * Responder System logic
     */

    var eventPaths = (0, _utils.getResponderPaths)(domEvent);
    var wasNegotiated = false;
    var wantsResponder;

    // If an event occured that might change the current responder...
    if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {
      // If there is already a responder, prune the event paths to the lowest common ancestor
      // of the existing responder and deepest target of the event.
      var currentResponderIdPath = currentResponder.idPath;
      var eventIdPath = eventPaths.idPath;
      if (currentResponderIdPath != null && eventIdPath != null) {
        var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);
        if (lowestCommonAncestor != null) {
          var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);
          // Skip the current responder so it doesn't receive unexpected "shouldSet" events.
          var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);
          eventPaths = {
            idPath: eventIdPath.slice(index),
            nodePath: eventPaths.nodePath.slice(index)
          };
        } else {
          eventPaths = null;
        }
      }
      if (eventPaths != null) {
        // If a node wants to become the responder, attempt to transfer.
        wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);
        if (wantsResponder != null) {
          // Sets responder if none exists, or negotates with existing responder.
          attemptTransfer(responderEvent, wantsResponder);
          wasNegotiated = true;
        }
      }
    }

    // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.
    if (currentResponder.id != null && currentResponder.node != null) {
      var _currentResponder = currentResponder,
        id = _currentResponder.id,
        node = _currentResponder.node;
      var _getResponderConfig = getResponderConfig(id),
        onResponderStart = _getResponderConfig.onResponderStart,
        onResponderMove = _getResponderConfig.onResponderMove,
        onResponderEnd = _getResponderConfig.onResponderEnd,
        onResponderRelease = _getResponderConfig.onResponderRelease,
        onResponderTerminate = _getResponderConfig.onResponderTerminate,
        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;
      responderEvent.bubbles = false;
      responderEvent.cancelable = false;
      responderEvent.currentTarget = node;

      // Start
      if (isStartEvent) {
        if (onResponderStart != null) {
          responderEvent.dispatchConfig.registrationName = 'onResponderStart';
          onResponderStart(responderEvent);
        }
      }
      // Move
      else if (isMoveEvent) {
        if (onResponderMove != null) {
          responderEvent.dispatchConfig.registrationName = 'onResponderMove';
          onResponderMove(responderEvent);
        }
      } else {
        var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) ||
        // native context menu
        eventType === 'contextmenu' ||
        // window blur
        eventType === 'blur' && eventTarget === window ||
        // responder (or ancestors) blur
        eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node ||
        // native scroll without using a pointer
        isScrollEvent && trackedTouchCount === 0 ||
        // native scroll on node that is parent of the responder (allow siblings to scroll)
        isScrollEvent && eventTarget.contains(node) && eventTarget !== node ||
        // native select/selectionchange on node
        isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);
        var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches);

        // End
        if (isEndEvent) {
          if (onResponderEnd != null) {
            responderEvent.dispatchConfig.registrationName = 'onResponderEnd';
            onResponderEnd(responderEvent);
          }
        }
        // Release
        if (isReleaseEvent) {
          if (onResponderRelease != null) {
            responderEvent.dispatchConfig.registrationName = 'onResponderRelease';
            onResponderRelease(responderEvent);
          }
          changeCurrentResponder(emptyResponder);
        }
        // Terminate
        if (isTerminateEvent) {
          var shouldTerminate = true;

          // Responders can still avoid termination but only for these events.
          if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {
            // Only call this function is it wasn't already called during negotiation.
            if (wasNegotiated) {
              shouldTerminate = false;
            } else if (onResponderTerminationRequest != null) {
              responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';
              if (onResponderTerminationRequest(responderEvent) === false) {
                shouldTerminate = false;
              }
            }
          }
          if (shouldTerminate) {
            if (onResponderTerminate != null) {
              responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';
              onResponderTerminate(responderEvent);
            }
            changeCurrentResponder(emptyResponder);
            isEmulatingMouseEvents = false;
            trackedTouchCount = 0;
          }
        }
      }
    }
  }

  /**
   * Walk the event path to/from the target node. At each node, stop and call the
   * relevant "shouldSet" functions for the given event type. If any of those functions
   * call "stopPropagation" on the event, stop searching for a responder.
   */
  function findWantsResponder(eventPaths, domEvent, responderEvent) {
    var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow

    if (shouldSetCallbacks != null) {
      var idPath = eventPaths.idPath,
        nodePath = eventPaths.nodePath;
      var shouldSetCallbackCaptureName = shouldSetCallbacks[0];
      var shouldSetCallbackBubbleName = shouldSetCallbacks[1];
      var bubbles = shouldSetCallbacks[2].bubbles;
      var check = function check(id, node, callbackName) {
        var config = getResponderConfig(id);
        var shouldSetCallback = config[callbackName];
        if (shouldSetCallback != null) {
          responderEvent.currentTarget = node;
          if (shouldSetCallback(responderEvent) === true) {
            // Start the path from the potential responder
            var prunedIdPath = idPath.slice(idPath.indexOf(id));
            return {
              id,
              node,
              idPath: prunedIdPath
            };
          }
        }
      };

      // capture
      for (var i = idPath.length - 1; i >= 0; i--) {
        var id = idPath[i];
        var node = nodePath[i];
        var result = check(id, node, shouldSetCallbackCaptureName);
        if (result != null) {
          return result;
        }
        if (responderEvent.isPropagationStopped() === true) {
          return;
        }
      }

      // bubble
      if (bubbles) {
        for (var _i = 0; _i < idPath.length; _i++) {
          var _id = idPath[_i];
          var _node = nodePath[_i];
          var _result = check(_id, _node, shouldSetCallbackBubbleName);
          if (_result != null) {
            return _result;
          }
          if (responderEvent.isPropagationStopped() === true) {
            return;
          }
        }
      } else {
        var _id2 = idPath[0];
        var _node2 = nodePath[0];
        var target = domEvent.target;
        if (target === _node2) {
          return check(_id2, _node2, shouldSetCallbackBubbleName);
        }
      }
    }
  }

  /**
   * Attempt to transfer the responder.
   */
  function attemptTransfer(responderEvent, wantsResponder) {
    var _currentResponder2 = currentResponder,
      currentId = _currentResponder2.id,
      currentNode = _currentResponder2.node;
    var id = wantsResponder.id,
      node = wantsResponder.node;
    var _getResponderConfig2 = getResponderConfig(id),
      onResponderGrant = _getResponderConfig2.onResponderGrant,
      onResponderReject = _getResponderConfig2.onResponderReject;
    responderEvent.bubbles = false;
    responderEvent.cancelable = false;
    responderEvent.currentTarget = node;

    // Set responder
    if (currentId == null) {
      if (onResponderGrant != null) {
        responderEvent.currentTarget = node;
        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';
        onResponderGrant(responderEvent);
      }
      changeCurrentResponder(wantsResponder);
    }
    // Negotiate with current responder
    else {
      var _getResponderConfig3 = getResponderConfig(currentId),
        onResponderTerminate = _getResponderConfig3.onResponderTerminate,
        onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;
      var allowTransfer = true;
      if (onResponderTerminationRequest != null) {
        responderEvent.currentTarget = currentNode;
        responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';
        if (onResponderTerminationRequest(responderEvent) === false) {
          allowTransfer = false;
        }
      }
      if (allowTransfer) {
        // Terminate existing responder
        if (onResponderTerminate != null) {
          responderEvent.currentTarget = currentNode;
          responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';
          onResponderTerminate(responderEvent);
        }
        // Grant next responder
        if (onResponderGrant != null) {
          responderEvent.currentTarget = node;
          responderEvent.dispatchConfig.registrationName = 'onResponderGrant';
          onResponderGrant(responderEvent);
        }
        changeCurrentResponder(wantsResponder);
      } else {
        // Reject responder request
        if (onResponderReject != null) {
          responderEvent.currentTarget = node;
          responderEvent.dispatchConfig.registrationName = 'onResponderReject';
          onResponderReject(responderEvent);
        }
      }
    }
  }

  /* ------------ PUBLIC API ------------ */

  /**
   * Attach Listeners
   *
   * Use native events as ReactDOM doesn't have a non-plugin API to implement
   * this system.
   */
  var documentEventsCapturePhase = ['blur', 'scroll'];
  var documentEventsBubblePhase = [
  // mouse
  'mousedown', 'mousemove', 'mouseup', 'dragstart',
  // touch
  'touchstart', 'touchmove', 'touchend', 'touchcancel',
  // other
  'contextmenu', 'select', 'selectionchange'];
  function attachListeners() {
    if (canUseDOM.default && window.__reactResponderSystemActive == null) {
      window.addEventListener('blur', eventListener);
      documentEventsBubblePhase.forEach(eventType => {
        document.addEventListener(eventType, eventListener);
      });
      documentEventsCapturePhase.forEach(eventType => {
        document.addEventListener(eventType, eventListener, true);
      });
      window.__reactResponderSystemActive = true;
    }
  }

  /**
   * Register a node with the ResponderSystem.
   */
  function addNode(id, node, config) {
    (0, _utils.setResponderId)(node, id);
    responderListenersMap.set(id, config);
  }

  /**
   * Unregister a node with the ResponderSystem.
   */
  function removeNode(id) {
    if (currentResponder.id === id) {
      terminateResponder();
    }
    if (responderListenersMap.has(id)) {
      responderListenersMap.delete(id);
    }
  }

  /**
   * Allow the current responder to be terminated from within components to support
   * more complex requirements, such as use with other React libraries for working
   * with scroll views, input views, etc.
   */
  function terminateResponder() {
    var _currentResponder3 = currentResponder,
      id = _currentResponder3.id,
      node = _currentResponder3.node;
    if (id != null && node != null) {
      var _getResponderConfig4 = getResponderConfig(id),
        onResponderTerminate = _getResponderConfig4.onResponderTerminate;
      if (onResponderTerminate != null) {
        var event = (0, createResponderEvent.default)({}, responderTouchHistoryStore);
        event.currentTarget = node;
        onResponderTerminate(event);
      }
      changeCurrentResponder(emptyResponder);
    }
    isEmulatingMouseEvents = false;
    trackedTouchCount = 0;
  }

  /**
   * Allow unit tests to inspect the current responder in the system.
   * FOR TESTING ONLY.
   */
  function getResponderNode() {
    return currentResponder.node;
  }
},127,[128,129,130,132,45],"node_modules/react-native-web/dist/modules/useResponderEvents/ResponderSystem.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return createResponderEvent;
    }
  });
  var _modulesGetBoundingClientRect = require(_dependencyMap[0], "../../modules/getBoundingClientRect");
  var getBoundingClientRect = _interopDefault(_modulesGetBoundingClientRect);
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyFunction = () => {};
  var emptyObject = {};
  var emptyArray = [];

  /**
   * Safari produces very large identifiers that would cause the `touchBank` array
   * length to be so large as to crash the browser, if not normalized like this.
   * In the future the `touchBank` should use an object/map instead.
   */
  function normalizeIdentifier(identifier) {
    return identifier > 20 ? identifier % 20 : identifier;
  }

  /**
   * Converts a native DOM event to a ResponderEvent.
   * Mouse events are transformed into fake touch events.
   */
  function createResponderEvent(domEvent, responderTouchHistoryStore) {
    var rect;
    var propagationWasStopped = false;
    var changedTouches;
    var touches;
    var domEventChangedTouches = domEvent.changedTouches;
    var domEventType = domEvent.type;
    var metaKey = domEvent.metaKey === true;
    var shiftKey = domEvent.shiftKey === true;
    var force = domEventChangedTouches && domEventChangedTouches[0].force || 0;
    var identifier = normalizeIdentifier(domEventChangedTouches && domEventChangedTouches[0].identifier || 0);
    var clientX = domEventChangedTouches && domEventChangedTouches[0].clientX || domEvent.clientX;
    var clientY = domEventChangedTouches && domEventChangedTouches[0].clientY || domEvent.clientY;
    var pageX = domEventChangedTouches && domEventChangedTouches[0].pageX || domEvent.pageX;
    var pageY = domEventChangedTouches && domEventChangedTouches[0].pageY || domEvent.pageY;
    var preventDefault = typeof domEvent.preventDefault === 'function' ? domEvent.preventDefault.bind(domEvent) : emptyFunction;
    var timestamp = domEvent.timeStamp;
    function normalizeTouches(touches) {
      return Array.prototype.slice.call(touches).map(touch => {
        return {
          force: touch.force,
          identifier: normalizeIdentifier(touch.identifier),
          get locationX() {
            return locationX(touch.clientX);
          },
          get locationY() {
            return locationY(touch.clientY);
          },
          pageX: touch.pageX,
          pageY: touch.pageY,
          target: touch.target,
          timestamp
        };
      });
    }
    if (domEventChangedTouches != null) {
      changedTouches = normalizeTouches(domEventChangedTouches);
      touches = normalizeTouches(domEvent.touches);
    } else {
      var emulatedTouches = [{
        force,
        identifier,
        get locationX() {
          return locationX(clientX);
        },
        get locationY() {
          return locationY(clientY);
        },
        pageX,
        pageY,
        target: domEvent.target,
        timestamp
      }];
      changedTouches = emulatedTouches;
      touches = domEventType === 'mouseup' || domEventType === 'dragstart' ? emptyArray : emulatedTouches;
    }
    var responderEvent = {
      bubbles: true,
      cancelable: true,
      // `currentTarget` is set before dispatch
      currentTarget: null,
      defaultPrevented: domEvent.defaultPrevented,
      dispatchConfig: emptyObject,
      eventPhase: domEvent.eventPhase,
      isDefaultPrevented() {
        return domEvent.defaultPrevented;
      },
      isPropagationStopped() {
        return propagationWasStopped;
      },
      isTrusted: domEvent.isTrusted,
      nativeEvent: {
        altKey: false,
        ctrlKey: false,
        metaKey,
        shiftKey,
        changedTouches,
        force,
        identifier,
        get locationX() {
          return locationX(clientX);
        },
        get locationY() {
          return locationY(clientY);
        },
        pageX,
        pageY,
        target: domEvent.target,
        timestamp,
        touches,
        type: domEventType
      },
      persist: emptyFunction,
      preventDefault,
      stopPropagation() {
        propagationWasStopped = true;
      },
      target: domEvent.target,
      timeStamp: timestamp,
      touchHistory: responderTouchHistoryStore.touchHistory
    };

    // Using getters and functions serves two purposes:
    // 1) The value of `currentTarget` is not initially available.
    // 2) Measuring the clientRect may cause layout jank and should only be done on-demand.
    function locationX(x) {
      rect = rect || (0, getBoundingClientRect.default)(responderEvent.currentTarget);
      if (rect) {
        return x - rect.left;
      }
    }
    function locationY(y) {
      rect = rect || (0, getBoundingClientRect.default)(responderEvent.currentTarget);
      if (rect) {
        return y - rect.top;
      }
    }
    return responderEvent;
  }
},128,[49],"node_modules/react-native-web/dist/modules/useResponderEvents/createResponderEvent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "BLUR", {
    enumerable: true,
    get: function () {
      return BLUR;
    }
  });
  Object.defineProperty(exports, "CONTEXT_MENU", {
    enumerable: true,
    get: function () {
      return CONTEXT_MENU;
    }
  });
  Object.defineProperty(exports, "FOCUS_OUT", {
    enumerable: true,
    get: function () {
      return FOCUS_OUT;
    }
  });
  Object.defineProperty(exports, "MOUSE_DOWN", {
    enumerable: true,
    get: function () {
      return MOUSE_DOWN;
    }
  });
  Object.defineProperty(exports, "MOUSE_MOVE", {
    enumerable: true,
    get: function () {
      return MOUSE_MOVE;
    }
  });
  Object.defineProperty(exports, "MOUSE_UP", {
    enumerable: true,
    get: function () {
      return MOUSE_UP;
    }
  });
  Object.defineProperty(exports, "MOUSE_CANCEL", {
    enumerable: true,
    get: function () {
      return MOUSE_CANCEL;
    }
  });
  Object.defineProperty(exports, "TOUCH_START", {
    enumerable: true,
    get: function () {
      return TOUCH_START;
    }
  });
  Object.defineProperty(exports, "TOUCH_MOVE", {
    enumerable: true,
    get: function () {
      return TOUCH_MOVE;
    }
  });
  Object.defineProperty(exports, "TOUCH_END", {
    enumerable: true,
    get: function () {
      return TOUCH_END;
    }
  });
  Object.defineProperty(exports, "TOUCH_CANCEL", {
    enumerable: true,
    get: function () {
      return TOUCH_CANCEL;
    }
  });
  Object.defineProperty(exports, "SCROLL", {
    enumerable: true,
    get: function () {
      return SCROLL;
    }
  });
  Object.defineProperty(exports, "SELECT", {
    enumerable: true,
    get: function () {
      return SELECT;
    }
  });
  Object.defineProperty(exports, "SELECTION_CHANGE", {
    enumerable: true,
    get: function () {
      return SELECTION_CHANGE;
    }
  });
  exports.isStartish = isStartish;
  exports.isMoveish = isMoveish;
  exports.isEndish = isEndish;
  exports.isCancelish = isCancelish;
  exports.isScroll = isScroll;
  exports.isSelectionChange = isSelectionChange;
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var BLUR = 'blur';
  var CONTEXT_MENU = 'contextmenu';
  var FOCUS_OUT = 'focusout';
  var MOUSE_DOWN = 'mousedown';
  var MOUSE_MOVE = 'mousemove';
  var MOUSE_UP = 'mouseup';
  var MOUSE_CANCEL = 'dragstart';
  var TOUCH_START = 'touchstart';
  var TOUCH_MOVE = 'touchmove';
  var TOUCH_END = 'touchend';
  var TOUCH_CANCEL = 'touchcancel';
  var SCROLL = 'scroll';
  var SELECT = 'select';
  var SELECTION_CHANGE = 'selectionchange';
  function isStartish(eventType) {
    return eventType === TOUCH_START || eventType === MOUSE_DOWN;
  }
  function isMoveish(eventType) {
    return eventType === TOUCH_MOVE || eventType === MOUSE_MOVE;
  }
  function isEndish(eventType) {
    return eventType === TOUCH_END || eventType === MOUSE_UP || isCancelish(eventType);
  }
  function isCancelish(eventType) {
    return eventType === TOUCH_CANCEL || eventType === MOUSE_CANCEL;
  }
  function isScroll(eventType) {
    return eventType === SCROLL;
  }
  function isSelectionChange(eventType) {
    return eventType === SELECT || eventType === SELECTION_CHANGE;
  }
},129,[],"node_modules/react-native-web/dist/modules/useResponderEvents/ResponderEventTypes.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.setResponderId = setResponderId;
  exports.getResponderPaths = getResponderPaths;
  exports.getLowestCommonAncestor = getLowestCommonAncestor;
  exports.hasTargetTouches = hasTargetTouches;
  exports.hasValidSelection = hasValidSelection;
  exports.isPrimaryPointerDown = isPrimaryPointerDown;
  var _modulesIsSelectionValid = require(_dependencyMap[0], "../../modules/isSelectionValid");
  var isSelectionValid = _interopDefault(_modulesIsSelectionValid);
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var keyName = '__reactResponderId';
  function getEventPath(domEvent) {
    // The 'selectionchange' event always has the 'document' as the target.
    // Use the anchor node as the initial target to reconstruct a path.
    // (We actually only need the first "responder" node in practice.)
    if (domEvent.type === 'selectionchange') {
      var target = window.getSelection().anchorNode;
      return composedPathFallback(target);
    } else {
      var path = domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);
      return path;
    }
  }
  function composedPathFallback(target) {
    var path = [];
    while (target != null && target !== document.body) {
      path.push(target);
      target = target.parentNode;
    }
    return path;
  }

  /**
   * Retrieve the responderId from a host node
   */
  function getResponderId(node) {
    if (node != null) {
      return node[keyName];
    }
    return null;
  }

  /**
   * Store the responderId on a host node
   */
  function setResponderId(node, id) {
    if (node != null) {
      node[keyName] = id;
    }
  }

  /**
   * Filter the event path to contain only the nodes attached to the responder system
   */
  function getResponderPaths(domEvent) {
    var idPath = [];
    var nodePath = [];
    var eventPath = getEventPath(domEvent);
    for (var i = 0; i < eventPath.length; i++) {
      var node = eventPath[i];
      var id = getResponderId(node);
      if (id != null) {
        idPath.push(id);
        nodePath.push(node);
      }
    }
    return {
      idPath,
      nodePath
    };
  }

  /**
   * Walk the paths and find the first common ancestor
   */
  function getLowestCommonAncestor(pathA, pathB) {
    var pathALength = pathA.length;
    var pathBLength = pathB.length;
    if (
    // If either path is empty
    pathALength === 0 || pathBLength === 0 ||
    // If the last elements aren't the same there can't be a common ancestor
    // that is connected to the responder system
    pathA[pathALength - 1] !== pathB[pathBLength - 1]) {
      return null;
    }
    var itemA = pathA[0];
    var indexA = 0;
    var itemB = pathB[0];
    var indexB = 0;

    // If A is deeper, skip indices that can't match.
    if (pathALength - pathBLength > 0) {
      indexA = pathALength - pathBLength;
      itemA = pathA[indexA];
      pathALength = pathBLength;
    }

    // If B is deeper, skip indices that can't match
    if (pathBLength - pathALength > 0) {
      indexB = pathBLength - pathALength;
      itemB = pathB[indexB];
      pathBLength = pathALength;
    }

    // Walk in lockstep until a match is found
    var depth = pathALength;
    while (depth--) {
      if (itemA === itemB) {
        return itemA;
      }
      itemA = pathA[indexA++];
      itemB = pathB[indexB++];
    }
    return null;
  }

  /**
   * Determine whether any of the active touches are within the current responder.
   * This cannot rely on W3C `targetTouches`, as neither IE11 nor Safari implement it.
   */
  function hasTargetTouches(target, touches) {
    if (!touches || touches.length === 0) {
      return false;
    }
    for (var i = 0; i < touches.length; i++) {
      var node = touches[i].target;
      if (node != null) {
        if (target.contains(node)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Ignore 'selectionchange' events that don't correspond with a person's intent to
   * select text.
   */
  function hasValidSelection(domEvent) {
    if (domEvent.type === 'selectionchange') {
      return (0, isSelectionValid.default)();
    }
    return domEvent.type === 'select';
  }

  /**
   * Events are only valid if the primary button was used without specific modifier keys.
   */
  function isPrimaryPointerDown(domEvent) {
    var altKey = domEvent.altKey,
      button = domEvent.button,
      buttons = domEvent.buttons,
      ctrlKey = domEvent.ctrlKey,
      type = domEvent.type;
    var isTouch = type === 'touchstart' || type === 'touchmove';
    var isPrimaryMouseDown = type === 'mousedown' && (button === 0 || buttons === 1);
    var isPrimaryMouseMove = type === 'mousemove' && buttons === 1;
    var noModifiers = altKey === false && ctrlKey === false;
    if (isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers) {
      return true;
    }
    return false;
  }
},130,[131],"node_modules/react-native-web/dist/modules/useResponderEvents/utils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return isSelectionValid;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function isSelectionValid() {
    var selection = window.getSelection();
    var string = selection.toString();
    var anchorNode = selection.anchorNode;
    var focusNode = selection.focusNode;
    var isTextNode = anchorNode && anchorNode.nodeType === window.Node.TEXT_NODE || focusNode && focusNode.nodeType === window.Node.TEXT_NODE;
    return string.length >= 1 && string !== '\n' && isTextNode;
  }
},131,[],"node_modules/react-native-web/dist/modules/isSelectionValid/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "ResponderTouchHistoryStore", {
    enumerable: true,
    get: function () {
      return ResponderTouchHistoryStore;
    }
  });
  var _ResponderEventTypes = require(_dependencyMap[0], "./ResponderEventTypes");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Tracks the position and time of each active touch by `touch.identifier`. We
   * should typically only see IDs in the range of 1-20 because IDs get recycled
   * when touches end and start again.
   */

  var __DEV__ = process.env.NODE_ENV !== 'production';
  var MAX_TOUCH_BANK = 20;
  function timestampForTouch(touch) {
    // The legacy internal implementation provides "timeStamp", which has been
    // renamed to "timestamp".
    return touch.timeStamp || touch.timestamp;
  }

  /**
   * TODO: Instead of making gestures recompute filtered velocity, we could
   * include a built in velocity computation that can be reused globally.
   */
  function createTouchRecord(touch) {
    return {
      touchActive: true,
      startPageX: touch.pageX,
      startPageY: touch.pageY,
      startTimeStamp: timestampForTouch(touch),
      currentPageX: touch.pageX,
      currentPageY: touch.pageY,
      currentTimeStamp: timestampForTouch(touch),
      previousPageX: touch.pageX,
      previousPageY: touch.pageY,
      previousTimeStamp: timestampForTouch(touch)
    };
  }
  function resetTouchRecord(touchRecord, touch) {
    touchRecord.touchActive = true;
    touchRecord.startPageX = touch.pageX;
    touchRecord.startPageY = touch.pageY;
    touchRecord.startTimeStamp = timestampForTouch(touch);
    touchRecord.currentPageX = touch.pageX;
    touchRecord.currentPageY = touch.pageY;
    touchRecord.currentTimeStamp = timestampForTouch(touch);
    touchRecord.previousPageX = touch.pageX;
    touchRecord.previousPageY = touch.pageY;
    touchRecord.previousTimeStamp = timestampForTouch(touch);
  }
  function getTouchIdentifier(_ref) {
    var identifier = _ref.identifier;
    if (identifier == null) {
      console.error('Touch object is missing identifier.');
    }
    if (__DEV__) {
      if (identifier > MAX_TOUCH_BANK) {
        console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);
      }
    }
    return identifier;
  }
  function recordTouchStart(touch, touchHistory) {
    var identifier = getTouchIdentifier(touch);
    var touchRecord = touchHistory.touchBank[identifier];
    if (touchRecord) {
      resetTouchRecord(touchRecord, touch);
    } else {
      touchHistory.touchBank[identifier] = createTouchRecord(touch);
    }
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  }
  function recordTouchMove(touch, touchHistory) {
    var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
    if (touchRecord) {
      touchRecord.touchActive = true;
      touchRecord.previousPageX = touchRecord.currentPageX;
      touchRecord.previousPageY = touchRecord.currentPageY;
      touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
      touchRecord.currentPageX = touch.pageX;
      touchRecord.currentPageY = touch.pageY;
      touchRecord.currentTimeStamp = timestampForTouch(touch);
      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
    } else {
      console.warn('Cannot record touch move without a touch start.\n', "Touch Move: " + printTouch(touch) + "\n", "Touch Bank: " + printTouchBank(touchHistory));
    }
  }
  function recordTouchEnd(touch, touchHistory) {
    var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
    if (touchRecord) {
      touchRecord.touchActive = false;
      touchRecord.previousPageX = touchRecord.currentPageX;
      touchRecord.previousPageY = touchRecord.currentPageY;
      touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
      touchRecord.currentPageX = touch.pageX;
      touchRecord.currentPageY = touch.pageY;
      touchRecord.currentTimeStamp = timestampForTouch(touch);
      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
    } else {
      console.warn('Cannot record touch end without a touch start.\n', "Touch End: " + printTouch(touch) + "\n", "Touch Bank: " + printTouchBank(touchHistory));
    }
  }
  function printTouch(touch) {
    return JSON.stringify({
      identifier: touch.identifier,
      pageX: touch.pageX,
      pageY: touch.pageY,
      timestamp: timestampForTouch(touch)
    });
  }
  function printTouchBank(touchHistory) {
    var touchBank = touchHistory.touchBank;
    var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
    if (touchBank.length > MAX_TOUCH_BANK) {
      printed += ' (original size: ' + touchBank.length + ')';
    }
    return printed;
  }
  class ResponderTouchHistoryStore {
    constructor() {
      this._touchHistory = {
        touchBank: [],
        //Array<TouchRecord>
        numberActiveTouches: 0,
        // If there is only one active touch, we remember its location. This prevents
        // us having to loop through all of the touches all the time in the most
        // common case.
        indexOfSingleActiveTouch: -1,
        mostRecentTimeStamp: 0
      };
    }
    recordTouchTrack(topLevelType, nativeEvent) {
      var touchHistory = this._touchHistory;
      if ((0, _ResponderEventTypes.isMoveish)(topLevelType)) {
        nativeEvent.changedTouches.forEach(touch => recordTouchMove(touch, touchHistory));
      } else if ((0, _ResponderEventTypes.isStartish)(topLevelType)) {
        nativeEvent.changedTouches.forEach(touch => recordTouchStart(touch, touchHistory));
        touchHistory.numberActiveTouches = nativeEvent.touches.length;
        if (touchHistory.numberActiveTouches === 1) {
          touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
        }
      } else if ((0, _ResponderEventTypes.isEndish)(topLevelType)) {
        nativeEvent.changedTouches.forEach(touch => recordTouchEnd(touch, touchHistory));
        touchHistory.numberActiveTouches = nativeEvent.touches.length;
        if (touchHistory.numberActiveTouches === 1) {
          var touchBank = touchHistory.touchBank;
          for (var i = 0; i < touchBank.length; i++) {
            var touchTrackToCheck = touchBank[i];
            if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
              touchHistory.indexOfSingleActiveTouch = i;
              break;
            }
          }
          if (__DEV__) {
            var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
            if (!(activeRecord != null && activeRecord.touchActive)) {
              console.error('Cannot find single active touch.');
            }
          }
        }
      }
    }
    get touchHistory() {
      return this._touchHistory;
    }
  }
},132,[129],"node_modules/react-native-web/dist/modules/useResponderEvents/ResponderTouchHistoryStore.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var TextAncestorContext = /*#__PURE__*/(0, _react.createContext)(false);
  var _default = TextAncestorContext;
},133,[9],"node_modules/react-native-web/dist/exports/Text/TextAncestorContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */
  'use strict';

  var emptyFunction = require(_dependencyMap[0], "./emptyFunction");
  /**
   * Similar to invariant but only logs a warning if the condition is not met.
   * This can be used to log issues in development environments in critical
   * paths. Removing the logging code for production environments will keep the
   * same logic and follow the same code paths.
   */

  function printWarning(format) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  }
  var warning = process.env.NODE_ENV !== "production" ? function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }
      printWarning.apply(void 0, [format].concat(args));
    }
  } : emptyFunction;
  module.exports = warning;
},134,[135],"node_modules/fbjs/lib/warning.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }
  /**
   * This function accepts and discards inputs; it has no side effects. This is
   * primarily useful idiomatically for overridable function endpoints which
   * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
   */

  var emptyFunction = function emptyFunction() {};
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function () {
    return this;
  };
  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };
  module.exports = emptyFunction;
},135,[],"node_modules/fbjs/lib/emptyFunction.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.getBackgroundColor = getBackgroundColor;
  exports.getBackgroundLightColor = getBackgroundLightColor;
  exports.getBackgroundDarkColor = getBackgroundDarkColor;
  exports.getWarningColor = getWarningColor;
  exports.getWarningDarkColor = getWarningDarkColor;
  exports.getFatalColor = getFatalColor;
  exports.getFatalDarkColor = getFatalDarkColor;
  exports.getErrorColor = getErrorColor;
  exports.getErrorDarkColor = getErrorDarkColor;
  exports.getLogColor = getLogColor;
  exports.getWarningHighlightColor = getWarningHighlightColor;
  exports.getDividerColor = getDividerColor;
  exports.getHighlightColor = getHighlightColor;
  exports.getTextColor = getTextColor;
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  function getBackgroundColor(opacity) {
    return `rgba(0, 0, 0, ${opacity == null ? 1 : opacity})`;
    // return `rgba(51, 51, 51, ${opacity == null ? 1 : opacity})`;
  }
  function getBackgroundLightColor(opacity) {
    return `rgba(69, 69, 69, ${opacity == null ? 1 : opacity})`;
  }
  function getBackgroundDarkColor(opacity) {
    return `rgba(34, 34, 34, ${opacity == null ? 1 : opacity})`;
  }
  function getWarningColor(opacity) {
    return `rgba(250, 186, 48, ${opacity == null ? 1 : opacity})`;
  }
  function getWarningDarkColor(opacity) {
    return `rgba(224, 167, 8, ${opacity == null ? 1 : opacity})`;
  }
  function getFatalColor(opacity) {
    return `rgba(243, 83, 105, ${opacity == null ? 1 : opacity})`;
  }
  function getFatalDarkColor(opacity) {
    return `rgba(208, 75, 95, ${opacity == null ? 1 : opacity})`;
  }
  function getErrorColor(opacity) {
    return `rgba(243, 83, 105, ${opacity == null ? 1 : opacity})`;
  }
  function getErrorDarkColor(opacity) {
    return `rgba(208, 75, 95, ${opacity == null ? 1 : opacity})`;
  }
  function getLogColor(opacity) {
    return `rgba(119, 119, 119, ${opacity == null ? 1 : opacity})`;
  }
  function getWarningHighlightColor(opacity) {
    return `rgba(252, 176, 29, ${opacity == null ? 1 : opacity})`;
  }
  function getDividerColor(opacity) {
    return `rgba(255, 255, 255, ${opacity == null ? 1 : opacity})`;
  }
  function getHighlightColor(opacity) {
    return `rgba(252, 176, 29, ${opacity == null ? 1 : opacity})`;
  }
  function getTextColor(opacity) {
    return `rgba(255, 255, 255, ${opacity == null ? 1 : opacity})`;
  }
},136,[],"node_modules/@expo/metro-runtime/src/error-overlay/UI/LogBoxStyle.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorCodeFrame.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.LogBoxInspectorCodeFrame = LogBoxInspectorCodeFrame;
  require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsScrollView = require(_dependencyMap[1], "react-native-web/dist/exports/ScrollView");
  var ScrollView = _interopDefault(_reactNativeWebDistExportsScrollView);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[3], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsView = require(_dependencyMap[4], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _LogBoxInspectorSection = require(_dependencyMap[5], "./LogBoxInspectorSection");
  var _UIAnsiHighlight = require(_dependencyMap[6], "../UI/AnsiHighlight");
  var _UILogBoxButton = require(_dependencyMap[7], "../UI/LogBoxButton");
  var _UILogBoxStyle = require(_dependencyMap[8], "../UI/LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_UILogBoxStyle);
  var _UIConstants = require(_dependencyMap[9], "../UI/constants");
  var _formatProjectFilePath = require(_dependencyMap[10], "../formatProjectFilePath");
  var _modulesOpenFileInEditor = require(_dependencyMap[11], "../modules/openFileInEditor");
  var openFileInEditor = _interopDefault(_modulesOpenFileInEditor);
  var _reactJsxDevRuntime = require(_dependencyMap[12], "react/jsx-dev-runtime");
  function LogBoxInspectorCodeFrame({
    codeFrame
  }) {
    if (codeFrame == null) {
      return null;
    }
    function getFileName() {
      return (0, _formatProjectFilePath.formatProjectFilePath)("C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot", codeFrame?.fileName);
    }
    function getLocation() {
      const location = codeFrame?.location;
      if (location != null) {
        return ` (${location.row}:${location.column + 1 /* Code frame columns are zero indexed */})`;
      }
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_LogBoxInspectorSection.LogBoxInspectorSection, {
      heading: "Source",
      children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: styles.box,
        children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
          style: styles.frame,
          children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ScrollView.default, {
            horizontal: true,
            contentContainerStyle: {
              flexDirection: 'column'
            },
            children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_UIAnsiHighlight.Ansi, {
              style: styles.content,
              text: codeFrame.content
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 49,
              columnNumber: 13
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 44,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 43,
          columnNumber: 9
        }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_UILogBoxButton.LogBoxButton, {
          backgroundColor: {
            default: 'transparent',
            pressed: LogBoxStyle.getBackgroundDarkColor(1)
          },
          style: styles.button,
          onPress: () => {
            (0, openFileInEditor.default)(codeFrame.fileName, codeFrame.location?.row ?? 0);
          },
          children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
            style: styles.fileText,
            children: [getFileName(), getLocation()]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 61,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 52,
          columnNumber: 9
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 42,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 41,
      columnNumber: 5
    }, this);
  }
  const styles = StyleSheet.default.create({
    box: {
      backgroundColor: LogBoxStyle.getBackgroundColor(),
      borderWidth: 1,
      borderColor: '#323232',
      marginLeft: 10,
      marginRight: 10,
      marginTop: 5,
      borderRadius: 3
    },
    frame: {
      padding: 10,
      borderBottomColor: LogBoxStyle.getTextColor(0.1),
      borderBottomWidth: 1
    },
    button: {
      paddingTop: 10,
      paddingBottom: 10
    },
    content: {
      flexDirection: 'column',
      color: LogBoxStyle.getTextColor(1),
      fontSize: 12,
      includeFontPadding: false,
      lineHeight: 20,
      fontFamily: _UIConstants.CODE_FONT
    },
    fileText: {
      userSelect: 'none',
      color: LogBoxStyle.getTextColor(0.5),
      textAlign: 'center',
      flex: 1,
      fontSize: 16,
      includeFontPadding: false,
      fontFamily: _UIConstants.CODE_FONT
    }
  });
},137,[9,36,55,138,110,139,140,142,136,150,151,152,33],"node_modules/@expo/metro-runtime/src/error-overlay/overlay/LogBoxInspectorCodeFrame.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[3], "../createElement");
  var createElement = _interopDefault(_createElement);
  var _modulesForwardedProps = require(_dependencyMap[4], "../../modules/forwardedProps");
  var forwardedProps = _interopNamespace(_modulesForwardedProps);
  var _modulesPick = require(_dependencyMap[5], "../../modules/pick");
  var pick = _interopDefault(_modulesPick);
  var _modulesUseElementLayout = require(_dependencyMap[6], "../../modules/useElementLayout");
  var useElementLayout = _interopDefault(_modulesUseElementLayout);
  var _modulesUseMergeRefs = require(_dependencyMap[7], "../../modules/useMergeRefs");
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePlatformMethods = require(_dependencyMap[8], "../../modules/usePlatformMethods");
  var usePlatformMethods = _interopDefault(_modulesUsePlatformMethods);
  var _modulesUseResponderEvents = require(_dependencyMap[9], "../../modules/useResponderEvents");
  var useResponderEvents = _interopDefault(_modulesUseResponderEvents);
  var _StyleSheet = require(_dependencyMap[10], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _TextAncestorContext = require(_dependencyMap[11], "./TextAncestorContext");
  var TextAncestorContext = _interopDefault(_TextAncestorContext);
  var _modulesUseLocale = require(_dependencyMap[12], "../../modules/useLocale");
  var _excluded = ["hrefAttrs", "numberOfLines", "onClick", "onLayout", "onPress", "onMoveShouldSetResponder", "onMoveShouldSetResponderCapture", "onResponderEnd", "onResponderGrant", "onResponderMove", "onResponderReject", "onResponderRelease", "onResponderStart", "onResponderTerminate", "onResponderTerminationRequest", "onScrollShouldSetResponder", "onScrollShouldSetResponderCapture", "onSelectionChangeShouldSetResponder", "onSelectionChangeShouldSetResponderCapture", "onStartShouldSetResponder", "onStartShouldSetResponderCapture", "selectable"];
  //import { warnOnce } from '../../modules/warnOnce';

  var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
    href: true,
    lang: true,
    pointerEvents: true
  });
  var pickProps = props => (0, pick.default)(props, forwardPropsList);
  var Text = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var hrefAttrs = props.hrefAttrs,
      numberOfLines = props.numberOfLines,
      onClick = props.onClick,
      onLayout = props.onLayout,
      onPress = props.onPress,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      selectable = props.selectable,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);

    /*
    if (selectable != null) {
      warnOnce(
        'selectable',
        'selectable prop is deprecated. Use styles.userSelect.'
      );
    }
    */

    var hasTextAncestor = React.useContext(TextAncestorContext.default);
    var hostRef = React.useRef(null);
    var _useLocaleContext = (0, _modulesUseLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;
    (0, useElementLayout.default)(hostRef, onLayout);
    (0, useResponderEvents.default)(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    var handleClick = React.useCallback(e => {
      if (onClick != null) {
        onClick(e);
      } else if (onPress != null) {
        e.stopPropagation();
        onPress(e);
      }
    }, [onClick, onPress]);
    var component = hasTextAncestor ? 'span' : 'div';
    var langDirection = props.lang != null ? (0, _modulesUseLocale.getLocaleDirection)(props.lang) : null;
    var componentDirection = props.dir || langDirection;
    var writingDirection = componentDirection || contextDirection;
    var supportedProps = pickProps(rest);
    supportedProps.dir = componentDirection;
    // 'auto' by default allows browsers to infer writing direction (root elements only)
    if (!hasTextAncestor) {
      supportedProps.dir = componentDirection != null ? componentDirection : 'auto';
    }
    if (onClick || onPress) {
      supportedProps.onClick = handleClick;
    }
    supportedProps.style = [numberOfLines != null && numberOfLines > 1 && {
      WebkitLineClamp: numberOfLines
    }, hasTextAncestor === true ? styles.textHasAncestor$raw : styles.text$raw, numberOfLines === 1 && styles.textOneLine, numberOfLines != null && numberOfLines > 1 && styles.textMultiLine, props.style, selectable === true && styles.selectable, selectable === false && styles.notSelectable, onPress && styles.pressable];
    if (props.href != null) {
      component = 'a';
      if (hrefAttrs != null) {
        var download = hrefAttrs.download,
          rel = hrefAttrs.rel,
          target = hrefAttrs.target;
        if (download != null) {
          supportedProps.download = download;
        }
        if (rel != null) {
          supportedProps.rel = rel;
        }
        if (typeof target === 'string') {
          supportedProps.target = target.charAt(0) !== '_' ? '_' + target : target;
        }
      }
    }
    var platformMethodsRef = (0, usePlatformMethods.default)(supportedProps);
    var setRef = (0, useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
    supportedProps.ref = setRef;
    var element = (0, createElement.default)(component, supportedProps, {
      writingDirection
    });
    return hasTextAncestor ? element : /*#__PURE__*/React.createElement(TextAncestorContext.default.Provider, {
      value: true
    }, element);
  });
  Text.displayName = 'Text';
  var textStyle = {
    backgroundColor: 'transparent',
    border: '0 solid black',
    boxSizing: 'border-box',
    color: 'black',
    display: 'inline',
    font: '14px System',
    listStyle: 'none',
    margin: 0,
    padding: 0,
    position: 'relative',
    textAlign: 'start',
    textDecoration: 'none',
    whiteSpace: 'pre-wrap',
    wordWrap: 'break-word'
  };
  var styles = StyleSheet.default.create({
    text$raw: textStyle,
    textHasAncestor$raw: (0, _objectSpread.default)((0, _objectSpread.default)({}, textStyle), {}, {
      color: 'inherit',
      font: 'inherit',
      textAlign: 'inherit',
      whiteSpace: 'inherit'
    }),
    textOneLine: {
      maxWidth: '100%',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      wordWrap: 'normal'
    },
    // See #13
    textMultiLine: {
      display: '-webkit-box',
      maxWidth: '100%',
      overflow: 'clip',
      textOverflow: 'ellipsis',
      WebkitBoxOrient: 'vertical'
    },
    notSelectable: {
      userSelect: 'none'
    },
    selectable: {
      userSelect: 'text'
    },
    pressable: {
      cursor: 'pointer'
    }
  });
  var _default = Text;
},138,[37,43,9,111,119,120,121,123,124,126,55,133,117],"node_modules/react-native-web/dist/exports/Text/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorSection.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.LogBoxInspectorSection = LogBoxInspectorSection;
  require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[1], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[2], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsView = require(_dependencyMap[3], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _UILogBoxStyle = require(_dependencyMap[4], "../UI/LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_UILogBoxStyle);
  var _reactJsxDevRuntime = require(_dependencyMap[5], "react/jsx-dev-runtime");
  function LogBoxInspectorSection(props) {
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: styles.section,
      children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: styles.heading,
        children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
          style: styles.headingText,
          children: props.heading
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 23,
          columnNumber: 9
        }, this), props.action]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 22,
        columnNumber: 7
      }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: styles.body,
        children: props.children
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 26,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 5
    }, this);
  }
  const styles = StyleSheet.default.create({
    section: {
      marginTop: 15
    },
    heading: {
      alignItems: 'center',
      flexDirection: 'row',
      paddingHorizontal: 12,
      marginBottom: 10
    },
    headingText: {
      color: LogBoxStyle.getTextColor(1),
      flex: 1,
      fontSize: 18,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 20
    },
    body: {
      paddingBottom: 10
    }
  });
},139,[9,55,138,110,136,33],"node_modules/@expo/metro-runtime/src/error-overlay/overlay/LogBoxInspectorSection.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\UI\\AnsiHighlight.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.Ansi = Ansi;
  var _anser = require(_dependencyMap[0], "anser");
  var Anser = _interopDefault(_anser);
  require(_dependencyMap[1], "react");
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[3], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsView = require(_dependencyMap[4], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactJsxDevRuntime = require(_dependencyMap[5], "react/jsx-dev-runtime");
  // Afterglow theme from https://iterm2colorschemes.com/
  const COLORS = {
    'ansi-black': 'rgb(27, 27, 27)',
    'ansi-red': 'rgb(187, 86, 83)',
    'ansi-green': 'rgb(144, 157, 98)',
    'ansi-yellow': 'rgb(234, 193, 121)',
    'ansi-blue': 'rgb(125, 169, 199)',
    'ansi-magenta': 'rgb(176, 101, 151)',
    'ansi-cyan': 'rgb(140, 220, 216)',
    // Instead of white, use the default color provided to the component
    // 'ansi-white': 'rgb(216, 216, 216)',
    'ansi-bright-black': 'rgb(98, 98, 98)',
    'ansi-bright-red': 'rgb(187, 86, 83)',
    'ansi-bright-green': 'rgb(144, 157, 98)',
    'ansi-bright-yellow': 'rgb(234, 193, 121)',
    'ansi-bright-blue': 'rgb(125, 169, 199)',
    'ansi-bright-magenta': 'rgb(176, 101, 151)',
    'ansi-bright-cyan': 'rgb(140, 220, 216)',
    'ansi-bright-white': 'rgb(247, 247, 247)'
  };
  function Ansi({
    text,
    style
  }) {
    let commonWhitespaceLength = Infinity;
    const parsedLines = text.split(/\n/).map(line => Anser.default.ansiToJson(line, {
      json: true,
      remove_empty: true,
      use_classes: true
    }));
    parsedLines.map(lines => {
      // The third item on each line includes the whitespace of the source code.
      // We are looking for the least amount of common whitespace to trim all lines.
      // Example: Array [" ", " 96 |", "     text", ...]
      const match = lines[2] && lines[2]?.content?.match(/^ +/);
      const whitespaceLength = match && match[0]?.length || 0;
      if (whitespaceLength < commonWhitespaceLength) {
        commonWhitespaceLength = whitespaceLength;
      }
    });
    const getText = (content, key) => {
      if (key === 1) {
        // Remove the vertical bar after line numbers
        return content.replace(/\| $/, ' ');
      } else if (key === 2 && commonWhitespaceLength < Infinity) {
        // Remove common whitespace at the beginning of the line
        return content.substr(commonWhitespaceLength);
      } else {
        return content;
      }
    };
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_reactJsxDevRuntime.Fragment, {
      children: parsedLines.map((items, i) => /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: styles.line,
        children: items.map((bundle, key) => {
          const textStyle = bundle.fg && COLORS[bundle.fg] ? {
            backgroundColor: bundle.bg && COLORS[bundle.bg],
            color: bundle.fg && COLORS[bundle.fg]
          } : {
            backgroundColor: bundle.bg && COLORS[bundle.bg]
          };
          return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
            style: [style, textStyle],
            children: getText(bundle.content, key)
          }, key, false, {
            fileName: _jsxFileName,
            lineNumber: 82,
            columnNumber: 15
          }, this);
        })
      }, i, false, {
        fileName: _jsxFileName,
        lineNumber: 70,
        columnNumber: 9
      }, this))
    }, void 0, false);
  }
  const styles = StyleSheet.default.create({
    line: {
      flexDirection: 'row'
    }
  });
},140,[141,9,55,138,110,33],"node_modules/@expo/metro-runtime/src/error-overlay/UI/AnsiHighlight.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var ANSI_COLORS = [[{
    color: "0, 0, 0",
    "class": "ansi-black"
  }, {
    color: "187, 0, 0",
    "class": "ansi-red"
  }, {
    color: "0, 187, 0",
    "class": "ansi-green"
  }, {
    color: "187, 187, 0",
    "class": "ansi-yellow"
  }, {
    color: "0, 0, 187",
    "class": "ansi-blue"
  }, {
    color: "187, 0, 187",
    "class": "ansi-magenta"
  }, {
    color: "0, 187, 187",
    "class": "ansi-cyan"
  }, {
    color: "255,255,255",
    "class": "ansi-white"
  }], [{
    color: "85, 85, 85",
    "class": "ansi-bright-black"
  }, {
    color: "255, 85, 85",
    "class": "ansi-bright-red"
  }, {
    color: "0, 255, 0",
    "class": "ansi-bright-green"
  }, {
    color: "255, 255, 85",
    "class": "ansi-bright-yellow"
  }, {
    color: "85, 85, 255",
    "class": "ansi-bright-blue"
  }, {
    color: "255, 85, 255",
    "class": "ansi-bright-magenta"
  }, {
    color: "85, 255, 255",
    "class": "ansi-bright-cyan"
  }, {
    color: "255, 255, 255",
    "class": "ansi-bright-white"
  }]];
  var Anser = function () {
    _createClass(Anser, null, [{
      key: "escapeForHtml",
      /**
       * Anser.escapeForHtml
       * Escape the input HTML.
       *
       * This does the minimum escaping of text to make it compliant with HTML.
       * In particular, the '&','<', and '>' characters are escaped. This should
       * be run prior to `ansiToHtml`.
       *
       * @name Anser.escapeForHtml
       * @function
       * @param {String} txt The input text (containing the ANSI snippets).
       * @returns {String} The escaped html.
       */
      value: function escapeForHtml(txt) {
        return new Anser().escapeForHtml(txt);
      }

      /**
       * Anser.linkify
       * Adds the links in the HTML.
       *
       * This replaces any links in the text with anchor tags that display the
       * link. The links should have at least one whitespace character
       * surrounding it. Also, you should apply this after you have run
       * `ansiToHtml` on the text.
       *
       * @name Anser.linkify
       * @function
       * @param {String} txt The input text.
       * @returns {String} The HTML containing the <a> tags (unescaped).
       */
    }, {
      key: "linkify",
      value: function linkify(txt) {
        return new Anser().linkify(txt);
      }

      /**
       * Anser.ansiToHtml
       * This replaces ANSI terminal escape codes with SPAN tags that wrap the
       * content.
       *
       * This function only interprets ANSI SGR (Select Graphic Rendition) codes
       * that can be represented in HTML.
       * For example, cursor movement codes are ignored and hidden from output.
       * The default style uses colors that are very close to the prescribed
       * standard. The standard assumes that the text will have a black
       * background. These colors are set as inline styles on the SPAN tags.
       *
       * Another option is to set `use_classes: true` in the options argument.
       * This will instead set classes on the spans so the colors can be set via
       * CSS. The class names used are of the format `ansi-*-fg/bg` and
       * `ansi-bright-*-fg/bg` where `*` is the color name,
       * i.e black/red/green/yellow/blue/magenta/cyan/white.
       *
       * @name Anser.ansiToHtml
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed to the ansiToHTML method.
       * @returns {String} The HTML output.
       */
    }, {
      key: "ansiToHtml",
      value: function ansiToHtml(txt, options) {
        return new Anser().ansiToHtml(txt, options);
      }

      /**
       * Anser.ansiToJson
       * Converts ANSI input into JSON output.
       *
       * @name Anser.ansiToJson
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed to the ansiToHTML method.
       * @returns {String} The HTML output.
       */
    }, {
      key: "ansiToJson",
      value: function ansiToJson(txt, options) {
        return new Anser().ansiToJson(txt, options);
      }

      /**
       * Anser.ansiToText
       * Converts ANSI input into text output.
       *
       * @name Anser.ansiToText
       * @function
       * @param {String} txt The input text.
       * @returns {String} The text output.
       */
    }, {
      key: "ansiToText",
      value: function ansiToText(txt) {
        return new Anser().ansiToText(txt);
      }

      /**
       * Anser
       * The `Anser` class.
       *
       * @name Anser
       * @function
       * @returns {Anser}
       */
    }]);
    function Anser() {
      _classCallCheck(this, Anser);
      this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
      this.bright = 0;
    }

    /**
     * setupPalette
     * Sets up the palette.
     *
     * @name setupPalette
     * @function
     */

    _createClass(Anser, [{
      key: "setupPalette",
      value: function setupPalette() {
        this.PALETTE_COLORS = [];

        // Index 0..15 : System color
        for (var i = 0; i < 2; ++i) {
          for (var j = 0; j < 8; ++j) {
            this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);
          }
        }

        // Index 16..231 : RGB 6x6x6
        // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml
        var levels = [0, 95, 135, 175, 215, 255];
        var format = function format(r, g, b) {
          return levels[r] + ", " + levels[g] + ", " + levels[b];
        };
        var r = void 0,
          g = void 0,
          b = void 0;
        for (var _r = 0; _r < 6; ++_r) {
          for (var _g = 0; _g < 6; ++_g) {
            for (var _b = 0; _b < 6; ++_b) {
              this.PALETTE_COLORS.push(format(_r, _g, _b));
            }
          }
        }

        // Index 232..255 : Grayscale
        var level = 8;
        for (var _i = 0; _i < 24; ++_i, level += 10) {
          this.PALETTE_COLORS.push(format(level, level, level));
        }
      }

      /**
       * escapeForHtml
       * Escapes the input text.
       *
       * @name escapeForHtml
       * @function
       * @param {String} txt The input text.
       * @returns {String} The escpaed HTML output.
       */
    }, {
      key: "escapeForHtml",
      value: function escapeForHtml(txt) {
        return txt.replace(/[&<>]/gm, function (str) {
          return str == "&" ? "&amp;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
        });
      }

      /**
       * linkify
       * Adds HTML link elements.
       *
       * @name linkify
       * @function
       * @param {String} txt The input text.
       * @returns {String} The HTML output containing link elements.
       */
    }, {
      key: "linkify",
      value: function linkify(txt) {
        return txt.replace(/(https?:\/\/[^\s]+)/gm, function (str) {
          return "<a href=\"" + str + "\">" + str + "</a>";
        });
      }

      /**
       * ansiToHtml
       * Converts ANSI input into HTML output.
       *
       * @name ansiToHtml
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed ot the `process` method.
       * @returns {String} The HTML output.
       */
    }, {
      key: "ansiToHtml",
      value: function ansiToHtml(txt, options) {
        return this.process(txt, options, true);
      }

      /**
       * ansiToJson
       * Converts ANSI input into HTML output.
       *
       * @name ansiToJson
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed ot the `process` method.
       * @returns {String} The JSON output.
       */
    }, {
      key: "ansiToJson",
      value: function ansiToJson(txt, options) {
        options = options || {};
        options.json = true;
        options.clearLine = false;
        return this.process(txt, options, true);
      }

      /**
       * ansiToText
       * Converts ANSI input into HTML output.
       *
       * @name ansiToText
       * @function
       * @param {String} txt The input text.
       * @returns {String} The text output.
       */
    }, {
      key: "ansiToText",
      value: function ansiToText(txt) {
        return this.process(txt, {}, false);
      }

      /**
       * process
       * Processes the input.
       *
       * @name process
       * @function
       * @param {String} txt The input text.
       * @param {Object} options An object passed to `processChunk` method, extended with:
       *
       *  - `json` (Boolean): If `true`, the result will be an object.
       *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
       *
       * @param {Boolean} markup
       */
    }, {
      key: "process",
      value: function process(txt, options, markup) {
        var _this = this;
        var self = this;
        var raw_text_chunks = txt.split(/\033\[/);
        var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split

        if (options === undefined || options === null) {
          options = {};
        }
        options.clearLine = /\r/.test(txt); // check for Carriage Return
        var color_chunks = raw_text_chunks.map(function (chunk) {
          return _this.processChunk(chunk, options, markup);
        });
        if (options && options.json) {
          var first = self.processChunkJson("");
          first.content = first_chunk;
          first.clearLine = options.clearLine;
          color_chunks.unshift(first);
          if (options.remove_empty) {
            color_chunks = color_chunks.filter(function (c) {
              return !c.isEmpty();
            });
          }
          return color_chunks;
        } else {
          color_chunks.unshift(first_chunk);
        }
        return color_chunks.join("");
      }

      /**
       * processChunkJson
       * Processes the current chunk into json output.
       *
       * @name processChunkJson
       * @function
       * @param {String} text The input text.
       * @param {Object} options An object containing the following fields:
       *
       *  - `json` (Boolean): If `true`, the result will be an object.
       *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
       *
       * @param {Boolean} markup If false, the colors will not be parsed.
       * @return {Object} The result object:
       *
       *  - `content` (String): The text.
       *  - `fg` (String|null): The foreground color.
       *  - `bg` (String|null): The background color.
       *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
       *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
       *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
       *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
       *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
       *
       */
    }, {
      key: "processChunkJson",
      value: function processChunkJson(text, options, markup) {
        // Are we using classes or styles?
        options = typeof options == "undefined" ? {} : options;
        var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
        var key = options.key = use_classes ? "class" : "color";
        var result = {
          content: text,
          fg: null,
          bg: null,
          fg_truecolor: null,
          bg_truecolor: null,
          clearLine: options.clearLine,
          decoration: null,
          was_processed: false,
          isEmpty: function isEmpty() {
            return !result.content;
          }
        };

        // Each "chunk" is the text after the CSI (ESC + "[") and before the next CSI/EOF.
        //
        // This regex matches four groups within a chunk.
        //
        // The first and third groups match code type.
        // We supported only SGR command. It has empty first group and "m" in third.
        //
        // The second group matches all of the number+semicolon command sequences
        // before the "m" (or other trailing) character.
        // These are the graphics or SGR commands.
        //
        // The last group is the text (including newlines) that is colored by
        // the other group"s commands.
        var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
        if (!matches) return result;
        var orig_txt = result.content = matches[4];
        var nums = matches[2].split(";");

        // We currently support only "SGR" (Select Graphic Rendition)
        // Simply ignore if not a SGR command.
        if (matches[1] !== "" || matches[3] !== "m") {
          return result;
        }
        if (!markup) {
          return result;
        }
        var self = this;
        self.decoration = null;
        while (nums.length > 0) {
          var num_str = nums.shift();
          var num = parseInt(num_str);
          if (isNaN(num) || num === 0) {
            self.fg = self.bg = self.decoration = null;
          } else if (num === 1) {
            self.decoration = "bold";
          } else if (num === 2) {
            self.decoration = "dim";
            // Enable code 2 to get string
          } else if (num == 3) {
            self.decoration = "italic";
          } else if (num == 4) {
            self.decoration = "underline";
          } else if (num == 5) {
            self.decoration = "blink";
          } else if (num === 7) {
            self.decoration = "reverse";
          } else if (num === 8) {
            self.decoration = "hidden";
            // Enable code 9 to get strikethrough
          } else if (num === 9) {
            self.decoration = "strikethrough";
          } else if (num == 39) {
            self.fg = null;
          } else if (num == 49) {
            self.bg = null;
            // Foreground color
          } else if (num >= 30 && num < 38) {
            self.fg = ANSI_COLORS[0][num % 10][key];
            // Foreground bright color
          } else if (num >= 90 && num < 98) {
            self.fg = ANSI_COLORS[1][num % 10][key];
            // Background color
          } else if (num >= 40 && num < 48) {
            self.bg = ANSI_COLORS[0][num % 10][key];
            // Background bright color
          } else if (num >= 100 && num < 108) {
            self.bg = ANSI_COLORS[1][num % 10][key];
          } else if (num === 38 || num === 48) {
            // extend color (38=fg, 48=bg)
            var is_foreground = num === 38;
            if (nums.length >= 1) {
              var mode = nums.shift();
              if (mode === "5" && nums.length >= 1) {
                // palette color
                var palette_index = parseInt(nums.shift());
                if (palette_index >= 0 && palette_index <= 255) {
                  if (!use_classes) {
                    if (!this.PALETTE_COLORS) {
                      self.setupPalette();
                    }
                    if (is_foreground) {
                      self.fg = this.PALETTE_COLORS[palette_index];
                    } else {
                      self.bg = this.PALETTE_COLORS[palette_index];
                    }
                  } else {
                    var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                    if (is_foreground) {
                      self.fg = klass;
                    } else {
                      self.bg = klass;
                    }
                  }
                }
              } else if (mode === "2" && nums.length >= 3) {
                // true color
                var r = parseInt(nums.shift());
                var g = parseInt(nums.shift());
                var b = parseInt(nums.shift());
                if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                  var color = r + ", " + g + ", " + b;
                  if (!use_classes) {
                    if (is_foreground) {
                      self.fg = color;
                    } else {
                      self.bg = color;
                    }
                  } else {
                    if (is_foreground) {
                      self.fg = "ansi-truecolor";
                      self.fg_truecolor = color;
                    } else {
                      self.bg = "ansi-truecolor";
                      self.bg_truecolor = color;
                    }
                  }
                }
              }
            }
          }
        }
        if (self.fg === null && self.bg === null && self.decoration === null) {
          return result;
        } else {
          var styles = [];
          var classes = [];
          var data = {};
          result.fg = self.fg;
          result.bg = self.bg;
          result.fg_truecolor = self.fg_truecolor;
          result.bg_truecolor = self.bg_truecolor;
          result.decoration = self.decoration;
          result.was_processed = true;
          return result;
        }
      }

      /**
       * processChunk
       * Processes the current chunk of text.
       *
       * @name processChunk
       * @function
       * @param {String} text The input text.
       * @param {Object} options An object containing the following fields:
       *
       *  - `json` (Boolean): If `true`, the result will be an object.
       *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
       *
       * @param {Boolean} markup If false, the colors will not be parsed.
       * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
       */
    }, {
      key: "processChunk",
      value: function processChunk(text, options, markup) {
        var _this2 = this;
        var self = this;
        options = options || {};
        var jsonChunk = this.processChunkJson(text, options, markup);
        if (options.json) {
          return jsonChunk;
        }
        if (jsonChunk.isEmpty()) {
          return "";
        }
        if (!jsonChunk.was_processed) {
          return jsonChunk.content;
        }
        var use_classes = options.use_classes;
        var styles = [];
        var classes = [];
        var data = {};
        var render_data = function render_data(data) {
          var fragments = [];
          var key = void 0;
          for (key in data) {
            if (data.hasOwnProperty(key)) {
              fragments.push("data-" + key + "=\"" + _this2.escapeForHtml(data[key]) + "\"");
            }
          }
          return fragments.length > 0 ? " " + fragments.join(" ") : "";
        };
        if (jsonChunk.fg) {
          if (use_classes) {
            classes.push(jsonChunk.fg + "-fg");
            if (jsonChunk.fg_truecolor !== null) {
              data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
              jsonChunk.fg_truecolor = null;
            }
          } else {
            styles.push("color:rgb(" + jsonChunk.fg + ")");
          }
        }
        if (jsonChunk.bg) {
          if (use_classes) {
            classes.push(jsonChunk.bg + "-bg");
            if (jsonChunk.bg_truecolor !== null) {
              data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
              jsonChunk.bg_truecolor = null;
            }
          } else {
            styles.push("background-color:rgb(" + jsonChunk.bg + ")");
          }
        }
        if (jsonChunk.decoration) {
          if (use_classes) {
            classes.push("ansi-" + jsonChunk.decoration);
          } else if (jsonChunk.decoration === "bold") {
            styles.push("font-weight:bold");
          } else if (jsonChunk.decoration === "dim") {
            styles.push("opacity:0.5");
          } else if (jsonChunk.decoration === "italic") {
            styles.push("font-style:italic");
            // underline and blink are treated bellow
          } else if (jsonChunk.decoration === "reverse") {
            styles.push("filter:invert(100%)");
          } else if (jsonChunk.decoration === "hidden") {
            styles.push("visibility:hidden");
          } else if (jsonChunk.decoration === "strikethrough") {
            styles.push("text-decoration:line-through");
          } else {
            styles.push("text-decoration:" + jsonChunk.decoration);
          }
        }
        if (use_classes) {
          return "<span class=\"" + classes.join(" ") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
        } else {
          return "<span style=\"" + styles.join(";") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
        }
      }
    }]);
    return Anser;
  }();
  ;
  module.exports = Anser;
},141,[],"node_modules/anser/lib/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\UI\\LogBoxButton.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.LogBoxButton = LogBoxButton;
  var _react = require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[1], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsPressable = require(_dependencyMap[2], "react-native-web/dist/exports/Pressable");
  var Pressable = _interopDefault(_reactNativeWebDistExportsPressable);
  var _reactNativeWebDistExportsView = require(_dependencyMap[3], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _LogBoxStyle = require(_dependencyMap[4], "./LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_LogBoxStyle);
  var _reactJsxDevRuntime = require(_dependencyMap[5], "react/jsx-dev-runtime");
  function LogBoxButton(props) {
    const [pressed, setPressed] = (0, _react.useState)(false);
    let backgroundColor = props.backgroundColor;
    if (!backgroundColor) {
      backgroundColor = {
        default: LogBoxStyle.getBackgroundColor(0.95),
        pressed: LogBoxStyle.getBackgroundColor(0.6)
      };
    }
    const content = /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: [Object.assign({
        backgroundColor: pressed ? backgroundColor.pressed : backgroundColor.default
      }, Platform.default.select({
        web: {
          cursor: 'pointer'
        }
      })), props.style],
      children: props.children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 5
    }, this);
    return props.onPress == null ? content : /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Pressable.default, {
      hitSlop: props.hitSlop,
      onPress: props.onPress,
      onPressIn: () => setPressed(true),
      onPressOut: () => setPressed(false),
      children: content
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 55,
      columnNumber: 5
    }, this);
  }
},142,[9,14,143,110,136,33],"node_modules/@expo/metro-runtime/src/error-overlay/UI/LogBoxButton.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _modulesUseMergeRefs = require(_dependencyMap[3], "../../modules/useMergeRefs");
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUseHover = require(_dependencyMap[4], "../../modules/useHover");
  var useHover = _interopDefault(_modulesUseHover);
  var _modulesUsePressEvents = require(_dependencyMap[5], "../../modules/usePressEvents");
  var usePressEvents = _interopDefault(_modulesUsePressEvents);
  var _StyleSheet = require(_dependencyMap[6], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[7], "../View");
  var View = _interopDefault(_View);
  var _excluded = ["children", "delayLongPress", "delayPressIn", "delayPressOut", "disabled", "onBlur", "onContextMenu", "onFocus", "onHoverIn", "onHoverOut", "onKeyDown", "onLongPress", "onPress", "onPressMove", "onPressIn", "onPressOut", "style", "tabIndex", "testOnly_hovered", "testOnly_pressed"];
  /**
   * Component used to build display components that should respond to whether the
   * component is currently pressed or not.
   */
  function Pressable(props, forwardedRef) {
    var children = props.children,
      delayLongPress = props.delayLongPress,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      disabled = props.disabled,
      onBlur = props.onBlur,
      onContextMenu = props.onContextMenu,
      onFocus = props.onFocus,
      onHoverIn = props.onHoverIn,
      onHoverOut = props.onHoverOut,
      onKeyDown = props.onKeyDown,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressMove = props.onPressMove,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      style = props.style,
      tabIndex = props.tabIndex,
      testOnly_hovered = props.testOnly_hovered,
      testOnly_pressed = props.testOnly_pressed,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var _useForceableState = useForceableState(testOnly_hovered === true),
      hovered = _useForceableState[0],
      setHovered = _useForceableState[1];
    var _useForceableState2 = useForceableState(false),
      focused = _useForceableState2[0],
      setFocused = _useForceableState2[1];
    var _useForceableState3 = useForceableState(testOnly_pressed === true),
      pressed = _useForceableState3[0],
      setPressed = _useForceableState3[1];
    var hostRef = (0, _react.useRef)(null);
    var setRef = (0, useMergeRefs.default)(forwardedRef, hostRef);
    var pressConfig = (0, _react.useMemo)(() => ({
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      disabled,
      onLongPress,
      onPress,
      onPressChange: setPressed,
      onPressStart: onPressIn,
      onPressMove,
      onPressEnd: onPressOut
    }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressMove, onPressOut, setPressed]);
    var pressEventHandlers = (0, usePressEvents.default)(hostRef, pressConfig);
    var onContextMenuPress = pressEventHandlers.onContextMenu,
      onKeyDownPress = pressEventHandlers.onKeyDown;
    (0, useHover.default)(hostRef, {
      contain: true,
      disabled,
      onHoverChange: setHovered,
      onHoverStart: onHoverIn,
      onHoverEnd: onHoverOut
    });
    var interactionState = {
      hovered,
      focused,
      pressed
    };
    var blurHandler = React.useCallback(e => {
      if (e.nativeEvent.target === hostRef.current) {
        setFocused(false);
        if (onBlur != null) {
          onBlur(e);
        }
      }
    }, [hostRef, setFocused, onBlur]);
    var focusHandler = React.useCallback(e => {
      if (e.nativeEvent.target === hostRef.current) {
        setFocused(true);
        if (onFocus != null) {
          onFocus(e);
        }
      }
    }, [hostRef, setFocused, onFocus]);
    var contextMenuHandler = React.useCallback(e => {
      if (onContextMenuPress != null) {
        onContextMenuPress(e);
      }
      if (onContextMenu != null) {
        onContextMenu(e);
      }
    }, [onContextMenu, onContextMenuPress]);
    var keyDownHandler = React.useCallback(e => {
      if (onKeyDownPress != null) {
        onKeyDownPress(e);
      }
      if (onKeyDown != null) {
        onKeyDown(e);
      }
    }, [onKeyDown, onKeyDownPress]);
    var _tabIndex;
    if (tabIndex !== undefined) {
      _tabIndex = tabIndex;
    } else {
      _tabIndex = disabled ? -1 : 0;
    }
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, pressEventHandlers, {
      "aria-disabled": disabled,
      onBlur: blurHandler,
      onContextMenu: contextMenuHandler,
      onFocus: focusHandler,
      onKeyDown: keyDownHandler,
      ref: setRef,
      style: [disabled ? styles.disabled : styles.active, typeof style === 'function' ? style(interactionState) : style],
      tabIndex: _tabIndex
    }), typeof children === 'function' ? children(interactionState) : children);
  }
  function useForceableState(forced) {
    var _useState = (0, _react.useState)(false),
      bool = _useState[0],
      setBool = _useState[1];
    return [bool || forced, setBool];
  }
  var styles = StyleSheet.default.create({
    active: {
      cursor: 'pointer',
      touchAction: 'manipulation'
    },
    disabled: {
      pointerEvents: 'box-none'
    }
  });
  var MemoedPressable = /*#__PURE__*/(0, _react.memo)(/*#__PURE__*/(0, _react.forwardRef)(Pressable));
  MemoedPressable.displayName = 'Pressable';
  var _default = MemoedPressable;
},143,[42,43,9,123,144,148,55,110],"node_modules/react-native-web/dist/exports/Pressable/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useHover;
    }
  });
  var _modality = require(_dependencyMap[0], "../modality");
  var _useEvent = require(_dependencyMap[1], "../useEvent");
  var useEvent = _interopDefault(_useEvent);
  var _useLayoutEffect = require(_dependencyMap[2], "../useLayoutEffect");
  var useLayoutEffect = _interopDefault(_useLayoutEffect);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Types
   */

  /**
   * Implementation
   */

  var emptyObject = {};
  var opts = {
    passive: true
  };
  var lockEventType = 'react-gui:hover:lock';
  var unlockEventType = 'react-gui:hover:unlock';
  var supportsPointerEvent = () => !!(typeof window !== 'undefined' && window.PointerEvent != null);
  function dispatchCustomEvent(target, type, payload) {
    var event = document.createEvent('CustomEvent');
    var _ref = payload || emptyObject,
      _ref$bubbles = _ref.bubbles,
      bubbles = _ref$bubbles === void 0 ? true : _ref$bubbles,
      _ref$cancelable = _ref.cancelable,
      cancelable = _ref$cancelable === void 0 ? true : _ref$cancelable,
      detail = _ref.detail;
    event.initCustomEvent(type, bubbles, cancelable, detail);
    target.dispatchEvent(event);
  }

  // This accounts for the non-PointerEvent fallback events.
  function getPointerType(event) {
    var pointerType = event.pointerType;
    return pointerType != null ? pointerType : (0, _modality.getModality)();
  }
  function useHover(targetRef, config) {
    var contain = config.contain,
      disabled = config.disabled,
      onHoverStart = config.onHoverStart,
      onHoverChange = config.onHoverChange,
      onHoverUpdate = config.onHoverUpdate,
      onHoverEnd = config.onHoverEnd;
    var canUsePE = supportsPointerEvent();
    var addMoveListener = (0, useEvent.default)(canUsePE ? 'pointermove' : 'mousemove', opts);
    var addEnterListener = (0, useEvent.default)(canUsePE ? 'pointerenter' : 'mouseenter', opts);
    var addLeaveListener = (0, useEvent.default)(canUsePE ? 'pointerleave' : 'mouseleave', opts);
    // These custom events are used to implement the "contain" prop.
    var addLockListener = (0, useEvent.default)(lockEventType, opts);
    var addUnlockListener = (0, useEvent.default)(unlockEventType, opts);
    (0, useLayoutEffect.default)(() => {
      var target = targetRef.current;
      if (target !== null) {
        /**
         * End the hover gesture
         */
        var hoverEnd = function hoverEnd(e) {
          if (onHoverEnd != null) {
            onHoverEnd(e);
          }
          if (onHoverChange != null) {
            onHoverChange(false);
          }
          // Remove the listeners once finished.
          addMoveListener(target, null);
          addLeaveListener(target, null);
        };

        /**
         * Leave element
         */
        var leaveListener = function leaveListener(e) {
          var target = targetRef.current;
          if (target != null && getPointerType(e) !== 'touch') {
            if (contain) {
              dispatchCustomEvent(target, unlockEventType);
            }
            hoverEnd(e);
          }
        };

        /**
         * Move within element
         */
        var moveListener = function moveListener(e) {
          if (getPointerType(e) !== 'touch') {
            if (onHoverUpdate != null) {
              // Not all browsers have these properties
              if (e.x == null) {
                e.x = e.clientX;
              }
              if (e.y == null) {
                e.y = e.clientY;
              }
              onHoverUpdate(e);
            }
          }
        };

        /**
         * Start the hover gesture
         */
        var hoverStart = function hoverStart(e) {
          if (onHoverStart != null) {
            onHoverStart(e);
          }
          if (onHoverChange != null) {
            onHoverChange(true);
          }
          // Set the listeners needed for the rest of the hover gesture.
          if (onHoverUpdate != null) {
            addMoveListener(target, !disabled ? moveListener : null);
          }
          addLeaveListener(target, !disabled ? leaveListener : null);
        };

        /**
         * Enter element
         */
        var enterListener = function enterListener(e) {
          var target = targetRef.current;
          if (target != null && getPointerType(e) !== 'touch') {
            if (contain) {
              dispatchCustomEvent(target, lockEventType);
            }
            hoverStart(e);
            var lockListener = function lockListener(lockEvent) {
              if (lockEvent.target !== target) {
                hoverEnd(e);
              }
            };
            var unlockListener = function unlockListener(lockEvent) {
              if (lockEvent.target !== target) {
                hoverStart(e);
              }
            };
            addLockListener(target, !disabled ? lockListener : null);
            addUnlockListener(target, !disabled ? unlockListener : null);
          }
        };
        addEnterListener(target, !disabled ? enterListener : null);
      }
    }, [addEnterListener, addMoveListener, addLeaveListener, addLockListener, addUnlockListener, contain, disabled, onHoverStart, onHoverChange, onHoverUpdate, onHoverEnd, targetRef]);
  }
},144,[145,147,122],"node_modules/react-native-web/dist/modules/useHover/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.getActiveModality = getActiveModality;
  exports.getModality = getModality;
  exports.addModalityListener = addModalityListener;
  exports.testOnly_resetActiveModality = testOnly_resetActiveModality;
  var _addEventListener = require(_dependencyMap[0], "../addEventListener");
  var _canUseDom = require(_dependencyMap[1], "../canUseDom");
  var canUseDOM = _interopDefault(_canUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var supportsPointerEvent = () => !!(typeof window !== 'undefined' && window.PointerEvent != null);
  var activeModality = 'keyboard';
  var modality = 'keyboard';
  var previousModality;
  var previousActiveModality;
  var isEmulatingMouseEvents = false;
  var listeners = new Set();
  var KEYBOARD = 'keyboard';
  var MOUSE = 'mouse';
  var TOUCH = 'touch';
  var BLUR = 'blur';
  var CONTEXTMENU = 'contextmenu';
  var FOCUS = 'focus';
  var KEYDOWN = 'keydown';
  var MOUSEDOWN = 'mousedown';
  var MOUSEMOVE = 'mousemove';
  var MOUSEUP = 'mouseup';
  var POINTERDOWN = 'pointerdown';
  var POINTERMOVE = 'pointermove';
  var SCROLL = 'scroll';
  var SELECTIONCHANGE = 'selectionchange';
  var TOUCHCANCEL = 'touchcancel';
  var TOUCHMOVE = 'touchmove';
  var TOUCHSTART = 'touchstart';
  var VISIBILITYCHANGE = 'visibilitychange';
  var bubbleOptions = {
    passive: true
  };
  var captureOptions = {
    capture: true,
    passive: true
  };
  function restoreModality() {
    if (previousModality != null || previousActiveModality != null) {
      if (previousModality != null) {
        modality = previousModality;
        previousModality = null;
      }
      if (previousActiveModality != null) {
        activeModality = previousActiveModality;
        previousActiveModality = null;
      }
      callListeners();
    }
  }
  function onBlurWindow() {
    previousModality = modality;
    previousActiveModality = activeModality;
    activeModality = KEYBOARD;
    modality = KEYBOARD;
    callListeners();
    // for fallback events
    isEmulatingMouseEvents = false;
  }
  function onFocusWindow() {
    restoreModality();
  }
  function onKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) {
      return;
    }
    if (modality !== KEYBOARD) {
      modality = KEYBOARD;
      activeModality = KEYBOARD;
      callListeners();
    }
  }
  function onVisibilityChange() {
    if (document.visibilityState !== 'hidden') {
      restoreModality();
    }
  }
  function onPointerish(event) {
    var eventType = event.type;
    if (supportsPointerEvent()) {
      if (eventType === POINTERDOWN) {
        if (activeModality !== event.pointerType) {
          modality = event.pointerType;
          activeModality = event.pointerType;
          callListeners();
        }
        return;
      }
      if (eventType === POINTERMOVE) {
        if (modality !== event.pointerType) {
          modality = event.pointerType;
          callListeners();
        }
        return;
      }
    }
    // Fallback for non-PointerEvent environment
    else {
      if (!isEmulatingMouseEvents) {
        if (eventType === MOUSEDOWN) {
          if (activeModality !== MOUSE) {
            modality = MOUSE;
            activeModality = MOUSE;
            callListeners();
          }
        }
        if (eventType === MOUSEMOVE) {
          if (modality !== MOUSE) {
            modality = MOUSE;
            callListeners();
          }
        }
      }

      // Flag when browser may produce emulated events
      if (eventType === TOUCHSTART) {
        isEmulatingMouseEvents = true;
        if (event.touches && event.touches.length > 1) {
          isEmulatingMouseEvents = false;
        }
        if (activeModality !== TOUCH) {
          modality = TOUCH;
          activeModality = TOUCH;
          callListeners();
        }
        return;
      }

      // Remove flag after emulated events are finished or cancelled, and if an
      // event occurs that cuts short a touch event sequence.
      if (eventType === CONTEXTMENU || eventType === MOUSEUP || eventType === SELECTIONCHANGE || eventType === SCROLL || eventType === TOUCHCANCEL || eventType === TOUCHMOVE) {
        isEmulatingMouseEvents = false;
      }
    }
  }
  if (canUseDOM.default) {
    // Window events
    (0, _addEventListener.addEventListener)(window, BLUR, onBlurWindow, bubbleOptions);
    (0, _addEventListener.addEventListener)(window, FOCUS, onFocusWindow, bubbleOptions);
    // Must be capture phase because 'stopPropagation' might prevent these
    // events bubbling to the document.
    (0, _addEventListener.addEventListener)(document, KEYDOWN, onKeyDown, captureOptions);
    (0, _addEventListener.addEventListener)(document, VISIBILITYCHANGE, onVisibilityChange, captureOptions);
    (0, _addEventListener.addEventListener)(document, POINTERDOWN, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, POINTERMOVE, onPointerish, captureOptions);
    // Fallback events
    (0, _addEventListener.addEventListener)(document, CONTEXTMENU, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, MOUSEDOWN, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, MOUSEMOVE, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, MOUSEUP, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, TOUCHCANCEL, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, TOUCHMOVE, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, TOUCHSTART, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, SELECTIONCHANGE, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, SCROLL, onPointerish, captureOptions);
  }
  function callListeners() {
    var value = {
      activeModality,
      modality
    };
    listeners.forEach(listener => {
      listener(value);
    });
  }
  function getActiveModality() {
    return activeModality;
  }
  function getModality() {
    return modality;
  }
  function addModalityListener(listener) {
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  }
  function testOnly_resetActiveModality() {
    isEmulatingMouseEvents = false;
    activeModality = KEYBOARD;
    modality = KEYBOARD;
  }
},145,[146,45],"node_modules/react-native-web/dist/modules/modality/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.addEventListener = addEventListener;
  var _canUseDom = require(_dependencyMap[0], "../canUseDom");
  var canUseDOM = _interopDefault(_canUseDom);
  var emptyFunction = () => {};
  function supportsPassiveEvents() {
    var supported = false;
    // Check if browser supports event with passive listeners
    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
    if (canUseDOM.default) {
      try {
        var options = {};
        Object.defineProperty(options, 'passive', {
          get() {
            supported = true;
            return false;
          }
        });
        window.addEventListener('test', null, options);
        window.removeEventListener('test', null, options);
      } catch (e) {}
    }
    return supported;
  }
  var canUsePassiveEvents = supportsPassiveEvents();
  function getOptions(options) {
    if (options == null) {
      return false;
    }
    return canUsePassiveEvents ? options : Boolean(options.capture);
  }

  /**
   * Shim generic API compatibility with ReactDOM's synthetic events, without needing the
   * large amount of code ReactDOM uses to do this. Ideally we wouldn't use a synthetic
   * event wrapper at all.
   */
  function isPropagationStopped() {
    return this.cancelBubble;
  }
  function isDefaultPrevented() {
    return this.defaultPrevented;
  }
  function normalizeEvent(event) {
    event.nativeEvent = event;
    event.persist = emptyFunction;
    event.isDefaultPrevented = isDefaultPrevented;
    event.isPropagationStopped = isPropagationStopped;
    return event;
  }

  /**
   *
   */
  function addEventListener(target, type, listener, options) {
    var opts = getOptions(options);
    var compatListener = e => listener(normalizeEvent(e));
    target.addEventListener(type, compatListener, opts);
    return function removeEventListener() {
      if (target != null) {
        target.removeEventListener(type, compatListener, opts);
      }
    };
  }
},146,[45],"node_modules/react-native-web/dist/modules/addEventListener/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useEvent;
    }
  });
  var _addEventListener = require(_dependencyMap[0], "../addEventListener");
  var _useLayoutEffect = require(_dependencyMap[1], "../useLayoutEffect");
  var useLayoutEffect = _interopDefault(_useLayoutEffect);
  var _useStable = require(_dependencyMap[2], "../useStable");
  var useStable = _interopDefault(_useStable);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * This can be used with any event type include custom events.
   *
   * const click = useEvent('click', options);
   * useEffect(() => {
   *   click.setListener(target, onClick);
   *   return () => click.clear();
   * }).
   */
  function useEvent(eventType, options) {
    var targetListeners = (0, useStable.default)(() => new Map());
    var addListener = (0, useStable.default)(() => {
      return (target, callback) => {
        var removeTargetListener = targetListeners.get(target);
        if (removeTargetListener != null) {
          removeTargetListener();
        }
        if (callback == null) {
          targetListeners.delete(target);
          callback = () => {};
        }
        var removeEventListener = (0, _addEventListener.addEventListener)(target, eventType, callback, options);
        targetListeners.set(target, removeEventListener);
        return removeEventListener;
      };
    });
    (0, useLayoutEffect.default)(() => {
      return () => {
        targetListeners.forEach(removeListener => {
          removeListener();
        });
        targetListeners.clear();
      };
    }, [targetListeners]);
    return addListener;
  }
},147,[146,122,125],"node_modules/react-native-web/dist/modules/useEvent/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return usePressEvents;
    }
  });
  var _PressResponder = require(_dependencyMap[0], "./PressResponder");
  var PressResponder = _interopDefault(_PressResponder);
  var _react = require(_dependencyMap[1], "react");
  function usePressEvents(hostRef, config) {
    var pressResponderRef = (0, _react.useRef)(null);
    if (pressResponderRef.current == null) {
      pressResponderRef.current = new PressResponder.default(config);
    }
    var pressResponder = pressResponderRef.current;

    // Re-configure to use the current node and configuration.
    (0, _react.useEffect)(() => {
      pressResponder.configure(config);
    }, [config, pressResponder]);

    // Reset the `pressResponder` when cleanup needs to occur. This is
    // a separate effect because we do not want to rest the responder when `config` changes.
    (0, _react.useEffect)(() => {
      return () => {
        pressResponder.reset();
      };
    }, [pressResponder]);
    (0, _react.useDebugValue)(config);
    return pressResponder.getEventHandlers();
  }
},148,[149,9],"node_modules/react-native-web/dist/modules/usePressEvents/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return PressResponder;
    }
  });
  var DELAY = 'DELAY';
  var ERROR = 'ERROR';
  var LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';
  var NOT_RESPONDER = 'NOT_RESPONDER';
  var RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';
  var RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';
  var RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';
  var RESPONDER_GRANT = 'RESPONDER_GRANT';
  var RESPONDER_RELEASE = 'RESPONDER_RELEASE';
  var RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';
  var Transitions = Object.freeze({
    NOT_RESPONDER: {
      DELAY: ERROR,
      RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
      RESPONDER_RELEASE: ERROR,
      RESPONDER_TERMINATED: ERROR,
      LONG_PRESS_DETECTED: ERROR
    },
    RESPONDER_INACTIVE_PRESS_START: {
      DELAY: RESPONDER_ACTIVE_PRESS_START,
      RESPONDER_GRANT: ERROR,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: ERROR
    },
    RESPONDER_ACTIVE_PRESS_START: {
      DELAY: ERROR,
      RESPONDER_GRANT: ERROR,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
    },
    RESPONDER_ACTIVE_LONG_PRESS_START: {
      DELAY: ERROR,
      RESPONDER_GRANT: ERROR,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
    },
    ERROR: {
      DELAY: NOT_RESPONDER,
      RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: NOT_RESPONDER
    }
  });
  var getElementRole = element => element.getAttribute('role');
  var getElementType = element => element.tagName.toLowerCase();
  var isActiveSignal = signal => signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;
  var isButtonRole = element => getElementRole(element) === 'button';
  var isPressStartSignal = signal => signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;
  var isTerminalSignal = signal => signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;
  var isValidKeyPress = event => {
    var key = event.key,
      target = event.target;
    var isSpacebar = key === ' ' || key === 'Spacebar';
    var isButtonish = getElementType(target) === 'button' || isButtonRole(target);
    return key === 'Enter' || isSpacebar && isButtonish;
  };
  var DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50
  var DEFAULT_PRESS_DELAY_MS = 50;

  /**
   * =========================== PressResponder Tutorial ===========================
   *
   * The `PressResponder` class helps you create press interactions by analyzing the
   * geometry of elements and observing when another responder (e.g. ScrollView)
   * has stolen the touch lock. It offers hooks for your component to provide
   * interaction feedback to the user:
   *
   * - When a press has activated (e.g. highlight an element)
   * - When a press has deactivated (e.g. un-highlight an element)
   * - When a press sould trigger an action, meaning it activated and deactivated
   *   while within the geometry of the element without the lock being stolen.
   *
   * A high quality interaction isn't as simple as you might think. There should
   * be a slight delay before activation. Moving your finger beyond an element's
   * bounds should trigger deactivation, but moving the same finger back within an
   * element's bounds should trigger reactivation.
   *
   * In order to use `PressResponder`, do the following:
   *
   *     const pressResponder = new PressResponder(config);
   *
   * 2. Choose the rendered component who should collect the press events. On that
   *    element, spread `pressability.getEventHandlers()` into its props.
   *
   *    return (
   *      <View {...this.state.pressResponder.getEventHandlers()} />
   *    );
   *
   * 3. Reset `PressResponder` when your component unmounts.
   *
   *    componentWillUnmount() {
   *      this.state.pressResponder.reset();
   *    }
   *
   * ==================== Implementation Details ====================
   *
   * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`
   * is an abstract box that is extended beyond the `HitRect`.
   *
   * # Geometry
   *
   *  ┌────────────────────────┐
   *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`.
   *  │  │  ┌────────────┐  │  │
   *  │  │  │ VisualRect │  │  │
   *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time
   *  │  │    HitRect       │  │   before letting up, `VisualRect` activates.
   *  │  └──────────────────┘  │
   *  │       Out Region   o   │
   *  └────────────────────│───┘
   *                       └────── When the press is released outside the `HitRect`,
   *                               the responder is NOT eligible for a "press".
   *
   * # State Machine
   *
   * ┌───────────────┐ ◀──── RESPONDER_RELEASE
   * │ NOT_RESPONDER │
   * └───┬───────────┘ ◀──── RESPONDER_TERMINATED
   *     │
   *     │ RESPONDER_GRANT (HitRect)
   *     │
   *     ▼
   * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐
   * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │
   * │ PRESS_START         ├────────▶ │ PRESS_START       ├────────────▶ │ LONG_PRESS_START  │
   * └─────────────────────┘          └───────────────────┘              └───────────────────┘
   *
   * T + DELAY => LONG_PRESS_DELAY + DELAY
   *
   * Not drawn are the side effects of each transition. The most important side
   * effect is the invocation of `onLongPress`. Only when the browser produces a
   * `click` event is `onPress` invoked.
   */
  class PressResponder {
    constructor(config) {
      this._eventHandlers = null;
      this._isPointerTouch = false;
      this._longPressDelayTimeout = null;
      this._longPressDispatched = false;
      this._pressDelayTimeout = null;
      this._pressOutDelayTimeout = null;
      this._touchState = NOT_RESPONDER;
      this._responderElement = null;
      this.configure(config);
    }
    configure(config) {
      this._config = config;
    }

    /**
     * Resets any pending timers. This should be called on unmount.
     */
    reset() {
      this._cancelLongPressDelayTimeout();
      this._cancelPressDelayTimeout();
      this._cancelPressOutDelayTimeout();
    }

    /**
     * Returns a set of props to spread into the interactive element.
     */
    getEventHandlers() {
      if (this._eventHandlers == null) {
        this._eventHandlers = this._createEventHandlers();
      }
      return this._eventHandlers;
    }
    _createEventHandlers() {
      var start = (event, shouldDelay) => {
        event.persist();
        this._cancelPressOutDelayTimeout();
        this._longPressDispatched = false;
        this._selectionTerminated = false;
        this._touchState = NOT_RESPONDER;
        this._isPointerTouch = event.nativeEvent.type === 'touchstart';
        this._receiveSignal(RESPONDER_GRANT, event);
        var delayPressStart = normalizeDelay(this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);
        if (shouldDelay !== false && delayPressStart > 0) {
          this._pressDelayTimeout = setTimeout(() => {
            this._receiveSignal(DELAY, event);
          }, delayPressStart);
        } else {
          this._receiveSignal(DELAY, event);
        }
        var delayLongPress = normalizeDelay(this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);
        this._longPressDelayTimeout = setTimeout(() => {
          this._handleLongPress(event);
        }, delayLongPress + delayPressStart);
      };
      var end = event => {
        this._receiveSignal(RESPONDER_RELEASE, event);
      };
      var keyupHandler = event => {
        var onPress = this._config.onPress;
        var target = event.target;
        if (this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {
          end(event);
          document.removeEventListener('keyup', keyupHandler);
          var role = target.getAttribute('role');
          var elementType = getElementType(target);
          var isNativeInteractiveElement = role === 'link' || elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea';
          var isActiveElement = this._responderElement === target;
          if (onPress != null && !isNativeInteractiveElement && isActiveElement) {
            onPress(event);
          }
          this._responderElement = null;
        }
      };
      return {
        onStartShouldSetResponder: event => {
          var disabled = this._config.disabled;
          if (disabled && isButtonRole(event.currentTarget)) {
            event.stopPropagation();
          }
          if (disabled == null) {
            return true;
          }
          return !disabled;
        },
        onKeyDown: event => {
          var disabled = this._config.disabled;
          var key = event.key,
            target = event.target;
          if (!disabled && isValidKeyPress(event)) {
            if (this._touchState === NOT_RESPONDER) {
              start(event, false);
              this._responderElement = target;
              // Listen to 'keyup' on document to account for situations where
              // focus is moved to another element during 'keydown'.
              document.addEventListener('keyup', keyupHandler);
            }
            var isSpacebarKey = key === ' ' || key === 'Spacebar';
            var role = getElementRole(target);
            var isButtonLikeRole = role === 'button' || role === 'menuitem';
            if (isSpacebarKey && isButtonLikeRole && getElementType(target) !== 'button') {
              // Prevent spacebar scrolling the window if using non-native button
              event.preventDefault();
            }
            event.stopPropagation();
          }
        },
        onResponderGrant: event => start(event),
        onResponderMove: event => {
          if (this._config.onPressMove != null) {
            this._config.onPressMove(event);
          }
          var touch = getTouchFromResponderEvent(event);
          if (this._touchActivatePosition != null) {
            var deltaX = this._touchActivatePosition.pageX - touch.pageX;
            var deltaY = this._touchActivatePosition.pageY - touch.pageY;
            if (Math.hypot(deltaX, deltaY) > 10) {
              this._cancelLongPressDelayTimeout();
            }
          }
        },
        onResponderRelease: event => end(event),
        onResponderTerminate: event => {
          if (event.nativeEvent.type === 'selectionchange') {
            this._selectionTerminated = true;
          }
          this._receiveSignal(RESPONDER_TERMINATED, event);
        },
        onResponderTerminationRequest: event => {
          var _this$_config = this._config,
            cancelable = _this$_config.cancelable,
            disabled = _this$_config.disabled,
            onLongPress = _this$_config.onLongPress;
          // If `onLongPress` is provided, don't terminate on `contextmenu` as default
          // behavior will be prevented for non-mouse pointers.
          if (!disabled && onLongPress != null && this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {
            return false;
          }
          if (cancelable == null) {
            return true;
          }
          return cancelable;
        },
        // NOTE: this diverges from react-native in 3 significant ways:
        // * The `onPress` callback is not connected to the responder system (the native
        //  `click` event must be used but is dispatched in many scenarios where no pointers
        //   are on the screen.) Therefore, it's possible for `onPress` to be called without
        //   `onPress{Start,End}` being called first.
        // * The `onPress` callback is only be called on the first ancestor of the native
        //   `click` target that is using the PressResponder.
        // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.
        onClick: event => {
          var _this$_config2 = this._config,
            disabled = _this$_config2.disabled,
            onPress = _this$_config2.onPress;
          if (!disabled) {
            // If long press dispatched, cancel default click behavior.
            // If the responder terminated because text was selected during the gesture,
            // cancel the default click behavior.
            event.stopPropagation();
            if (this._longPressDispatched || this._selectionTerminated) {
              event.preventDefault();
            } else if (onPress != null && event.altKey === false) {
              onPress(event);
            }
          } else {
            if (isButtonRole(event.currentTarget)) {
              event.stopPropagation();
            }
          }
        },
        // If `onLongPress` is provided and a touch pointer is being used, prevent the
        // default context menu from opening.
        onContextMenu: event => {
          var _this$_config3 = this._config,
            disabled = _this$_config3.disabled,
            onLongPress = _this$_config3.onLongPress;
          if (!disabled) {
            if (onLongPress != null && this._isPointerTouch && !event.defaultPrevented) {
              event.preventDefault();
              event.stopPropagation();
            }
          } else {
            if (isButtonRole(event.currentTarget)) {
              event.stopPropagation();
            }
          }
        }
      };
    }

    /**
     * Receives a state machine signal, performs side effects of the transition
     * and stores the new state. Validates the transition as well.
     */
    _receiveSignal(signal, event) {
      var prevState = this._touchState;
      var nextState = null;
      if (Transitions[prevState] != null) {
        nextState = Transitions[prevState][signal];
      }
      if (this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) {
        return;
      }
      if (nextState == null || nextState === ERROR) {
        console.error("PressResponder: Invalid signal " + signal + " for state " + prevState + " on responder");
      } else if (prevState !== nextState) {
        this._performTransitionSideEffects(prevState, nextState, signal, event);
        this._touchState = nextState;
      }
    }

    /**
     * Performs a transition between touchable states and identify any activations
     * or deactivations (and callback invocations).
     */
    _performTransitionSideEffects(prevState, nextState, signal, event) {
      if (isTerminalSignal(signal)) {
        // Pressable suppression of contextmenu on windows.
        // On Windows, the contextmenu is displayed after pointerup.
        // https://github.com/necolas/react-native-web/issues/2296
        setTimeout(() => {
          this._isPointerTouch = false;
        }, 0);
        this._touchActivatePosition = null;
        this._cancelLongPressDelayTimeout();
      }
      if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {
        var onLongPress = this._config.onLongPress;
        // Long press is not supported for keyboards because 'click' can be dispatched
        // immediately (and multiple times) after 'keydown'.
        if (onLongPress != null && event.nativeEvent.key == null) {
          onLongPress(event);
          this._longPressDispatched = true;
        }
      }
      var isPrevActive = isActiveSignal(prevState);
      var isNextActive = isActiveSignal(nextState);
      if (!isPrevActive && isNextActive) {
        this._activate(event);
      } else if (isPrevActive && !isNextActive) {
        this._deactivate(event);
      }
      if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {
        var _this$_config4 = this._config,
          _onLongPress = _this$_config4.onLongPress,
          onPress = _this$_config4.onPress;
        if (onPress != null) {
          var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;
          if (!isPressCanceledByLongPress) {
            // If we never activated (due to delays), activate and deactivate now.
            if (!isNextActive && !isPrevActive) {
              this._activate(event);
              this._deactivate(event);
            }
          }
        }
      }
      this._cancelPressDelayTimeout();
    }
    _activate(event) {
      var _this$_config5 = this._config,
        onPressChange = _this$_config5.onPressChange,
        onPressStart = _this$_config5.onPressStart;
      var touch = getTouchFromResponderEvent(event);
      this._touchActivatePosition = {
        pageX: touch.pageX,
        pageY: touch.pageY
      };
      if (onPressStart != null) {
        onPressStart(event);
      }
      if (onPressChange != null) {
        onPressChange(true);
      }
    }
    _deactivate(event) {
      var _this$_config6 = this._config,
        onPressChange = _this$_config6.onPressChange,
        onPressEnd = _this$_config6.onPressEnd;
      function end() {
        if (onPressEnd != null) {
          onPressEnd(event);
        }
        if (onPressChange != null) {
          onPressChange(false);
        }
      }
      var delayPressEnd = normalizeDelay(this._config.delayPressEnd);
      if (delayPressEnd > 0) {
        this._pressOutDelayTimeout = setTimeout(() => {
          end();
        }, delayPressEnd);
      } else {
        end();
      }
    }
    _handleLongPress(event) {
      if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {
        this._receiveSignal(LONG_PRESS_DETECTED, event);
      }
    }
    _cancelLongPressDelayTimeout() {
      if (this._longPressDelayTimeout != null) {
        clearTimeout(this._longPressDelayTimeout);
        this._longPressDelayTimeout = null;
      }
    }
    _cancelPressDelayTimeout() {
      if (this._pressDelayTimeout != null) {
        clearTimeout(this._pressDelayTimeout);
        this._pressDelayTimeout = null;
      }
    }
    _cancelPressOutDelayTimeout() {
      if (this._pressOutDelayTimeout != null) {
        clearTimeout(this._pressOutDelayTimeout);
        this._pressOutDelayTimeout = null;
      }
    }
  }
  function normalizeDelay(delay, min, fallback) {
    if (min === void 0) {
      min = 0;
    }
    if (fallback === void 0) {
      fallback = 0;
    }
    return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);
  }
  function getTouchFromResponderEvent(event) {
    var _event$nativeEvent = event.nativeEvent,
      changedTouches = _event$nativeEvent.changedTouches,
      touches = _event$nativeEvent.touches;
    if (touches != null && touches.length > 0) {
      return touches[0];
    }
    if (changedTouches != null && changedTouches.length > 0) {
      return changedTouches[0];
    }
    return event.nativeEvent;
  }
},149,[],"node_modules/react-native-web/dist/modules/usePressEvents/PressResponder.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "CODE_FONT", {
    enumerable: true,
    get: function () {
      return CODE_FONT;
    }
  });
  const CODE_FONT = false ?
  // iOS
  'Courier New' : false ?
  // Android
  'monospace' :
  // Default
  'Courier';
},150,[],"node_modules/@expo/metro-runtime/src/error-overlay/UI/constants.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.formatProjectFilePath = formatProjectFilePath;
  exports.getStackFormattedLocation = getStackFormattedLocation;
  function formatProjectFilePath(projectRoot, file) {
    if (file == null) {
      return '<unknown>';
    }
    return pathRelativeToPath(file.replace(/\\/g, '/'), projectRoot.replace(/\\/g, '/')).replace(/\?.*$/, '');
  }
  function pathRelativeToPath(path, relativeTo, sep = '/') {
    const relativeToParts = relativeTo.split(sep);
    const pathParts = path.split(sep);
    let i = 0;
    while (i < relativeToParts.length && i < pathParts.length) {
      if (relativeToParts[i] !== pathParts[i]) {
        break;
      }
      i++;
    }
    return pathParts.slice(i).join(sep);
  }
  function getStackFormattedLocation(projectRoot, frame) {
    const column = frame.column != null && parseInt(String(frame.column), 10);
    const location = formatProjectFilePath(projectRoot, frame.file) + (frame.lineNumber != null ? ':' + frame.lineNumber + (column && !isNaN(column) ? ':' + (column + 1) : '') : '');
    return location;
  }
},151,[],"node_modules/@expo/metro-runtime/src/error-overlay/formatProjectFilePath.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  function openFileInEditor(file, lineNumber) {
    if (process.env.NODE_ENV !== 'production') {
      // TODO: This is not a great URL since it now blocks users from accessing the `/open-stack-frame` url in their router
      // ideally it would be something like `/_devtools/open-stack-frame`.
      const baseUrl = window.location.protocol + '//' + window.location.host;
      fetch(baseUrl + '/open-stack-frame', {
        method: 'POST',
        body: JSON.stringify({
          file,
          lineNumber
        })
      });
    }
  }
  var _default = openFileInEditor;
},152,[],"node_modules/@expo/metro-runtime/src/error-overlay/modules/openFileInEditor/index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorFooter.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.LogBoxInspectorFooter = LogBoxInspectorFooter;
  require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[1], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsPressable = require(_dependencyMap[2], "react-native-web/dist/exports/Pressable");
  var Pressable = _interopDefault(_reactNativeWebDistExportsPressable);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[4], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsView = require(_dependencyMap[5], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _DataLogContext = require(_dependencyMap[6], "../Data/LogContext");
  var _UILogBoxStyle = require(_dependencyMap[7], "../UI/LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_UILogBoxStyle);
  var _reactJsxDevRuntime = require(_dependencyMap[8], "react/jsx-dev-runtime");
  function LogBoxInspectorFooter(props) {
    const log = (0, _DataLogContext.useSelectedLog)();
    if (['static', 'syntax'].includes(log.level)) {
      return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: styles.root,
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
          style: styles.button,
          children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
            style: styles.syntaxErrorText,
            children: "This error cannot be dismissed."
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 26,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 25,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 24,
        columnNumber: 7
      }, this);
    }
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: styles.root,
      children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(FooterButton, {
        text: "Dismiss",
        onPress: props.onDismiss
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 34,
        columnNumber: 7
      }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(FooterButton, {
        text: "Minimize",
        onPress: props.onMinimize
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 35,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 33,
      columnNumber: 5
    }, this);
  }
  function FooterButton({
    text,
    onPress
  }) {
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Pressable.default, {
      onPress: onPress,
      style: {
        flex: 1
      },
      children: ({
        /** @ts-expect-error: react-native types are broken. */
        hovered,
        pressed
      }) => /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: [buttonStyles.safeArea, {
          // @ts-expect-error: web-only type
          transitionDuration: '150ms',
          backgroundColor: pressed ? '#323232' : hovered ? '#111111' : LogBoxStyle.getBackgroundColor()
        }],
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
          style: buttonStyles.content,
          children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
            style: buttonStyles.label,
            children: text
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 62,
            columnNumber: 13
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 61,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 48,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 5
    }, this);
  }
  const buttonStyles = StyleSheet.default.create({
    safeArea: {
      flex: 1,
      borderTopWidth: 1,
      borderColor: '#323232'
      // paddingBottom: DeviceInfo.getConstants().isIPhoneX_deprecated ? 30 : 0,
    },
    content: {
      alignItems: 'center',
      height: 48,
      justifyContent: 'center'
    },
    label: {
      userSelect: 'none',
      color: LogBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 20
    }
  });
  const styles = StyleSheet.default.create({
    root: Object.assign({
      backgroundColor: LogBoxStyle.getBackgroundColor(1)
    }, Platform.default.select({
      web: {
        boxShadow: `0 -2px 0 2px #000`
      }
    }), {
      flexDirection: 'row'
    }),
    button: {
      flex: 1
    },
    syntaxErrorText: {
      textAlign: 'center',
      width: '100%',
      height: 48,
      fontSize: 14,
      lineHeight: 20,
      paddingTop: 20,
      paddingBottom: 50,
      fontStyle: 'italic',
      color: LogBoxStyle.getTextColor(0.6)
    }
  });
},153,[9,14,143,55,138,110,21,136,33],"node_modules/@expo/metro-runtime/src/error-overlay/overlay/LogBoxInspectorFooter.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorHeader.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.LogBoxInspectorHeader = LogBoxInspectorHeader;
  require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsImage = require(_dependencyMap[1], "react-native-web/dist/exports/Image");
  var Image = _interopDefault(_reactNativeWebDistExportsImage);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[2], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStatusBar = require(_dependencyMap[3], "react-native-web/dist/exports/StatusBar");
  var StatusBar = _interopDefault(_reactNativeWebDistExportsStatusBar);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[5], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsView = require(_dependencyMap[6], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _DataLogContext = require(_dependencyMap[7], "../Data/LogContext");
  var _UILogBoxButton = require(_dependencyMap[8], "../UI/LogBoxButton");
  var _UILogBoxStyle = require(_dependencyMap[9], "../UI/LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_UILogBoxStyle);
  var _reactJsxDevRuntime = require(_dependencyMap[10], "react/jsx-dev-runtime");
  function LogBoxInspectorHeader(props) {
    const {
      selectedLogIndex: selectedIndex,
      logs
    } = (0, _DataLogContext.useLogs)();
    const total = logs.length;
    if (props.level === 'syntax') {
      return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: [styles.safeArea, styles[props.level]],
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
          style: styles.header,
          children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
            style: styles.title,
            children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
              style: styles.titleText,
              children: "Failed to compile"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 30,
              columnNumber: 13
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 29,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 28,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 27,
        columnNumber: 7
      }, this);
    }
    const prevIndex = selectedIndex - 1 < 0 ? total - 1 : selectedIndex - 1;
    const nextIndex = selectedIndex + 1 > total - 1 ? 0 : selectedIndex + 1;
    const titleText = `Log ${selectedIndex + 1} of ${total}`;
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: [styles.safeArea, styles[props.level]],
      children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: styles.header,
        children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(LogBoxInspectorHeaderButton, {
          disabled: total <= 1,
          level: props.level,
          image: require(_dependencyMap[11], "@expo/metro-runtime/assets/chevron-left.png"),
          onPress: () => props.onSelectIndex(prevIndex)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 45,
          columnNumber: 9
        }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
          style: styles.title,
          children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
            style: styles.titleText,
            children: titleText
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 52,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 51,
          columnNumber: 9
        }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(LogBoxInspectorHeaderButton, {
          disabled: total <= 1,
          level: props.level,
          image: require(_dependencyMap[12], "@expo/metro-runtime/assets/chevron-right.png"),
          onPress: () => props.onSelectIndex(nextIndex)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 54,
          columnNumber: 9
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 44,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 5
    }, this);
  }
  const backgroundForLevel = level => ({
    warn: {
      default: 'transparent',
      pressed: LogBoxStyle.getWarningDarkColor()
    },
    error: {
      default: 'transparent',
      pressed: LogBoxStyle.getErrorDarkColor()
    },
    fatal: {
      default: 'transparent',
      pressed: LogBoxStyle.getFatalDarkColor()
    },
    syntax: {
      default: 'transparent',
      pressed: LogBoxStyle.getFatalDarkColor()
    },
    static: {
      default: 'transparent',
      pressed: LogBoxStyle.getFatalDarkColor()
    }
  })[level];
  function LogBoxInspectorHeaderButton(props) {
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_UILogBoxButton.LogBoxButton, {
      backgroundColor: backgroundForLevel(props.level),
      onPress: props.disabled ? undefined : props.onPress,
      style: headerStyles.button,
      children: props.disabled ? null : /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Image.default, {
        source: props.image,
        tintColor: LogBoxStyle.getTextColor(),
        style: headerStyles.buttonImage
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 101,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 96,
      columnNumber: 5
    }, this);
  }
  const headerStyles = StyleSheet.default.create({
    button: {
      alignItems: 'center',
      justifyContent: 'center',
      aspectRatio: 1,
      marginRight: 6,
      marginLeft: 6,
      borderRadius: 3
    },
    buttonImage: {
      height: 14,
      width: 8
    }
  });
  const styles = StyleSheet.default.create({
    syntax: {
      backgroundColor: LogBoxStyle.getFatalColor()
    },
    static: {
      backgroundColor: LogBoxStyle.getFatalColor()
    },
    fatal: {
      backgroundColor: LogBoxStyle.getFatalColor()
    },
    warn: {
      backgroundColor: LogBoxStyle.getWarningColor()
    },
    error: {
      backgroundColor: LogBoxStyle.getErrorColor()
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: 8,
      height: Platform.default.select({
        default: 48,
        ios: 44
      })
    },
    title: {
      alignItems: 'center',
      flex: 1,
      justifyContent: 'center'
    },
    titleText: {
      color: LogBoxStyle.getTextColor(),
      fontSize: 16,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 20
    },
    safeArea: {
      paddingTop: true ? StatusBar.default.currentHeight : 40
    }
  });
},154,[9,155,14,159,55,138,110,21,142,136,33,160,161],"node_modules/@expo/metro-runtime/src/error-overlay/overlay/LogBoxInspectorHeader.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersExtends = require(_dependencyMap[1], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[3], "react");
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[4], "../createElement");
  var createElement = _interopDefault(_createElement);
  var _modulesAssetRegistry = require(_dependencyMap[5], "../../modules/AssetRegistry");
  var _StyleSheetPreprocess = require(_dependencyMap[6], "../StyleSheet/preprocess");
  var _modulesImageLoader = require(_dependencyMap[7], "../../modules/ImageLoader");
  var ImageLoader = _interopDefault(_modulesImageLoader);
  var _PixelRatio = require(_dependencyMap[8], "../PixelRatio");
  var PixelRatio = _interopDefault(_PixelRatio);
  var _StyleSheet = require(_dependencyMap[9], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _TextTextAncestorContext = require(_dependencyMap[10], "../Text/TextAncestorContext");
  var TextAncestorContext = _interopDefault(_TextTextAncestorContext);
  var _View = require(_dependencyMap[11], "../View");
  var View = _interopDefault(_View);
  var _modulesWarnOnce = require(_dependencyMap[12], "../../modules/warnOnce");
  var _excluded = ["aria-label", "accessibilityLabel", "blurRadius", "defaultSource", "draggable", "onError", "onLayout", "onLoad", "onLoadEnd", "onLoadStart", "pointerEvents", "source", "style"];
  var ERRORED = 'ERRORED';
  var LOADED = 'LOADED';
  var LOADING = 'LOADING';
  var IDLE = 'IDLE';
  var _filterId = 0;
  var svgDataUriPattern = /^(data:image\/svg\+xml;utf8,)(.*)/;
  function createTintColorSVG(tintColor, id) {
    return tintColor && id != null ? /*#__PURE__*/React.createElement("svg", {
      style: {
        position: 'absolute',
        height: 0,
        visibility: 'hidden',
        width: 0
      }
    }, /*#__PURE__*/React.createElement("defs", null, /*#__PURE__*/React.createElement("filter", {
      id: "tint-" + id,
      suppressHydrationWarning: true
    }, /*#__PURE__*/React.createElement("feFlood", {
      floodColor: "" + tintColor,
      key: tintColor
    }), /*#__PURE__*/React.createElement("feComposite", {
      in2: "SourceAlpha",
      operator: "in"
    })))) : null;
  }
  function extractNonStandardStyleProps(style, blurRadius, filterId, tintColorProp) {
    var flatStyle = StyleSheet.default.flatten(style);
    var filter = flatStyle.filter,
      resizeMode = flatStyle.resizeMode,
      shadowOffset = flatStyle.shadowOffset,
      tintColor = flatStyle.tintColor;
    if (flatStyle.resizeMode) {
      (0, _modulesWarnOnce.warnOnce)('Image.style.resizeMode', 'Image: style.resizeMode is deprecated. Please use props.resizeMode.');
    }
    if (flatStyle.tintColor) {
      (0, _modulesWarnOnce.warnOnce)('Image.style.tintColor', 'Image: style.tintColor is deprecated. Please use props.tintColor.');
    }

    // Add CSS filters
    // React Native exposes these features as props and proprietary styles
    var filters = [];
    var _filter = null;
    if (filter) {
      filters.push(filter);
    }
    if (blurRadius) {
      filters.push("blur(" + blurRadius + "px)");
    }
    if (shadowOffset) {
      var shadowString = (0, _StyleSheetPreprocess.createBoxShadowValue)(flatStyle);
      if (shadowString) {
        filters.push("drop-shadow(" + shadowString + ")");
      }
    }
    if ((tintColorProp || tintColor) && filterId != null) {
      filters.push("url(#tint-" + filterId + ")");
    }
    if (filters.length > 0) {
      _filter = filters.join(' ');
    }
    return [resizeMode, _filter, tintColor];
  }
  function resolveAssetDimensions(source) {
    if (typeof source === 'number') {
      var _getAssetByID = (0, _modulesAssetRegistry.getAssetByID)(source),
        _height = _getAssetByID.height,
        _width = _getAssetByID.width;
      return {
        height: _height,
        width: _width
      };
    } else if (source != null && !Array.isArray(source) && typeof source === 'object') {
      var _height2 = source.height,
        _width2 = source.width;
      return {
        height: _height2,
        width: _width2
      };
    }
  }
  function resolveAssetUri(source) {
    var uri = null;
    if (typeof source === 'number') {
      // get the URI from the packager
      var asset = (0, _modulesAssetRegistry.getAssetByID)(source);
      if (asset == null) {
        throw new Error("Image: asset with ID \"" + source + "\" could not be found. Please check the image source or packager.");
      }
      var scale = asset.scales[0];
      if (asset.scales.length > 1) {
        var preferredScale = PixelRatio.default.get();
        // Get the scale which is closest to the preferred scale
        scale = asset.scales.reduce((prev, curr) => Math.abs(curr - preferredScale) < Math.abs(prev - preferredScale) ? curr : prev);
      }
      var scaleSuffix = scale !== 1 ? "@" + scale + "x" : '';
      uri = asset ? asset.httpServerLocation + "/" + asset.name + scaleSuffix + "." + asset.type : '';
    } else if (typeof source === 'string') {
      uri = source;
    } else if (source && typeof source.uri === 'string') {
      uri = source.uri;
    }
    if (uri) {
      var match = uri.match(svgDataUriPattern);
      // inline SVG markup may contain characters (e.g., #, ") that need to be escaped
      if (match) {
        var prefix = match[1],
          svg = match[2];
        var encodedSvg = encodeURIComponent(svg);
        return "" + prefix + encodedSvg;
      }
    }
    return uri;
  }
  var Image = /*#__PURE__*/React.forwardRef((props, ref) => {
    var _ariaLabel = props['aria-label'],
      accessibilityLabel = props.accessibilityLabel,
      blurRadius = props.blurRadius,
      defaultSource = props.defaultSource,
      draggable = props.draggable,
      onError = props.onError,
      onLayout = props.onLayout,
      onLoad = props.onLoad,
      onLoadEnd = props.onLoadEnd,
      onLoadStart = props.onLoadStart,
      pointerEvents = props.pointerEvents,
      source = props.source,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var ariaLabel = _ariaLabel || accessibilityLabel;
    if (process.env.NODE_ENV !== 'production') {
      if (props.children) {
        throw new Error('The <Image> component cannot contain children. If you want to render content on top of the image, consider using the <ImageBackground> component or absolute positioning.');
      }
    }
    var _React$useState = React.useState(() => {
        var uri = resolveAssetUri(source);
        if (uri != null) {
          var isLoaded = ImageLoader.default.has(uri);
          if (isLoaded) {
            return LOADED;
          }
        }
        return IDLE;
      }),
      state = _React$useState[0],
      updateState = _React$useState[1];
    var _React$useState2 = React.useState({}),
      layout = _React$useState2[0],
      updateLayout = _React$useState2[1];
    var hasTextAncestor = React.useContext(TextAncestorContext.default);
    var hiddenImageRef = React.useRef(null);
    var filterRef = React.useRef(_filterId++);
    var requestRef = React.useRef(null);
    var shouldDisplaySource = state === LOADED || state === LOADING && defaultSource == null;
    var _extractNonStandardSt = extractNonStandardStyleProps(style, blurRadius, filterRef.current, props.tintColor),
      _resizeMode = _extractNonStandardSt[0],
      filter = _extractNonStandardSt[1],
      _tintColor = _extractNonStandardSt[2];
    var resizeMode = props.resizeMode || _resizeMode || 'cover';
    var tintColor = props.tintColor || _tintColor;
    var selectedSource = shouldDisplaySource ? source : defaultSource;
    var displayImageUri = resolveAssetUri(selectedSource);
    var imageSizeStyle = resolveAssetDimensions(selectedSource);
    var backgroundImage = displayImageUri ? "url(\"" + displayImageUri + "\")" : null;
    var backgroundSize = getBackgroundSize();

    // Accessibility image allows users to trigger the browser's image context menu
    var hiddenImage = displayImageUri ? (0, createElement.default)('img', {
      alt: ariaLabel || '',
      style: styles.accessibilityImage$raw,
      draggable: draggable || false,
      ref: hiddenImageRef,
      src: displayImageUri
    }) : null;
    function getBackgroundSize() {
      if (hiddenImageRef.current != null && (resizeMode === 'center' || resizeMode === 'repeat')) {
        var _hiddenImageRef$curre = hiddenImageRef.current,
          naturalHeight = _hiddenImageRef$curre.naturalHeight,
          naturalWidth = _hiddenImageRef$curre.naturalWidth;
        var _height3 = layout.height,
          _width3 = layout.width;
        if (naturalHeight && naturalWidth && _height3 && _width3) {
          var scaleFactor = Math.min(1, _width3 / naturalWidth, _height3 / naturalHeight);
          var x = Math.ceil(scaleFactor * naturalWidth);
          var y = Math.ceil(scaleFactor * naturalHeight);
          return x + "px " + y + "px";
        }
      }
    }
    function handleLayout(e) {
      if (resizeMode === 'center' || resizeMode === 'repeat' || onLayout) {
        var _layout = e.nativeEvent.layout;
        onLayout && onLayout(e);
        updateLayout(_layout);
      }
    }

    // Image loading
    var uri = resolveAssetUri(source);
    React.useEffect(() => {
      abortPendingRequest();
      if (uri != null) {
        updateState(LOADING);
        if (onLoadStart) {
          onLoadStart();
        }
        requestRef.current = ImageLoader.default.load(uri, function load(e) {
          updateState(LOADED);
          if (onLoad) {
            onLoad(e);
          }
          if (onLoadEnd) {
            onLoadEnd();
          }
        }, function error() {
          updateState(ERRORED);
          if (onError) {
            onError({
              nativeEvent: {
                error: "Failed to load resource " + uri
              }
            });
          }
          if (onLoadEnd) {
            onLoadEnd();
          }
        });
      }
      function abortPendingRequest() {
        if (requestRef.current != null) {
          ImageLoader.default.abort(requestRef.current);
          requestRef.current = null;
        }
      }
      return abortPendingRequest;
    }, [uri, requestRef, updateState, onError, onLoad, onLoadEnd, onLoadStart]);
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, {
      "aria-label": ariaLabel,
      onLayout: handleLayout,
      pointerEvents: pointerEvents,
      ref: ref,
      style: [styles.root, hasTextAncestor && styles.inline, imageSizeStyle, style, styles.undo,
      // TEMP: avoid deprecated shadow props regression
      // until Image refactored to use createElement.
      {
        boxShadow: null
      }]
    }), /*#__PURE__*/React.createElement(View.default, {
      style: [styles.image, resizeModeStyles[resizeMode], {
        backgroundImage,
        filter
      }, backgroundSize != null && {
        backgroundSize
      }],
      suppressHydrationWarning: true
    }), hiddenImage, createTintColorSVG(tintColor, filterRef.current));
  });
  Image.displayName = 'Image';

  // $FlowIgnore: This is the correct type, but casting makes it unhappy since the variables aren't defined yet
  var ImageWithStatics = Image;
  ImageWithStatics.getSize = function (uri, success, failure) {
    ImageLoader.default.getSize(uri, success, failure);
  };
  ImageWithStatics.prefetch = function (uri) {
    return ImageLoader.default.prefetch(uri);
  };
  ImageWithStatics.queryCache = function (uris) {
    return ImageLoader.default.queryCache(uris);
  };
  var styles = StyleSheet.default.create({
    root: {
      flexBasis: 'auto',
      overflow: 'hidden',
      zIndex: 0
    },
    inline: {
      display: 'inline-flex'
    },
    undo: {
      // These styles are converted to CSS filters applied to the
      // element displaying the background image.
      blurRadius: null,
      shadowColor: null,
      shadowOpacity: null,
      shadowOffset: null,
      shadowRadius: null,
      tintColor: null,
      // These styles are not supported
      overlayColor: null,
      resizeMode: null
    },
    image: (0, _objectSpread.default)((0, _objectSpread.default)({}, StyleSheet.default.absoluteFillObject), {}, {
      backgroundColor: 'transparent',
      backgroundPosition: 'center',
      backgroundRepeat: 'no-repeat',
      backgroundSize: 'cover',
      height: '100%',
      width: '100%',
      zIndex: -1
    }),
    accessibilityImage$raw: (0, _objectSpread.default)((0, _objectSpread.default)({}, StyleSheet.default.absoluteFillObject), {}, {
      height: '100%',
      opacity: 0,
      width: '100%',
      zIndex: -1
    })
  });
  var resizeModeStyles = StyleSheet.default.create({
    center: {
      backgroundSize: 'auto'
    },
    contain: {
      backgroundSize: 'contain'
    },
    cover: {
      backgroundSize: 'cover'
    },
    none: {
      backgroundPosition: '0',
      backgroundSize: 'auto'
    },
    repeat: {
      backgroundPosition: '0',
      backgroundRepeat: 'repeat',
      backgroundSize: 'auto'
    },
    stretch: {
      backgroundSize: '100% 100%'
    }
  });
  var _default = ImageWithStatics;
},155,[37,42,43,9,111,156,101,157,158,55,133,110,102],"node_modules/react-native-web/dist/exports/Image/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const assets = [];
  module.exports = {
    registerAsset: s => assets.push(s),
    getAssetByID: s => assets[s - 1]
  };
},156,[],"\u0000polyfill:assets-registry");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "ImageUriCache", {
    enumerable: true,
    get: function () {
      return ImageUriCache;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var dataUriPattern = /^data:/;
  class ImageUriCache {
    static has(uri) {
      var entries = ImageUriCache._entries;
      var isDataUri = dataUriPattern.test(uri);
      return isDataUri || Boolean(entries[uri]);
    }
    static add(uri) {
      var entries = ImageUriCache._entries;
      var lastUsedTimestamp = Date.now();
      if (entries[uri]) {
        entries[uri].lastUsedTimestamp = lastUsedTimestamp;
        entries[uri].refCount += 1;
      } else {
        entries[uri] = {
          lastUsedTimestamp,
          refCount: 1
        };
      }
    }
    static remove(uri) {
      var entries = ImageUriCache._entries;
      if (entries[uri]) {
        entries[uri].refCount -= 1;
      }
      // Free up entries when the cache is "full"
      ImageUriCache._cleanUpIfNeeded();
    }
    static _cleanUpIfNeeded() {
      var entries = ImageUriCache._entries;
      var imageUris = Object.keys(entries);
      if (imageUris.length + 1 > ImageUriCache._maximumEntries) {
        var leastRecentlyUsedKey;
        var leastRecentlyUsedEntry;
        imageUris.forEach(uri => {
          var entry = entries[uri];
          if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {
            leastRecentlyUsedKey = uri;
            leastRecentlyUsedEntry = entry;
          }
        });
        if (leastRecentlyUsedKey) {
          delete entries[leastRecentlyUsedKey];
        }
      }
    }
  }
  ImageUriCache._maximumEntries = 256;
  ImageUriCache._entries = {};
  var id = 0;
  var requests = {};
  var ImageLoader = {
    abort(requestId) {
      var image = requests["" + requestId];
      if (image) {
        image.onerror = null;
        image.onload = null;
        image = null;
        delete requests["" + requestId];
      }
    },
    getSize(uri, success, failure) {
      var complete = false;
      var interval = setInterval(callback, 16);
      var requestId = ImageLoader.load(uri, callback, errorCallback);
      function callback() {
        var image = requests["" + requestId];
        if (image) {
          var naturalHeight = image.naturalHeight,
            naturalWidth = image.naturalWidth;
          if (naturalHeight && naturalWidth) {
            success(naturalWidth, naturalHeight);
            complete = true;
          }
        }
        if (complete) {
          ImageLoader.abort(requestId);
          clearInterval(interval);
        }
      }
      function errorCallback() {
        if (typeof failure === 'function') {
          failure();
        }
        ImageLoader.abort(requestId);
        clearInterval(interval);
      }
    },
    has(uri) {
      return ImageUriCache.has(uri);
    },
    load(uri, onLoad, onError) {
      id += 1;
      var image = new window.Image();
      image.onerror = onError;
      image.onload = e => {
        // avoid blocking the main thread
        var onDecode = () => onLoad({
          nativeEvent: e
        });
        if (typeof image.decode === 'function') {
          // Safari currently throws exceptions when decoding svgs.
          // We want to catch that error and allow the load handler
          // to be forwarded to the onLoad handler in this case
          image.decode().then(onDecode, onDecode);
        } else {
          setTimeout(onDecode, 0);
        }
      };
      image.src = uri;
      requests["" + id] = image;
      return id;
    },
    prefetch(uri) {
      return new Promise((resolve, reject) => {
        ImageLoader.load(uri, () => {
          // Add the uri to the cache so it can be immediately displayed when used
          // but also immediately remove it to correctly reflect that it has no active references
          ImageUriCache.add(uri);
          ImageUriCache.remove(uri);
          resolve();
        }, reject);
      });
    },
    queryCache(uris) {
      var result = {};
      uris.forEach(u => {
        if (ImageUriCache.has(u)) {
          result[u] = 'disk/memory';
        }
      });
      return Promise.resolve(result);
    }
  };
  var _default = ImageLoader;
},157,[],"node_modules/react-native-web/dist/modules/ImageLoader/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return PixelRatio;
    }
  });
  var _Dimensions = require(_dependencyMap[0], "../Dimensions");
  var Dimensions = _interopDefault(_Dimensions);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * PixelRatio gives access to the device pixel density.
   */
  class PixelRatio {
    /**
     * Returns the device pixel density.
     */
    static get() {
      return Dimensions.default.get('window').scale;
    }

    /**
     * No equivalent for Web
     */
    static getFontScale() {
      return Dimensions.default.get('window').fontScale || PixelRatio.get();
    }

    /**
     * Converts a layout size (dp) to pixel size (px).
     * Guaranteed to return an integer number.
     */
    static getPixelSizeForLayoutSize(layoutSize) {
      return Math.round(layoutSize * PixelRatio.get());
    }

    /**
     * Rounds a layout size (dp) to the nearest layout size that corresponds to
     * an integer number of pixels. For example, on a device with a PixelRatio
     * of 3, `PixelRatio.roundToNearestPixel(8.4) = 8.33`, which corresponds to
     * exactly (8.33 * 3) = 25 pixels.
     */
    static roundToNearestPixel(layoutSize) {
      var ratio = PixelRatio.get();
      return Math.round(layoutSize * ratio) / ratio;
    }
  }
},158,[44],"node_modules/react-native-web/dist/exports/PixelRatio/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyFunction = () => {};
  function StatusBar() {
    return null;
  }
  StatusBar.setBackgroundColor = emptyFunction;
  StatusBar.setBarStyle = emptyFunction;
  StatusBar.setHidden = emptyFunction;
  StatusBar.setNetworkActivityIndicatorVisible = emptyFunction;
  StatusBar.setTranslucent = emptyFunction;
  var _default = StatusBar;
},159,[],"node_modules/react-native-web/dist/exports/StatusBar/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fmetro-runtime%2Fassets/chevron-left.png",
    width: 16,
    height: 28
  };
},160,[],"node_modules/@expo/metro-runtime/assets/chevron-left.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fmetro-runtime%2Fassets/chevron-right.png",
    width: 16,
    height: 28
  };
},161,[],"node_modules/@expo/metro-runtime/assets/chevron-right.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorMessageHeader.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.LogBoxInspectorMessageHeader = LogBoxInspectorMessageHeader;
  require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[1], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[3], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsView = require(_dependencyMap[4], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _UILogBoxMessage = require(_dependencyMap[5], "../UI/LogBoxMessage");
  var _UILogBoxStyle = require(_dependencyMap[6], "../UI/LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_UILogBoxStyle);
  var _reactJsxDevRuntime = require(_dependencyMap[7], "react/jsx-dev-runtime");
  const SHOW_MORE_MESSAGE_LENGTH = 300;
  function ShowMoreButton({
    message,
    collapsed,
    onPress
  }) {
    if (message.content.length < SHOW_MORE_MESSAGE_LENGTH || !collapsed) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
      style: styles.collapse,
      onPress: onPress,
      children: "... See More"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 35,
      columnNumber: 5
    }, this);
  }
  function LogBoxInspectorMessageHeader(props) {
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: styles.body,
      children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: styles.heading,
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
          testID: "logbox_title",
          style: [styles.headingText, styles[props.level]],
          children: props.title
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 45,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 44,
        columnNumber: 7
      }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
        style: styles.bodyText,
        children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_UILogBoxMessage.LogBoxMessage, {
          maxLength: props.collapsed ? SHOW_MORE_MESSAGE_LENGTH : Infinity,
          message: props.message,
          style: styles.messageText
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 50,
          columnNumber: 9
        }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ShowMoreButton, Object.assign({}, props), void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 55,
          columnNumber: 9
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 49,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 5
    }, this);
  }
  const styles = StyleSheet.default.create({
    body: Object.assign({
      backgroundColor: LogBoxStyle.getBackgroundColor(1)
    }, Platform.default.select({
      web: {
        boxShadow: `0 2px 0 2px #00000080`
      }
    })),
    bodyText: {
      color: LogBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 20,
      fontWeight: '500',
      paddingHorizontal: 12,
      paddingBottom: 10
    },
    heading: {
      alignItems: 'center',
      flexDirection: 'row',
      paddingHorizontal: 12,
      marginTop: 10,
      marginBottom: 5
    },
    headingText: {
      flex: 1,
      fontSize: 20,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 28
    },
    warn: {
      color: LogBoxStyle.getWarningColor(1)
    },
    error: {
      color: LogBoxStyle.getErrorColor(1)
    },
    fatal: {
      color: LogBoxStyle.getFatalColor(1)
    },
    syntax: {
      color: LogBoxStyle.getFatalColor(1)
    },
    static: {
      color: LogBoxStyle.getFatalColor(1)
    },
    messageText: {
      color: LogBoxStyle.getTextColor(0.6)
    },
    collapse: {
      color: LogBoxStyle.getTextColor(0.7),
      fontSize: 14,
      fontWeight: '300',
      lineHeight: 12
    },
    button: {
      paddingVertical: 5,
      paddingHorizontal: 10,
      borderRadius: 3
    }
  });
},162,[9,14,55,138,110,163,136,33],"node_modules/@expo/metro-runtime/src/error-overlay/overlay/LogBoxInspectorMessageHeader.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\UI\\LogBoxMessage.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.LogBoxMessage = LogBoxMessage;
  require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsText = require(_dependencyMap[1], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactJsxDevRuntime = require(_dependencyMap[2], "react/jsx-dev-runtime");
  const cleanContent = content => content.replace(/^(TransformError |Warning: (Warning: )?|Error: )/g, '');
  function LogBoxMessage(props) {
    const {
      content,
      substitutions
    } = props.message;
    if (props.plaintext === true) {
      return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
        children: cleanContent(content)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 27,
        columnNumber: 12
      }, this);
    }
    const maxLength = props.maxLength != null ? props.maxLength : Infinity;
    const substitutionStyle = props.style;
    const elements = [];
    let length = 0;
    const createUnderLength = (key, message, style) => {
      let cleanMessage = cleanContent(message);
      if (props.maxLength != null) {
        cleanMessage = cleanMessage.slice(0, props.maxLength - length);
      }
      if (length < maxLength) {
        elements.push(/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
          style: style,
          children: cleanMessage
        }, key, false, {
          fileName: _jsxFileName,
          lineNumber: 43,
          columnNumber: 9
        }, this));
      }
      length += cleanMessage.length;
    };
    const lastOffset = substitutions.reduce((prevOffset, substitution, index) => {
      const key = String(index);
      if (substitution.offset > prevOffset) {
        const prevPart = content.substr(prevOffset, substitution.offset - prevOffset);
        createUnderLength(key, prevPart);
      }
      const substititionPart = content.substr(substitution.offset, substitution.length);
      createUnderLength(key + '.5', substititionPart, substitutionStyle);
      return substitution.offset + substitution.length;
    }, 0);
    if (lastOffset < content.length) {
      const lastPart = content.substr(lastOffset);
      createUnderLength('-1', lastPart);
    }
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_reactJsxDevRuntime.Fragment, {
      children: elements
    }, void 0, false);
  }
},163,[9,138,33],"node_modules/@expo/metro-runtime/src/error-overlay/UI/LogBoxMessage.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorStackFrames.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.getCollapseMessage = getCollapseMessage;
  exports.LogBoxInspectorStackFrames = LogBoxInspectorStackFrames;
  var _react = require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[1], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[2], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsView = require(_dependencyMap[3], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _LogBoxInspectorSection = require(_dependencyMap[4], "./LogBoxInspectorSection");
  var _LogBoxInspectorSourceMapStatus = require(_dependencyMap[5], "./LogBoxInspectorSourceMapStatus");
  var _LogBoxInspectorStackFrame = require(_dependencyMap[6], "./LogBoxInspectorStackFrame");
  var _DataLogContext = require(_dependencyMap[7], "../Data/LogContext");
  var _UILogBoxButton = require(_dependencyMap[8], "../UI/LogBoxButton");
  var _UILogBoxStyle = require(_dependencyMap[9], "../UI/LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_UILogBoxStyle);
  var _modulesOpenFileInEditor = require(_dependencyMap[10], "../modules/openFileInEditor");
  var openFileInEditor = _interopDefault(_modulesOpenFileInEditor);
  var _reactJsxDevRuntime = require(_dependencyMap[11], "react/jsx-dev-runtime");
  function getCollapseMessage(stackFrames, collapsed) {
    if (stackFrames.length === 0) {
      return 'No frames to show';
    }
    const collapsedCount = stackFrames.reduce((count, {
      collapse
    }) => {
      if (collapse === true) {
        return count + 1;
      }
      return count;
    }, 0);
    if (collapsedCount === 0) {
      return 'Showing all frames';
    }
    const framePlural = `frame${collapsedCount > 1 ? 's' : ''}`;
    if (collapsedCount === stackFrames.length) {
      return collapsed ? `See${collapsedCount > 1 ? ' all ' : ' '}${collapsedCount} collapsed ${framePlural}` : `Collapse${collapsedCount > 1 ? ' all ' : ' '}${collapsedCount} ${framePlural}`;
    } else {
      return collapsed ? `See ${collapsedCount} more ${framePlural}` : `Collapse ${collapsedCount} ${framePlural}`;
    }
  }
  function LogBoxInspectorStackFrames({
    onRetry,
    type
  }) {
    const log = (0, _DataLogContext.useSelectedLog)();
    const [collapsed, setCollapsed] = (0, _react.useState)(() => {
      // Only collapse frames initially if some frames are not collapsed.
      return log.getAvailableStack(type)?.some(({
        collapse
      }) => !collapse);
    });
    function getStackList() {
      if (collapsed === true) {
        return log.getAvailableStack(type)?.filter(({
          collapse
        }) => !collapse);
      } else {
        return log.getAvailableStack(type);
      }
    }
    if (log.getAvailableStack(type)?.length === 0) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_LogBoxInspectorSection.LogBoxInspectorSection, {
      heading: type === 'component' ? 'Component Stack' : 'Call Stack',
      action: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_LogBoxInspectorSourceMapStatus.LogBoxInspectorSourceMapStatus, {
        onPress: log.symbolicated[type].status === 'FAILED' ? onRetry : null,
        status: log.symbolicated[type].status
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 79,
        columnNumber: 9
      }, this),
      children: [log.symbolicated[type].status !== 'COMPLETE' && /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: stackStyles.hintBox,
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
          style: stackStyles.hintText,
          children: "This call stack is not symbolicated. Some features are unavailable such as viewing the function name or tapping to open files."
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 86,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 85,
        columnNumber: 9
      }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(StackFrameList, {
        list: getStackList(),
        status: log.symbolicated[type].status
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 92,
        columnNumber: 7
      }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(StackFrameFooter, {
        onPress: () => setCollapsed(!collapsed),
        message: getCollapseMessage(log.getAvailableStack(type), !!collapsed)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 93,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 76,
      columnNumber: 5
    }, this);
  }
  function StackFrameList({
    list,
    status
  }) {
    return list.map((frame, index) => {
      const {
        file,
        lineNumber
      } = frame;
      return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_LogBoxInspectorStackFrame.LogBoxInspectorStackFrame, {
        frame: frame,
        onPress: status === 'COMPLETE' && file != null && lineNumber != null ? () => (0, openFileInEditor.default)(file, lineNumber) : undefined
      }, index, false, {
        fileName: _jsxFileName,
        lineNumber: 111,
        columnNumber: 7
      }, this);
    });
  }
  function StackFrameFooter({
    message,
    onPress
  }) {
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: stackStyles.collapseContainer,
      children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_UILogBoxButton.LogBoxButton, {
        backgroundColor: {
          default: 'transparent',
          pressed: LogBoxStyle.getBackgroundColor(1)
        },
        onPress: onPress,
        style: stackStyles.collapseButton,
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
          style: stackStyles.collapse,
          children: message
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 134,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 127,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 126,
      columnNumber: 5
    }, this);
  }
  const stackStyles = StyleSheet.default.create({
    section: {
      marginTop: 15
    },
    heading: {
      alignItems: 'center',
      flexDirection: 'row',
      paddingHorizontal: 12,
      marginBottom: 10
    },
    headingText: {
      color: LogBoxStyle.getTextColor(1),
      flex: 1,
      fontSize: 20,
      fontWeight: '600',
      includeFontPadding: false,
      lineHeight: 20
    },
    body: {
      paddingBottom: 10
    },
    bodyText: {
      color: LogBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18,
      fontWeight: '500',
      paddingHorizontal: 27
    },
    hintText: {
      color: LogBoxStyle.getTextColor(0.7),
      fontSize: 13,
      includeFontPadding: false,
      lineHeight: 18,
      fontWeight: '400',
      marginHorizontal: 10
    },
    hintBox: {
      backgroundColor: LogBoxStyle.getBackgroundColor(),
      marginHorizontal: 10,
      paddingHorizontal: 5,
      paddingVertical: 10,
      borderRadius: 5,
      marginBottom: 5
    },
    collapseContainer: {
      marginLeft: 15,
      flexDirection: 'row'
    },
    collapseButton: {
      borderRadius: 5
    },
    collapse: {
      color: LogBoxStyle.getTextColor(0.7),
      fontSize: 12,
      fontWeight: '300',
      lineHeight: 20,
      marginTop: 0,
      paddingHorizontal: 10,
      paddingVertical: 5
    }
  });
},164,[9,55,138,110,139,165,240,21,142,136,152,33],"node_modules/@expo/metro-runtime/src/error-overlay/overlay/LogBoxInspectorStackFrames.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use client';
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorSourceMapStatus.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.LogBoxInspectorSourceMapStatus = LogBoxInspectorSourceMapStatus;
  var _react = require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[1], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsEasing = require(_dependencyMap[2], "react-native-web/dist/exports/Easing");
  var Easing = _interopDefault(_reactNativeWebDistExportsEasing);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[4], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _UILogBoxButton = require(_dependencyMap[5], "../UI/LogBoxButton");
  var _UILogBoxStyle = require(_dependencyMap[6], "../UI/LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_UILogBoxStyle);
  var _reactJsxDevRuntime = require(_dependencyMap[7], "react/jsx-dev-runtime");
  function LogBoxInspectorSourceMapStatus(props) {
    const [state, setState] = (0, _react.useState)({
      animation: null,
      rotate: null
    });
    (0, _react.useEffect)(() => {
      if (props.status === 'PENDING') {
        if (state.animation == null) {
          const animated = new Animated.default.Value(0);
          const animation = Animated.default.loop(Animated.default.timing(animated, {
            duration: 2000,
            easing: Easing.default.linear,
            toValue: 1,
            useNativeDriver: true
          }));
          setState({
            animation,
            rotate: animated.interpolate({
              inputRange: [0, 1],
              outputRange: ['0deg', '360deg']
            })
          });
          animation.start();
        }
      } else {
        if (state.animation != null) {
          state.animation.stop();
          setState({
            animation: null,
            rotate: null
          });
        }
      }
      return () => {
        if (state.animation != null) {
          state.animation.stop();
        }
      };
    }, [props.status, state.animation]);
    let image;
    let color;
    switch (props.status) {
      case 'FAILED':
        image = require(_dependencyMap[8], "@expo/metro-runtime/assets/alert-triangle.png");
        color = LogBoxStyle.getErrorColor(1);
        break;
      case 'PENDING':
        image = require(_dependencyMap[9], "@expo/metro-runtime/assets/loader.png");
        color = LogBoxStyle.getWarningColor(1);
        break;
    }
    if (props.status === 'COMPLETE' || image == null) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_UILogBoxButton.LogBoxButton, {
      backgroundColor: {
        default: 'transparent',
        pressed: LogBoxStyle.getBackgroundColor(1)
      },
      hitSlop: {
        bottom: 8,
        left: 8,
        right: 8,
        top: 8
      },
      onPress: props.onPress,
      style: styles.root,
      children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Animated.default.Image, {
        source: image,
        tintColor: color ?? LogBoxStyle.getTextColor(0.4),
        style: [styles.image, state.rotate == null || props.status !== 'PENDING' ? null : {
          transform: [{
            rotate: state.rotate
          }]
        }]
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 96,
        columnNumber: 7
      }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
        style: [styles.text, {
          color
        }],
        children: "Source Map"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 106,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 88,
      columnNumber: 5
    }, this);
  }
  const styles = StyleSheet.default.create({
    root: {
      alignItems: 'center',
      borderRadius: 12,
      flexDirection: 'row',
      height: 24,
      paddingHorizontal: 8
    },
    image: {
      height: 14,
      width: 16,
      marginEnd: 4
    },
    text: {
      fontSize: 12,
      includeFontPadding: false,
      lineHeight: 16
    }
  });
},165,[9,166,235,55,138,142,136,33,238,239],"node_modules/@expo/metro-runtime/src/error-overlay/overlay/LogBoxInspectorSourceMapStatus.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeAnimatedAnimated = require(_dependencyMap[0], "../../vendor/react-native/Animated/Animated");
  var Animated = _interopDefault(_vendorReactNativeAnimatedAnimated);
  var _default = Animated.default;
},166,[167],"node_modules/react-native-web/dist/exports/Animated/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _exportsPlatform = require(_dependencyMap[1], "../../../exports/Platform");
  var Platform = _interopDefault(_exportsPlatform);
  var _componentsAnimatedFlatList = require(_dependencyMap[2], "./components/AnimatedFlatList");
  var FlatList = _interopDefault(_componentsAnimatedFlatList);
  var _componentsAnimatedImage = require(_dependencyMap[3], "./components/AnimatedImage");
  var Image = _interopDefault(_componentsAnimatedImage);
  var _componentsAnimatedScrollView = require(_dependencyMap[4], "./components/AnimatedScrollView");
  var ScrollView = _interopDefault(_componentsAnimatedScrollView);
  var _componentsAnimatedSectionList = require(_dependencyMap[5], "./components/AnimatedSectionList");
  var SectionList = _interopDefault(_componentsAnimatedSectionList);
  var _componentsAnimatedText = require(_dependencyMap[6], "./components/AnimatedText");
  var Text = _interopDefault(_componentsAnimatedText);
  var _componentsAnimatedView = require(_dependencyMap[7], "./components/AnimatedView");
  var View = _interopDefault(_componentsAnimatedView);
  var _AnimatedMock = require(_dependencyMap[8], "./AnimatedMock");
  var AnimatedMock = _interopDefault(_AnimatedMock);
  var _AnimatedImplementation = require(_dependencyMap[9], "./AnimatedImplementation");
  var AnimatedImplementation = _interopDefault(_AnimatedImplementation);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var Animated = Platform.default.isTesting ? AnimatedMock.default : AnimatedImplementation.default;
  var _default = (0, _objectSpread.default)({
    FlatList: FlatList.default,
    Image: Image.default,
    ScrollView: ScrollView.default,
    SectionList: SectionList.default,
    Text: Text.default,
    View: View.default
  }, Animated);
},167,[37,14,168,211,212,213,217,218,219,220],"node_modules/react-native-web/dist/vendor/react-native/Animated/Animated.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _exportsFlatList = require(_dependencyMap[2], "../../../../exports/FlatList");
  var FlatList = _interopDefault(_exportsFlatList);
  var _createAnimatedComponent = require(_dependencyMap[3], "../createAnimatedComponent");
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * @see https://github.com/facebook/react-native/commit/b8c8562
   */
  var FlatListWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(FlatList.default, (0, _extends.default)({
    scrollEventThrottle: 0.0001
  }, props, {
    ref: ref
  })));
  var _default = (0, createAnimatedComponent.default)(FlatListWithEventThrottle);
},168,[42,9,169,193],"node_modules/react-native-web/dist/vendor/react-native/Animated/components/AnimatedFlatList.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeFlatList = require(_dependencyMap[0], "../../vendor/react-native/FlatList");
  var FlatList = _interopDefault(_vendorReactNativeFlatList);
  var _default = FlatList.default;
},169,[170],"node_modules/react-native-web/dist/exports/FlatList/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[2], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _exportsView = require(_dependencyMap[3], "../../../exports/View");
  var View = _interopDefault(_exportsView);
  var _exportsStyleSheet = require(_dependencyMap[4], "../../../exports/StyleSheet");
  var StyleSheet = _interopDefault(_exportsStyleSheet);
  var _deepDiffer = require(_dependencyMap[5], "../deepDiffer");
  var deepDiffer = _interopDefault(_deepDiffer);
  var _exportsPlatform = require(_dependencyMap[6], "../../../exports/Platform");
  var Platform = _interopDefault(_exportsPlatform);
  var _fbjsLibInvariant = require(_dependencyMap[7], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _react = require(_dependencyMap[8], "react");
  var React = _interopNamespace(_react);
  var _VirtualizedList = require(_dependencyMap[9], "../VirtualizedList");
  var VirtualizedList = _interopDefault(_VirtualizedList);
  var _VirtualizeUtils = require(_dependencyMap[10], "../VirtualizeUtils");
  var _memoizeOne = require(_dependencyMap[11], "memoize-one");
  var memoizeOne = _interopDefault(_memoizeOne);
  var _excluded = ["numColumns", "columnWrapperStyle", "removeClippedSubviews", "strictMode"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Default Props Helper Functions
   * Use the following helper functions for default values
   */

  // removeClippedSubviewsOrDefault(this.props.removeClippedSubviews)
  function removeClippedSubviewsOrDefault(removeClippedSubviews) {
    return removeClippedSubviews !== null && removeClippedSubviews !== void 0 ? removeClippedSubviews : Platform.default.OS === 'android';
  }

  // numColumnsOrDefault(this.props.numColumns)
  function numColumnsOrDefault(numColumns) {
    return numColumns !== null && numColumns !== void 0 ? numColumns : 1;
  }
  function isArrayLike(data) {
    // $FlowExpectedError[incompatible-use]
    return typeof Object(data).length === 'number';
  }
  /**
   * A performant interface for rendering simple, flat lists, supporting the most handy features:
   *
   *  - Fully cross-platform.
   *  - Optional horizontal mode.
   *  - Configurable viewability callbacks.
   *  - Header support.
   *  - Footer support.
   *  - Separator support.
   *  - Pull to Refresh.
   *  - Scroll loading.
   *  - ScrollToIndex support.
   *
   * If you need section support, use [`<SectionList>`](docs/sectionlist.html).
   *
   * Minimal Example:
   *
   *     <FlatList
   *       data={[{key: 'a'}, {key: 'b'}]}
   *       renderItem={({item}) => <Text>{item.key}</Text>}
   *     />
   *
   * More complex, multi-select example demonstrating `PureComponent` usage for perf optimization and avoiding bugs.
   *
   * - By binding the `onPressItem` handler, the props will remain `===` and `PureComponent` will
   *   prevent wasteful re-renders unless the actual `id`, `selected`, or `title` props change, even
   *   if the components rendered in `MyListItem` did not have such optimizations.
   * - By passing `extraData={this.state}` to `FlatList` we make sure `FlatList` itself will re-render
   *   when the `state.selected` changes. Without setting this prop, `FlatList` would not know it
   *   needs to re-render any items because it is also a `PureComponent` and the prop comparison will
   *   not show any changes.
   * - `keyExtractor` tells the list to use the `id`s for the react keys instead of the default `key` property.
   *
   *
   *     class MyListItem extends React.PureComponent {
   *       _onPress = () => {
   *         this.props.onPressItem(this.props.id);
   *       };
   *
   *       render() {
   *         const textColor = this.props.selected ? "red" : "black";
   *         return (
   *           <TouchableOpacity onPress={this._onPress}>
   *             <View>
   *               <Text style={{ color: textColor }}>
   *                 {this.props.title}
   *               </Text>
   *             </View>
   *           </TouchableOpacity>
   *         );
   *       }
   *     }
   *
   *     class MultiSelectList extends React.PureComponent {
   *       state = {selected: (new Map(): Map<string, boolean>)};
   *
   *       _keyExtractor = (item, index) => item.id;
   *
   *       _onPressItem = (id: string) => {
   *         // updater functions are preferred for transactional updates
   *         this.setState((state) => {
   *           // copy the map rather than modifying state.
   *           const selected = new Map(state.selected);
   *           selected.set(id, !selected.get(id)); // toggle
   *           return {selected};
   *         });
   *       };
   *
   *       _renderItem = ({item}) => (
   *         <MyListItem
   *           id={item.id}
   *           onPressItem={this._onPressItem}
   *           selected={!!this.state.selected.get(item.id)}
   *           title={item.title}
   *         />
   *       );
   *
   *       render() {
   *         return (
   *           <FlatList
   *             data={this.props.data}
   *             extraData={this.state}
   *             keyExtractor={this._keyExtractor}
   *             renderItem={this._renderItem}
   *           />
   *         );
   *       }
   *     }
   *
   * This is a convenience wrapper around [`<VirtualizedList>`](docs/virtualizedlist.html),
   * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed
   * here, along with the following caveats:
   *
   * - Internal state is not preserved when content scrolls out of the render window. Make sure all
   *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
   * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
   *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
   *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
   *   changes. This includes the `data` prop and parent component state.
   * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
   *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see
   *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
   *   and we are working on improving it behind the scenes.
   * - By default, the list looks for a `key` prop on each item and uses that for the React key.
   *   Alternatively, you can provide a custom `keyExtractor` prop.
   *
   * Also inherits [ScrollView Props](docs/scrollview.html#props), unless it is nested in another FlatList of same orientation.
   */
  class FlatList extends React.PureComponent {
    /**
     * Scrolls to the end of the content. May be janky without `getItemLayout` prop.
     */
    scrollToEnd(params) {
      if (this._listRef) {
        this._listRef.scrollToEnd(params);
      }
    }

    /**
     * Scrolls to the item at the specified index such that it is positioned in the viewable area
     * such that `viewPosition` 0 places it at the top, 1 at the bottom, and 0.5 centered in the
     * middle. `viewOffset` is a fixed number of pixels to offset the final target position.
     *
     * Note: cannot scroll to locations outside the render window without specifying the
     * `getItemLayout` prop.
     */
    scrollToIndex(params) {
      if (this._listRef) {
        this._listRef.scrollToIndex(params);
      }
    }

    /**
     * Requires linear scan through data - use `scrollToIndex` instead if possible.
     *
     * Note: cannot scroll to locations outside the render window without specifying the
     * `getItemLayout` prop.
     */
    scrollToItem(params) {
      if (this._listRef) {
        this._listRef.scrollToItem(params);
      }
    }

    /**
     * Scroll to a specific content pixel offset in the list.
     *
     * Check out [scrollToOffset](docs/virtualizedlist.html#scrolltooffset) of VirtualizedList
     */
    scrollToOffset(params) {
      if (this._listRef) {
        this._listRef.scrollToOffset(params);
      }
    }

    /**
     * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g.
     * if `waitForInteractions` is true and the user has not scrolled. This is typically called by
     * taps on items or by navigation actions.
     */
    recordInteraction() {
      if (this._listRef) {
        this._listRef.recordInteraction();
      }
    }

    /**
     * Displays the scroll indicators momentarily.
     *
     * @platform ios
     */
    flashScrollIndicators() {
      if (this._listRef) {
        this._listRef.flashScrollIndicators();
      }
    }

    /**
     * Provides a handle to the underlying scroll responder.
     */
    getScrollResponder() {
      if (this._listRef) {
        return this._listRef.getScrollResponder();
      }
    }

    /**
     * Provides a reference to the underlying host component
     */
    getNativeScrollRef() {
      if (this._listRef) {
        /* $FlowFixMe[incompatible-return] Suppresses errors found when fixing
         * TextInput typing */
        return this._listRef.getScrollRef();
      }
    }
    getScrollableNode() {
      if (this._listRef) {
        return this._listRef.getScrollableNode();
      }
    }
    constructor(_props) {
      super(_props);
      this._virtualizedListPairs = [];
      this._captureRef = ref => {
        this._listRef = ref;
      };
      this._getItem = (data, index) => {
        var numColumns = numColumnsOrDefault(this.props.numColumns);
        if (numColumns > 1) {
          var ret = [];
          for (var kk = 0; kk < numColumns; kk++) {
            var itemIndex = index * numColumns + kk;
            if (itemIndex < data.length) {
              var _item = data[itemIndex];
              ret.push(_item);
            }
          }
          return ret;
        } else {
          return data[index];
        }
      };
      this._getItemCount = data => {
        // Legacy behavior of FlatList was to forward "undefined" length if invalid
        // data like a non-arraylike object is passed. VirtualizedList would then
        // coerce this, and the math would work out to no-op. For compatibility, if
        // invalid data is passed, we tell VirtualizedList there are zero items
        // available to prevent it from trying to read from the invalid data
        // (without propagating invalidly typed data).
        if (data != null && isArrayLike(data)) {
          var numColumns = numColumnsOrDefault(this.props.numColumns);
          return numColumns > 1 ? Math.ceil(data.length / numColumns) : data.length;
        } else {
          return 0;
        }
      };
      this._keyExtractor = (items, index) => {
        var _this$props$keyExtrac;
        var numColumns = numColumnsOrDefault(this.props.numColumns);
        var keyExtractor = (_this$props$keyExtrac = this.props.keyExtractor) !== null && _this$props$keyExtrac !== void 0 ? _this$props$keyExtrac : _VirtualizeUtils.keyExtractor;
        if (numColumns > 1) {
          (0, invariant.default)(Array.isArray(items), 'FlatList: Encountered internal consistency error, expected each item to consist of an ' + 'array with 1-%s columns; instead, received a single item.', numColumns);
          return items.map((item, kk) => keyExtractor(item, index * numColumns + kk)).join(':');
        }

        // $FlowFixMe[incompatible-call] Can't call keyExtractor with an array
        return keyExtractor(items, index);
      };
      this._renderer = (ListItemComponent, renderItem, columnWrapperStyle, numColumns, extraData
      // $FlowFixMe[missing-local-annot]
      ) => {
        var cols = numColumnsOrDefault(numColumns);
        var render = props => {
          if (ListItemComponent) {
            // $FlowFixMe[not-a-component] Component isn't valid
            // $FlowFixMe[incompatible-type-arg] Component isn't valid
            // $FlowFixMe[incompatible-return] Component isn't valid
            return /*#__PURE__*/React.createElement(ListItemComponent, props);
          } else if (renderItem) {
            // $FlowFixMe[incompatible-call]
            return renderItem(props);
          } else {
            return null;
          }
        };
        var renderProp = info => {
          if (cols > 1) {
            var _item2 = info.item,
              _index = info.index;
            (0, invariant.default)(Array.isArray(_item2), 'Expected array of items with numColumns > 1');
            return /*#__PURE__*/React.createElement(View.default, {
              style: [styles.row, columnWrapperStyle]
            }, _item2.map((it, kk) => {
              var element = render({
                // $FlowFixMe[incompatible-call]
                item: it,
                index: _index * cols + kk,
                separators: info.separators
              });
              return element != null ? /*#__PURE__*/React.createElement(React.Fragment, {
                key: kk
              }, element) : null;
            }));
          } else {
            return render(info);
          }
        };
        return ListItemComponent ? {
          ListItemComponent: renderProp
        } : {
          renderItem: renderProp
        };
      };
      this._memoizedRenderer = (0, memoizeOne.default)(this._renderer);
      this._checkProps(this.props);
      if (this.props.viewabilityConfigCallbackPairs) {
        this._virtualizedListPairs = this.props.viewabilityConfigCallbackPairs.map(pair => ({
          viewabilityConfig: pair.viewabilityConfig,
          onViewableItemsChanged: this._createOnViewableItemsChanged(pair.onViewableItemsChanged)
        }));
      } else if (this.props.onViewableItemsChanged) {
        this._virtualizedListPairs.push({
          /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
           * comment suppresses an error found when Flow v0.63 was deployed. To
           * see the error delete this comment and run Flow. */
          viewabilityConfig: this.props.viewabilityConfig,
          onViewableItemsChanged: this._createOnViewableItemsChanged(this.props.onViewableItemsChanged)
        });
      }
    }

    // $FlowFixMe[missing-local-annot]
    componentDidUpdate(prevProps) {
      (0, invariant.default)(prevProps.numColumns === this.props.numColumns, 'Changing numColumns on the fly is not supported. Change the key prop on FlatList when ' + 'changing the number of columns to force a fresh render of the component.');
      (0, invariant.default)(prevProps.onViewableItemsChanged === this.props.onViewableItemsChanged, 'Changing onViewableItemsChanged on the fly is not supported');
      (0, invariant.default)(!(0, deepDiffer.default)(prevProps.viewabilityConfig, this.props.viewabilityConfig), 'Changing viewabilityConfig on the fly is not supported');
      (0, invariant.default)(prevProps.viewabilityConfigCallbackPairs === this.props.viewabilityConfigCallbackPairs, 'Changing viewabilityConfigCallbackPairs on the fly is not supported');
      this._checkProps(this.props);
    }
    // $FlowFixMe[missing-local-annot]
    _checkProps(props) {
      var getItem = props.getItem,
        getItemCount = props.getItemCount,
        horizontal = props.horizontal,
        columnWrapperStyle = props.columnWrapperStyle,
        onViewableItemsChanged = props.onViewableItemsChanged,
        viewabilityConfigCallbackPairs = props.viewabilityConfigCallbackPairs;
      var numColumns = numColumnsOrDefault(this.props.numColumns);
      (0, invariant.default)(!getItem && !getItemCount, 'FlatList does not support custom data formats.');
      if (numColumns > 1) {
        (0, invariant.default)(!horizontal, 'numColumns does not support horizontal.');
      } else {
        (0, invariant.default)(!columnWrapperStyle, 'columnWrapperStyle not supported for single column lists');
      }
      (0, invariant.default)(!(onViewableItemsChanged && viewabilityConfigCallbackPairs), 'FlatList does not support setting both onViewableItemsChanged and ' + 'viewabilityConfigCallbackPairs.');
    }
    _pushMultiColumnViewable(arr, v) {
      var _this$props$keyExtrac2;
      var numColumns = numColumnsOrDefault(this.props.numColumns);
      var keyExtractor = (_this$props$keyExtrac2 = this.props.keyExtractor) !== null && _this$props$keyExtrac2 !== void 0 ? _this$props$keyExtrac2 : _VirtualizeUtils.keyExtractor;
      v.item.forEach((item, ii) => {
        (0, invariant.default)(v.index != null, 'Missing index!');
        var index = v.index * numColumns + ii;
        arr.push((0, _objectSpread.default)((0, _objectSpread.default)({}, v), {}, {
          item,
          key: keyExtractor(item, index),
          index
        }));
      });
    }
    _createOnViewableItemsChanged(onViewableItemsChanged
    // $FlowFixMe[missing-local-annot]
    ) {
      return info => {
        var numColumns = numColumnsOrDefault(this.props.numColumns);
        if (onViewableItemsChanged) {
          if (numColumns > 1) {
            var changed = [];
            var viewableItems = [];
            info.viewableItems.forEach(v => this._pushMultiColumnViewable(viewableItems, v));
            info.changed.forEach(v => this._pushMultiColumnViewable(changed, v));
            onViewableItemsChanged({
              viewableItems,
              changed
            });
          } else {
            onViewableItemsChanged(info);
          }
        }
      };
    }

    // $FlowFixMe[missing-local-annot]

    render() {
      var _this$props = this.props,
        numColumns = _this$props.numColumns,
        columnWrapperStyle = _this$props.columnWrapperStyle,
        _removeClippedSubviews = _this$props.removeClippedSubviews,
        _this$props$strictMod = _this$props.strictMode,
        strictMode = _this$props$strictMod === void 0 ? false : _this$props$strictMod,
        restProps = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      var renderer = strictMode ? this._memoizedRenderer : this._renderer;
      return (/*#__PURE__*/
        // $FlowFixMe[incompatible-exact] - `restProps` (`Props`) is inexact.
        React.createElement(VirtualizedList.default, (0, _extends.default)({}, restProps, {
          getItem: this._getItem,
          getItemCount: this._getItemCount,
          keyExtractor: this._keyExtractor,
          ref: this._captureRef,
          viewabilityConfigCallbackPairs: this._virtualizedListPairs,
          removeClippedSubviews: removeClippedSubviewsOrDefault(_removeClippedSubviews)
        }, renderer(this.props.ListItemComponent, this.props.renderItem, columnWrapperStyle, numColumns, this.props.extraData)))
      );
    }
  }
  var styles = StyleSheet.default.create({
    row: {
      flexDirection: 'row'
    }
  });
  var _default = FlatList;
},170,[42,43,37,110,55,171,14,17,9,172,190,192],"node_modules/react-native-web/dist/vendor/react-native/FlatList/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  /*
   * @returns {bool} true if different, false if equal
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var deepDiffer = function deepDiffer(one, two, maxDepth) {
    if (maxDepth === void 0) {
      maxDepth = -1;
    }
    if (maxDepth === 0) {
      return true;
    }
    if (one === two) {
      // Short circuit on identical object references instead of traversing them.
      return false;
    }
    if (typeof one === 'function' && typeof two === 'function') {
      // We consider all functions equal
      return false;
    }
    if (typeof one !== 'object' || one === null) {
      // Primitives can be directly compared
      return one !== two;
    }
    if (typeof two !== 'object' || two === null) {
      // We know they are different because the previous case would have triggered
      // otherwise.
      return true;
    }
    if (one.constructor !== two.constructor) {
      return true;
    }
    if (Array.isArray(one)) {
      // We know two is also an array because the constructors are equal
      var len = one.length;
      if (two.length !== len) {
        return true;
      }
      for (var ii = 0; ii < len; ii++) {
        if (deepDiffer(one[ii], two[ii], maxDepth - 1)) {
          return true;
        }
      }
    } else {
      for (var key in one) {
        if (deepDiffer(one[key], two[key], maxDepth - 1)) {
          return true;
        }
      }
      for (var twoKey in two) {
        // The only case we haven't checked yet is keys that are in two but aren't
        // in one, which means they are different.
        if (one[twoKey] === undefined && two[twoKey] !== undefined) {
          return true;
        }
      }
    }
    return false;
  };
  var _default = deepDiffer;
},171,[],"node_modules/react-native-web/dist/vendor/react-native/deepDiffer/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersCreateForOfIteratorHelperLoose = require(_dependencyMap[0], "@babel/runtime/helpers/createForOfIteratorHelperLoose");
  var _createForOfIteratorHelperLoose = _interopDefault(_babelRuntimeHelpersCreateForOfIteratorHelperLoose);
  var _babelRuntimeHelpersExtends = require(_dependencyMap[1], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[2], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _exportsRefreshControl = require(_dependencyMap[3], "../../../exports/RefreshControl");
  var RefreshControl = _interopDefault(_exportsRefreshControl);
  var _exportsScrollView = require(_dependencyMap[4], "../../../exports/ScrollView");
  var ScrollView = _interopDefault(_exportsScrollView);
  var _exportsView = require(_dependencyMap[5], "../../../exports/View");
  var View = _interopDefault(_exportsView);
  var _exportsStyleSheet = require(_dependencyMap[6], "../../../exports/StyleSheet");
  var StyleSheet = _interopDefault(_exportsStyleSheet);
  var _Batchinator = require(_dependencyMap[7], "../Batchinator");
  var Batchinator = _interopDefault(_Batchinator);
  var _UtilitiesClamp = require(_dependencyMap[8], "../Utilities/clamp");
  var clamp = _interopDefault(_UtilitiesClamp);
  var _infoLog = require(_dependencyMap[9], "../infoLog");
  var infoLog = _interopDefault(_infoLog);
  var _CellRenderMask = require(_dependencyMap[10], "./CellRenderMask");
  var _ChildListCollection = require(_dependencyMap[11], "./ChildListCollection");
  var ChildListCollection = _interopDefault(_ChildListCollection);
  var _FillRateHelper = require(_dependencyMap[12], "../FillRateHelper");
  var FillRateHelper = _interopDefault(_FillRateHelper);
  var _StateSafePureComponent = require(_dependencyMap[13], "./StateSafePureComponent");
  var StateSafePureComponent = _interopDefault(_StateSafePureComponent);
  var _ViewabilityHelper = require(_dependencyMap[14], "../ViewabilityHelper");
  var ViewabilityHelper = _interopDefault(_ViewabilityHelper);
  var _VirtualizedListCellRenderer = require(_dependencyMap[15], "./VirtualizedListCellRenderer");
  var CellRenderer = _interopDefault(_VirtualizedListCellRenderer);
  var _VirtualizedListContextJs = require(_dependencyMap[16], "./VirtualizedListContext.js");
  var _VirtualizeUtils = require(_dependencyMap[17], "../VirtualizeUtils");
  var _fbjsLibInvariant = require(_dependencyMap[18], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _nullthrows = require(_dependencyMap[19], "nullthrows");
  var nullthrows = _interopDefault(_nullthrows);
  var _react = require(_dependencyMap[20], "react");
  var React = _interopNamespace(_react);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var __DEV__ = process.env.NODE_ENV !== 'production';
  var ON_EDGE_REACHED_EPSILON = 0.001;
  var _usedIndexForKey = false;
  var _keylessItemComponentName = '';
  /**
   * Default Props Helper Functions
   * Use the following helper functions for default values
   */

  // horizontalOrDefault(this.props.horizontal)
  function horizontalOrDefault(horizontal) {
    return horizontal !== null && horizontal !== void 0 ? horizontal : false;
  }

  // initialNumToRenderOrDefault(this.props.initialNumToRender)
  function initialNumToRenderOrDefault(initialNumToRender) {
    return initialNumToRender !== null && initialNumToRender !== void 0 ? initialNumToRender : 10;
  }

  // maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch)
  function maxToRenderPerBatchOrDefault(maxToRenderPerBatch) {
    return maxToRenderPerBatch !== null && maxToRenderPerBatch !== void 0 ? maxToRenderPerBatch : 10;
  }

  // onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold)
  function onStartReachedThresholdOrDefault(onStartReachedThreshold) {
    return onStartReachedThreshold !== null && onStartReachedThreshold !== void 0 ? onStartReachedThreshold : 2;
  }

  // onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold)
  function onEndReachedThresholdOrDefault(onEndReachedThreshold) {
    return onEndReachedThreshold !== null && onEndReachedThreshold !== void 0 ? onEndReachedThreshold : 2;
  }

  // getScrollingThreshold(visibleLength, onEndReachedThreshold)
  function getScrollingThreshold(threshold, visibleLength) {
    return threshold * visibleLength / 2;
  }

  // scrollEventThrottleOrDefault(this.props.scrollEventThrottle)
  function scrollEventThrottleOrDefault(scrollEventThrottle) {
    return scrollEventThrottle !== null && scrollEventThrottle !== void 0 ? scrollEventThrottle : 50;
  }

  // windowSizeOrDefault(this.props.windowSize)
  function windowSizeOrDefault(windowSize) {
    return windowSize !== null && windowSize !== void 0 ? windowSize : 21;
  }
  function findLastWhere(arr, predicate) {
    for (var i = arr.length - 1; i >= 0; i--) {
      if (predicate(arr[i])) {
        return arr[i];
      }
    }
    return null;
  }

  /**
   * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)
   * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better
   * documented. In general, this should only really be used if you need more flexibility than
   * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.
   *
   * Virtualization massively improves memory consumption and performance of large lists by
   * maintaining a finite render window of active items and replacing all items outside of the render
   * window with appropriately sized blank space. The window adapts to scrolling behavior, and items
   * are rendered incrementally with low-pri (after any running interactions) if they are far from the
   * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.
   *
   * Some caveats:
   *
   * - Internal state is not preserved when content scrolls out of the render window. Make sure all
   *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
   * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
   *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
   *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
   *   changes. This includes the `data` prop and parent component state.
   * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
   *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see
   *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
   *   and we are working on improving it behind the scenes.
   * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.
   *   Alternatively, you can provide a custom `keyExtractor` prop.
   * - As an effort to remove defaultProps, use helper functions when referencing certain props
   *
   */
  class VirtualizedList extends StateSafePureComponent.default {
    // scrollToEnd may be janky without getItemLayout prop
    scrollToEnd(params) {
      var animated = params ? params.animated : true;
      var veryLast = this.props.getItemCount(this.props.data) - 1;
      if (veryLast < 0) {
        return;
      }
      var frame = this.__getFrameMetricsApprox(veryLast, this.props);
      var offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);
      if (this._scrollRef == null) {
        return;
      }
      if (this._scrollRef.scrollTo == null) {
        console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');
        return;
      }
      this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
        x: offset,
        animated
      } : {
        y: offset,
        animated
      });
    }

    // scrollToIndex may be janky without getItemLayout prop
    scrollToIndex(params) {
      var _this$props = this.props,
        data = _this$props.data,
        horizontal = _this$props.horizontal,
        getItemCount = _this$props.getItemCount,
        getItemLayout = _this$props.getItemLayout,
        onScrollToIndexFailed = _this$props.onScrollToIndexFailed;
      var animated = params.animated,
        index = params.index,
        viewOffset = params.viewOffset,
        viewPosition = params.viewPosition;
      (0, invariant.default)(index >= 0, "scrollToIndex out of range: requested index " + index + " but minimum is 0");
      (0, invariant.default)(getItemCount(data) >= 1, "scrollToIndex out of range: item length " + getItemCount(data) + " but minimum is 1");
      (0, invariant.default)(index < getItemCount(data), "scrollToIndex out of range: requested index " + index + " is out of 0 to " + (getItemCount(data) - 1));
      if (!getItemLayout && index > this._highestMeasuredFrameIndex) {
        (0, invariant.default)(!!onScrollToIndexFailed, 'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' + 'otherwise there is no way to know the location of offscreen indices or handle failures.');
        onScrollToIndexFailed({
          averageItemLength: this._averageCellLength,
          highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
          index
        });
        return;
      }
      var frame = this.__getFrameMetricsApprox(Math.floor(index), this.props);
      var offset = Math.max(0, this._getOffsetApprox(index, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);
      if (this._scrollRef == null) {
        return;
      }
      if (this._scrollRef.scrollTo == null) {
        console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');
        return;
      }
      this._scrollRef.scrollTo(horizontal ? {
        x: offset,
        animated
      } : {
        y: offset,
        animated
      });
    }

    // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -
    // use scrollToIndex instead if possible.
    scrollToItem(params) {
      var item = params.item;
      var _this$props2 = this.props,
        data = _this$props2.data,
        getItem = _this$props2.getItem,
        getItemCount = _this$props2.getItemCount;
      var itemCount = getItemCount(data);
      for (var _index = 0; _index < itemCount; _index++) {
        if (getItem(data, _index) === item) {
          this.scrollToIndex((0, _objectSpread.default)((0, _objectSpread.default)({}, params), {}, {
            index: _index
          }));
          break;
        }
      }
    }

    /**
     * Scroll to a specific content pixel offset in the list.
     *
     * Param `offset` expects the offset to scroll to.
     * In case of `horizontal` is true, the offset is the x-value,
     * in any other case the offset is the y-value.
     *
     * Param `animated` (`true` by default) defines whether the list
     * should do an animation while scrolling.
     */
    scrollToOffset(params) {
      var animated = params.animated,
        offset = params.offset;
      if (this._scrollRef == null) {
        return;
      }
      if (this._scrollRef.scrollTo == null) {
        console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');
        return;
      }
      this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
        x: offset,
        animated
      } : {
        y: offset,
        animated
      });
    }
    recordInteraction() {
      this._nestedChildLists.forEach(childList => {
        childList.recordInteraction();
      });
      this._viewabilityTuples.forEach(t => {
        t.viewabilityHelper.recordInteraction();
      });
      this._updateViewableItems(this.props, this.state.cellsAroundViewport);
    }
    flashScrollIndicators() {
      if (this._scrollRef == null) {
        return;
      }
      this._scrollRef.flashScrollIndicators();
    }

    /**
     * Provides a handle to the underlying scroll responder.
     * Note that `this._scrollRef` might not be a `ScrollView`, so we
     * need to check that it responds to `getScrollResponder` before calling it.
     */
    getScrollResponder() {
      if (this._scrollRef && this._scrollRef.getScrollResponder) {
        return this._scrollRef.getScrollResponder();
      }
    }
    getScrollableNode() {
      if (this._scrollRef && this._scrollRef.getScrollableNode) {
        return this._scrollRef.getScrollableNode();
      } else {
        return this._scrollRef;
      }
    }
    getScrollRef() {
      if (this._scrollRef && this._scrollRef.getScrollRef) {
        return this._scrollRef.getScrollRef();
      } else {
        return this._scrollRef;
      }
    }
    _getCellKey() {
      var _this$context;
      return ((_this$context = this.context) == null ? void 0 : _this$context.cellKey) || 'rootList';
    }

    // $FlowFixMe[missing-local-annot]

    hasMore() {
      return this._hasMore;
    }

    // $FlowFixMe[missing-local-annot]

    // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.

    constructor(_props) {
      var _this$props$updateCel;
      super(_props);
      this._getScrollMetrics = () => {
        return this._scrollMetrics;
      };
      this._getOutermostParentListRef = () => {
        if (this._isNestedWithSameOrientation()) {
          return this.context.getOutermostParentListRef();
        } else {
          return this;
        }
      };
      this._registerAsNestedChild = childList => {
        this._nestedChildLists.add(childList.ref, childList.cellKey);
        if (this._hasInteracted) {
          childList.ref.recordInteraction();
        }
      };
      this._unregisterAsNestedChild = childList => {
        this._nestedChildLists.remove(childList.ref);
      };
      this._onUpdateSeparators = (keys, newProps) => {
        keys.forEach(key => {
          var ref = key != null && this._cellRefs[key];
          ref && ref.updateSeparatorProps(newProps);
        });
      };
      this._getSpacerKey = isVertical => isVertical ? 'height' : 'width';
      this._averageCellLength = 0;
      this._cellRefs = {};
      this._frames = {};
      this._footerLength = 0;
      this._hasTriggeredInitialScrollToIndex = false;
      this._hasInteracted = false;
      this._hasMore = false;
      this._hasWarned = {};
      this._headerLength = 0;
      this._hiPriInProgress = false;
      this._highestMeasuredFrameIndex = 0;
      this._indicesToKeys = new Map();
      this._lastFocusedCellKey = null;
      this._nestedChildLists = new ChildListCollection.default();
      this._offsetFromParentVirtualizedList = 0;
      this._prevParentOffset = 0;
      this._scrollMetrics = {
        contentLength: 0,
        dOffset: 0,
        dt: 10,
        offset: 0,
        timestamp: 0,
        velocity: 0,
        visibleLength: 0,
        zoomScale: 1
      };
      this._scrollRef = null;
      this._sentStartForContentLength = 0;
      this._sentEndForContentLength = 0;
      this._totalCellLength = 0;
      this._totalCellsMeasured = 0;
      this._viewabilityTuples = [];
      this._captureScrollRef = ref => {
        this._scrollRef = ref;
      };
      this._defaultRenderScrollComponent = props => {
        var onRefresh = props.onRefresh;
        if (this._isNestedWithSameOrientation()) {
          // $FlowFixMe[prop-missing] - Typing ReactNativeComponent revealed errors
          return /*#__PURE__*/React.createElement(View.default, props);
        } else if (onRefresh) {
          var _props$refreshing;
          (0, invariant.default)(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify((_props$refreshing = props.refreshing) !== null && _props$refreshing !== void 0 ? _props$refreshing : 'undefined') + '`');
          return (/*#__PURE__*/
            // $FlowFixMe[prop-missing] Invalid prop usage
            // $FlowFixMe[incompatible-use]
            React.createElement(ScrollView.default, (0, _extends.default)({}, props, {
              refreshControl: props.refreshControl == null ? /*#__PURE__*/React.createElement(RefreshControl.default // $FlowFixMe[incompatible-type]
              , {
                refreshing: props.refreshing,
                onRefresh: onRefresh,
                progressViewOffset: props.progressViewOffset
              }) : props.refreshControl
            }))
          );
        } else {
          // $FlowFixMe[prop-missing] Invalid prop usage
          // $FlowFixMe[incompatible-use]
          return /*#__PURE__*/React.createElement(ScrollView.default, props);
        }
      };
      this._onCellLayout = (e, cellKey, index) => {
        var layout = e.nativeEvent.layout;
        var next = {
          offset: this._selectOffset(layout),
          length: this._selectLength(layout),
          index,
          inLayout: true
        };
        var curr = this._frames[cellKey];
        if (!curr || next.offset !== curr.offset || next.length !== curr.length || index !== curr.index) {
          this._totalCellLength += next.length - (curr ? curr.length : 0);
          this._totalCellsMeasured += curr ? 0 : 1;
          this._averageCellLength = this._totalCellLength / this._totalCellsMeasured;
          this._frames[cellKey] = next;
          this._highestMeasuredFrameIndex = Math.max(this._highestMeasuredFrameIndex, index);
          this._scheduleCellsToRenderUpdate();
        } else {
          this._frames[cellKey].inLayout = true;
        }
        this._triggerRemeasureForChildListsInCell(cellKey);
        this._computeBlankness();
        this._updateViewableItems(this.props, this.state.cellsAroundViewport);
      };
      this._onCellUnmount = cellKey => {
        delete this._cellRefs[cellKey];
        var curr = this._frames[cellKey];
        if (curr) {
          this._frames[cellKey] = (0, _objectSpread.default)((0, _objectSpread.default)({}, curr), {}, {
            inLayout: false
          });
        }
      };
      this._onLayout = e => {
        if (this._isNestedWithSameOrientation()) {
          // Need to adjust our scroll metrics to be relative to our containing
          // VirtualizedList before we can make claims about list item viewability
          this.measureLayoutRelativeToContainingList();
        } else {
          this._scrollMetrics.visibleLength = this._selectLength(e.nativeEvent.layout);
        }
        this.props.onLayout && this.props.onLayout(e);
        this._scheduleCellsToRenderUpdate();
        this._maybeCallOnEdgeReached();
      };
      this._onLayoutEmpty = e => {
        this.props.onLayout && this.props.onLayout(e);
      };
      this._onLayoutFooter = e => {
        this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());
        this._footerLength = this._selectLength(e.nativeEvent.layout);
      };
      this._onLayoutHeader = e => {
        this._headerLength = this._selectLength(e.nativeEvent.layout);
      };
      this._onContentSizeChange = (width, height) => {
        if (width > 0 && height > 0 && this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 && !this._hasTriggeredInitialScrollToIndex) {
          if (this.props.contentOffset == null) {
            if (this.props.initialScrollIndex < this.props.getItemCount(this.props.data)) {
              this.scrollToIndex({
                animated: false,
                index: (0, nullthrows.default)(this.props.initialScrollIndex)
              });
            } else {
              this.scrollToEnd({
                animated: false
              });
            }
          }
          this._hasTriggeredInitialScrollToIndex = true;
        }
        if (this.props.onContentSizeChange) {
          this.props.onContentSizeChange(width, height);
        }
        this._scrollMetrics.contentLength = this._selectLength({
          height,
          width
        });
        this._scheduleCellsToRenderUpdate();
        this._maybeCallOnEdgeReached();
      };
      this._convertParentScrollMetrics = metrics => {
        // Offset of the top of the nested list relative to the top of its parent's viewport
        var offset = metrics.offset - this._offsetFromParentVirtualizedList;
        // Child's visible length is the same as its parent's
        var visibleLength = metrics.visibleLength;
        var dOffset = offset - this._scrollMetrics.offset;
        var contentLength = this._scrollMetrics.contentLength;
        return {
          visibleLength,
          contentLength,
          offset,
          dOffset
        };
      };
      this._onScroll = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onScroll(e);
        });
        if (this.props.onScroll) {
          this.props.onScroll(e);
        }
        var timestamp = e.timeStamp;
        var visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);
        var contentLength = this._selectLength(e.nativeEvent.contentSize);
        var offset = this._selectOffset(e.nativeEvent.contentOffset);
        var dOffset = offset - this._scrollMetrics.offset;
        if (this._isNestedWithSameOrientation()) {
          if (this._scrollMetrics.contentLength === 0) {
            // Ignore scroll events until onLayout has been called and we
            // know our offset from our offset from our parent
            return;
          }
          var _this$_convertParentS = this._convertParentScrollMetrics({
            visibleLength,
            offset
          });
          visibleLength = _this$_convertParentS.visibleLength;
          contentLength = _this$_convertParentS.contentLength;
          offset = _this$_convertParentS.offset;
          dOffset = _this$_convertParentS.dOffset;
        }
        var dt = this._scrollMetrics.timestamp ? Math.max(1, timestamp - this._scrollMetrics.timestamp) : 1;
        var velocity = dOffset / dt;
        if (dt > 500 && this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !this._hasWarned.perf) {
          (0, infoLog.default)('VirtualizedList: You have a large list that is slow to update - make sure your ' + 'renderItem function renders components that follow React performance best practices ' + 'like PureComponent, shouldComponentUpdate, etc.', {
            dt,
            prevDt: this._scrollMetrics.dt,
            contentLength
          });
          this._hasWarned.perf = true;
        }

        // For invalid negative values (w/ RTL), set this to 1.
        var zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;
        this._scrollMetrics = {
          contentLength,
          dt,
          dOffset,
          offset,
          timestamp,
          velocity,
          visibleLength,
          zoomScale
        };
        this._updateViewableItems(this.props, this.state.cellsAroundViewport);
        if (!this.props) {
          return;
        }
        this._maybeCallOnEdgeReached();
        if (velocity !== 0) {
          this._fillRateHelper.activate();
        }
        this._computeBlankness();
        this._scheduleCellsToRenderUpdate();
      };
      this._onScrollBeginDrag = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onScrollBeginDrag(e);
        });
        this._viewabilityTuples.forEach(tuple => {
          tuple.viewabilityHelper.recordInteraction();
        });
        this._hasInteracted = true;
        this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
      };
      this._onScrollEndDrag = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onScrollEndDrag(e);
        });
        var velocity = e.nativeEvent.velocity;
        if (velocity) {
          this._scrollMetrics.velocity = this._selectOffset(velocity);
        }
        this._computeBlankness();
        this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
      };
      this._onMomentumScrollBegin = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onMomentumScrollBegin(e);
        });
        this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
      };
      this._onMomentumScrollEnd = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onMomentumScrollEnd(e);
        });
        this._scrollMetrics.velocity = 0;
        this._computeBlankness();
        this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
      };
      this._updateCellsToRender = () => {
        this._updateViewableItems(this.props, this.state.cellsAroundViewport);
        this.setState((state, props) => {
          var cellsAroundViewport = this._adjustCellsAroundViewport(props, state.cellsAroundViewport);
          var renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, this._getNonViewportRenderRegions(props));
          if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {
            return null;
          }
          return {
            cellsAroundViewport,
            renderMask
          };
        });
      };
      this._createViewToken = (index, isViewable, props
      // $FlowFixMe[missing-local-annot]
      ) => {
        var data = props.data,
          getItem = props.getItem;
        var item = getItem(data, index);
        return {
          index,
          item,
          key: this._keyExtractor(item, index, props),
          isViewable
        };
      };
      this._getOffsetApprox = (index, props) => {
        if (Number.isInteger(index)) {
          return this.__getFrameMetricsApprox(index, props).offset;
        } else {
          var frameMetrics = this.__getFrameMetricsApprox(Math.floor(index), props);
          var remainder = index - Math.floor(index);
          return frameMetrics.offset + remainder * frameMetrics.length;
        }
      };
      this.__getFrameMetricsApprox = (index, props) => {
        var frame = this._getFrameMetrics(index, props);
        if (frame && frame.index === index) {
          // check for invalid frames due to row re-ordering
          return frame;
        } else {
          var data = props.data,
            getItemCount = props.getItemCount,
            getItemLayout = props.getItemLayout;
          (0, invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
          (0, invariant.default)(!getItemLayout, 'Should not have to estimate frames when a measurement metrics function is provided');
          return {
            length: this._averageCellLength,
            offset: this._averageCellLength * index
          };
        }
      };
      this._getFrameMetrics = (index, props) => {
        var data = props.data,
          getItem = props.getItem,
          getItemCount = props.getItemCount,
          getItemLayout = props.getItemLayout;
        (0, invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
        var item = getItem(data, index);
        var frame = this._frames[this._keyExtractor(item, index, props)];
        if (!frame || frame.index !== index) {
          if (getItemLayout) {
            /* $FlowFixMe[prop-missing] (>=0.63.0 site=react_native_fb) This comment
             * suppresses an error found when Flow v0.63 was deployed. To see the error
             * delete this comment and run Flow. */
            return getItemLayout(data, index);
          }
        }
        return frame;
      };
      this._getNonViewportRenderRegions = props => {
        // Keep a viewport's worth of content around the last focused cell to allow
        // random navigation around it without any blanking. E.g. tabbing from one
        // focused item out of viewport to another.
        if (!(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])) {
          return [];
        }
        var lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];
        var focusedCellIndex = lastFocusedCellRenderer.props.index;
        var itemCount = props.getItemCount(props.data);

        // The last cell we rendered may be at a new index. Bail if we don't know
        // where it is.
        if (focusedCellIndex >= itemCount || this._keyExtractor(props.getItem(props.data, focusedCellIndex), focusedCellIndex, props) !== this._lastFocusedCellKey) {
          return [];
        }
        var first = focusedCellIndex;
        var heightOfCellsBeforeFocused = 0;
        for (var i = first - 1; i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength; i--) {
          first--;
          heightOfCellsBeforeFocused += this.__getFrameMetricsApprox(i, props).length;
        }
        var last = focusedCellIndex;
        var heightOfCellsAfterFocused = 0;
        for (var _i = last + 1; _i < itemCount && heightOfCellsAfterFocused < this._scrollMetrics.visibleLength; _i++) {
          last++;
          heightOfCellsAfterFocused += this.__getFrameMetricsApprox(_i, props).length;
        }
        return [{
          first,
          last
        }];
      };
      this._checkProps(_props);
      this._fillRateHelper = new FillRateHelper.default(this._getFrameMetrics);
      this._updateCellsToRenderBatcher = new Batchinator.default(this._updateCellsToRender, (_this$props$updateCel = this.props.updateCellsBatchingPeriod) !== null && _this$props$updateCel !== void 0 ? _this$props$updateCel : 50);
      if (this.props.viewabilityConfigCallbackPairs) {
        this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(pair => ({
          viewabilityHelper: new ViewabilityHelper.default(pair.viewabilityConfig),
          onViewableItemsChanged: pair.onViewableItemsChanged
        }));
      } else {
        var _this$props3 = this.props,
          onViewableItemsChanged = _this$props3.onViewableItemsChanged,
          viewabilityConfig = _this$props3.viewabilityConfig;
        if (onViewableItemsChanged) {
          this._viewabilityTuples.push({
            viewabilityHelper: new ViewabilityHelper.default(viewabilityConfig),
            onViewableItemsChanged: onViewableItemsChanged
          });
        }
      }
      var initialRenderRegion = VirtualizedList._initialRenderRegion(_props);
      this.state = {
        cellsAroundViewport: initialRenderRegion,
        renderMask: VirtualizedList._createRenderMask(_props, initialRenderRegion)
      };

      // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
      // For issue https://github.com/necolas/react-native-web/issues/995
      this.invertedWheelEventHandler = ev => {
        var scrollOffset = this.props.horizontal ? ev.target.scrollLeft : ev.target.scrollTop;
        var scrollLength = this.props.horizontal ? ev.target.scrollWidth : ev.target.scrollHeight;
        var clientLength = this.props.horizontal ? ev.target.clientWidth : ev.target.clientHeight;
        var isEventTargetScrollable = scrollLength > clientLength;
        var delta = this.props.horizontal ? ev.deltaX || ev.wheelDeltaX : ev.deltaY || ev.wheelDeltaY;
        var leftoverDelta = delta;
        if (isEventTargetScrollable) {
          leftoverDelta = delta < 0 ? Math.min(delta + scrollOffset, 0) : Math.max(delta - (scrollLength - clientLength - scrollOffset), 0);
        }
        var targetDelta = delta - leftoverDelta;
        if (this.props.inverted && this._scrollRef && this._scrollRef.getScrollableNode) {
          var node = this._scrollRef.getScrollableNode();
          if (this.props.horizontal) {
            ev.target.scrollLeft += targetDelta;
            var nextScrollLeft = node.scrollLeft - leftoverDelta;
            node.scrollLeft = !this.props.getItemLayout ? Math.min(nextScrollLeft, this._totalCellLength) : nextScrollLeft;
          } else {
            ev.target.scrollTop += targetDelta;
            var nextScrollTop = node.scrollTop - leftoverDelta;
            node.scrollTop = !this.props.getItemLayout ? Math.min(nextScrollTop, this._totalCellLength) : nextScrollTop;
          }
          ev.preventDefault();
        }
      };
    }
    _checkProps(props) {
      var onScroll = props.onScroll,
        windowSize = props.windowSize,
        getItemCount = props.getItemCount,
        data = props.data,
        initialScrollIndex = props.initialScrollIndex;
      (0, invariant.default)(
      // $FlowFixMe[prop-missing]
      !onScroll || !onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');
      (0, invariant.default)(windowSizeOrDefault(windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');
      (0, invariant.default)(getItemCount, 'VirtualizedList: The "getItemCount" prop must be provided');
      var itemCount = getItemCount(data);
      if (initialScrollIndex != null && !this._hasTriggeredInitialScrollToIndex && (initialScrollIndex < 0 || itemCount > 0 && initialScrollIndex >= itemCount) && !this._hasWarned.initialScrollIndex) {
        console.warn("initialScrollIndex \"" + initialScrollIndex + "\" is not valid (list has " + itemCount + " items)");
        this._hasWarned.initialScrollIndex = true;
      }
      if (__DEV__ && !this._hasWarned.flexWrap) {
        // $FlowFixMe[underconstrained-implicit-instantiation]
        var flatStyles = StyleSheet.default.flatten(this.props.contentContainerStyle);
        if (flatStyles != null && flatStyles.flexWrap === 'wrap') {
          console.warn('`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' + 'Consider using `numColumns` with `FlatList` instead.');
          this._hasWarned.flexWrap = true;
        }
      }
    }
    static _createRenderMask(props, cellsAroundViewport, additionalRegions) {
      var itemCount = props.getItemCount(props.data);
      (0, invariant.default)(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, "Invalid cells around viewport \"[" + cellsAroundViewport.first + ", " + cellsAroundViewport.last + "]\" was passed to VirtualizedList._createRenderMask");
      var renderMask = new _CellRenderMask.CellRenderMask(itemCount);
      if (itemCount > 0) {
        var allRegions = [cellsAroundViewport, ...(additionalRegions !== null && additionalRegions !== void 0 ? additionalRegions : [])];
        for (var _i2 = 0, _allRegions = allRegions; _i2 < _allRegions.length; _i2++) {
          var region = _allRegions[_i2];
          renderMask.addCells(region);
        }

        // The initially rendered cells are retained as part of the
        // "scroll-to-top" optimization
        if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {
          var initialRegion = VirtualizedList._initialRenderRegion(props);
          renderMask.addCells(initialRegion);
        }

        // The layout coordinates of sticker headers may be off-screen while the
        // actual header is on-screen. Keep the most recent before the viewport
        // rendered, even if its layout coordinates are not in viewport.
        var stickyIndicesSet = new Set(props.stickyHeaderIndices);
        VirtualizedList._ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellsAroundViewport.first);
      }
      return renderMask;
    }
    static _initialRenderRegion(props) {
      var _props$initialScrollI;
      var itemCount = props.getItemCount(props.data);
      var firstCellIndex = Math.max(0, Math.min(itemCount - 1, Math.floor((_props$initialScrollI = props.initialScrollIndex) !== null && _props$initialScrollI !== void 0 ? _props$initialScrollI : 0)));
      var lastCellIndex = Math.min(itemCount, firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender)) - 1;
      return {
        first: firstCellIndex,
        last: lastCellIndex
      };
    }
    static _ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellIdx) {
      var stickyOffset = props.ListHeaderComponent ? 1 : 0;
      for (var itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {
        if (stickyIndicesSet.has(itemIdx + stickyOffset)) {
          renderMask.addCells({
            first: itemIdx,
            last: itemIdx
          });
          break;
        }
      }
    }
    _adjustCellsAroundViewport(props, cellsAroundViewport) {
      var data = props.data,
        getItemCount = props.getItemCount;
      var onEndReachedThreshold = onEndReachedThresholdOrDefault(props.onEndReachedThreshold);
      var _this$_scrollMetrics = this._scrollMetrics,
        contentLength = _this$_scrollMetrics.contentLength,
        offset = _this$_scrollMetrics.offset,
        visibleLength = _this$_scrollMetrics.visibleLength;
      var distanceFromEnd = contentLength - visibleLength - offset;

      // Wait until the scroll view metrics have been set up. And until then,
      // we will trust the initialNumToRender suggestion
      if (visibleLength <= 0 || contentLength <= 0) {
        return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
      }
      var newCellsAroundViewport;
      if (props.disableVirtualization) {
        var renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch) : 0;
        newCellsAroundViewport = {
          first: 0,
          last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)
        };
      } else {
        // If we have a non-zero initialScrollIndex and run this before we've scrolled,
        // we'll wipe out the initialNumToRender rendered elements starting at initialScrollIndex.
        // So let's wait until we've scrolled the view to the right place. And until then,
        // we will trust the initialScrollIndex suggestion.

        // Thus, we want to recalculate the windowed render limits if any of the following hold:
        // - initialScrollIndex is undefined or is 0
        // - initialScrollIndex > 0 AND scrolling is complete
        // - initialScrollIndex > 0 AND the end of the list is visible (this handles the case
        //   where the list is shorter than the visible area)
        if (props.initialScrollIndex && !this._scrollMetrics.offset && Math.abs(distanceFromEnd) >= Number.EPSILON) {
          return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
        }
        newCellsAroundViewport = (0, _VirtualizeUtils.computeWindowedRenderLimits)(props, maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch), windowSizeOrDefault(props.windowSize), cellsAroundViewport, this.__getFrameMetricsApprox, this._scrollMetrics);
        (0, invariant.default)(newCellsAroundViewport.last < getItemCount(data), 'computeWindowedRenderLimits() should return range in-bounds');
      }
      if (this._nestedChildLists.size() > 0) {
        // If some cell in the new state has a child list in it, we should only render
        // up through that item, so that we give that list a chance to render.
        // Otherwise there's churn from multiple child lists mounting and un-mounting
        // their items.

        // Will this prevent rendering if the nested list doesn't realize the end?
        var childIdx = this._findFirstChildWithMore(newCellsAroundViewport.first, newCellsAroundViewport.last);
        newCellsAroundViewport.last = childIdx !== null && childIdx !== void 0 ? childIdx : newCellsAroundViewport.last;
      }
      return newCellsAroundViewport;
    }
    _findFirstChildWithMore(first, last) {
      for (var ii = first; ii <= last; ii++) {
        var cellKeyForIndex = this._indicesToKeys.get(ii);
        if (cellKeyForIndex != null && this._nestedChildLists.anyInCell(cellKeyForIndex, childList => childList.hasMore())) {
          return ii;
        }
      }
      return null;
    }
    componentDidMount() {
      if (this._isNestedWithSameOrientation()) {
        this.context.registerAsNestedChild({
          ref: this,
          cellKey: this.context.cellKey
        });
      }

      // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
      this.setupWebWheelHandler();
    }
    componentWillUnmount() {
      if (this._isNestedWithSameOrientation()) {
        this.context.unregisterAsNestedChild({
          ref: this
        });
      }
      this._updateCellsToRenderBatcher.dispose({
        abort: true
      });
      this._viewabilityTuples.forEach(tuple => {
        tuple.viewabilityHelper.dispose();
      });
      this._fillRateHelper.deactivateAndFlush();

      // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
      this.teardownWebWheelHandler();
    }

    // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
    setupWebWheelHandler() {
      if (this._scrollRef && this._scrollRef.getScrollableNode) {
        this._scrollRef.getScrollableNode().addEventListener('wheel', this.invertedWheelEventHandler);
      } else {
        setTimeout(() => this.setupWebWheelHandler(), 50);
        return;
      }
    }

    // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
    teardownWebWheelHandler() {
      if (this._scrollRef && this._scrollRef.getScrollableNode) {
        this._scrollRef.getScrollableNode().removeEventListener('wheel', this.invertedWheelEventHandler);
      }
    }
    static getDerivedStateFromProps(newProps, prevState) {
      // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make
      // sure we're rendering a reasonable range here.
      var itemCount = newProps.getItemCount(newProps.data);
      if (itemCount === prevState.renderMask.numCells()) {
        return prevState;
      }
      var constrainedCells = VirtualizedList._constrainToItemCount(prevState.cellsAroundViewport, newProps);
      return {
        cellsAroundViewport: constrainedCells,
        renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells)
      };
    }
    _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
      var _this = this;
      var _this$props4 = this.props,
        CellRendererComponent = _this$props4.CellRendererComponent,
        ItemSeparatorComponent = _this$props4.ItemSeparatorComponent,
        ListHeaderComponent = _this$props4.ListHeaderComponent,
        ListItemComponent = _this$props4.ListItemComponent,
        data = _this$props4.data,
        debug = _this$props4.debug,
        getItem = _this$props4.getItem,
        getItemCount = _this$props4.getItemCount,
        getItemLayout = _this$props4.getItemLayout,
        horizontal = _this$props4.horizontal,
        renderItem = _this$props4.renderItem;
      var stickyOffset = ListHeaderComponent ? 1 : 0;
      var end = getItemCount(data) - 1;
      var prevCellKey;
      last = Math.min(end, last);
      var _loop = function _loop() {
        var item = getItem(data, ii);
        var key = _this._keyExtractor(item, ii, _this.props);
        _this._indicesToKeys.set(ii, key);
        if (stickyIndicesFromProps.has(ii + stickyOffset)) {
          stickyHeaderIndices.push(cells.length);
        }
        var shouldListenForLayout = getItemLayout == null || debug || _this._fillRateHelper.enabled();
        cells.push(/*#__PURE__*/React.createElement(CellRenderer.default, (0, _extends.default)({
          CellRendererComponent: CellRendererComponent,
          ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,
          ListItemComponent: ListItemComponent,
          cellKey: key,
          horizontal: horizontal,
          index: ii,
          inversionStyle: inversionStyle,
          item: item,
          key: key,
          prevCellKey: prevCellKey,
          onUpdateSeparators: _this._onUpdateSeparators,
          onCellFocusCapture: e => _this._onCellFocusCapture(key),
          onUnmount: _this._onCellUnmount,
          ref: _ref => {
            _this._cellRefs[key] = _ref;
          },
          renderItem: renderItem
        }, shouldListenForLayout && {
          onCellLayout: _this._onCellLayout
        })));
        prevCellKey = key;
      };
      for (var ii = first; ii <= last; ii++) {
        _loop();
      }
    }
    static _constrainToItemCount(cells, props) {
      var itemCount = props.getItemCount(props.data);
      var last = Math.min(itemCount - 1, cells.last);
      var maxToRenderPerBatch = maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch);
      return {
        first: (0, clamp.default)(0, itemCount - 1 - maxToRenderPerBatch, cells.first),
        last
      };
    }
    _isNestedWithSameOrientation() {
      var nestedContext = this.context;
      return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));
    }
    _keyExtractor(item, index, props
    // $FlowFixMe[missing-local-annot]
    ) {
      if (props.keyExtractor != null) {
        return props.keyExtractor(item, index);
      }
      var key = (0, _VirtualizeUtils.keyExtractor)(item, index);
      if (key === String(index)) {
        _usedIndexForKey = true;
        if (item.type && item.type.displayName) {
          _keylessItemComponentName = item.type.displayName;
        }
      }
      return key;
    }
    render() {
      this._checkProps(this.props);
      var _this$props5 = this.props,
        ListEmptyComponent = _this$props5.ListEmptyComponent,
        ListFooterComponent = _this$props5.ListFooterComponent,
        ListHeaderComponent = _this$props5.ListHeaderComponent;
      var _this$props6 = this.props,
        data = _this$props6.data,
        horizontal = _this$props6.horizontal;
      var inversionStyle = this.props.inverted ? horizontalOrDefault(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;
      var cells = [];
      var stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);
      var stickyHeaderIndices = [];

      // 1. Add cell for ListHeaderComponent
      if (ListHeaderComponent) {
        if (stickyIndicesFromProps.has(0)) {
          stickyHeaderIndices.push(0);
        }
        var _element = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ListHeaderComponent) ? ListHeaderComponent : /*#__PURE__*/
        // $FlowFixMe[not-a-component]
        // $FlowFixMe[incompatible-type-arg]
        React.createElement(ListHeaderComponent, null);
        cells.push(/*#__PURE__*/React.createElement(_VirtualizedListContextJs.VirtualizedListCellContextProvider, {
          cellKey: this._getCellKey() + '-header',
          key: "$header"
        }, /*#__PURE__*/React.createElement(View.default, {
          onLayout: this._onLayoutHeader,
          style: [inversionStyle, this.props.ListHeaderComponentStyle]
        },
        // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
        _element)));
      }

      // 2a. Add a cell for ListEmptyComponent if applicable
      var itemCount = this.props.getItemCount(data);
      if (itemCount === 0 && ListEmptyComponent) {
        var _element2 = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ListEmptyComponent) ? ListEmptyComponent : /*#__PURE__*/
        // $FlowFixMe[not-a-component]
        // $FlowFixMe[incompatible-type-arg]
        React.createElement(ListEmptyComponent, null);
        cells.push(/*#__PURE__*/React.createElement(_VirtualizedListContextJs.VirtualizedListCellContextProvider, {
          cellKey: this._getCellKey() + '-empty',
          key: "$empty"
        }, /*#__PURE__*/React.cloneElement(_element2, {
          onLayout: event => {
            this._onLayoutEmpty(event);
            if (_element2.props.onLayout) {
              _element2.props.onLayout(event);
            }
          },
          style: [inversionStyle, _element2.props.style]
        })));
      }

      // 2b. Add cells and spacers for each item
      if (itemCount > 0) {
        _usedIndexForKey = false;
        _keylessItemComponentName = '';
        var spacerKey = this._getSpacerKey(!horizontal);
        var renderRegions = this.state.renderMask.enumerateRegions();
        var lastSpacer = findLastWhere(renderRegions, r => r.isSpacer);
        for (var _iterator = (0, _createForOfIteratorHelperLoose.default)(renderRegions), _step; !(_step = _iterator()).done;) {
          var section = _step.value;
          if (section.isSpacer) {
            // Legacy behavior is to avoid spacers when virtualization is
            // disabled (including head spacers on initial render).
            if (this.props.disableVirtualization) {
              continue;
            }

            // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to
            // prevent the user for hyperscrolling into un-measured area because otherwise content will
            // likely jump around as it renders in above the viewport.
            var isLastSpacer = section === lastSpacer;
            var constrainToMeasured = isLastSpacer && !this.props.getItemLayout;
            var last = constrainToMeasured ? (0, clamp.default)(section.first - 1, section.last, this._highestMeasuredFrameIndex) : section.last;
            var firstMetrics = this.__getFrameMetricsApprox(section.first, this.props);
            var lastMetrics = this.__getFrameMetricsApprox(last, this.props);
            var spacerSize = lastMetrics.offset + lastMetrics.length - firstMetrics.offset;
            cells.push(/*#__PURE__*/React.createElement(View.default, {
              key: "$spacer-" + section.first,
              style: {
                [spacerKey]: spacerSize
              }
            }));
          } else {
            this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, section.first, section.last, inversionStyle);
          }
        }
        if (!this._hasWarned.keys && _usedIndexForKey) {
          console.warn('VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' + 'item or provide a custom keyExtractor.', _keylessItemComponentName);
          this._hasWarned.keys = true;
        }
      }

      // 3. Add cell for ListFooterComponent
      if (ListFooterComponent) {
        var _element3 = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ListFooterComponent) ? ListFooterComponent : /*#__PURE__*/
        // $FlowFixMe[not-a-component]
        // $FlowFixMe[incompatible-type-arg]
        React.createElement(ListFooterComponent, null);
        cells.push(/*#__PURE__*/React.createElement(_VirtualizedListContextJs.VirtualizedListCellContextProvider, {
          cellKey: this._getFooterCellKey(),
          key: "$footer"
        }, /*#__PURE__*/React.createElement(View.default, {
          onLayout: this._onLayoutFooter,
          style: [inversionStyle, this.props.ListFooterComponentStyle]
        },
        // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
        _element3)));
      }

      // 4. Render the ScrollView
      var scrollProps = (0, _objectSpread.default)((0, _objectSpread.default)({}, this.props), {}, {
        onContentSizeChange: this._onContentSizeChange,
        onLayout: this._onLayout,
        onScroll: this._onScroll,
        onScrollBeginDrag: this._onScrollBeginDrag,
        onScrollEndDrag: this._onScrollEndDrag,
        onMomentumScrollBegin: this._onMomentumScrollBegin,
        onMomentumScrollEnd: this._onMomentumScrollEnd,
        scrollEventThrottle: scrollEventThrottleOrDefault(this.props.scrollEventThrottle),
        // TODO: Android support
        invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,
        stickyHeaderIndices,
        style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style
      });
      this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;
      var innerRet = /*#__PURE__*/React.createElement(_VirtualizedListContextJs.VirtualizedListContextProvider, {
        value: {
          cellKey: null,
          getScrollMetrics: this._getScrollMetrics,
          horizontal: horizontalOrDefault(this.props.horizontal),
          getOutermostParentListRef: this._getOutermostParentListRef,
          registerAsNestedChild: this._registerAsNestedChild,
          unregisterAsNestedChild: this._unregisterAsNestedChild
        }
      }, /*#__PURE__*/React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {
        ref: this._captureScrollRef
      }, cells));
      var ret = innerRet;
      /* https://github.com/necolas/react-native-web/issues/2239: Re-enable when ScrollView.Context.Consumer is available.
      if (__DEV__) {
        ret = (
          <ScrollView.Context.Consumer>
            {scrollContext => {
              if (
                scrollContext != null &&
                !scrollContext.horizontal ===
                  !horizontalOrDefault(this.props.horizontal) &&
                !this._hasWarned.nesting &&
                this.context == null &&
                this.props.scrollEnabled !== false
              ) {
                // TODO (T46547044): use React.warn once 16.9 is sync'd: https://github.com/facebook/react/pull/15170
                console.error(
                  'VirtualizedLists should never be nested inside plain ScrollViews with the same ' +
                    'orientation because it can break windowing and other functionality - use another ' +
                    'VirtualizedList-backed container instead.',
                );
                this._hasWarned.nesting = true;
              }
              return innerRet;
            }}
          </ScrollView.Context.Consumer>
        );
      }*/
      if (this.props.debug) {
        return /*#__PURE__*/React.createElement(View.default, {
          style: styles.debug
        }, ret, this._renderDebugOverlay());
      } else {
        return ret;
      }
    }
    componentDidUpdate(prevProps) {
      var _this$props7 = this.props,
        data = _this$props7.data,
        extraData = _this$props7.extraData;
      if (data !== prevProps.data || extraData !== prevProps.extraData) {
        // clear the viewableIndices cache to also trigger
        // the onViewableItemsChanged callback with the new data
        this._viewabilityTuples.forEach(tuple => {
          tuple.viewabilityHelper.resetViewableIndices();
        });
      }
      // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen
      // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true
      // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with
      // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The
      // `_scheduleCellsToRenderUpdate` will check this condition and not perform
      // another hiPri update.
      var hiPriInProgress = this._hiPriInProgress;
      this._scheduleCellsToRenderUpdate();
      // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`
      // is triggered with `this._hiPriInProgress = true`
      if (hiPriInProgress) {
        this._hiPriInProgress = false;
      }
    }

    // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex

    // flag to prevent infinite hiPri cell limit update

    // $FlowFixMe[missing-local-annot]

    /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
     * LTI update could not be added via codemod */

    _computeBlankness() {
      this._fillRateHelper.computeBlankness(this.props, this.state.cellsAroundViewport, this._scrollMetrics);
    }

    /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
     * LTI update could not be added via codemod */

    _onCellFocusCapture(cellKey) {
      this._lastFocusedCellKey = cellKey;
      this._updateCellsToRender();
    }
    _triggerRemeasureForChildListsInCell(cellKey) {
      this._nestedChildLists.forEachInCell(cellKey, childList => {
        childList.measureLayoutRelativeToContainingList();
      });
    }
    measureLayoutRelativeToContainingList() {
      // TODO (T35574538): findNodeHandle sometimes crashes with "Unable to find
      // node on an unmounted component" during scrolling
      try {
        if (!this._scrollRef) {
          return;
        }
        // We are assuming that getOutermostParentListRef().getScrollRef()
        // is a non-null reference to a ScrollView
        this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), (x, y, width, height) => {
          this._offsetFromParentVirtualizedList = this._selectOffset({
            x,
            y
          });
          this._scrollMetrics.contentLength = this._selectLength({
            width,
            height
          });
          var scrollMetrics = this._convertParentScrollMetrics(this.context.getScrollMetrics());
          var metricsChanged = this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || this._scrollMetrics.offset !== scrollMetrics.offset;
          if (metricsChanged) {
            this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;
            this._scrollMetrics.offset = scrollMetrics.offset;

            // If metrics of the scrollView changed, then we triggered remeasure for child list
            // to ensure VirtualizedList has the right information.
            this._nestedChildLists.forEach(childList => {
              childList.measureLayoutRelativeToContainingList();
            });
          }
        }, error => {
          console.warn("VirtualizedList: Encountered an error while measuring a list's" + ' offset from its containing VirtualizedList.');
        });
      } catch (error) {
        console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);
      }
    }
    _getFooterCellKey() {
      return this._getCellKey() + '-footer';
    }
    // $FlowFixMe[missing-local-annot]
    _renderDebugOverlay() {
      var normalize = this._scrollMetrics.visibleLength / (this._scrollMetrics.contentLength || 1);
      var framesInLayout = [];
      var itemCount = this.props.getItemCount(this.props.data);
      for (var ii = 0; ii < itemCount; ii++) {
        var frame = this.__getFrameMetricsApprox(ii, this.props);
        /* $FlowFixMe[prop-missing] (>=0.68.0 site=react_native_fb) This comment
         * suppresses an error found when Flow v0.68 was deployed. To see the
         * error delete this comment and run Flow. */
        if (frame.inLayout) {
          framesInLayout.push(frame);
        }
      }
      var windowTop = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.first, this.props).offset;
      var frameLast = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.last, this.props);
      var windowLen = frameLast.offset + frameLast.length - windowTop;
      var visTop = this._scrollMetrics.offset;
      var visLen = this._scrollMetrics.visibleLength;
      return /*#__PURE__*/React.createElement(View.default, {
        style: [styles.debugOverlayBase, styles.debugOverlay]
      }, framesInLayout.map((f, ii) => /*#__PURE__*/React.createElement(View.default, {
        key: 'f' + ii,
        style: [styles.debugOverlayBase, styles.debugOverlayFrame, {
          top: f.offset * normalize,
          height: f.length * normalize
        }]
      })), /*#__PURE__*/React.createElement(View.default, {
        style: [styles.debugOverlayBase, styles.debugOverlayFrameLast, {
          top: windowTop * normalize,
          height: windowLen * normalize
        }]
      }), /*#__PURE__*/React.createElement(View.default, {
        style: [styles.debugOverlayBase, styles.debugOverlayFrameVis, {
          top: visTop * normalize,
          height: visLen * normalize
        }]
      }));
    }
    _selectLength(metrics) {
      return !horizontalOrDefault(this.props.horizontal) ? metrics.height : metrics.width;
    }
    _selectOffset(metrics) {
      return !horizontalOrDefault(this.props.horizontal) ? metrics.y : metrics.x;
    }
    _maybeCallOnEdgeReached() {
      var _this$props8 = this.props,
        data = _this$props8.data,
        getItemCount = _this$props8.getItemCount,
        onStartReached = _this$props8.onStartReached,
        onStartReachedThreshold = _this$props8.onStartReachedThreshold,
        onEndReached = _this$props8.onEndReached,
        onEndReachedThreshold = _this$props8.onEndReachedThreshold,
        initialScrollIndex = _this$props8.initialScrollIndex;
      var _this$_scrollMetrics2 = this._scrollMetrics,
        contentLength = _this$_scrollMetrics2.contentLength,
        visibleLength = _this$_scrollMetrics2.visibleLength,
        offset = _this$_scrollMetrics2.offset;
      var distanceFromStart = offset;
      var distanceFromEnd = contentLength - visibleLength - offset;

      // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0
      // since debouncing causes us to not fire this event for every single "pixel" we scroll and can thus
      // be at the edge of the list with a distance approximating 0 but not quite there.
      if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {
        distanceFromStart = 0;
      }
      if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {
        distanceFromEnd = 0;
      }

      // TODO: T121172172 Look into why we're "defaulting" to a threshold of 2px
      // when oERT is not present (different from 2 viewports used elsewhere)
      var DEFAULT_THRESHOLD_PX = 2;
      var startThreshold = onStartReachedThreshold != null ? onStartReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
      var endThreshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
      var isWithinStartThreshold = distanceFromStart <= startThreshold;
      var isWithinEndThreshold = distanceFromEnd <= endThreshold;

      // First check if the user just scrolled within the end threshold
      // and call onEndReached only once for a given content length,
      // and only if onStartReached is not being executed
      if (onEndReached && this.state.cellsAroundViewport.last === getItemCount(data) - 1 && isWithinEndThreshold && this._scrollMetrics.contentLength !== this._sentEndForContentLength) {
        this._sentEndForContentLength = this._scrollMetrics.contentLength;
        onEndReached({
          distanceFromEnd
        });
      }

      // Next check if the user just scrolled within the start threshold
      // and call onStartReached only once for a given content length,
      // and only if onEndReached is not being executed
      else if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._scrollMetrics.contentLength !== this._sentStartForContentLength) {
        // On initial mount when using initialScrollIndex the offset will be 0 initially
        // and will trigger an unexpected onStartReached. To avoid this we can use
        // timestamp to differentiate between the initial scroll metrics and when we actually
        // received the first scroll event.
        if (!initialScrollIndex || this._scrollMetrics.timestamp !== 0) {
          this._sentStartForContentLength = this._scrollMetrics.contentLength;
          onStartReached({
            distanceFromStart
          });
        }
      }

      // If the user scrolls away from the start or end and back again,
      // cause onStartReached or onEndReached to be triggered again
      else {
        this._sentStartForContentLength = isWithinStartThreshold ? this._sentStartForContentLength : 0;
        this._sentEndForContentLength = isWithinEndThreshold ? this._sentEndForContentLength : 0;
      }
    }

    /* Translates metrics from a scroll event in a parent VirtualizedList into
     * coordinates relative to the child list.
     */

    _scheduleCellsToRenderUpdate() {
      var _this$state$cellsArou = this.state.cellsAroundViewport,
        first = _this$state$cellsArou.first,
        last = _this$state$cellsArou.last;
      var _this$_scrollMetrics3 = this._scrollMetrics,
        offset = _this$_scrollMetrics3.offset,
        visibleLength = _this$_scrollMetrics3.visibleLength,
        velocity = _this$_scrollMetrics3.velocity;
      var itemCount = this.props.getItemCount(this.props.data);
      var hiPri = false;
      var onStartReachedThreshold = onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold);
      var onEndReachedThreshold = onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold);
      // Mark as high priority if we're close to the start of the first item
      // But only if there are items before the first rendered item
      if (first > 0) {
        var distTop = offset - this.__getFrameMetricsApprox(first, this.props).offset;
        hiPri = distTop < 0 || velocity < -2 && distTop < getScrollingThreshold(onStartReachedThreshold, visibleLength);
      }
      // Mark as high priority if we're close to the end of the last item
      // But only if there are items after the last rendered item
      if (!hiPri && last >= 0 && last < itemCount - 1) {
        var distBottom = this.__getFrameMetricsApprox(last, this.props).offset - (offset + visibleLength);
        hiPri = distBottom < 0 || velocity > 2 && distBottom < getScrollingThreshold(onEndReachedThreshold, visibleLength);
      }
      // Only trigger high-priority updates if we've actually rendered cells,
      // and with that size estimate, accurately compute how many cells we should render.
      // Otherwise, it would just render as many cells as it can (of zero dimension),
      // each time through attempting to render more (limited by maxToRenderPerBatch),
      // starving the renderer from actually laying out the objects and computing _averageCellLength.
      // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate
      // We shouldn't do another hipri cellToRenderUpdate
      if (hiPri && (this._averageCellLength || this.props.getItemLayout) && !this._hiPriInProgress) {
        this._hiPriInProgress = true;
        // Don't worry about interactions when scrolling quickly; focus on filling content as fast
        // as possible.
        this._updateCellsToRenderBatcher.dispose({
          abort: true
        });
        this._updateCellsToRender();
        return;
      } else {
        this._updateCellsToRenderBatcher.schedule();
      }
    }

    /**
     * Gets an approximate offset to an item at a given index. Supports
     * fractional indices.
     */

    _updateViewableItems(props, cellsAroundViewport) {
      this._viewabilityTuples.forEach(tuple => {
        tuple.viewabilityHelper.onUpdate(props, this._scrollMetrics.offset, this._scrollMetrics.visibleLength, this._getFrameMetrics, this._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);
      });
    }
  }
  VirtualizedList.contextType = _VirtualizedListContextJs.VirtualizedListContext;
  var styles = StyleSheet.default.create({
    verticallyInverted: {
      transform: 'scaleY(-1)'
    },
    horizontallyInverted: {
      transform: 'scaleX(-1)'
    },
    debug: {
      flex: 1
    },
    debugOverlayBase: {
      position: 'absolute',
      top: 0,
      right: 0
    },
    debugOverlay: {
      bottom: 0,
      width: 20,
      borderColor: 'blue',
      borderWidth: 1
    },
    debugOverlayFrame: {
      left: 0,
      backgroundColor: 'orange'
    },
    debugOverlayFrameLast: {
      left: 0,
      borderColor: 'green',
      borderWidth: 2
    },
    debugOverlayFrameVis: {
      left: 0,
      borderColor: 'red',
      borderWidth: 2
    }
  });
  var _default = VirtualizedList;
},172,[173,42,37,176,36,110,55,177,181,182,183,184,185,186,187,188,189,190,17,191,9],"node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _createForOfIteratorHelperLoose;
    }
  });
  var _unsupportedIterableToArrayJs = require(_dependencyMap[0], "./unsupportedIterableToArray.js");
  var unsupportedIterableToArray = _interopDefault(_unsupportedIterableToArrayJs);
  function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = (0, unsupportedIterableToArray.default)(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var o = 0;
      return function () {
        return o >= r.length ? {
          done: !0
        } : {
          done: !1,
          value: r[o++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
},173,[174],"node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelperLoose.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _unsupportedIterableToArray;
    }
  });
  var _arrayLikeToArrayJs = require(_dependencyMap[0], "./arrayLikeToArray.js");
  var arrayLikeToArray = _interopDefault(_arrayLikeToArrayJs);
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return (0, arrayLikeToArray.default)(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? (0, arrayLikeToArray.default)(r, a) : void 0;
    }
  }
},174,[175],"node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _arrayLikeToArray;
    }
  });
  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
},175,[],"node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _View = require(_dependencyMap[1], "../View");
  var View = _interopDefault(_View);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopDefault(_react);
  var _excluded = ["colors", "enabled", "onRefresh", "progressBackgroundColor", "progressViewOffset", "refreshing", "size", "tintColor", "title", "titleColor"];
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function RefreshControl(props) {
    var colors = props.colors,
      enabled = props.enabled,
      onRefresh = props.onRefresh,
      progressBackgroundColor = props.progressBackgroundColor,
      progressViewOffset = props.progressViewOffset,
      refreshing = props.refreshing,
      size = props.size,
      tintColor = props.tintColor,
      title = props.title,
      titleColor = props.titleColor,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    return /*#__PURE__*/React.default.createElement(View.default, rest);
  }
  var _default = RefreshControl;
},176,[43,110,9],"node_modules/react-native-web/dist/exports/RefreshControl/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _exportsInteractionManager = require(_dependencyMap[0], "../../../exports/InteractionManager");
  var InteractionManager = _interopDefault(_exportsInteractionManager);
  /**
   * A simple class for batching up invocations of a low-pri callback. A timeout is set to run the
   * callback once after a delay, no matter how many times it's scheduled. Once the delay is reached,
   * InteractionManager.runAfterInteractions is used to invoke the callback after any hi-pri
   * interactions are done running.
   *
   * Make sure to cleanup with dispose().  Example:
   *
   *   class Widget extends React.Component {
   *     _batchedSave: new Batchinator(() => this._saveState, 1000);
   *     _saveSate() {
   *       // save this.state to disk
   *     }
   *     componentDidUpdate() {
   *       this._batchedSave.schedule();
   *     }
   *     componentWillUnmount() {
   *       this._batchedSave.dispose();
   *     }
   *     ...
   *   }
   */
  class Batchinator {
    constructor(callback, delayMS) {
      this._delay = delayMS;
      this._callback = callback;
    }
    /*
     * Cleanup any pending tasks.
     *
     * By default, if there is a pending task the callback is run immediately. Set the option abort to
     * true to not call the callback if it was pending.
     */
    dispose(options) {
      if (options === void 0) {
        options = {
          abort: false
        };
      }
      if (this._taskHandle) {
        this._taskHandle.cancel();
        if (!options.abort) {
          this._callback();
        }
        this._taskHandle = null;
      }
    }
    schedule() {
      if (this._taskHandle) {
        return;
      }
      var timeoutHandle = setTimeout(() => {
        this._taskHandle = InteractionManager.default.runAfterInteractions(() => {
          // Note that we clear the handle before invoking the callback so that if the callback calls
          // schedule again, it will actually schedule another task.
          this._taskHandle = null;
          this._callback();
        });
      }, this._delay);
      this._taskHandle = {
        cancel: () => clearTimeout(timeoutHandle)
      };
    }
  }
  var _default = Batchinator;
},177,[178],"node_modules/react-native-web/dist/vendor/react-native/Batchinator/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _TaskQueue = require(_dependencyMap[1], "./TaskQueue");
  var TaskQueue = _interopDefault(_TaskQueue);
  var _vendorReactNativeVendorEmitterEventEmitter = require(_dependencyMap[2], "../../vendor/react-native/vendor/emitter/EventEmitter");
  var EventEmitter = _interopDefault(_vendorReactNativeVendorEmitterEventEmitter);
  var _modulesRequestIdleCallback = require(_dependencyMap[3], "../../modules/requestIdleCallback");
  var requestIdleCallback = _interopDefault(_modulesRequestIdleCallback);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _emitter = new EventEmitter.default();
  var InteractionManager = {
    Events: {
      interactionStart: 'interactionStart',
      interactionComplete: 'interactionComplete'
    },
    /**
     * Schedule a function to run after all interactions have completed.
     */
    runAfterInteractions(task) {
      var tasks = [];
      var promise = new Promise(resolve => {
        _scheduleUpdate();
        if (task) {
          tasks.push(task);
        }
        tasks.push({
          run: resolve,
          name: 'resolve ' + (task && task.name || '?')
        });
        _taskQueue.enqueueTasks(tasks);
      });
      return {
        then: promise.then.bind(promise),
        done: promise.then.bind(promise),
        cancel: () => {
          _taskQueue.cancelTasks(tasks);
        }
      };
    },
    /**
     * Notify manager that an interaction has started.
     */
    createInteractionHandle() {
      _scheduleUpdate();
      var handle = ++_inc;
      _addInteractionSet.add(handle);
      return handle;
    },
    /**
     * Notify manager that an interaction has completed.
     */
    clearInteractionHandle(handle) {
      (0, invariant.default)(!!handle, 'Must provide a handle to clear.');
      _scheduleUpdate();
      _addInteractionSet.delete(handle);
      _deleteInteractionSet.add(handle);
    },
    addListener: _emitter.addListener.bind(_emitter),
    /**
     *
     * @param deadline
     */
    setDeadline(deadline) {
      _deadline = deadline;
    }
  };
  var _interactionSet = new Set();
  var _addInteractionSet = new Set();
  var _deleteInteractionSet = new Set();
  var _taskQueue = new TaskQueue.default({
    onMoreTasks: _scheduleUpdate
  });
  var _nextUpdateHandle = 0;
  var _inc = 0;
  var _deadline = -1;

  /**
   * Schedule an asynchronous update to the interaction state.
   */
  function _scheduleUpdate() {
    if (!_nextUpdateHandle) {
      if (_deadline > 0) {
        _nextUpdateHandle = setTimeout(_processUpdate);
      } else {
        _nextUpdateHandle = (0, requestIdleCallback.default)(_processUpdate);
      }
    }
  }

  /**
   * Notify listeners, process queue, etc
   */
  function _processUpdate() {
    _nextUpdateHandle = 0;
    var interactionCount = _interactionSet.size;
    _addInteractionSet.forEach(handle => _interactionSet.add(handle));
    _deleteInteractionSet.forEach(handle => _interactionSet.delete(handle));
    var nextInteractionCount = _interactionSet.size;
    if (interactionCount !== 0 && nextInteractionCount === 0) {
      _emitter.emit(InteractionManager.Events.interactionComplete);
    } else if (interactionCount === 0 && nextInteractionCount !== 0) {
      _emitter.emit(InteractionManager.Events.interactionStart);
    }
    if (nextInteractionCount === 0) {
      // It seems that we can't know the running time of the current event loop,
      // we can only calculate the running time of the current task queue.
      var begin = Date.now();
      while (_taskQueue.hasTasksToProcess()) {
        _taskQueue.processNext();
        if (_deadline > 0 && Date.now() - begin >= _deadline) {
          _scheduleUpdate();
          break;
        }
      }
    }
    _addInteractionSet.clear();
    _deleteInteractionSet.clear();
  }
  var _default = InteractionManager;
},178,[17,179,16,180],"node_modules/react-native-web/dist/exports/InteractionManager/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _fbjsLibInvariant = require(_dependencyMap[1], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  class TaskQueue {
    constructor(_ref) {
      var onMoreTasks = _ref.onMoreTasks;
      this._onMoreTasks = onMoreTasks;
      this._queueStack = [{
        tasks: [],
        popable: true
      }];
    }
    enqueue(task) {
      this._getCurrentQueue().push(task);
    }
    enqueueTasks(tasks) {
      tasks.forEach(task => this.enqueue(task));
    }
    cancelTasks(tasksToCancel) {
      this._queueStack = this._queueStack.map(queue => (0, _objectSpread.default)((0, _objectSpread.default)({}, queue), {}, {
        tasks: queue.tasks.filter(task => tasksToCancel.indexOf(task) === -1)
      })).filter((queue, idx) => queue.tasks.length > 0 || idx === 0);
    }
    hasTasksToProcess() {
      return this._getCurrentQueue().length > 0;
    }

    /**
     * Executes the next task in the queue.
     */
    processNext() {
      var queue = this._getCurrentQueue();
      if (queue.length) {
        var task = queue.shift();
        try {
          if (typeof task === 'object' && task.gen) {
            this._genPromise(task);
          } else if (typeof task === 'object' && task.run) {
            task.run();
          } else {
            (0, invariant.default)(typeof task === 'function', 'Expected Function, SimpleTask, or PromiseTask, but got:\n' + JSON.stringify(task, null, 2));
            task();
          }
        } catch (e) {
          e.message = 'TaskQueue: Error with task ' + (task.name || '') + ': ' + e.message;
          throw e;
        }
      }
    }
    _getCurrentQueue() {
      var stackIdx = this._queueStack.length - 1;
      var queue = this._queueStack[stackIdx];
      if (queue.popable && queue.tasks.length === 0 && stackIdx > 0) {
        this._queueStack.pop();
        return this._getCurrentQueue();
      } else {
        return queue.tasks;
      }
    }
    _genPromise(task) {
      var length = this._queueStack.push({
        tasks: [],
        popable: false
      });
      var stackIdx = length - 1;
      var stackItem = this._queueStack[stackIdx];
      task.gen().then(() => {
        stackItem.popable = true;
        this.hasTasksToProcess() && this._onMoreTasks();
      }).catch(ex => {
        setTimeout(() => {
          ex.message = "TaskQueue: Error resolving Promise in task " + task.name + ": " + ex.message;
          throw ex;
        }, 0);
      });
    }
  }
  var _default = TaskQueue;
},179,[37,17],"node_modules/react-native-web/dist/exports/InteractionManager/TaskQueue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "cancelIdleCallback", {
    enumerable: true,
    get: function () {
      return cancelIdleCallback;
    }
  });
  var _canUseDom = require(_dependencyMap[0], "../canUseDom");
  var canUseDOM = _interopDefault(_canUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _requestIdleCallback = function _requestIdleCallback(cb, options) {
    return setTimeout(() => {
      var start = Date.now();
      cb({
        didTimeout: false,
        timeRemaining() {
          return Math.max(0, 50 - (Date.now() - start));
        }
      });
    }, 1);
  };
  var _cancelIdleCallback = function _cancelIdleCallback(id) {
    clearTimeout(id);
  };
  var isSupported = canUseDOM.default && typeof window.requestIdleCallback !== 'undefined';
  var requestIdleCallback = isSupported ? window.requestIdleCallback : _requestIdleCallback;
  var cancelIdleCallback = isSupported ? window.cancelIdleCallback : _cancelIdleCallback;
  var _default = requestIdleCallback;
},180,[45],"node_modules/react-native-web/dist/modules/requestIdleCallback/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  function clamp(min, value, max) {
    if (value < min) {
      return min;
    }
    if (value > max) {
      return max;
    }
    return value;
  }
  var _default = clamp;
},181,[],"node_modules/react-native-web/dist/vendor/react-native/Utilities/clamp.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  /**
   * Intentional info-level logging for clear separation from ad-hoc console debug logging.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  function infoLog() {
    return console.log(...arguments);
  }
  var _default = infoLog;
},182,[],"node_modules/react-native-web/dist/vendor/react-native/infoLog/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "CellRenderMask", {
    enumerable: true,
    get: function () {
      return CellRenderMask;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _fbjsLibInvariant = require(_dependencyMap[1], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  class CellRenderMask {
    constructor(numCells) {
      (0, invariant.default)(numCells >= 0, 'CellRenderMask must contain a non-negative number os cells');
      this._numCells = numCells;
      if (numCells === 0) {
        this._regions = [];
      } else {
        this._regions = [{
          first: 0,
          last: numCells - 1,
          isSpacer: true
        }];
      }
    }
    enumerateRegions() {
      return this._regions;
    }
    addCells(cells) {
      (0, invariant.default)(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, 'CellRenderMask.addCells called with invalid cell range');

      // VirtualizedList uses inclusive ranges, where zero-count states are
      // possible. E.g. [0, -1] for no cells, starting at 0.
      if (cells.last < cells.first) {
        return;
      }
      var _this$_findRegion = this._findRegion(cells.first),
        firstIntersect = _this$_findRegion[0],
        firstIntersectIdx = _this$_findRegion[1];
      var _this$_findRegion2 = this._findRegion(cells.last),
        lastIntersect = _this$_findRegion2[0],
        lastIntersectIdx = _this$_findRegion2[1];

      // Fast-path if the cells to add are already all present in the mask. We
      // will otherwise need to do some mutation.
      if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {
        return;
      }

      // We need to replace the existing covered regions with 1-3 new regions
      // depending whether we need to split spacers out of overlapping regions.
      var newLeadRegion = [];
      var newTailRegion = [];
      var newMainRegion = (0, _objectSpread.default)((0, _objectSpread.default)({}, cells), {}, {
        isSpacer: false
      });
      if (firstIntersect.first < newMainRegion.first) {
        if (firstIntersect.isSpacer) {
          newLeadRegion.push({
            first: firstIntersect.first,
            last: newMainRegion.first - 1,
            isSpacer: true
          });
        } else {
          newMainRegion.first = firstIntersect.first;
        }
      }
      if (lastIntersect.last > newMainRegion.last) {
        if (lastIntersect.isSpacer) {
          newTailRegion.push({
            first: newMainRegion.last + 1,
            last: lastIntersect.last,
            isSpacer: true
          });
        } else {
          newMainRegion.last = lastIntersect.last;
        }
      }
      var replacementRegions = [...newLeadRegion, newMainRegion, ...newTailRegion];
      var numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;
      this._regions.splice(firstIntersectIdx, numRegionsToDelete, ...replacementRegions);
    }
    numCells() {
      return this._numCells;
    }
    equals(other) {
      return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every((region, i) => region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer);
    }
    _findRegion(cellIdx) {
      var firstIdx = 0;
      var lastIdx = this._regions.length - 1;
      while (firstIdx <= lastIdx) {
        var middleIdx = Math.floor((firstIdx + lastIdx) / 2);
        var middleRegion = this._regions[middleIdx];
        if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {
          return [middleRegion, middleIdx];
        } else if (cellIdx < middleRegion.first) {
          lastIdx = middleIdx - 1;
        } else if (cellIdx > middleRegion.last) {
          firstIdx = middleIdx + 1;
        }
      }
      (0, invariant.default)(false, "A region was not found containing cellIdx " + cellIdx);
    }
  }
},183,[37,17],"node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/CellRenderMask.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return ChildListCollection;
    }
  });
  var _babelRuntimeHelpersCreateForOfIteratorHelperLoose = require(_dependencyMap[0], "@babel/runtime/helpers/createForOfIteratorHelperLoose");
  var _createForOfIteratorHelperLoose = _interopDefault(_babelRuntimeHelpersCreateForOfIteratorHelperLoose);
  var _fbjsLibInvariant = require(_dependencyMap[1], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  class ChildListCollection {
    constructor() {
      this._cellKeyToChildren = new Map();
      this._childrenToCellKey = new Map();
    }
    add(list, cellKey) {
      var _this$_cellKeyToChild;
      (0, invariant.default)(!this._childrenToCellKey.has(list), 'Trying to add already present child list');
      var cellLists = (_this$_cellKeyToChild = this._cellKeyToChildren.get(cellKey)) !== null && _this$_cellKeyToChild !== void 0 ? _this$_cellKeyToChild : new Set();
      cellLists.add(list);
      this._cellKeyToChildren.set(cellKey, cellLists);
      this._childrenToCellKey.set(list, cellKey);
    }
    remove(list) {
      var cellKey = this._childrenToCellKey.get(list);
      (0, invariant.default)(cellKey != null, 'Trying to remove non-present child list');
      this._childrenToCellKey.delete(list);
      var cellLists = this._cellKeyToChildren.get(cellKey);
      (0, invariant.default)(cellLists, '_cellKeyToChildren should contain cellKey');
      cellLists.delete(list);
      if (cellLists.size === 0) {
        this._cellKeyToChildren.delete(cellKey);
      }
    }
    forEach(fn) {
      for (var _iterator = (0, _createForOfIteratorHelperLoose.default)(this._cellKeyToChildren.values()), _step; !(_step = _iterator()).done;) {
        var listSet = _step.value;
        for (var _iterator2 = (0, _createForOfIteratorHelperLoose.default)(listSet), _step2; !(_step2 = _iterator2()).done;) {
          var list = _step2.value;
          fn(list);
        }
      }
    }
    forEachInCell(cellKey, fn) {
      var _this$_cellKeyToChild2;
      var listSet = (_this$_cellKeyToChild2 = this._cellKeyToChildren.get(cellKey)) !== null && _this$_cellKeyToChild2 !== void 0 ? _this$_cellKeyToChild2 : [];
      for (var _iterator3 = (0, _createForOfIteratorHelperLoose.default)(listSet), _step3; !(_step3 = _iterator3()).done;) {
        var list = _step3.value;
        fn(list);
      }
    }
    anyInCell(cellKey, fn) {
      var _this$_cellKeyToChild3;
      var listSet = (_this$_cellKeyToChild3 = this._cellKeyToChildren.get(cellKey)) !== null && _this$_cellKeyToChild3 !== void 0 ? _this$_cellKeyToChild3 : [];
      for (var _iterator4 = (0, _createForOfIteratorHelperLoose.default)(listSet), _step4; !(_step4 = _iterator4()).done;) {
        var list = _step4.value;
        if (fn(list)) {
          return true;
        }
      }
      return false;
    }
    size() {
      return this._childrenToCellKey.size;
    }
  }
},184,[173,17],"node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/ChildListCollection.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  class Info {
    constructor() {
      this.any_blank_count = 0;
      this.any_blank_ms = 0;
      this.any_blank_speed_sum = 0;
      this.mostly_blank_count = 0;
      this.mostly_blank_ms = 0;
      this.pixels_blank = 0;
      this.pixels_sampled = 0;
      this.pixels_scrolled = 0;
      this.total_time_spent = 0;
      this.sample_count = 0;
    }
  }
  var DEBUG = false;
  var _listeners = [];
  var _minSampleCount = 10;
  var _sampleRate = DEBUG ? 1 : null;

  /**
   * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.
   * By default the sampling rate is set to zero and this will do nothing. If you want to collect
   * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.
   *
   * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with
   * `SceneTracker.getActiveScene` to determine the context of the events.
   */
  class FillRateHelper {
    static addListener(callback) {
      if (_sampleRate === null) {
        console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');
      }
      _listeners.push(callback);
      return {
        remove: () => {
          _listeners = _listeners.filter(listener => callback !== listener);
        }
      };
    }
    static setSampleRate(sampleRate) {
      _sampleRate = sampleRate;
    }
    static setMinSampleCount(minSampleCount) {
      _minSampleCount = minSampleCount;
    }
    constructor(getFrameMetrics) {
      this._anyBlankStartTime = null;
      this._enabled = false;
      this._info = new Info();
      this._mostlyBlankStartTime = null;
      this._samplesStartTime = null;
      this._getFrameMetrics = getFrameMetrics;
      this._enabled = (_sampleRate || 0) > Math.random();
      this._resetData();
    }
    activate() {
      if (this._enabled && this._samplesStartTime == null) {
        DEBUG && console.debug('FillRateHelper: activate');
        this._samplesStartTime = global.performance.now();
      }
    }
    deactivateAndFlush() {
      if (!this._enabled) {
        return;
      }
      var start = this._samplesStartTime; // const for flow
      if (start == null) {
        DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');
        return;
      }
      if (this._info.sample_count < _minSampleCount) {
        // Don't bother with under-sampled events.
        this._resetData();
        return;
      }
      var total_time_spent = global.performance.now() - start;
      var info = (0, _objectSpread.default)((0, _objectSpread.default)({}, this._info), {}, {
        total_time_spent
      });
      if (DEBUG) {
        var derived = {
          avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,
          avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),
          avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,
          any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),
          any_blank_time_frac: this._info.any_blank_ms / total_time_spent,
          mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),
          mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent
        };
        for (var key in derived) {
          // $FlowFixMe[prop-missing]
          derived[key] = Math.round(1000 * derived[key]) / 1000;
        }
        console.debug('FillRateHelper deactivateAndFlush: ', {
          derived,
          info
        });
      }
      _listeners.forEach(listener => listener(info));
      this._resetData();
    }
    computeBlankness(props, cellsAroundViewport, scrollMetrics) {
      if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null) {
        return 0;
      }
      var dOffset = scrollMetrics.dOffset,
        offset = scrollMetrics.offset,
        velocity = scrollMetrics.velocity,
        visibleLength = scrollMetrics.visibleLength;

      // Denominator metrics that we track for all events - most of the time there is no blankness and
      // we want to capture that.
      this._info.sample_count++;
      this._info.pixels_sampled += Math.round(visibleLength);
      this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
      var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec

      // Whether blank now or not, record the elapsed time blank if we were blank last time.
      var now = global.performance.now();
      if (this._anyBlankStartTime != null) {
        this._info.any_blank_ms += now - this._anyBlankStartTime;
      }
      this._anyBlankStartTime = null;
      if (this._mostlyBlankStartTime != null) {
        this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;
      }
      this._mostlyBlankStartTime = null;
      var blankTop = 0;
      var first = cellsAroundViewport.first;
      var firstFrame = this._getFrameMetrics(first, props);
      while (first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.inLayout)) {
        firstFrame = this._getFrameMetrics(first, props);
        first++;
      }
      // Only count blankTop if we aren't rendering the first item, otherwise we will count the header
      // as blank.
      if (firstFrame && first > 0) {
        blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));
      }
      var blankBottom = 0;
      var last = cellsAroundViewport.last;
      var lastFrame = this._getFrameMetrics(last, props);
      while (last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.inLayout)) {
        lastFrame = this._getFrameMetrics(last, props);
        last--;
      }
      // Only count blankBottom if we aren't rendering the last item, otherwise we will count the
      // footer as blank.
      if (lastFrame && last < props.getItemCount(props.data) - 1) {
        var bottomEdge = lastFrame.offset + lastFrame.length;
        blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));
      }
      var pixels_blank = Math.round(blankTop + blankBottom);
      var blankness = pixels_blank / visibleLength;
      if (blankness > 0) {
        this._anyBlankStartTime = now;
        this._info.any_blank_speed_sum += scrollSpeed;
        this._info.any_blank_count++;
        this._info.pixels_blank += pixels_blank;
        if (blankness > 0.5) {
          this._mostlyBlankStartTime = now;
          this._info.mostly_blank_count++;
        }
      } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {
        this.deactivateAndFlush();
      }
      return blankness;
    }
    enabled() {
      return this._enabled;
    }
    _resetData() {
      this._anyBlankStartTime = null;
      this._info = new Info();
      this._mostlyBlankStartTime = null;
      this._samplesStartTime = null;
    }
  }
  var _default = FillRateHelper;
},185,[37],"node_modules/react-native-web/dist/vendor/react-native/FillRateHelper/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return StateSafePureComponent;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * `setState` is called asynchronously, and should not rely on the value of
   * `this.props` or `this.state`:
   * https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous
   *
   * SafePureComponent adds runtime enforcement, to catch cases where these
   * variables are read in a state updater function, instead of the ones passed
   * in.
   */
  class StateSafePureComponent extends React.PureComponent {
    constructor(props) {
      super(props);
      this._inAsyncStateUpdate = false;
      this._installSetStateHooks();
    }
    setState(partialState, callback) {
      if (typeof partialState === 'function') {
        super.setState((state, props) => {
          this._inAsyncStateUpdate = true;
          var ret;
          try {
            ret = partialState(state, props);
          } catch (err) {
            throw err;
          } finally {
            this._inAsyncStateUpdate = false;
          }
          return ret;
        }, callback);
      } else {
        super.setState(partialState, callback);
      }
    }
    _installSetStateHooks() {
      var that = this;
      var props = this.props,
        state = this.state;
      Object.defineProperty(this, 'props', {
        get() {
          (0, invariant.default)(!that._inAsyncStateUpdate, '"this.props" should not be accessed during state updates');
          return props;
        },
        set(newProps) {
          props = newProps;
        }
      });
      Object.defineProperty(this, 'state', {
        get() {
          (0, invariant.default)(!that._inAsyncStateUpdate, '"this.state" should not be acceessed during state updates');
          return state;
        },
        set(newState) {
          state = newState;
        }
      });
    }
  }
},186,[17,9],"node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/StateSafePureComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersCreateForOfIteratorHelperLoose = require(_dependencyMap[1], "@babel/runtime/helpers/createForOfIteratorHelperLoose");
  var _createForOfIteratorHelperLoose = _interopDefault(_babelRuntimeHelpersCreateForOfIteratorHelperLoose);
  var _fbjsLibInvariant = require(_dependencyMap[2], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * A Utility class for calculating viewable items based on current metrics like scroll position and
   * layout.
   *
   * An item is said to be in a "viewable" state when any of the following
   * is true for longer than `minimumViewTime` milliseconds (after an interaction if `waitForInteraction`
   * is true):
   *
   * - Occupying >= `viewAreaCoveragePercentThreshold` of the view area XOR fraction of the item
   *   visible in the view area >= `itemVisiblePercentThreshold`.
   * - Entirely visible on screen
   */
  class ViewabilityHelper {
    constructor(config) {
      if (config === void 0) {
        config = {
          viewAreaCoveragePercentThreshold: 0
        };
      }
      this._hasInteracted = false;
      this._timers = new Set();
      this._viewableIndices = [];
      this._viewableItems = new Map();
      this._config = config;
    }

    /**
     * Cleanup, e.g. on unmount. Clears any pending timers.
     */
    dispose() {
      /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
       * comment suppresses an error found when Flow v0.63 was deployed. To see
       * the error delete this comment and run Flow. */
      this._timers.forEach(clearTimeout);
    }

    /**
     * Determines which items are viewable based on the current metrics and config.
     */
    computeViewableItems(props, scrollOffset, viewportHeight, getFrameMetrics,
    // Optional optimization to reduce the scan size
    renderRange) {
      var itemCount = props.getItemCount(props.data);
      var _this$_config = this._config,
        itemVisiblePercentThreshold = _this$_config.itemVisiblePercentThreshold,
        viewAreaCoveragePercentThreshold = _this$_config.viewAreaCoveragePercentThreshold;
      var viewAreaMode = viewAreaCoveragePercentThreshold != null;
      var viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;
      (0, invariant.default)(viewablePercentThreshold != null && itemVisiblePercentThreshold != null !== (viewAreaCoveragePercentThreshold != null), 'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold');
      var viewableIndices = [];
      if (itemCount === 0) {
        return viewableIndices;
      }
      var firstVisible = -1;
      var _ref = renderRange || {
          first: 0,
          last: itemCount - 1
        },
        first = _ref.first,
        last = _ref.last;
      if (last >= itemCount) {
        console.warn('Invalid render range computing viewability ' + JSON.stringify({
          renderRange,
          itemCount
        }));
        return [];
      }
      for (var idx = first; idx <= last; idx++) {
        var metrics = getFrameMetrics(idx, props);
        if (!metrics) {
          continue;
        }
        var top = metrics.offset - scrollOffset;
        var bottom = top + metrics.length;
        if (top < viewportHeight && bottom > 0) {
          firstVisible = idx;
          if (_isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, metrics.length)) {
            viewableIndices.push(idx);
          }
        } else if (firstVisible >= 0) {
          break;
        }
      }
      return viewableIndices;
    }

    /**
     * Figures out which items are viewable and how that has changed from before and calls
     * `onViewableItemsChanged` as appropriate.
     */
    onUpdate(props, scrollOffset, viewportHeight, getFrameMetrics, createViewToken, onViewableItemsChanged,
    // Optional optimization to reduce the scan size
    renderRange) {
      var itemCount = props.getItemCount(props.data);
      if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !getFrameMetrics(0, props)) {
        return;
      }
      var viewableIndices = [];
      if (itemCount) {
        viewableIndices = this.computeViewableItems(props, scrollOffset, viewportHeight, getFrameMetrics, renderRange);
      }
      if (this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every((v, ii) => v === viewableIndices[ii])) {
        // We might get a lot of scroll events where visibility doesn't change and we don't want to do
        // extra work in those cases.
        return;
      }
      this._viewableIndices = viewableIndices;
      if (this._config.minimumViewTime) {
        var handle = setTimeout(() => {
          /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
           * comment suppresses an error found when Flow v0.63 was deployed. To
           * see the error delete this comment and run Flow. */
          this._timers.delete(handle);
          this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
        }, this._config.minimumViewTime);
        /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.63 was deployed. To see
         * the error delete this comment and run Flow. */
        this._timers.add(handle);
      } else {
        this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
      }
    }

    /**
     * clean-up cached _viewableIndices to evaluate changed items on next update
     */
    resetViewableIndices() {
      this._viewableIndices = [];
    }

    /**
     * Records that an interaction has happened even if there has been no scroll.
     */
    recordInteraction() {
      this._hasInteracted = true;
    }
    _onUpdateSync(props, viewableIndicesToCheck, onViewableItemsChanged, createViewToken) {
      // Filter out indices that have gone out of view since this call was scheduled.
      viewableIndicesToCheck = viewableIndicesToCheck.filter(ii => this._viewableIndices.includes(ii));
      var prevItems = this._viewableItems;
      var nextItems = new Map(viewableIndicesToCheck.map(ii => {
        var viewable = createViewToken(ii, true, props);
        return [viewable.key, viewable];
      }));
      var changed = [];
      for (var _iterator = (0, _createForOfIteratorHelperLoose.default)(nextItems), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
          key = _step$value[0],
          viewable = _step$value[1];
        if (!prevItems.has(key)) {
          changed.push(viewable);
        }
      }
      for (var _iterator2 = (0, _createForOfIteratorHelperLoose.default)(prevItems), _step2; !(_step2 = _iterator2()).done;) {
        var _step2$value = _step2.value,
          _key = _step2$value[0],
          _viewable = _step2$value[1];
        if (!nextItems.has(_key)) {
          changed.push((0, _objectSpread.default)((0, _objectSpread.default)({}, _viewable), {}, {
            isViewable: false
          }));
        }
      }
      if (changed.length > 0) {
        this._viewableItems = nextItems;
        onViewableItemsChanged({
          viewableItems: Array.from(nextItems.values()),
          changed,
          viewabilityConfig: this._config
        });
      }
    }
  }
  function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
    if (_isEntirelyVisible(top, bottom, viewportHeight)) {
      return true;
    } else {
      var pixels = _getPixelsVisible(top, bottom, viewportHeight);
      var percent = 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);
      return percent >= viewablePercentThreshold;
    }
  }
  function _getPixelsVisible(top, bottom, viewportHeight) {
    var visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
    return Math.max(0, visibleHeight);
  }
  function _isEntirelyVisible(top, bottom, viewportHeight) {
    return top >= 0 && bottom <= viewportHeight && bottom > top;
  }
  var _default = ViewabilityHelper;
},187,[37,173,17],"node_modules/react-native-web/dist/vendor/react-native/ViewabilityHelper/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return CellRenderer;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _exportsView = require(_dependencyMap[2], "../../../exports/View");
  var View = _interopDefault(_exportsView);
  var _exportsStyleSheet = require(_dependencyMap[3], "../../../exports/StyleSheet");
  var StyleSheet = _interopDefault(_exportsStyleSheet);
  var _VirtualizedListContextJs = require(_dependencyMap[4], "./VirtualizedListContext.js");
  var _fbjsLibInvariant = require(_dependencyMap[5], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _react = require(_dependencyMap[6], "react");
  var React = _interopNamespace(_react);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  class CellRenderer extends React.Component {
    constructor() {
      super(...arguments);
      this.state = {
        separatorProps: {
          highlighted: false,
          leadingItem: this.props.item
        }
      };
      this._separators = {
        highlight: () => {
          var _this$props = this.props,
            cellKey = _this$props.cellKey,
            prevCellKey = _this$props.prevCellKey;
          this.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: true
          });
        },
        unhighlight: () => {
          var _this$props2 = this.props,
            cellKey = _this$props2.cellKey,
            prevCellKey = _this$props2.prevCellKey;
          this.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: false
          });
        },
        updateProps: (select, newProps) => {
          var _this$props3 = this.props,
            cellKey = _this$props3.cellKey,
            prevCellKey = _this$props3.prevCellKey;
          this.props.onUpdateSeparators([select === 'leading' ? prevCellKey : cellKey], newProps);
        }
      };
      this._onLayout = nativeEvent => {
        this.props.onCellLayout && this.props.onCellLayout(nativeEvent, this.props.cellKey, this.props.index);
      };
    }
    static getDerivedStateFromProps(props, prevState) {
      return {
        separatorProps: (0, _objectSpread.default)((0, _objectSpread.default)({}, prevState.separatorProps), {}, {
          leadingItem: props.item
        })
      };
    }

    // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not
    // reused by SectionList and we can keep VirtualizedList simpler.
    // $FlowFixMe[missing-local-annot]

    updateSeparatorProps(newProps) {
      this.setState(state => ({
        separatorProps: (0, _objectSpread.default)((0, _objectSpread.default)({}, state.separatorProps), newProps)
      }));
    }
    componentWillUnmount() {
      this.props.onUnmount(this.props.cellKey);
    }
    _renderElement(renderItem, ListItemComponent, item, index) {
      if (renderItem && ListItemComponent) {
        console.warn('VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take' + ' precedence over renderItem.');
      }
      if (ListItemComponent) {
        /* $FlowFixMe[not-a-component] (>=0.108.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.108 was deployed. To
         * see the error, delete this comment and run Flow. */
        /* $FlowFixMe[incompatible-type-arg] (>=0.108.0 site=react_native_fb)
         * This comment suppresses an error found when Flow v0.108 was deployed.
         * To see the error, delete this comment and run Flow. */
        return /*#__PURE__*/React.createElement(ListItemComponent, {
          item,
          index,
          separators: this._separators
        });
      }
      if (renderItem) {
        return renderItem({
          item,
          index,
          separators: this._separators
        });
      }
      (0, invariant.default)(false, 'VirtualizedList: Either ListItemComponent or renderItem props are required but none were found.');
    }
    render() {
      var _this$props4 = this.props,
        CellRendererComponent = _this$props4.CellRendererComponent,
        ItemSeparatorComponent = _this$props4.ItemSeparatorComponent,
        ListItemComponent = _this$props4.ListItemComponent,
        cellKey = _this$props4.cellKey,
        horizontal = _this$props4.horizontal,
        item = _this$props4.item,
        index = _this$props4.index,
        inversionStyle = _this$props4.inversionStyle,
        onCellFocusCapture = _this$props4.onCellFocusCapture,
        onCellLayout = _this$props4.onCellLayout,
        renderItem = _this$props4.renderItem;
      var element = this._renderElement(renderItem, ListItemComponent, item, index);

      // NOTE: that when this is a sticky header, `onLayout` will get automatically extracted and
      // called explicitly by `ScrollViewStickyHeader`.
      var itemSeparator = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ItemSeparatorComponent) ?
      // $FlowFixMe[incompatible-type]
      ItemSeparatorComponent :
      // $FlowFixMe[incompatible-type]
      ItemSeparatorComponent && /*#__PURE__*/React.createElement(ItemSeparatorComponent, this.state.separatorProps);
      var cellStyle = inversionStyle ? horizontal ? [styles.rowReverse, inversionStyle] : [styles.columnReverse, inversionStyle] : horizontal ? [styles.row, inversionStyle] : inversionStyle;
      var result = !CellRendererComponent ? /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({
        style: cellStyle,
        onFocusCapture: onCellFocusCapture
      }, onCellLayout && {
        onLayout: this._onLayout
      }), element, itemSeparator) : /*#__PURE__*/React.createElement(CellRendererComponent, (0, _extends.default)({
        cellKey: cellKey,
        index: index,
        item: item,
        style: cellStyle,
        onFocusCapture: onCellFocusCapture
      }, onCellLayout && {
        onLayout: this._onLayout
      }), element, itemSeparator);
      return /*#__PURE__*/React.createElement(_VirtualizedListContextJs.VirtualizedListCellContextProvider, {
        cellKey: this.props.cellKey
      }, result);
    }
  }
  var styles = StyleSheet.default.create({
    row: {
      flexDirection: 'row'
    },
    rowReverse: {
      flexDirection: 'row-reverse'
    },
    columnReverse: {
      flexDirection: 'column-reverse'
    }
  });
},188,[42,37,110,55,189,17,9],"node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/VirtualizedListCellRenderer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "VirtualizedListContext", {
    enumerable: true,
    get: function () {
      return VirtualizedListContext;
    }
  });
  exports.VirtualizedListContextResetter = VirtualizedListContextResetter;
  exports.VirtualizedListContextProvider = VirtualizedListContextProvider;
  exports.VirtualizedListCellContextProvider = VirtualizedListCellContextProvider;
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var __DEV__ = process.env.NODE_ENV !== 'production';
  var VirtualizedListContext = /*#__PURE__*/React.createContext(null);
  if (__DEV__) {
    VirtualizedListContext.displayName = 'VirtualizedListContext';
  }

  /**
   * Resets the context. Intended for use by portal-like components (e.g. Modal).
   */
  function VirtualizedListContextResetter(_ref) {
    var children = _ref.children;
    return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
      value: null
    }, children);
  }

  /**
   * Sets the context with memoization. Intended to be used by `VirtualizedList`.
   */
  function VirtualizedListContextProvider(_ref2) {
    var children = _ref2.children,
      value = _ref2.value;
    // Avoid setting a newly created context object if the values are identical.
    var context = (0, _react.useMemo)(() => ({
      cellKey: null,
      getScrollMetrics: value.getScrollMetrics,
      horizontal: value.horizontal,
      getOutermostParentListRef: value.getOutermostParentListRef,
      registerAsNestedChild: value.registerAsNestedChild,
      unregisterAsNestedChild: value.unregisterAsNestedChild
    }), [value.getScrollMetrics, value.horizontal, value.getOutermostParentListRef, value.registerAsNestedChild, value.unregisterAsNestedChild]);
    return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
      value: context
    }, children);
  }

  /**
   * Sets the `cellKey`. Intended to be used by `VirtualizedList` for each cell.
   */
  function VirtualizedListCellContextProvider(_ref3) {
    var cellKey = _ref3.cellKey,
      children = _ref3.children;
    // Avoid setting a newly created context object if the values are identical.
    var currContext = (0, _react.useContext)(VirtualizedListContext);
    var context = (0, _react.useMemo)(() => currContext == null ? null : (0, _objectSpread.default)((0, _objectSpread.default)({}, currContext), {}, {
      cellKey
    }), [currContext, cellKey]);
    return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
      value: context
    }, children);
  }
},189,[37,9],"node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/VirtualizedListContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  /**
   * Used to find the indices of the frames that overlap the given offsets. Useful for finding the
   * items that bound different windows of content, such as the visible area or the buffered overscan
   * area.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;
  exports.newRangeCount = newRangeCount;
  exports.computeWindowedRenderLimits = computeWindowedRenderLimits;
  exports.keyExtractor = keyExtractor;
  function elementsThatOverlapOffsets(offsets, props, getFrameMetrics, zoomScale) {
    if (zoomScale === void 0) {
      zoomScale = 1;
    }
    var itemCount = props.getItemCount(props.data);
    var result = [];
    for (var offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {
      var currentOffset = offsets[offsetIndex];
      var left = 0;
      var right = itemCount - 1;
      while (left <= right) {
        // eslint-disable-next-line no-bitwise
        var mid = left + (right - left >>> 1);
        var frame = getFrameMetrics(mid, props);
        var scaledOffsetStart = frame.offset * zoomScale;
        var scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;

        // We want the first frame that contains the offset, with inclusive bounds. Thus, for the
        // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.
        if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart) {
          right = mid - 1;
        } else if (currentOffset > scaledOffsetEnd) {
          left = mid + 1;
        } else {
          result[offsetIndex] = mid;
          break;
        }
      }
    }
    return result;
  }

  /**
   * Computes the number of elements in the `next` range that are new compared to the `prev` range.
   * Handy for calculating how many new items will be rendered when the render window changes so we
   * can restrict the number of new items render at once so that content can appear on the screen
   * faster.
   */
  function newRangeCount(prev, next) {
    return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));
  }

  /**
   * Custom logic for determining which items should be rendered given the current frame and scroll
   * metrics, as well as the previous render state. The algorithm may evolve over time, but generally
   * prioritizes the visible area first, then expands that with overscan regions ahead and behind,
   * biased in the direction of scroll.
   */
  function computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {
    var itemCount = props.getItemCount(props.data);
    if (itemCount === 0) {
      return {
        first: 0,
        last: -1
      };
    }
    var offset = scrollMetrics.offset,
      velocity = scrollMetrics.velocity,
      visibleLength = scrollMetrics.visibleLength,
      _scrollMetrics$zoomSc = scrollMetrics.zoomScale,
      zoomScale = _scrollMetrics$zoomSc === void 0 ? 1 : _scrollMetrics$zoomSc;

    // Start with visible area, then compute maximum overscan region by expanding from there, biased
    // in the direction of scroll. Total overscan area is capped, which should cap memory consumption
    // too.
    var visibleBegin = Math.max(0, offset);
    var visibleEnd = visibleBegin + visibleLength;
    var overscanLength = (windowSize - 1) * visibleLength;

    // Considering velocity seems to introduce more churn than it's worth.
    var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));

    var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';
    var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);
    var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);
    var lastItemOffset = getFrameMetricsApprox(itemCount - 1, props).offset * zoomScale;
    if (lastItemOffset < overscanBegin) {
      // Entire list is before our overscan window
      return {
        first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),
        last: itemCount - 1
      };
    }

    // Find the indices that correspond to the items at the render boundaries we're targeting.
    var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props, getFrameMetricsApprox, zoomScale),
      overscanFirst = _elementsThatOverlapO[0],
      first = _elementsThatOverlapO[1],
      last = _elementsThatOverlapO[2],
      overscanLast = _elementsThatOverlapO[3];
    overscanFirst = overscanFirst == null ? 0 : overscanFirst;
    first = first == null ? Math.max(0, overscanFirst) : first;
    overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;
    last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;
    var visible = {
      first,
      last
    };

    // We want to limit the number of new cells we're rendering per batch so that we can fill the
    // content on the screen quickly. If we rendered the entire overscan window at once, the user
    // could be staring at white space for a long time waiting for a bunch of offscreen content to
    // render.
    var newCellCount = newRangeCount(prev, visible);
    while (true) {
      if (first <= overscanFirst && last >= overscanLast) {
        // If we fill the entire overscan range, we're done.
        break;
      }
      var maxNewCells = newCellCount >= maxToRenderPerBatch;
      var firstWillAddMore = first <= prev.first || first > prev.last;
      var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);
      var lastWillAddMore = last >= prev.last || last < prev.first;
      var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);
      if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {
        // We only want to stop if we've hit maxNewCells AND we cannot increment first or last
        // without rendering new items. This let's us preserve as many already rendered items as
        // possible, reducing render churn and keeping the rendered overscan range as large as
        // possible.
        break;
      }
      if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {
        if (firstWillAddMore) {
          newCellCount++;
        }
        first--;
      }
      if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {
        if (lastWillAddMore) {
          newCellCount++;
        }
        last++;
      }
    }
    if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {
      throw new Error('Bad window calculation ' + JSON.stringify({
        first,
        last,
        itemCount,
        overscanFirst,
        overscanLast,
        visible
      }));
    }
    return {
      first,
      last
    };
  }
  function keyExtractor(item, index) {
    if (typeof item === 'object' && (item == null ? void 0 : item.key) != null) {
      return item.key;
    }
    if (typeof item === 'object' && (item == null ? void 0 : item.id) != null) {
      return item.id;
    }
    return String(index);
  }
},190,[],"node_modules/react-native-web/dist/vendor/react-native/VirtualizeUtils/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function nullthrows(x, message) {
    if (x != null) {
      return x;
    }
    var error = new Error(message !== undefined ? message : 'Got unexpected ' + x);
    error.framesToPop = 1; // Skip nullthrows's own stack frame.
    throw error;
  }
  module.exports = nullthrows;
  module.exports.default = nullthrows;
  Object.defineProperty(module.exports, '__esModule', {
    value: true
  });
},191,[],"node_modules/nullthrows/nullthrows.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return memoizeOne;
    }
  });
  var safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === 'number' && value !== value;
  };
  function isEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
      return true;
    }
    return false;
  }
  function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
      if (!isEqual(newInputs[i], lastInputs[i])) {
        return false;
      }
    }
    return true;
  }
  function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) {
      isEqual = areInputsEqual;
    }
    var cache = null;
    function memoized() {
      var newArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        newArgs[_i] = arguments[_i];
      }
      if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
        return cache.lastResult;
      }
      var lastResult = resultFn.apply(this, newArgs);
      cache = {
        lastResult: lastResult,
        lastArgs: newArgs,
        lastThis: this
      };
      return lastResult;
    }
    memoized.clear = function clear() {
      cache = null;
    };
    return memoized;
  }
},192,[],"node_modules/react-native-web/node_modules/memoize-one/dist/memoize-one.esm.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return createAnimatedComponent;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _useAnimatedProps2 = require(_dependencyMap[2], "./useAnimatedProps");
  var useAnimatedProps = _interopDefault(_useAnimatedProps2);
  var _UtilitiesUseMergeRefs = require(_dependencyMap[3], "../Utilities/useMergeRefs");
  var useMergeRefs = _interopDefault(_UtilitiesUseMergeRefs);
  require(_dependencyMap[4], "../../../exports/StyleSheet");
  require(_dependencyMap[5], "../../../exports/View");
  var _react = require(_dependencyMap[6], "react");
  var React = _interopNamespace(_react);
  var _excluded = ["style"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Experimental implementation of `createAnimatedComponent` that is intended to
   * be compatible with concurrent rendering.
   */
  function createAnimatedComponent(Component) {
    return /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
      var _useAnimatedProps = (0, useAnimatedProps.default)(props),
        reducedProps = _useAnimatedProps[0],
        callbackRef = _useAnimatedProps[1];
      var ref = (0, useMergeRefs.default)(callbackRef, forwardedRef);

      // Some components require explicit passthrough values for animation
      // to work properly. For example, if an animated component is
      // transformed and Pressable, onPress will not work after transform
      // without these passthrough values.
      // $FlowFixMe[prop-missing]
      var passthroughAnimatedPropExplicitValues = reducedProps.passthroughAnimatedPropExplicitValues,
        style = reducedProps.style;
      var _ref = passthroughAnimatedPropExplicitValues !== null && passthroughAnimatedPropExplicitValues !== void 0 ? passthroughAnimatedPropExplicitValues : {},
        passthroughStyle = _ref.style,
        passthroughProps = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
      var mergedStyle = [style, passthroughStyle];
      return /*#__PURE__*/React.createElement(Component, (0, _extends.default)({}, reducedProps, passthroughProps, {
        style: mergedStyle,
        ref: ref
      }));
    });
  }
},193,[42,43,194,210,55,110,9],"node_modules/react-native-web/dist/vendor/react-native/Animated/createAnimatedComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useAnimatedProps;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _nodesAnimatedProps = require(_dependencyMap[1], "./nodes/AnimatedProps");
  var AnimatedProps = _interopDefault(_nodesAnimatedProps);
  var _AnimatedEvent = require(_dependencyMap[2], "./AnimatedEvent");
  var _UtilitiesUseRefEffect = require(_dependencyMap[3], "../Utilities/useRefEffect");
  var useRefEffect = _interopDefault(_UtilitiesUseRefEffect);
  var _NativeAnimatedHelper = require(_dependencyMap[4], "./NativeAnimatedHelper");
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _react = require(_dependencyMap[5], "react");
  var _modulesUseLayoutEffect = require(_dependencyMap[6], "../../../modules/useLayoutEffect");
  var useLayoutEffect = _interopDefault(_modulesUseLayoutEffect);
  function useAnimatedProps(props) {
    var _useReducer = (0, _react.useReducer)(count => count + 1, 0),
      scheduleUpdate = _useReducer[1];
    var onUpdateRef = (0, _react.useRef)(null);

    // TODO: Only invalidate `node` if animated props or `style` change. In the
    // previous implementation, we permitted `style` to override props with the
    // same name property name as styles, so we can probably continue doing that.
    // The ordering of other props *should* not matter.
    var node = (0, _react.useMemo)(() => new AnimatedProps.default(props, () => onUpdateRef.current == null ? void 0 : onUpdateRef.current()), [props]);
    useAnimatedPropsLifecycle(node);

    // TODO: This "effect" does three things:
    //
    //   1) Call `setNativeView`.
    //   2) Update `onUpdateRef`.
    //   3) Update listeners for `AnimatedEvent` props.
    //
    // Ideally, each of these would be separat "effects" so that they are not
    // unnecessarily re-run when irrelevant dependencies change. For example, we
    // should be able to hoist all `AnimatedEvent` props and only do #3 if either
    // the `AnimatedEvent` props change or `instance` changes.
    //
    // But there is no way to transparently compose three separate callback refs,
    // so we just combine them all into one for now.
    var refEffect = (0, _react.useCallback)(instance => {
      // NOTE: This may be called more often than necessary (e.g. when `props`
      // changes), but `setNativeView` already optimizes for that.
      node.setNativeView(instance);

      // NOTE: This callback is only used by the JavaScript animation driver.
      onUpdateRef.current = () => {
        // Schedule an update for this component to update `reducedProps`,
        // but do not compute it immediately. If a parent also updated, we
        // need to merge those new props in before updating.
        scheduleUpdate();
      };
      var target = getEventTarget(instance);
      var events = [];
      for (var propName in props) {
        var propValue = props[propName];
        if (propValue instanceof _AnimatedEvent.AnimatedEvent && propValue.__isNative) {
          propValue.__attach(target, propName);
          events.push([propName, propValue]);
        }
      }
      return () => {
        onUpdateRef.current = null;
        for (var _i = 0, _events = events; _i < _events.length; _i++) {
          var _events$_i = _events[_i],
            _propName = _events$_i[0],
            _propValue = _events$_i[1];
          _propValue.__detach(target, _propName);
        }
      };
    }, [props, node]);
    var callbackRef = (0, useRefEffect.default)(refEffect);
    return [reduceAnimatedProps(node), callbackRef];
  }
  function reduceAnimatedProps(node) {
    // Force `collapsable` to be false so that the native view is not flattened.
    // Flattened views cannot be accurately referenced by the native driver.
    return (0, _objectSpread.default)((0, _objectSpread.default)({}, node.__getValue()), {}, {
      collapsable: false
    });
  }

  /**
   * Manages the lifecycle of the supplied `AnimatedProps` by invoking `__attach`
   * and `__detach`. However, this is more complicated because `AnimatedProps`
   * uses reference counting to determine when to recursively detach its children
   * nodes. So in order to optimize this, we avoid detaching until the next attach
   * unless we are unmounting.
   */
  function useAnimatedPropsLifecycle(node) {
    var prevNodeRef = (0, _react.useRef)(null);
    var isUnmountingRef = (0, _react.useRef)(false);
    (0, _react.useEffect)(() => {
      // It is ok for multiple components to call `flushQueue` because it noops
      // if the queue is empty. When multiple animated components are mounted at
      // the same time. Only first component flushes the queue and the others will noop.
      NativeAnimatedHelper.default.API.flushQueue();
    });
    (0, useLayoutEffect.default)(() => {
      isUnmountingRef.current = false;
      return () => {
        isUnmountingRef.current = true;
      };
    }, []);
    (0, useLayoutEffect.default)(() => {
      node.__attach();
      if (prevNodeRef.current != null) {
        var prevNode = prevNodeRef.current;
        // TODO: Stop restoring default values (unless `reset` is called).
        prevNode.__restoreDefaultValues();
        prevNode.__detach();
        prevNodeRef.current = null;
      }
      return () => {
        if (isUnmountingRef.current) {
          // NOTE: Do not restore default values on unmount, see D18197735.
          node.__detach();
        } else {
          prevNodeRef.current = node;
        }
      };
    }, [node]);
  }
  function getEventTarget(instance) {
    return typeof instance === 'object' && typeof (instance == null ? void 0 : instance.getScrollableNode) === 'function' ?
    // $FlowFixMe[incompatible-use] - Legacy instance assumptions.
    instance.getScrollableNode() : instance;
  }

  // $FlowFixMe[unclear-type] - Legacy instance assumptions.
  function isFabricInstance(instance) {
    var _instance$getScrollRe;
    return hasFabricHandle(instance) ||
    // Some components have a setNativeProps function but aren't a host component
    // such as lists like FlatList and SectionList. These should also use
    // forceUpdate in Fabric since setNativeProps doesn't exist on the underlying
    // host component. This crazy hack is essentially special casing those lists and
    // ScrollView itself to use forceUpdate in Fabric.
    // If these components end up using forwardRef then these hacks can go away
    // as instance would actually be the underlying host component and the above check
    // would be sufficient.
    hasFabricHandle(instance == null ? void 0 : instance.getNativeScrollRef == null ? void 0 : instance.getNativeScrollRef()) || hasFabricHandle(instance == null ? void 0 : instance.getScrollResponder == null ? void 0 : (_instance$getScrollRe = instance.getScrollResponder()) == null ? void 0 : _instance$getScrollRe.getNativeScrollRef == null ? void 0 : _instance$getScrollRe.getNativeScrollRef());
  }

  // $FlowFixMe[unclear-type] - Legacy instance assumptions.
  function hasFabricHandle(instance) {
    var _instance$_internalIn, _instance$_internalIn2;
    // eslint-disable-next-line dot-notation
    return (instance == null ? void 0 : (_instance$_internalIn = instance['_internalInstanceHandle']) == null ? void 0 : (_instance$_internalIn2 = _instance$_internalIn.stateNode) == null ? void 0 : _instance$_internalIn2.canonical) != null;
  }
},194,[37,195,196,209,201,9,122],"node_modules/react-native-web/dist/vendor/react-native/Animated/useAnimatedProps.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _AnimatedEvent = require(_dependencyMap[1], "../AnimatedEvent");
  var _AnimatedNode = require(_dependencyMap[2], "./AnimatedNode");
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _AnimatedStyle = require(_dependencyMap[3], "./AnimatedStyle");
  var AnimatedStyle = _interopDefault(_AnimatedStyle);
  var _NativeAnimatedHelper = require(_dependencyMap[4], "../NativeAnimatedHelper");
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _fbjsLibInvariant = require(_dependencyMap[5], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  class AnimatedProps extends AnimatedNode.default {
    constructor(props, callback) {
      super();
      if (props.style) {
        props = (0, _objectSpread.default)((0, _objectSpread.default)({}, props), {}, {
          style: new AnimatedStyle.default(props.style)
        });
      }
      this._props = props;
      this._callback = callback;
    }
    __getValue() {
      var props = {};
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof AnimatedNode.default) {
          if (!value.__isNative || value instanceof AnimatedStyle.default) {
            // We cannot use value of natively driven nodes this way as the value we have access from
            // JS may not be up to date.
            props[key] = value.__getValue();
          }
        } else if (value instanceof _AnimatedEvent.AnimatedEvent) {
          props[key] = value.__getHandler();
        } else {
          props[key] = value;
        }
      }
      return props;
    }
    __getAnimatedValue() {
      var props = {};
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof AnimatedNode.default) {
          props[key] = value.__getAnimatedValue();
        }
      }
      return props;
    }
    __attach() {
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof AnimatedNode.default) {
          value.__addChild(this);
        }
      }
    }
    __detach() {
      if (this.__isNative && this._animatedView) {
        this.__disconnectAnimatedView();
      }
      this._animatedView = null;
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof AnimatedNode.default) {
          value.__removeChild(this);
        }
      }
      super.__detach();
    }
    update() {
      this._callback();
    }
    __makeNative() {
      if (!this.__isNative) {
        this.__isNative = true;
        for (var key in this._props) {
          var value = this._props[key];
          if (value instanceof AnimatedNode.default) {
            value.__makeNative();
          }
        }
        if (this._animatedView) {
          this.__connectAnimatedView();
        }
      }
    }
    setNativeView(animatedView) {
      if (this._animatedView === animatedView) {
        return;
      }
      this._animatedView = animatedView;
      if (this.__isNative) {
        this.__connectAnimatedView();
      }
    }
    __connectAnimatedView() {
      (0, invariant.default)(this.__isNative, 'Expected node to be marked as "native"');
      var nativeViewTag = this._animatedView;
      (0, invariant.default)(nativeViewTag != null, 'Unable to locate attached view in the native tree');
      NativeAnimatedHelper.default.API.connectAnimatedNodeToView(this.__getNativeTag(), nativeViewTag);
    }
    __disconnectAnimatedView() {
      (0, invariant.default)(this.__isNative, 'Expected node to be marked as "native"');
      var nativeViewTag = this._animatedView;
      (0, invariant.default)(nativeViewTag != null, 'Unable to locate attached view in the native tree');
      NativeAnimatedHelper.default.API.disconnectAnimatedNodeFromView(this.__getNativeTag(), nativeViewTag);
    }
    __restoreDefaultValues() {
      // When using the native driver, view properties need to be restored to
      // their default values manually since react no longer tracks them. This
      // is needed to handle cases where a prop driven by native animated is removed
      // after having been changed natively by an animation.
      if (this.__isNative) {
        NativeAnimatedHelper.default.API.restoreDefaultValues(this.__getNativeTag());
      }
    }
    __getNativeConfig() {
      var propsConfig = {};
      for (var propKey in this._props) {
        var value = this._props[propKey];
        if (value instanceof AnimatedNode.default) {
          value.__makeNative();
          propsConfig[propKey] = value.__getNativeTag();
        }
      }
      return {
        type: 'props',
        props: propsConfig
      };
    }
  }
  var _default = AnimatedProps;
},195,[37,196,200,207,201,17],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedProps.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.attachNativeEvent = attachNativeEvent;
  Object.defineProperty(exports, "AnimatedEvent", {
    enumerable: true,
    get: function () {
      return AnimatedEvent;
    }
  });
  var _nodesAnimatedValue = require(_dependencyMap[0], "./nodes/AnimatedValue");
  var AnimatedValue = _interopDefault(_nodesAnimatedValue);
  var _NativeAnimatedHelper = require(_dependencyMap[1], "./NativeAnimatedHelper");
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _fbjsLibInvariant = require(_dependencyMap[2], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var __DEV__ = process.env.NODE_ENV !== 'production';
  function attachNativeEvent(viewRef, eventName, argMapping) {
    // Find animated values in `argMapping` and create an array representing their
    // key path inside the `nativeEvent` object. Ex.: ['contentOffset', 'x'].
    var eventMappings = [];
    var traverse = (value, path) => {
      if (value instanceof AnimatedValue.default) {
        value.__makeNative();
        eventMappings.push({
          nativeEventPath: path,
          animatedValueTag: value.__getNativeTag()
        });
      } else if (typeof value === 'object') {
        for (var _key in value) {
          traverse(value[_key], path.concat(_key));
        }
      }
    };
    (0, invariant.default)(argMapping[0] && argMapping[0].nativeEvent, 'Native driven events only support animated values contained inside `nativeEvent`.');

    // Assume that the event containing `nativeEvent` is always the first argument.
    traverse(argMapping[0].nativeEvent, []);
    if (viewRef != null) {
      eventMappings.forEach(mapping => {
        NativeAnimatedHelper.default.API.addAnimatedEventToView(viewRef, eventName, mapping);
      });
    }
    return {
      detach() {
        if (viewRef != null) {
          eventMappings.forEach(mapping => {
            NativeAnimatedHelper.default.API.removeAnimatedEventFromView(viewRef, eventName,
            // $FlowFixMe[incompatible-call]
            mapping.animatedValueTag);
          });
        }
      }
    };
  }
  function validateMapping(argMapping, args) {
    var validate = (recMapping, recEvt, key) => {
      if (recMapping instanceof AnimatedValue.default) {
        (0, invariant.default)(typeof recEvt === 'number', 'Bad mapping of event key ' + key + ', should be number but got ' + typeof recEvt);
        return;
      }
      if (typeof recEvt === 'number') {
        (0, invariant.default)(recMapping instanceof AnimatedValue.default, 'Bad mapping of type ' + typeof recMapping + ' for key ' + key + ', event value must map to AnimatedValue');
        return;
      }
      (0, invariant.default)(typeof recMapping === 'object', 'Bad mapping of type ' + typeof recMapping + ' for key ' + key);
      (0, invariant.default)(typeof recEvt === 'object', 'Bad event of type ' + typeof recEvt + ' for key ' + key);
      for (var mappingKey in recMapping) {
        validate(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
      }
    };
    (0, invariant.default)(args.length >= argMapping.length, 'Event has less arguments than mapping');
    argMapping.forEach((mapping, idx) => {
      validate(mapping, args[idx], 'arg' + idx);
    });
  }
  class AnimatedEvent {
    constructor(argMapping, config) {
      this._listeners = [];
      this._argMapping = argMapping;
      if (config == null) {
        console.warn('Animated.event now requires a second argument for options');
        config = {
          useNativeDriver: false
        };
      }
      if (config.listener) {
        this.__addListener(config.listener);
      }
      this._callListeners = this._callListeners.bind(this);
      this._attachedEvent = null;
      this.__isNative = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
    }
    __addListener(callback) {
      this._listeners.push(callback);
    }
    __removeListener(callback) {
      this._listeners = this._listeners.filter(listener => listener !== callback);
    }
    __attach(viewRef, eventName) {
      (0, invariant.default)(this.__isNative, 'Only native driven events need to be attached.');
      this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping);
    }
    __detach(viewTag, eventName) {
      (0, invariant.default)(this.__isNative, 'Only native driven events need to be detached.');
      this._attachedEvent && this._attachedEvent.detach();
    }
    __getHandler() {
      var _this = this;
      if (this.__isNative) {
        if (__DEV__) {
          var _validatedMapping = false;
          return function () {
            for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
              args[_key2] = arguments[_key2];
            }
            if (!_validatedMapping) {
              validateMapping(_this._argMapping, args);
              _validatedMapping = true;
            }
            _this._callListeners(...args);
          };
        } else {
          return this._callListeners;
        }
      }
      var validatedMapping = false;
      return function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
          args[_key3] = arguments[_key3];
        }
        if (__DEV__ && !validatedMapping) {
          validateMapping(_this._argMapping, args);
          validatedMapping = true;
        }
        var traverse = (recMapping, recEvt, key) => {
          if (recMapping instanceof AnimatedValue.default) {
            if (typeof recEvt === 'number') {
              recMapping.setValue(recEvt);
            }
          } else if (typeof recMapping === 'object') {
            for (var mappingKey in recMapping) {
              /* $FlowFixMe(>=0.120.0) This comment suppresses an error found
               * when Flow v0.120 was deployed. To see the error, delete this
               * comment and run Flow. */
              traverse(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
            }
          }
        };
        _this._argMapping.forEach((mapping, idx) => {
          traverse(mapping, args[idx], 'arg' + idx);
        });
        _this._callListeners(...args);
      };
    }
    _callListeners() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
        args[_key4] = arguments[_key4];
      }
      this._listeners.forEach(listener => listener(...args));
    }
  }
},196,[197,201,17],"node_modules/react-native-web/dist/vendor/react-native/Animated/AnimatedEvent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0], "./AnimatedInterpolation");
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedWithChildren = require(_dependencyMap[1], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _exportsInteractionManager = require(_dependencyMap[2], "../../../../exports/InteractionManager");
  var InteractionManager = _interopDefault(_exportsInteractionManager);
  var _NativeAnimatedHelper = require(_dependencyMap[3], "../NativeAnimatedHelper");
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var NativeAnimatedAPI = NativeAnimatedHelper.default.API;

  /**
   * Animated works by building a directed acyclic graph of dependencies
   * transparently when you render your Animated components.
   *
   *               new Animated.Value(0)
   *     .interpolate()        .interpolate()    new Animated.Value(1)
   *         opacity               translateY      scale
   *          style                         transform
   *         View#234                         style
   *                                         View#123
   *
   * A) Top Down phase
   * When an Animated.Value is updated, we recursively go down through this
   * graph in order to find leaf nodes: the views that we flag as needing
   * an update.
   *
   * B) Bottom Up phase
   * When a view is flagged as needing an update, we recursively go back up
   * in order to build the new value that it needs. The reason why we need
   * this two-phases process is to deal with composite props such as
   * transform which can receive values from multiple parents.
   */
  function _flush(rootNode) {
    var animatedStyles = new Set();
    function findAnimatedStyles(node) {
      /* $FlowFixMe[prop-missing] (>=0.68.0 site=react_native_fb) This comment
       * suppresses an error found when Flow v0.68 was deployed. To see the error
       * delete this comment and run Flow. */
      if (typeof node.update === 'function') {
        animatedStyles.add(node);
      } else {
        node.__getChildren().forEach(findAnimatedStyles);
      }
    }
    findAnimatedStyles(rootNode);
    // $FlowFixMe[prop-missing]
    animatedStyles.forEach(animatedStyle => animatedStyle.update());
  }

  /**
   * Some operations are executed only on batch end, which is _mostly_ scheduled when
   * Animated component props change. For some of the changes which require immediate execution
   * (e.g. setValue), we create a separate batch in case none is scheduled.
   */
  function _executeAsAnimatedBatch(id, operation) {
    NativeAnimatedAPI.setWaitingForIdentifier(id);
    operation();
    NativeAnimatedAPI.unsetWaitingForIdentifier(id);
  }

  /**
   * Standard value for driving animations.  One `Animated.Value` can drive
   * multiple properties in a synchronized fashion, but can only be driven by one
   * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,
   * or calling `setValue`) will stop any previous ones.
   *
   * See https://reactnative.dev/docs/animatedvalue
   */
  class AnimatedValue extends AnimatedWithChildren.default {
    constructor(value, config) {
      super();
      if (typeof value !== 'number') {
        throw new Error('AnimatedValue: Attempting to set value to undefined');
      }
      this._startingValue = this._value = value;
      this._offset = 0;
      this._animation = null;
      if (config && config.useNativeDriver) {
        this.__makeNative();
      }
    }
    __detach() {
      if (this.__isNative) {
        NativeAnimatedAPI.getValue(this.__getNativeTag(), value => {
          this._value = value - this._offset;
        });
      }
      this.stopAnimation();
      super.__detach();
    }
    __getValue() {
      return this._value + this._offset;
    }

    /**
     * Directly set the value.  This will stop any animations running on the value
     * and update all the bound properties.
     *
     * See https://reactnative.dev/docs/animatedvalue#setvalue
     */
    setValue(value) {
      if (this._animation) {
        this._animation.stop();
        this._animation = null;
      }
      this._updateValue(value, !this.__isNative /* don't perform a flush for natively driven values */);
      if (this.__isNative) {
        _executeAsAnimatedBatch(this.__getNativeTag().toString(), () => NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), value));
      }
    }

    /**
     * Sets an offset that is applied on top of whatever value is set, whether via
     * `setValue`, an animation, or `Animated.event`.  Useful for compensating
     * things like the start of a pan gesture.
     *
     * See https://reactnative.dev/docs/animatedvalue#setoffset
     */
    setOffset(offset) {
      this._offset = offset;
      if (this.__isNative) {
        NativeAnimatedAPI.setAnimatedNodeOffset(this.__getNativeTag(), offset);
      }
    }

    /**
     * Merges the offset value into the base value and resets the offset to zero.
     * The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvalue#flattenoffset
     */
    flattenOffset() {
      this._value += this._offset;
      this._offset = 0;
      if (this.__isNative) {
        NativeAnimatedAPI.flattenAnimatedNodeOffset(this.__getNativeTag());
      }
    }

    /**
     * Sets the offset value to the base value, and resets the base value to zero.
     * The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvalue#extractoffset
     */
    extractOffset() {
      this._offset += this._value;
      this._value = 0;
      if (this.__isNative) {
        NativeAnimatedAPI.extractAnimatedNodeOffset(this.__getNativeTag());
      }
    }

    /**
     * Stops any running animation or tracking. `callback` is invoked with the
     * final value after stopping the animation, which is useful for updating
     * state to match the animation position with layout.
     *
     * See https://reactnative.dev/docs/animatedvalue#stopanimation
     */
    stopAnimation(callback) {
      this.stopTracking();
      this._animation && this._animation.stop();
      this._animation = null;
      if (callback) {
        if (this.__isNative) {
          NativeAnimatedAPI.getValue(this.__getNativeTag(), callback);
        } else {
          callback(this.__getValue());
        }
      }
    }

    /**
     * Stops any animation and resets the value to its original.
     *
     * See https://reactnative.dev/docs/animatedvalue#resetanimation
     */
    resetAnimation(callback) {
      this.stopAnimation(callback);
      this._value = this._startingValue;
      if (this.__isNative) {
        NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), this._startingValue);
      }
    }
    __onAnimatedValueUpdateReceived(value) {
      this._updateValue(value, false /*flush*/);
    }

    /**
     * Interpolates the value before updating the property, e.g. mapping 0-1 to
     * 0-10.
     */
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }

    /**
     * Typically only used internally, but could be used by a custom Animation
     * class.
     *
     * See https://reactnative.dev/docs/animatedvalue#animate
     */
    animate(animation, callback) {
      var handle = null;
      if (animation.__isInteraction) {
        handle = InteractionManager.default.createInteractionHandle();
      }
      var previousAnimation = this._animation;
      this._animation && this._animation.stop();
      this._animation = animation;
      animation.start(this._value, value => {
        // Natively driven animations will never call into that callback
        this._updateValue(value, true /* flush */);
      }, result => {
        this._animation = null;
        if (handle !== null) {
          InteractionManager.default.clearInteractionHandle(handle);
        }
        callback && callback(result);
      }, previousAnimation, this);
    }

    /**
     * Typically only used internally.
     */
    stopTracking() {
      this._tracking && this._tracking.__detach();
      this._tracking = null;
    }

    /**
     * Typically only used internally.
     */
    track(tracking) {
      this.stopTracking();
      this._tracking = tracking;
      // Make sure that the tracking animation starts executing
      this._tracking && this._tracking.update();
    }
    _updateValue(value, flush) {
      if (value === undefined) {
        throw new Error('AnimatedValue: Attempting to set value to undefined');
      }
      this._value = value;
      if (flush) {
        _flush(this);
      }
      super.__callListeners(this.__getValue());
    }
    __getNativeConfig() {
      return {
        type: 'value',
        value: this._value,
        offset: this._offset
      };
    }
  }
  var _default = AnimatedValue;
},197,[198,199,178,201],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /* eslint no-bitwise: 0 */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _AnimatedWithChildren = require(_dependencyMap[1], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _NativeAnimatedHelper = require(_dependencyMap[2], "../NativeAnimatedHelper");
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _fbjsLibInvariant = require(_dependencyMap[3], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _reactNativeNormalizeColors = require(_dependencyMap[4], "@react-native/normalize-colors");
  var normalizeColor = _interopDefault(_reactNativeNormalizeColors);
  var __DEV__ = process.env.NODE_ENV !== 'production';
  var linear = t => t;

  /**
   * Very handy helper to map input ranges to output ranges with an easing
   * function and custom behavior outside of the ranges.
   */
  function createInterpolation(config) {
    if (config.outputRange && typeof config.outputRange[0] === 'string') {
      return createInterpolationFromStringOutputRange(config);
    }
    var outputRange = config.outputRange;
    var inputRange = config.inputRange;
    if (__DEV__) {
      checkInfiniteRange('outputRange', outputRange);
      checkInfiniteRange('inputRange', inputRange);
      checkValidInputRange(inputRange);
      (0, invariant.default)(inputRange.length === outputRange.length, 'inputRange (' + inputRange.length + ') and outputRange (' + outputRange.length + ') must have the same length');
    }
    var easing = config.easing || linear;
    var extrapolateLeft = 'extend';
    if (config.extrapolateLeft !== undefined) {
      extrapolateLeft = config.extrapolateLeft;
    } else if (config.extrapolate !== undefined) {
      extrapolateLeft = config.extrapolate;
    }
    var extrapolateRight = 'extend';
    if (config.extrapolateRight !== undefined) {
      extrapolateRight = config.extrapolateRight;
    } else if (config.extrapolate !== undefined) {
      extrapolateRight = config.extrapolate;
    }
    return input => {
      (0, invariant.default)(typeof input === 'number', 'Cannot interpolation an input which is not a number');
      var range = findRange(input, inputRange);
      return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
    };
  }
  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
    var result = input;

    // Extrapolate
    if (result < inputMin) {
      if (extrapolateLeft === 'identity') {
        return result;
      } else if (extrapolateLeft === 'clamp') {
        result = inputMin;
      } else if (extrapolateLeft === 'extend') {
        // noop
      }
    }
    if (result > inputMax) {
      if (extrapolateRight === 'identity') {
        return result;
      } else if (extrapolateRight === 'clamp') {
        result = inputMax;
      } else if (extrapolateRight === 'extend') {
        // noop
      }
    }
    if (outputMin === outputMax) {
      return outputMin;
    }
    if (inputMin === inputMax) {
      if (input <= inputMin) {
        return outputMin;
      }
      return outputMax;
    }

    // Input Range
    if (inputMin === -Infinity) {
      result = -result;
    } else if (inputMax === Infinity) {
      result = result - inputMin;
    } else {
      result = (result - inputMin) / (inputMax - inputMin);
    }

    // Easing
    result = easing(result);

    // Output Range
    if (outputMin === -Infinity) {
      result = -result;
    } else if (outputMax === Infinity) {
      result = result + outputMin;
    } else {
      result = result * (outputMax - outputMin) + outputMin;
    }
    return result;
  }
  function colorToRgba(input) {
    var normalizedColor = (0, normalizeColor.default)(input);
    if (normalizedColor === null || typeof normalizedColor !== 'number') {
      return input;
    }
    normalizedColor = normalizedColor || 0;
    var r = (normalizedColor & 0xff000000) >>> 24;
    var g = (normalizedColor & 0x00ff0000) >>> 16;
    var b = (normalizedColor & 0x0000ff00) >>> 8;
    var a = (normalizedColor & 0x000000ff) / 255;
    return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
  }
  var stringShapeRegex = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;

  /**
   * Supports string shapes by extracting numbers so new values can be computed,
   * and recombines those values into new strings of the same shape.  Supports
   * things like:
   *
   *   rgba(123, 42, 99, 0.36) // colors
   *   -45deg                  // values with units
   */
  function createInterpolationFromStringOutputRange(config) {
    var outputRange = config.outputRange;
    (0, invariant.default)(outputRange.length >= 2, 'Bad output range');
    outputRange = outputRange.map(colorToRgba);
    checkPattern(outputRange);

    // ['rgba(0, 100, 200, 0)', 'rgba(50, 150, 250, 0.5)']
    // ->
    // [
    //   [0, 50],
    //   [100, 150],
    //   [200, 250],
    //   [0, 0.5],
    // ]
    /* $FlowFixMe[incompatible-use] (>=0.18.0): `outputRange[0].match()` can
     * return `null`. Need to guard against this possibility. */
    var outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
    outputRange.forEach(value => {
      /* $FlowFixMe[incompatible-use] (>=0.18.0): `value.match()` can return
       * `null`. Need to guard against this possibility. */
      value.match(stringShapeRegex).forEach((number, i) => {
        outputRanges[i].push(+number);
      });
    });
    var interpolations = outputRange[0].match(stringShapeRegex)
    /* $FlowFixMe[incompatible-use] (>=0.18.0): `outputRange[0].match()` can
     * return `null`. Need to guard against this possibility. */
    /* $FlowFixMe[incompatible-call] (>=0.18.0): `outputRange[0].match()` can
     * return `null`. Need to guard against this possibility. */.map((value, i) => {
      return createInterpolation((0, _objectSpread.default)((0, _objectSpread.default)({}, config), {}, {
        outputRange: outputRanges[i]
      }));
    });

    // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to
    // round the opacity (4th column).
    var shouldRound = isRgbOrRgba(outputRange[0]);
    return input => {
      var i = 0;
      // 'rgba(0, 100, 200, 0)'
      // ->
      // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'
      return outputRange[0].replace(stringShapeRegex, () => {
        var val = +interpolations[i++](input);
        if (shouldRound) {
          val = i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;
        }
        return String(val);
      });
    };
  }
  function isRgbOrRgba(range) {
    return typeof range === 'string' && range.startsWith('rgb');
  }
  function checkPattern(arr) {
    var pattern = arr[0].replace(stringShapeRegex, '');
    for (var i = 1; i < arr.length; ++i) {
      (0, invariant.default)(pattern === arr[i].replace(stringShapeRegex, ''), 'invalid pattern ' + arr[0] + ' and ' + arr[i]);
    }
  }
  function findRange(input, inputRange) {
    var i;
    for (i = 1; i < inputRange.length - 1; ++i) {
      if (inputRange[i] >= input) {
        break;
      }
    }
    return i - 1;
  }
  function checkValidInputRange(arr) {
    (0, invariant.default)(arr.length >= 2, 'inputRange must have at least 2 elements');
    var message = 'inputRange must be monotonically non-decreasing ' + String(arr);
    for (var i = 1; i < arr.length; ++i) {
      (0, invariant.default)(arr[i] >= arr[i - 1], message);
    }
  }
  function checkInfiniteRange(name, arr) {
    (0, invariant.default)(arr.length >= 2, name + ' must have at least 2 elements');
    (0, invariant.default)(arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity,
    /* $FlowFixMe[incompatible-type] (>=0.13.0) - In the addition expression
     * below this comment, one or both of the operands may be something that
     * doesn't cleanly convert to a string, like undefined, null, and object,
     * etc. If you really mean this implicit string conversion, you can do
     * something like String(myThing) */
    name + 'cannot be ]-infinity;+infinity[ ' + arr);
  }
  class AnimatedInterpolation extends AnimatedWithChildren.default {
    // Export for testing.

    constructor(parent, config) {
      super();
      this._parent = parent;
      this._config = config;
      this._interpolation = createInterpolation(config);
    }
    __makeNative(platformConfig) {
      this._parent.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      var parentValue = this._parent.__getValue();
      (0, invariant.default)(typeof parentValue === 'number', 'Cannot interpolate an input which is not a number.');
      return this._interpolation(parentValue);
    }
    interpolate(config) {
      return new AnimatedInterpolation(this, config);
    }
    __attach() {
      this._parent.__addChild(this);
    }
    __detach() {
      this._parent.__removeChild(this);
      super.__detach();
    }
    __transformDataType(range) {
      return range.map(NativeAnimatedHelper.default.transformDataType);
    }
    __getNativeConfig() {
      if (__DEV__) {
        NativeAnimatedHelper.default.validateInterpolation(this._config);
      }
      return {
        inputRange: this._config.inputRange,
        // Only the `outputRange` can contain strings so we don't need to transform `inputRange` here
        outputRange: this.__transformDataType(this._config.outputRange),
        extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || 'extend',
        extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || 'extend',
        type: 'interpolation'
      };
    }
  }
  AnimatedInterpolation.__createInterpolation = createInterpolation;
  var _default = AnimatedInterpolation;
},198,[37,199,201,17,63],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedInterpolation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersCreateForOfIteratorHelperLoose = require(_dependencyMap[0], "@babel/runtime/helpers/createForOfIteratorHelperLoose");
  var _createForOfIteratorHelperLoose = _interopDefault(_babelRuntimeHelpersCreateForOfIteratorHelperLoose);
  var _AnimatedNode = require(_dependencyMap[1], "./AnimatedNode");
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _NativeAnimatedHelper = require(_dependencyMap[2], "../NativeAnimatedHelper");
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  class AnimatedWithChildren extends AnimatedNode.default {
    constructor() {
      super();
      this._children = [];
    }
    __makeNative(platformConfig) {
      if (!this.__isNative) {
        this.__isNative = true;
        for (var _iterator = (0, _createForOfIteratorHelperLoose.default)(this._children), _step; !(_step = _iterator()).done;) {
          var child = _step.value;
          child.__makeNative(platformConfig);
          NativeAnimatedHelper.default.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
        }
      }
      super.__makeNative(platformConfig);
    }
    __addChild(child) {
      if (this._children.length === 0) {
        this.__attach();
      }
      this._children.push(child);
      if (this.__isNative) {
        // Only accept "native" animated nodes as children
        child.__makeNative(this.__getPlatformConfig());
        NativeAnimatedHelper.default.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
      }
    }
    __removeChild(child) {
      var index = this._children.indexOf(child);
      if (index === -1) {
        console.warn("Trying to remove a child that doesn't exist");
        return;
      }
      if (this.__isNative && child.__isNative) {
        NativeAnimatedHelper.default.API.disconnectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
      }
      this._children.splice(index, 1);
      if (this._children.length === 0) {
        this.__detach();
      }
    }
    __getChildren() {
      return this._children;
    }
    __callListeners(value) {
      super.__callListeners(value);
      if (!this.__isNative) {
        for (var _iterator2 = (0, _createForOfIteratorHelperLoose.default)(this._children), _step2; !(_step2 = _iterator2()).done;) {
          var child = _step2.value;
          // $FlowFixMe[method-unbinding] added when improving typing for this parameters
          if (child.__getValue) {
            child.__callListeners(child.__getValue());
          }
        }
      }
    }
  }
  var _default = AnimatedWithChildren;
},199,[173,200,201],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedWithChildren.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _NativeAnimatedHelper = require(_dependencyMap[0], "../NativeAnimatedHelper");
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _fbjsLibInvariant = require(_dependencyMap[1], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var NativeAnimatedAPI = NativeAnimatedHelper.default.API;
  var _uniqueId = 1;

  // Note(vjeux): this would be better as an interface but flow doesn't
  // support them yet
  class AnimatedNode {
    __attach() {}
    __detach() {
      if (this.__isNative && this.__nativeTag != null) {
        NativeAnimatedHelper.default.API.dropAnimatedNode(this.__nativeTag);
        this.__nativeTag = undefined;
      }
    }
    __getValue() {}
    __getAnimatedValue() {
      return this.__getValue();
    }
    __addChild(child) {}
    __removeChild(child) {}
    __getChildren() {
      return [];
    }

    /* Methods and props used by native Animated impl */

    constructor() {
      this._listeners = {};
    }
    __makeNative(platformConfig) {
      if (!this.__isNative) {
        throw new Error('This node cannot be made a "native" animated node');
      }
      this._platformConfig = platformConfig;
      if (this.hasListeners()) {
        this._startListeningToNativeValueUpdates();
      }
    }

    /**
     * Adds an asynchronous listener to the value so you can observe updates from
     * animations.  This is useful because there is no way to
     * synchronously read the value because it might be driven natively.
     *
     * See https://reactnative.dev/docs/animatedvalue#addlistener
     */
    addListener(callback) {
      var id = String(_uniqueId++);
      this._listeners[id] = callback;
      if (this.__isNative) {
        this._startListeningToNativeValueUpdates();
      }
      return id;
    }

    /**
     * Unregister a listener. The `id` param shall match the identifier
     * previously returned by `addListener()`.
     *
     * See https://reactnative.dev/docs/animatedvalue#removelistener
     */
    removeListener(id) {
      delete this._listeners[id];
      if (this.__isNative && !this.hasListeners()) {
        this._stopListeningForNativeValueUpdates();
      }
    }

    /**
     * Remove all registered listeners.
     *
     * See https://reactnative.dev/docs/animatedvalue#removealllisteners
     */
    removeAllListeners() {
      this._listeners = {};
      if (this.__isNative) {
        this._stopListeningForNativeValueUpdates();
      }
    }
    hasListeners() {
      return !!Object.keys(this._listeners).length;
    }
    _startListeningToNativeValueUpdates() {
      if (this.__nativeAnimatedValueListener && !this.__shouldUpdateListenersForNewNativeTag) {
        return;
      }
      if (this.__shouldUpdateListenersForNewNativeTag) {
        this.__shouldUpdateListenersForNewNativeTag = false;
        this._stopListeningForNativeValueUpdates();
      }
      NativeAnimatedAPI.startListeningToAnimatedNodeValue(this.__getNativeTag());
      this.__nativeAnimatedValueListener = NativeAnimatedHelper.default.nativeEventEmitter.addListener('onAnimatedValueUpdate', data => {
        if (data.tag !== this.__getNativeTag()) {
          return;
        }
        this.__onAnimatedValueUpdateReceived(data.value);
      });
    }
    __onAnimatedValueUpdateReceived(value) {
      this.__callListeners(value);
    }
    __callListeners(value) {
      for (var _key in this._listeners) {
        this._listeners[_key]({
          value
        });
      }
    }
    _stopListeningForNativeValueUpdates() {
      if (!this.__nativeAnimatedValueListener) {
        return;
      }
      this.__nativeAnimatedValueListener.remove();
      this.__nativeAnimatedValueListener = null;
      NativeAnimatedAPI.stopListeningToAnimatedNodeValue(this.__getNativeTag());
    }
    __getNativeTag() {
      var _this$__nativeTag;
      NativeAnimatedHelper.default.assertNativeAnimatedModule();
      (0, invariant.default)(this.__isNative, 'Attempt to get native tag from node not marked as "native"');
      var nativeTag = (_this$__nativeTag = this.__nativeTag) !== null && _this$__nativeTag !== void 0 ? _this$__nativeTag : NativeAnimatedHelper.default.generateNewNodeTag();
      if (this.__nativeTag == null) {
        this.__nativeTag = nativeTag;
        var config = this.__getNativeConfig();
        if (this._platformConfig) {
          config.platformConfig = this._platformConfig;
        }
        NativeAnimatedHelper.default.API.createAnimatedNode(nativeTag, config);
        this.__shouldUpdateListenersForNewNativeTag = true;
      }
      return nativeTag;
    }
    __getNativeConfig() {
      throw new Error('This JS animated node type cannot be used as native animated node');
    }
    toJSON() {
      return this.__getValue();
    }
    __getPlatformConfig() {
      return this._platformConfig;
    }
    __setPlatformConfig(platformConfig) {
      this._platformConfig = platformConfig;
    }
  }
  var _default = AnimatedNode;
},200,[201,17],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedNode.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "API", {
    enumerable: true,
    get: function () {
      return API;
    }
  });
  Object.defineProperty(exports, "isSupportedColorStyleProp", {
    enumerable: true,
    get: function () {
      return isSupportedColorStyleProp;
    }
  });
  Object.defineProperty(exports, "isSupportedStyleProp", {
    enumerable: true,
    get: function () {
      return isSupportedStyleProp;
    }
  });
  Object.defineProperty(exports, "isSupportedTransformProp", {
    enumerable: true,
    get: function () {
      return isSupportedTransformProp;
    }
  });
  Object.defineProperty(exports, "isSupportedInterpolationParam", {
    enumerable: true,
    get: function () {
      return isSupportedInterpolationParam;
    }
  });
  Object.defineProperty(exports, "addWhitelistedStyleProp", {
    enumerable: true,
    get: function () {
      return addWhitelistedStyleProp;
    }
  });
  Object.defineProperty(exports, "addWhitelistedTransformProp", {
    enumerable: true,
    get: function () {
      return addWhitelistedTransformProp;
    }
  });
  Object.defineProperty(exports, "addWhitelistedInterpolationParam", {
    enumerable: true,
    get: function () {
      return addWhitelistedInterpolationParam;
    }
  });
  Object.defineProperty(exports, "validateStyles", {
    enumerable: true,
    get: function () {
      return validateStyles;
    }
  });
  Object.defineProperty(exports, "validateTransform", {
    enumerable: true,
    get: function () {
      return validateTransform;
    }
  });
  Object.defineProperty(exports, "validateInterpolation", {
    enumerable: true,
    get: function () {
      return validateInterpolation;
    }
  });
  Object.defineProperty(exports, "generateNewNodeTag", {
    enumerable: true,
    get: function () {
      return generateNewNodeTag;
    }
  });
  Object.defineProperty(exports, "generateNewAnimationId", {
    enumerable: true,
    get: function () {
      return generateNewAnimationId;
    }
  });
  Object.defineProperty(exports, "assertNativeAnimatedModule", {
    enumerable: true,
    get: function () {
      return assertNativeAnimatedModule;
    }
  });
  Object.defineProperty(exports, "shouldUseNativeDriver", {
    enumerable: true,
    get: function () {
      return shouldUseNativeDriver;
    }
  });
  Object.defineProperty(exports, "transformDataType", {
    enumerable: true,
    get: function () {
      return transformDataType;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _NativeAnimatedModule = require(_dependencyMap[1], "./NativeAnimatedModule");
  var NativeAnimatedNonTurboModule = _interopDefault(_NativeAnimatedModule);
  var _NativeAnimatedTurboModule = require(_dependencyMap[2], "./NativeAnimatedTurboModule");
  var NativeAnimatedTurboModule = _interopDefault(_NativeAnimatedTurboModule);
  var _EventEmitterNativeEventEmitter = require(_dependencyMap[3], "../EventEmitter/NativeEventEmitter");
  var NativeEventEmitter = _interopDefault(_EventEmitterNativeEventEmitter);
  var _UtilitiesPlatform = require(_dependencyMap[4], "../Utilities/Platform");
  var Platform = _interopDefault(_UtilitiesPlatform);
  var _ReactNativeReactNativeFeatureFlags = require(_dependencyMap[5], "../ReactNative/ReactNativeFeatureFlags");
  var ReactNativeFeatureFlags = _interopDefault(_ReactNativeReactNativeFeatureFlags);
  var _fbjsLibInvariant = require(_dependencyMap[6], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _EventEmitterRCTDeviceEventEmitter = require(_dependencyMap[7], "../EventEmitter/RCTDeviceEventEmitter");
  var RCTDeviceEventEmitter = _interopDefault(_EventEmitterRCTDeviceEventEmitter);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  // TODO T69437152 @petetheheat - Delete this fork when Fabric ships to 100%.
  var NativeAnimatedModule = Platform.default.OS === 'ios' && global.RN$Bridgeless === true ? NativeAnimatedTurboModule.default : NativeAnimatedNonTurboModule.default;
  var __nativeAnimatedNodeTagCount = 1; /* used for animated nodes */
  var __nativeAnimationIdCount = 1; /* used for started animations */

  var nativeEventEmitter;
  var waitingForQueuedOperations = new Set();
  var queueOperations = false;
  var queue = [];
  // $FlowFixMe
  var singleOpQueue = [];
  var useSingleOpBatching = false;
  Platform.default.OS === 'android' && !!(NativeAnimatedModule != null && NativeAnimatedModule.queueAndExecuteBatchedOperations) && ReactNativeFeatureFlags.default.animatedShouldUseSingleOp();
  var flushQueueTimeout = null;
  var eventListenerGetValueCallbacks = {};
  var eventListenerAnimationFinishedCallbacks = {};
  var globalEventEmitterGetValueListener = null;
  var globalEventEmitterAnimationFinishedListener = null;
  var nativeOps = useSingleOpBatching ? function () {
    var apis = ['createAnimatedNode',
    // 1
    'updateAnimatedNodeConfig',
    // 2
    'getValue',
    // 3
    'startListeningToAnimatedNodeValue',
    // 4
    'stopListeningToAnimatedNodeValue',
    // 5
    'connectAnimatedNodes',
    // 6
    'disconnectAnimatedNodes',
    // 7
    'startAnimatingNode',
    // 8
    'stopAnimation',
    // 9
    'setAnimatedNodeValue',
    // 10
    'setAnimatedNodeOffset',
    // 11
    'flattenAnimatedNodeOffset',
    // 12
    'extractAnimatedNodeOffset',
    // 13
    'connectAnimatedNodeToView',
    // 14
    'disconnectAnimatedNodeFromView',
    // 15
    'restoreDefaultValues',
    // 16
    'dropAnimatedNode',
    // 17
    'addAnimatedEventToView',
    // 18
    'removeAnimatedEventFromView',
    // 19
    'addListener',
    // 20
    'removeListener' // 21
    ];
    return apis.reduce((acc, functionName, i) => {
      // These indices need to be kept in sync with the indices in native (see NativeAnimatedModule in Java, or the equivalent for any other native platform).
      // $FlowFixMe[prop-missing]
      acc[functionName] = i + 1;
      return acc;
    }, {});
  }() : NativeAnimatedModule;

  /**
   * Wrappers around NativeAnimatedModule to provide flow and autocomplete support for
   * the native module methods, and automatic queue management on Android
   */
  var API = {
    getValue: function getValue(tag, saveValueCallback) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      if (useSingleOpBatching) {
        if (saveValueCallback) {
          eventListenerGetValueCallbacks[tag] = saveValueCallback;
        }
        // $FlowFixMe
        API.queueOperation(nativeOps.getValue, tag);
      } else {
        API.queueOperation(nativeOps.getValue, tag, saveValueCallback);
      }
    },
    setWaitingForIdentifier: function setWaitingForIdentifier(id) {
      waitingForQueuedOperations.add(id);
      queueOperations = true;
      if (ReactNativeFeatureFlags.default.animatedShouldDebounceQueueFlush() && flushQueueTimeout) {
        clearTimeout(flushQueueTimeout);
      }
    },
    unsetWaitingForIdentifier: function unsetWaitingForIdentifier(id) {
      waitingForQueuedOperations.delete(id);
      if (waitingForQueuedOperations.size === 0) {
        queueOperations = false;
        API.disableQueue();
      }
    },
    disableQueue: function disableQueue() {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      if (ReactNativeFeatureFlags.default.animatedShouldDebounceQueueFlush()) {
        var prevTimeout = flushQueueTimeout;
        clearImmediate(prevTimeout);
        flushQueueTimeout = setImmediate(API.flushQueue);
      } else {
        API.flushQueue();
      }
    },
    flushQueue: function flushQueue() {
      /*
      invariant(NativeAnimatedModule, 'Native animated module is not available');
      flushQueueTimeout = null;
       // Early returns before calling any APIs
      if (useSingleOpBatching && singleOpQueue.length === 0) {
        return;
      }
      if (!useSingleOpBatching && queue.length === 0) {
        return;
      }
       if (useSingleOpBatching) {
        // Set up event listener for callbacks if it's not set up
        if (
          !globalEventEmitterGetValueListener ||
          !globalEventEmitterAnimationFinishedListener
        ) {
          setupGlobalEventEmitterListeners();
        }
        // Single op batching doesn't use callback functions, instead we
        // use RCTDeviceEventEmitter. This reduces overhead of sending lots of
        // JSI functions across to native code; but also, TM infrastructure currently
        // does not support packing a function into native arrays.
        NativeAnimatedModule.queueAndExecuteBatchedOperations?.(singleOpQueue);
        singleOpQueue.length = 0;
      } else {
        Platform.OS === 'android' && NativeAnimatedModule.startOperationBatch?.();
        for (let q = 0, l = queue.length; q < l; q++) {
          queue[q]();
        }
        queue.length = 0;
        Platform.OS === 'android' &&
          NativeAnimatedModule.finishOperationBatch?.();
      }
      */
    },
    queueOperation: function queueOperation(fn) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (useSingleOpBatching) {
        // Get the command ID from the queued function, and push that ID and any arguments needed to execute the operation
        // $FlowFixMe: surprise, fn is actually a number
        singleOpQueue.push(fn, ...args);
        return;
      }

      // If queueing is explicitly on, *or* the queue has not yet
      // been flushed, use the queue. This is to prevent operations
      // from being executed out of order.
      if (queueOperations || queue.length !== 0) {
        queue.push(() => fn(...args));
      } else {
        fn(...args);
      }
    },
    createAnimatedNode: function createAnimatedNode(tag, config) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.createAnimatedNode, tag, config);
    },
    updateAnimatedNodeConfig: function updateAnimatedNodeConfig(tag, config) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      //if (nativeOps.updateAnimatedNodeConfig) {
      //  API.queueOperation(nativeOps.updateAnimatedNodeConfig, tag, config);
      //}
    },
    startListeningToAnimatedNodeValue: function startListeningToAnimatedNodeValue(tag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.startListeningToAnimatedNodeValue, tag);
    },
    stopListeningToAnimatedNodeValue: function stopListeningToAnimatedNodeValue(tag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.stopListeningToAnimatedNodeValue, tag);
    },
    connectAnimatedNodes: function connectAnimatedNodes(parentTag, childTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.connectAnimatedNodes, parentTag, childTag);
    },
    disconnectAnimatedNodes: function disconnectAnimatedNodes(parentTag, childTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.disconnectAnimatedNodes, parentTag, childTag);
    },
    startAnimatingNode: function startAnimatingNode(animationId, nodeTag, config, endCallback) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      if (useSingleOpBatching) {
        if (endCallback) {
          eventListenerAnimationFinishedCallbacks[animationId] = endCallback;
        }
        // $FlowFixMe
        API.queueOperation(nativeOps.startAnimatingNode, animationId, nodeTag, config);
      } else {
        API.queueOperation(nativeOps.startAnimatingNode, animationId, nodeTag, config, endCallback);
      }
    },
    stopAnimation: function stopAnimation(animationId) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.stopAnimation, animationId);
    },
    setAnimatedNodeValue: function setAnimatedNodeValue(nodeTag, value) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.setAnimatedNodeValue, nodeTag, value);
    },
    setAnimatedNodeOffset: function setAnimatedNodeOffset(nodeTag, offset) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.setAnimatedNodeOffset, nodeTag, offset);
    },
    flattenAnimatedNodeOffset: function flattenAnimatedNodeOffset(nodeTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.flattenAnimatedNodeOffset, nodeTag);
    },
    extractAnimatedNodeOffset: function extractAnimatedNodeOffset(nodeTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.extractAnimatedNodeOffset, nodeTag);
    },
    connectAnimatedNodeToView: function connectAnimatedNodeToView(nodeTag, viewTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.connectAnimatedNodeToView, nodeTag, viewTag);
    },
    disconnectAnimatedNodeFromView: function disconnectAnimatedNodeFromView(nodeTag, viewTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.disconnectAnimatedNodeFromView, nodeTag, viewTag);
    },
    restoreDefaultValues: function restoreDefaultValues(nodeTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      // Backwards compat with older native runtimes, can be removed later.
      if (nativeOps.restoreDefaultValues != null) {
        API.queueOperation(nativeOps.restoreDefaultValues, nodeTag);
      }
    },
    dropAnimatedNode: function dropAnimatedNode(tag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.dropAnimatedNode, tag);
    },
    addAnimatedEventToView: function addAnimatedEventToView(viewTag, eventName, eventMapping) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.addAnimatedEventToView, viewTag, eventName, eventMapping);
    },
    removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.removeAnimatedEventFromView, viewTag, eventName, animatedNodeTag);
    }
  };
  function setupGlobalEventEmitterListeners() {
    globalEventEmitterGetValueListener = RCTDeviceEventEmitter.default.addListener('onNativeAnimatedModuleGetValue', function (params) {
      var tag = params.tag;
      var callback = eventListenerGetValueCallbacks[tag];
      if (!callback) {
        return;
      }
      callback(params.value);
      delete eventListenerGetValueCallbacks[tag];
    });
    globalEventEmitterAnimationFinishedListener = RCTDeviceEventEmitter.default.addListener('onNativeAnimatedModuleAnimationFinished', function (params) {
      var animationId = params.animationId;
      var callback = eventListenerAnimationFinishedCallbacks[animationId];
      if (!callback) {
        return;
      }
      callback(params);
      delete eventListenerAnimationFinishedCallbacks[animationId];
    });
  }

  /**
   * Styles allowed by the native animated implementation.
   *
   * In general native animated implementation should support any numeric or color property that
   * doesn't need to be updated through the shadow view hierarchy (all non-layout properties).
   */
  var SUPPORTED_COLOR_STYLES = {
    backgroundColor: true,
    borderBottomColor: true,
    borderColor: true,
    borderEndColor: true,
    borderLeftColor: true,
    borderRightColor: true,
    borderStartColor: true,
    borderTopColor: true,
    color: true,
    tintColor: true
  };
  var SUPPORTED_STYLES = (0, _objectSpread.default)((0, _objectSpread.default)({}, SUPPORTED_COLOR_STYLES), {}, {
    borderBottomEndRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    borderBottomStartRadius: true,
    borderRadius: true,
    borderTopEndRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderTopStartRadius: true,
    elevation: true,
    opacity: true,
    transform: true,
    zIndex: true,
    /* ios styles */
    shadowOpacity: true,
    shadowRadius: true,
    /* legacy android transform properties */
    scaleX: true,
    scaleY: true,
    translateX: true,
    translateY: true
  });
  var SUPPORTED_TRANSFORMS = {
    translateX: true,
    translateY: true,
    scale: true,
    scaleX: true,
    scaleY: true,
    rotate: true,
    rotateX: true,
    rotateY: true,
    rotateZ: true,
    perspective: true
  };
  var SUPPORTED_INTERPOLATION_PARAMS = {
    inputRange: true,
    outputRange: true,
    extrapolate: true,
    extrapolateRight: true,
    extrapolateLeft: true
  };
  function addWhitelistedStyleProp(prop) {
    SUPPORTED_STYLES[prop] = true;
  }
  function addWhitelistedTransformProp(prop) {
    SUPPORTED_TRANSFORMS[prop] = true;
  }
  function addWhitelistedInterpolationParam(param) {
    SUPPORTED_INTERPOLATION_PARAMS[param] = true;
  }
  function isSupportedColorStyleProp(prop) {
    return SUPPORTED_COLOR_STYLES.hasOwnProperty(prop);
  }
  function isSupportedStyleProp(prop) {
    return SUPPORTED_STYLES.hasOwnProperty(prop);
  }
  function isSupportedTransformProp(prop) {
    return SUPPORTED_TRANSFORMS.hasOwnProperty(prop);
  }
  function isSupportedInterpolationParam(param) {
    return SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(param);
  }
  function validateTransform(configs) {
    configs.forEach(config => {
      if (!isSupportedTransformProp(config.property)) {
        throw new Error("Property '" + config.property + "' is not supported by native animated module");
      }
    });
  }
  function validateStyles(styles) {
    for (var _key2 in styles) {
      if (!isSupportedStyleProp(_key2)) {
        throw new Error("Style property '" + _key2 + "' is not supported by native animated module");
      }
    }
  }
  function validateInterpolation(config) {
    for (var _key3 in config) {
      if (!isSupportedInterpolationParam(_key3)) {
        throw new Error("Interpolation property '" + _key3 + "' is not supported by native animated module");
      }
    }
  }
  function generateNewNodeTag() {
    return __nativeAnimatedNodeTagCount++;
  }
  function generateNewAnimationId() {
    return __nativeAnimationIdCount++;
  }
  function assertNativeAnimatedModule() {
    (0, invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
  }
  var _warnedMissingNativeAnimated = false;
  function shouldUseNativeDriver(config) {
    if (config.useNativeDriver == null) {
      console.warn('Animated: `useNativeDriver` was not specified. This is a required ' + 'option and must be explicitly set to `true` or `false`');
    }
    if (config.useNativeDriver === true && !NativeAnimatedModule) {
      if (!_warnedMissingNativeAnimated) {
        console.warn('Animated: `useNativeDriver` is not supported because the native ' + 'animated module is missing. Falling back to JS-based animation. To ' + 'resolve this, add `RCTAnimation` module to this app, or remove ' + '`useNativeDriver`. ' + 'Make sure to run `bundle exec pod install` first. Read more about autolinking: https://github.com/react-native-community/cli/blob/master/docs/autolinking.md');
        _warnedMissingNativeAnimated = true;
      }
      return false;
    }
    return config.useNativeDriver || false;
  }
  function transformDataType(value) {
    // Change the string type to number type so we can reuse the same logic in
    // iOS and Android platform
    if (typeof value !== 'string') {
      return value;
    }
    if (/deg$/.test(value)) {
      var degrees = parseFloat(value) || 0;
      var radians = degrees * Math.PI / 180.0;
      return radians;
    } else {
      return value;
    }
  }
  var _default = {
    API,
    isSupportedColorStyleProp,
    isSupportedStyleProp,
    isSupportedTransformProp,
    isSupportedInterpolationParam,
    addWhitelistedStyleProp,
    addWhitelistedTransformProp,
    addWhitelistedInterpolationParam,
    validateStyles,
    validateTransform,
    validateInterpolation,
    generateNewNodeTag,
    generateNewAnimationId,
    assertNativeAnimatedModule,
    shouldUseNativeDriver,
    transformDataType,
    // $FlowExpectedError[unsafe-getters-setters] - unsafe getter lint suppresion
    // $FlowExpectedError[missing-type-arg] - unsafe getter lint suppresion
    get nativeEventEmitter() {
      if (!nativeEventEmitter) {
        nativeEventEmitter = new NativeEventEmitter.default(
        // T88715063: NativeEventEmitter only used this parameter on iOS. Now it uses it on all platforms, so this code was modified automatically to preserve its behavior
        // If you want to use the native module on other platforms, please remove this condition and test its behavior
        Platform.default.OS !== 'ios' ? null : NativeAnimatedModule);
      }
      return nativeEventEmitter;
    }
  };
},201,[37,202,204,13,205,206,17,15],"node_modules/react-native-web/dist/vendor/react-native/Animated/NativeAnimatedHelper.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _TurboModuleTurboModuleRegistry = require(_dependencyMap[0], "../TurboModule/TurboModuleRegistry");
  var TurboModuleRegistry = _interopNamespace(_TurboModuleTurboModuleRegistry);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  // The config has different keys depending on the type of the Node
  // TODO(T54896888): Make these types strict

  var _default = TurboModuleRegistry.get('NativeAnimatedModule');
},202,[203],"node_modules/react-native-web/dist/vendor/react-native/Animated/NativeAnimatedModule.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.get = get;
  exports.getEnforcing = getEnforcing;
  var _fbjsLibInvariant = require(_dependencyMap[0], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  function get(name) {
    return null;
  }
  function getEnforcing(name) {
    var module = get(name);
    (0, invariant.default)(module != null, "TurboModuleRegistry.getEnforcing(...): '" + name + "' could not be found. " + 'Verify that a module by this name is registered in the native binary.');
    return module;
  }
},203,[17],"node_modules/react-native-web/dist/vendor/react-native/TurboModule/TurboModuleRegistry.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _TurboModuleTurboModuleRegistry = require(_dependencyMap[0], "../TurboModule/TurboModuleRegistry");
  var TurboModuleRegistry = _interopNamespace(_TurboModuleTurboModuleRegistry);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  // The config has different keys depending on the type of the Node
  // TODO(T54896888): Make these types strict

  var _default = TurboModuleRegistry.get('NativeAnimatedTurboModule');
},204,[203],"node_modules/react-native-web/dist/vendor/react-native/Animated/NativeAnimatedTurboModule.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _exportsPlatform = require(_dependencyMap[0], "../../../exports/Platform");
  var Platform = _interopDefault(_exportsPlatform);
  var _default = Platform.default;
},205,[14],"node_modules/react-native-web/dist/vendor/react-native/Utilities/Platform.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var ReactNativeFeatureFlags = {
    isLayoutAnimationEnabled: () => true,
    shouldEmitW3CPointerEvents: () => false,
    shouldPressibilityUseW3CPointerEventsForHover: () => false,
    animatedShouldDebounceQueueFlush: () => false,
    animatedShouldUseSingleOp: () => false
  };
  var _default = ReactNativeFeatureFlags;
},206,[],"node_modules/react-native-web/dist/vendor/react-native/ReactNative/ReactNativeFeatureFlags.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedNode = require(_dependencyMap[0], "./AnimatedNode");
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _AnimatedTransform = require(_dependencyMap[1], "./AnimatedTransform");
  var AnimatedTransform = _interopDefault(_AnimatedTransform);
  var _AnimatedWithChildren = require(_dependencyMap[2], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _NativeAnimatedHelper = require(_dependencyMap[3], "../NativeAnimatedHelper");
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _exportsStyleSheet = require(_dependencyMap[4], "../../../../exports/StyleSheet");
  var StyleSheet = _interopDefault(_exportsStyleSheet);
  var flattenStyle = StyleSheet.default.flatten;
  function createAnimatedStyle(inputStyle) {
    var style = flattenStyle(inputStyle);
    var animatedStyles = {};
    for (var key in style) {
      var value = style[key];
      if (key === 'transform' && Array.isArray(value)) {
        animatedStyles[key] = new AnimatedTransform.default(value);
      } else if (value instanceof AnimatedNode.default) {
        animatedStyles[key] = value;
      } else if (value && !Array.isArray(value) && typeof value === 'object') {
        animatedStyles[key] = createAnimatedStyle(value);
      }
    }
    return animatedStyles;
  }
  class AnimatedStyle extends AnimatedWithChildren.default {
    constructor(style) {
      super();
      this._inputStyle = style;
      this._style = createAnimatedStyle(style);
    }

    // Recursively get values for nested styles (like iOS's shadowOffset)
    _walkStyleAndGetValues(style) {
      var updatedStyle = {};
      for (var key in style) {
        var value = style[key];
        if (value instanceof AnimatedNode.default) {
          if (!value.__isNative) {
            // We cannot use value of natively driven nodes this way as the value we have access from
            // JS may not be up to date.
            updatedStyle[key] = value.__getValue();
          }
        } else if (value && !Array.isArray(value) && typeof value === 'object') {
          // Support animating nested values (for example: shadowOffset.height)
          updatedStyle[key] = this._walkStyleAndGetValues(value);
        } else {
          updatedStyle[key] = value;
        }
      }
      return updatedStyle;
    }
    __getValue() {
      return [this._inputStyle, this._walkStyleAndGetValues(this._style)];
    }

    // Recursively get animated values for nested styles (like iOS's shadowOffset)
    _walkStyleAndGetAnimatedValues(style) {
      var updatedStyle = {};
      for (var key in style) {
        var value = style[key];
        if (value instanceof AnimatedNode.default) {
          updatedStyle[key] = value.__getAnimatedValue();
        } else if (value && !Array.isArray(value) && typeof value === 'object') {
          // Support animating nested values (for example: shadowOffset.height)
          updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value);
        }
      }
      return updatedStyle;
    }
    __getAnimatedValue() {
      return this._walkStyleAndGetAnimatedValues(this._style);
    }
    __attach() {
      for (var key in this._style) {
        var value = this._style[key];
        if (value instanceof AnimatedNode.default) {
          value.__addChild(this);
        }
      }
    }
    __detach() {
      for (var key in this._style) {
        var value = this._style[key];
        if (value instanceof AnimatedNode.default) {
          value.__removeChild(this);
        }
      }
      super.__detach();
    }
    __makeNative() {
      for (var key in this._style) {
        var value = this._style[key];
        if (value instanceof AnimatedNode.default) {
          value.__makeNative();
        }
      }
      super.__makeNative();
    }
    __getNativeConfig() {
      var styleConfig = {};
      for (var styleKey in this._style) {
        if (this._style[styleKey] instanceof AnimatedNode.default) {
          var style = this._style[styleKey];
          style.__makeNative();
          styleConfig[styleKey] = style.__getNativeTag();
        }
      }
      NativeAnimatedHelper.default.validateStyles(styleConfig);
      return {
        type: 'style',
        style: styleConfig
      };
    }
  }
  var _default = AnimatedStyle;
},207,[200,208,199,201,55],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedStyle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedNode = require(_dependencyMap[0], "./AnimatedNode");
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _AnimatedWithChildren = require(_dependencyMap[1], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _NativeAnimatedHelper = require(_dependencyMap[2], "../NativeAnimatedHelper");
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  class AnimatedTransform extends AnimatedWithChildren.default {
    constructor(transforms) {
      super();
      this._transforms = transforms;
    }
    __makeNative() {
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            value.__makeNative();
          }
        }
      });
      super.__makeNative();
    }
    __getValue() {
      return this._transforms.map(transform => {
        var result = {};
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            result[key] = value.__getValue();
          } else {
            result[key] = value;
          }
        }
        return result;
      });
    }
    __getAnimatedValue() {
      return this._transforms.map(transform => {
        var result = {};
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            result[key] = value.__getAnimatedValue();
          } else {
            // All transform components needed to recompose matrix
            result[key] = value;
          }
        }
        return result;
      });
    }
    __attach() {
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            value.__addChild(this);
          }
        }
      });
    }
    __detach() {
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            value.__removeChild(this);
          }
        }
      });
      super.__detach();
    }
    __getNativeConfig() {
      var transConfigs = [];
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            transConfigs.push({
              type: 'animated',
              property: key,
              nodeTag: value.__getNativeTag()
            });
          } else {
            transConfigs.push({
              type: 'static',
              property: key,
              value: NativeAnimatedHelper.default.transformDataType(value)
            });
          }
        }
      });
      NativeAnimatedHelper.default.validateTransform(transConfigs);
      return {
        type: 'transform',
        transforms: transConfigs
      };
    }
  }
  var _default = AnimatedTransform;
},208,[200,199,201],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedTransform.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useRefEffect;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Constructs a callback ref that provides similar semantics as `useEffect`. The
   * supplied `effect` callback will be called with non-null component instances.
   * The `effect` callback can also optionally return a cleanup function.
   *
   * When a component is updated or unmounted, the cleanup function is called. The
   * `effect` callback will then be called again, if applicable.
   *
   * When a new `effect` callback is supplied, the previously returned cleanup
   * function will be called before the new `effect` callback is called with the
   * same instance.
   *
   * WARNING: The `effect` callback should be stable (e.g. using `useCallback`).
   */
  function useRefEffect(effect) {
    var cleanupRef = (0, _react.useRef)(undefined);
    return (0, _react.useCallback)(instance => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = undefined;
      }
      if (instance != null) {
        cleanupRef.current = effect(instance);
      }
    }, [effect]);
  }
},209,[9],"node_modules/react-native-web/dist/vendor/react-native/Utilities/useRefEffect.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useMergeRefs;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Constructs a new ref that forwards new values to each of the given refs. The
   * given refs will always be invoked in the order that they are supplied.
   *
   * WARNING: A known problem of merging refs using this approach is that if any
   * of the given refs change, the returned callback ref will also be changed. If
   * the returned callback ref is supplied as a `ref` to a React element, this may
   * lead to problems with the given refs being invoked more times than desired.
   */
  function useMergeRefs() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }
    return (0, _react.useCallback)(current => {
      for (var _i = 0, _refs = refs; _i < _refs.length; _i++) {
        var ref = _refs[_i];
        if (ref != null) {
          if (typeof ref === 'function') {
            ref(current);
          } else {
            ref.current = current;
          }
        }
      }
    }, [...refs] // eslint-disable-line react-hooks/exhaustive-deps
    );
  }
},210,[9],"node_modules/react-native-web/dist/vendor/react-native/Utilities/useMergeRefs.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  require(_dependencyMap[0], "react");
  var _exportsImage = require(_dependencyMap[1], "../../../../exports/Image");
  var Image = _interopDefault(_exportsImage);
  var _createAnimatedComponent = require(_dependencyMap[2], "../createAnimatedComponent");
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var _default = (0, createAnimatedComponent.default)(Image.default);
},211,[9,155,193],"node_modules/react-native-web/dist/vendor/react-native/Animated/components/AnimatedImage.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _exportsScrollView = require(_dependencyMap[2], "../../../../exports/ScrollView");
  var ScrollView = _interopDefault(_exportsScrollView);
  var _createAnimatedComponent = require(_dependencyMap[3], "../createAnimatedComponent");
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * @see https://github.com/facebook/react-native/commit/b8c8562
   */
  var ScrollViewWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(ScrollView.default, (0, _extends.default)({
    scrollEventThrottle: 0.0001
  }, props, {
    ref: ref
  })));
  var _default = (0, createAnimatedComponent.default)(ScrollViewWithEventThrottle);
},212,[42,9,36,193],"node_modules/react-native-web/dist/vendor/react-native/Animated/components/AnimatedScrollView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _exportsSectionList = require(_dependencyMap[2], "../../../../exports/SectionList");
  var SectionList = _interopDefault(_exportsSectionList);
  var _createAnimatedComponent = require(_dependencyMap[3], "../createAnimatedComponent");
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * @see https://github.com/facebook/react-native/commit/b8c8562
   */
  var SectionListWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(SectionList.default, (0, _extends.default)({
    scrollEventThrottle: 0.0001
  }, props, {
    ref: ref
  })));
  var _default = (0, createAnimatedComponent.default)(SectionListWithEventThrottle);
},213,[42,9,214,193],"node_modules/react-native-web/dist/vendor/react-native/Animated/components/AnimatedSectionList.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeSectionList = require(_dependencyMap[0], "../../vendor/react-native/SectionList");
  var SectionList = _interopDefault(_vendorReactNativeSectionList);
  var _default = SectionList.default;
},214,[215],"node_modules/react-native-web/dist/exports/SectionList/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return SectionList;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _exportsPlatform = require(_dependencyMap[2], "../../../exports/Platform");
  var Platform = _interopDefault(_exportsPlatform);
  var _react = require(_dependencyMap[3], "react");
  var React = _interopNamespace(_react);
  var _VirtualizedSectionList = require(_dependencyMap[4], "../VirtualizedSectionList");
  var VirtualizedSectionList = _interopDefault(_VirtualizedSectionList);
  var _excluded = ["stickySectionHeadersEnabled"];
  /**
   * A performant interface for rendering sectioned lists, supporting the most handy features:
   *
   *  - Fully cross-platform.
   *  - Configurable viewability callbacks.
   *  - List header support.
   *  - List footer support.
   *  - Item separator support.
   *  - Section header support.
   *  - Section separator support.
   *  - Heterogeneous data and item rendering support.
   *  - Pull to Refresh.
   *  - Scroll loading.
   *
   * If you don't need section support and want a simpler interface, use
   * [`<FlatList>`](https://reactnative.dev/docs/flatlist).
   *
   * Simple Examples:
   *
   *     <SectionList
   *       renderItem={({item}) => <ListItem title={item} />}
   *       renderSectionHeader={({section}) => <Header title={section.title} />}
   *       sections={[ // homogeneous rendering between sections
   *         {data: [...], title: ...},
   *         {data: [...], title: ...},
   *         {data: [...], title: ...},
   *       ]}
   *     />
   *
   *     <SectionList
   *       sections={[ // heterogeneous rendering between sections
   *         {data: [...], renderItem: ...},
   *         {data: [...], renderItem: ...},
   *         {data: [...], renderItem: ...},
   *       ]}
   *     />
   *
   * This is a convenience wrapper around [`<VirtualizedList>`](docs/virtualizedlist),
   * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed
   * here, along with the following caveats:
   *
   * - Internal state is not preserved when content scrolls out of the render window. Make sure all
   *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
   * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
   *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
   *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
   *   changes. This includes the `data` prop and parent component state.
   * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
   *   offscreen. This means it's possible to scroll faster than the fill rate and momentarily see
   *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
   *   and we are working on improving it behind the scenes.
   * - By default, the list looks for a `key` prop on each item and uses that for the React key.
   *   Alternatively, you can provide a custom `keyExtractor` prop.
   *
   */
  class SectionList extends React.PureComponent {
    constructor() {
      super(...arguments);
      this._captureRef = ref => {
        this._wrapperListRef = ref;
      };
    }
    /**
     * Scrolls to the item at the specified `sectionIndex` and `itemIndex` (within the section)
     * positioned in the viewable area such that `viewPosition` 0 places it at the top (and may be
     * covered by a sticky header), 1 at the bottom, and 0.5 centered in the middle. `viewOffset` is a
     * fixed number of pixels to offset the final target position, e.g. to compensate for sticky
     * headers.
     *
     * Note: cannot scroll to locations outside the render window without specifying the
     * `getItemLayout` prop.
     */
    scrollToLocation(params) {
      if (this._wrapperListRef != null) {
        this._wrapperListRef.scrollToLocation(params);
      }
    }

    /**
     * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g.
     * if `waitForInteractions` is true and the user has not scrolled. This is typically called by
     * taps on items or by navigation actions.
     */
    recordInteraction() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      listRef && listRef.recordInteraction();
    }

    /**
     * Displays the scroll indicators momentarily.
     *
     * @platform ios
     */
    flashScrollIndicators() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      listRef && listRef.flashScrollIndicators();
    }

    /**
     * Provides a handle to the underlying scroll responder.
     */
    getScrollResponder() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      if (listRef) {
        return listRef.getScrollResponder();
      }
    }
    getScrollableNode() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      if (listRef) {
        return listRef.getScrollableNode();
      }
    }
    render() {
      var _this$props = this.props,
        _stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,
        restProps = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      var stickySectionHeadersEnabled = _stickySectionHeadersEnabled !== null && _stickySectionHeadersEnabled !== void 0 ? _stickySectionHeadersEnabled : Platform.default.OS === 'ios';
      return /*#__PURE__*/React.createElement(VirtualizedSectionList.default, (0, _extends.default)({}, restProps, {
        stickySectionHeadersEnabled: stickySectionHeadersEnabled,
        ref: this._captureRef,
        getItemCount: items => items.length,
        getItem: (items, index) => items[index]
      }));
    }
  }
},215,[42,43,14,9,216],"node_modules/react-native-web/dist/vendor/react-native/SectionList/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersCreateForOfIteratorHelperLoose = require(_dependencyMap[1], "@babel/runtime/helpers/createForOfIteratorHelperLoose");
  var _createForOfIteratorHelperLoose = _interopDefault(_babelRuntimeHelpersCreateForOfIteratorHelperLoose);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[3], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _exportsView = require(_dependencyMap[4], "../../../exports/View");
  var View = _interopDefault(_exportsView);
  var _VirtualizedList = require(_dependencyMap[5], "../VirtualizedList");
  var VirtualizedList = _interopDefault(_VirtualizedList);
  var _VirtualizeUtils = require(_dependencyMap[6], "../VirtualizeUtils");
  var _fbjsLibInvariant = require(_dependencyMap[7], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _react = require(_dependencyMap[8], "react");
  var React = _interopNamespace(_react);
  var _excluded = ["ItemSeparatorComponent", "SectionSeparatorComponent", "renderItem", "renderSectionFooter", "renderSectionHeader", "sections", "stickySectionHeadersEnabled"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Right now this just flattens everything into one list and uses VirtualizedList under the
   * hood. The only operation that might not scale well is concatting the data arrays of all the
   * sections when new props are received, which should be plenty fast for up to ~10,000 items.
   */
  class VirtualizedSectionList extends React.PureComponent {
    constructor() {
      super(...arguments);
      this._keyExtractor = (item, index) => {
        var info = this._subExtractor(index);
        return info && info.key || String(index);
      };
      this._convertViewable = viewable => {
        var _info$index;
        (0, invariant.default)(viewable.index != null, 'Received a broken ViewToken');
        var info = this._subExtractor(viewable.index);
        if (!info) {
          return null;
        }
        var keyExtractorWithNullableIndex = info.section.keyExtractor;
        var keyExtractorWithNonNullableIndex = this.props.keyExtractor || _VirtualizeUtils.keyExtractor;
        var key = keyExtractorWithNullableIndex != null ? keyExtractorWithNullableIndex(viewable.item, info.index) : keyExtractorWithNonNullableIndex(viewable.item, (_info$index = info.index) !== null && _info$index !== void 0 ? _info$index : 0);
        return (0, _objectSpread.default)((0, _objectSpread.default)({}, viewable), {}, {
          index: info.index,
          key,
          section: info.section
        });
      };
      this._onViewableItemsChanged = _ref => {
        var viewableItems = _ref.viewableItems,
          changed = _ref.changed;
        var onViewableItemsChanged = this.props.onViewableItemsChanged;
        if (onViewableItemsChanged != null) {
          onViewableItemsChanged({
            viewableItems: viewableItems.map(this._convertViewable, this).filter(Boolean),
            changed: changed.map(this._convertViewable, this).filter(Boolean)
          });
        }
      };
      this._renderItem = listItemCount =>
      // eslint-disable-next-line react/no-unstable-nested-components
      _ref2 => {
        var item = _ref2.item,
          index = _ref2.index;
        var info = this._subExtractor(index);
        if (!info) {
          return null;
        }
        var infoIndex = info.index;
        if (infoIndex == null) {
          var section = info.section;
          if (info.header === true) {
            var renderSectionHeader = this.props.renderSectionHeader;
            return renderSectionHeader ? renderSectionHeader({
              section
            }) : null;
          } else {
            var renderSectionFooter = this.props.renderSectionFooter;
            return renderSectionFooter ? renderSectionFooter({
              section
            }) : null;
          }
        } else {
          var renderItem = info.section.renderItem || this.props.renderItem;
          var SeparatorComponent = this._getSeparatorComponent(index, info, listItemCount);
          (0, invariant.default)(renderItem, 'no renderItem!');
          return /*#__PURE__*/React.createElement(ItemWithSeparator, {
            SeparatorComponent: SeparatorComponent,
            LeadingSeparatorComponent: infoIndex === 0 ? this.props.SectionSeparatorComponent : undefined,
            cellKey: info.key,
            index: infoIndex,
            item: item,
            leadingItem: info.leadingItem,
            leadingSection: info.leadingSection,
            prevCellKey: (this._subExtractor(index - 1) || {}).key
            // Callback to provide updateHighlight for this item
            ,

            setSelfHighlightCallback: this._setUpdateHighlightFor,
            setSelfUpdatePropsCallback: this._setUpdatePropsFor
            // Provide child ability to set highlight/updateProps for previous item using prevCellKey
            ,

            updateHighlightFor: this._updateHighlightFor,
            updatePropsFor: this._updatePropsFor,
            renderItem: renderItem,
            section: info.section,
            trailingItem: info.trailingItem,
            trailingSection: info.trailingSection,
            inverted: !!this.props.inverted
          });
        }
      };
      this._updatePropsFor = (cellKey, value) => {
        var updateProps = this._updatePropsMap[cellKey];
        if (updateProps != null) {
          updateProps(value);
        }
      };
      this._updateHighlightFor = (cellKey, value) => {
        var updateHighlight = this._updateHighlightMap[cellKey];
        if (updateHighlight != null) {
          updateHighlight(value);
        }
      };
      this._setUpdateHighlightFor = (cellKey, updateHighlightFn) => {
        if (updateHighlightFn != null) {
          this._updateHighlightMap[cellKey] = updateHighlightFn;
        } else {
          // $FlowFixMe[prop-missing]
          delete this._updateHighlightFor[cellKey];
        }
      };
      this._setUpdatePropsFor = (cellKey, updatePropsFn) => {
        if (updatePropsFn != null) {
          this._updatePropsMap[cellKey] = updatePropsFn;
        } else {
          delete this._updatePropsMap[cellKey];
        }
      };
      this._updateHighlightMap = {};
      this._updatePropsMap = {};
      this._captureRef = ref => {
        this._listRef = ref;
      };
    }
    scrollToLocation(params) {
      var index = params.itemIndex;
      for (var i = 0; i < params.sectionIndex; i++) {
        index += this.props.getItemCount(this.props.sections[i].data) + 2;
      }
      var viewOffset = params.viewOffset || 0;
      if (this._listRef == null) {
        return;
      }
      if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {
        var frame = this._listRef.__getFrameMetricsApprox(index - params.itemIndex, this._listRef.props);
        viewOffset += frame.length;
      }
      var toIndexParams = (0, _objectSpread.default)((0, _objectSpread.default)({}, params), {}, {
        viewOffset,
        index
      });
      // $FlowFixMe[incompatible-use]
      this._listRef.scrollToIndex(toIndexParams);
    }
    getListRef() {
      return this._listRef;
    }
    render() {
      var _this$props = this.props,
        ItemSeparatorComponent = _this$props.ItemSeparatorComponent,
        SectionSeparatorComponent = _this$props.SectionSeparatorComponent,
        _renderItem = _this$props.renderItem,
        renderSectionFooter = _this$props.renderSectionFooter,
        renderSectionHeader = _this$props.renderSectionHeader,
        _sections = _this$props.sections,
        stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,
        passThroughProps = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      var listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0;
      var stickyHeaderIndices = this.props.stickySectionHeadersEnabled ? [] : undefined;
      var itemCount = 0;
      for (var _iterator = (0, _createForOfIteratorHelperLoose.default)(this.props.sections), _step; !(_step = _iterator()).done;) {
        var section = _step.value;
        // Track the section header indices
        if (stickyHeaderIndices != null) {
          stickyHeaderIndices.push(itemCount + listHeaderOffset);
        }

        // Add two for the section header and footer.
        itemCount += 2;
        itemCount += this.props.getItemCount(section.data);
      }
      var renderItem = this._renderItem(itemCount);
      return /*#__PURE__*/React.createElement(VirtualizedList.default, (0, _extends.default)({}, passThroughProps, {
        keyExtractor: this._keyExtractor,
        stickyHeaderIndices: stickyHeaderIndices,
        renderItem: renderItem,
        data: this.props.sections,
        getItem: (sections, index) => this._getItem(this.props, sections, index),
        getItemCount: () => itemCount,
        onViewableItemsChanged: this.props.onViewableItemsChanged ? this._onViewableItemsChanged : undefined,
        ref: this._captureRef
      }));
    }
    _getItem(props, sections, index) {
      if (!sections) {
        return null;
      }
      var itemIdx = index - 1;
      for (var i = 0; i < sections.length; i++) {
        var section = sections[i];
        var sectionData = section.data;
        var itemCount = props.getItemCount(sectionData);
        if (itemIdx === -1 || itemIdx === itemCount) {
          // We intend for there to be overflow by one on both ends of the list.
          // This will be for headers and footers. When returning a header or footer
          // item the section itself is the item.
          return section;
        } else if (itemIdx < itemCount) {
          // If we are in the bounds of the list's data then return the item.
          return props.getItem(sectionData, itemIdx);
        } else {
          itemIdx -= itemCount + 2; // Add two for the header and footer
        }
      }
      return null;
    }

    // $FlowFixMe[missing-local-annot]

    _subExtractor(index) {
      var itemIndex = index;
      var _this$props2 = this.props,
        getItem = _this$props2.getItem,
        getItemCount = _this$props2.getItemCount,
        keyExtractor = _this$props2.keyExtractor,
        sections = _this$props2.sections;
      for (var i = 0; i < sections.length; i++) {
        var section = sections[i];
        var sectionData = section.data;
        var key = section.key || String(i);
        itemIndex -= 1; // The section adds an item for the header
        if (itemIndex >= getItemCount(sectionData) + 1) {
          itemIndex -= getItemCount(sectionData) + 1; // The section adds an item for the footer.
        } else if (itemIndex === -1) {
          return {
            section,
            key: key + ':header',
            index: null,
            header: true,
            trailingSection: sections[i + 1]
          };
        } else if (itemIndex === getItemCount(sectionData)) {
          return {
            section,
            key: key + ':footer',
            index: null,
            header: false,
            trailingSection: sections[i + 1]
          };
        } else {
          var extractor = section.keyExtractor || keyExtractor || _VirtualizeUtils.keyExtractor;
          return {
            section,
            key: key + ':' + extractor(getItem(sectionData, itemIndex), itemIndex),
            index: itemIndex,
            leadingItem: getItem(sectionData, itemIndex - 1),
            leadingSection: sections[i - 1],
            trailingItem: getItem(sectionData, itemIndex + 1),
            trailingSection: sections[i + 1]
          };
        }
      }
    }
    _getSeparatorComponent(index, info, listItemCount) {
      info = info || this._subExtractor(index);
      if (!info) {
        return null;
      }
      var ItemSeparatorComponent = info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;
      var SectionSeparatorComponent = this.props.SectionSeparatorComponent;
      var isLastItemInList = index === listItemCount - 1;
      var isLastItemInSection = info.index === this.props.getItemCount(info.section.data) - 1;
      if (SectionSeparatorComponent && isLastItemInSection) {
        return SectionSeparatorComponent;
      }
      if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {
        return ItemSeparatorComponent;
      }
      return null;
    }
  }
  function ItemWithSeparator(props) {
    var LeadingSeparatorComponent = props.LeadingSeparatorComponent,
      SeparatorComponent = props.SeparatorComponent,
      cellKey = props.cellKey,
      prevCellKey = props.prevCellKey,
      setSelfHighlightCallback = props.setSelfHighlightCallback,
      updateHighlightFor = props.updateHighlightFor,
      setSelfUpdatePropsCallback = props.setSelfUpdatePropsCallback,
      updatePropsFor = props.updatePropsFor,
      item = props.item,
      index = props.index,
      section = props.section,
      inverted = props.inverted;
    var _React$useState = React.useState(false),
      leadingSeparatorHiglighted = _React$useState[0],
      setLeadingSeparatorHighlighted = _React$useState[1];
    var _React$useState2 = React.useState(false),
      separatorHighlighted = _React$useState2[0],
      setSeparatorHighlighted = _React$useState2[1];
    var _React$useState3 = React.useState({
        leadingItem: props.leadingItem,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.item,
        trailingSection: props.trailingSection
      }),
      leadingSeparatorProps = _React$useState3[0],
      setLeadingSeparatorProps = _React$useState3[1];
    var _React$useState4 = React.useState({
        leadingItem: props.item,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.trailingItem,
        trailingSection: props.trailingSection
      }),
      separatorProps = _React$useState4[0],
      setSeparatorProps = _React$useState4[1];
    React.useEffect(() => {
      setSelfHighlightCallback(cellKey, setSeparatorHighlighted);
      // $FlowFixMe[incompatible-call]
      setSelfUpdatePropsCallback(cellKey, setSeparatorProps);
      return () => {
        setSelfUpdatePropsCallback(cellKey, null);
        setSelfHighlightCallback(cellKey, null);
      };
    }, [cellKey, setSelfHighlightCallback, setSeparatorProps, setSelfUpdatePropsCallback]);
    var separators = {
      highlight: () => {
        setLeadingSeparatorHighlighted(true);
        setSeparatorHighlighted(true);
        if (prevCellKey != null) {
          updateHighlightFor(prevCellKey, true);
        }
      },
      unhighlight: () => {
        setLeadingSeparatorHighlighted(false);
        setSeparatorHighlighted(false);
        if (prevCellKey != null) {
          updateHighlightFor(prevCellKey, false);
        }
      },
      updateProps: (select, newProps) => {
        if (select === 'leading') {
          if (LeadingSeparatorComponent != null) {
            setLeadingSeparatorProps((0, _objectSpread.default)((0, _objectSpread.default)({}, leadingSeparatorProps), newProps));
          } else if (prevCellKey != null) {
            // update the previous item's separator
            updatePropsFor(prevCellKey, (0, _objectSpread.default)((0, _objectSpread.default)({}, leadingSeparatorProps), newProps));
          }
        } else if (select === 'trailing' && SeparatorComponent != null) {
          setSeparatorProps((0, _objectSpread.default)((0, _objectSpread.default)({}, separatorProps), newProps));
        }
      }
    };
    var element = props.renderItem({
      item,
      index,
      section,
      separators
    });
    var leadingSeparator = LeadingSeparatorComponent != null && /*#__PURE__*/React.createElement(LeadingSeparatorComponent, (0, _extends.default)({
      highlighted: leadingSeparatorHiglighted
    }, leadingSeparatorProps));
    var separator = SeparatorComponent != null && /*#__PURE__*/React.createElement(SeparatorComponent, (0, _extends.default)({
      highlighted: separatorHighlighted
    }, separatorProps));
    return leadingSeparator || separator ? /*#__PURE__*/React.createElement(View.default, null, inverted === false ? leadingSeparator : separator, element, inverted === false ? separator : leadingSeparator) : element;
  }

  /* $FlowFixMe[class-object-subtyping] added when improving typing for this
   * parameters */
  // $FlowFixMe[method-unbinding]
  var _default = VirtualizedSectionList;
},216,[42,173,43,37,110,172,190,17,9],"node_modules/react-native-web/dist/vendor/react-native/VirtualizedSectionList/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  require(_dependencyMap[0], "react");
  var _exportsText = require(_dependencyMap[1], "../../../../exports/Text");
  var Text = _interopDefault(_exportsText);
  var _createAnimatedComponent = require(_dependencyMap[2], "../createAnimatedComponent");
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var _default = (0, createAnimatedComponent.default)(Text.default);
},217,[9,138,193],"node_modules/react-native-web/dist/vendor/react-native/Animated/components/AnimatedText.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  require(_dependencyMap[0], "react");
  var _exportsView = require(_dependencyMap[1], "../../../../exports/View");
  var View = _interopDefault(_exportsView);
  var _createAnimatedComponent = require(_dependencyMap[2], "../createAnimatedComponent");
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var _default = (0, createAnimatedComponent.default)(View.default);
},218,[9,110,193],"node_modules/react-native-web/dist/vendor/react-native/Animated/components/AnimatedView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _AnimatedEvent = require(_dependencyMap[1], "./AnimatedEvent");
  var _AnimatedImplementation = require(_dependencyMap[2], "./AnimatedImplementation");
  var AnimatedImplementation = _interopDefault(_AnimatedImplementation);
  var _nodesAnimatedInterpolation = require(_dependencyMap[3], "./nodes/AnimatedInterpolation");
  var AnimatedInterpolation = _interopDefault(_nodesAnimatedInterpolation);
  var _nodesAnimatedNode = require(_dependencyMap[4], "./nodes/AnimatedNode");
  var AnimatedNode = _interopDefault(_nodesAnimatedNode);
  var _nodesAnimatedValue = require(_dependencyMap[5], "./nodes/AnimatedValue");
  var AnimatedValue = _interopDefault(_nodesAnimatedValue);
  var _nodesAnimatedValueXY = require(_dependencyMap[6], "./nodes/AnimatedValueXY");
  var AnimatedValueXY = _interopDefault(_nodesAnimatedValueXY);
  var _createAnimatedComponent = require(_dependencyMap[7], "./createAnimatedComponent");
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  var _nodesAnimatedColor = require(_dependencyMap[8], "./nodes/AnimatedColor");
  var AnimatedColor = _interopDefault(_nodesAnimatedColor);
  /**
   * Animations are a source of flakiness in snapshot testing. This mock replaces
   * animation functions from AnimatedImplementation with empty animations for
   * predictability in tests. When possible the animation will run immediately
   * to the final state.
   */

  // Prevent any callback invocation from recursively triggering another
  // callback, which may trigger another animation
  var inAnimationCallback = false;
  function mockAnimationStart(start) {
    return callback => {
      var guardedCallback = callback == null ? callback : function () {
        if (inAnimationCallback) {
          console.warn('Ignoring recursive animation callback when running mock animations');
          return;
        }
        inAnimationCallback = true;
        try {
          callback(...arguments);
        } finally {
          inAnimationCallback = false;
        }
      };
      start(guardedCallback);
    };
  }
  var emptyAnimation = {
    start: () => {},
    stop: () => {},
    reset: () => {},
    _startNativeLoop: () => {},
    _isUsingNativeDriver: () => {
      return false;
    }
  };
  var mockCompositeAnimation = animations => (0, _objectSpread.default)((0, _objectSpread.default)({}, emptyAnimation), {}, {
    start: mockAnimationStart(callback => {
      animations.forEach(animation => animation.start());
      callback == null ? void 0 : callback({
        finished: true
      });
    })
  });
  var spring = function spring(value, config) {
    var anyValue = value;
    return (0, _objectSpread.default)((0, _objectSpread.default)({}, emptyAnimation), {}, {
      start: mockAnimationStart(callback => {
        anyValue.setValue(config.toValue);
        callback == null ? void 0 : callback({
          finished: true
        });
      })
    });
  };
  var timing = function timing(value, config) {
    var anyValue = value;
    return (0, _objectSpread.default)((0, _objectSpread.default)({}, emptyAnimation), {}, {
      start: mockAnimationStart(callback => {
        anyValue.setValue(config.toValue);
        callback == null ? void 0 : callback({
          finished: true
        });
      })
    });
  };
  var decay = function decay(value, config) {
    return emptyAnimation;
  };
  var sequence = function sequence(animations) {
    return mockCompositeAnimation(animations);
  };
  var parallel = function parallel(animations, config) {
    return mockCompositeAnimation(animations);
  };
  var delay = function delay(time) {
    return emptyAnimation;
  };
  var stagger = function stagger(time, animations) {
    return mockCompositeAnimation(animations);
  };
  var loop = function loop(animation,
  // $FlowFixMe[prop-missing]
  _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      _ref$iterations = _ref.iterations,
      iterations = _ref$iterations === void 0 ? -1 : _ref$iterations;
    return emptyAnimation;
  };
  var _default = {
    Value: AnimatedValue.default,
    ValueXY: AnimatedValueXY.default,
    Color: AnimatedColor.default,
    Interpolation: AnimatedInterpolation.default,
    Node: AnimatedNode.default,
    decay,
    timing,
    spring,
    add: AnimatedImplementation.default.add,
    subtract: AnimatedImplementation.default.subtract,
    divide: AnimatedImplementation.default.divide,
    multiply: AnimatedImplementation.default.multiply,
    modulo: AnimatedImplementation.default.modulo,
    diffClamp: AnimatedImplementation.default.diffClamp,
    delay,
    sequence,
    parallel,
    stagger,
    loop,
    event: AnimatedImplementation.default.event,
    createAnimatedComponent: createAnimatedComponent.default,
    attachNativeEvent: _AnimatedEvent.attachNativeEvent,
    forkEvent: AnimatedImplementation.default.forkEvent,
    unforkEvent: AnimatedImplementation.default.unforkEvent,
    Event: _AnimatedEvent.AnimatedEvent
  };
},219,[37,196,220,198,200,197,228,193,233],"node_modules/react-native-web/dist/vendor/react-native/Animated/AnimatedMock.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _AnimatedEvent = require(_dependencyMap[1], "./AnimatedEvent");
  var _nodesAnimatedAddition = require(_dependencyMap[2], "./nodes/AnimatedAddition");
  var AnimatedAddition = _interopDefault(_nodesAnimatedAddition);
  var _nodesAnimatedDiffClamp = require(_dependencyMap[3], "./nodes/AnimatedDiffClamp");
  var AnimatedDiffClamp = _interopDefault(_nodesAnimatedDiffClamp);
  var _nodesAnimatedDivision = require(_dependencyMap[4], "./nodes/AnimatedDivision");
  var AnimatedDivision = _interopDefault(_nodesAnimatedDivision);
  var _nodesAnimatedInterpolation = require(_dependencyMap[5], "./nodes/AnimatedInterpolation");
  var AnimatedInterpolation = _interopDefault(_nodesAnimatedInterpolation);
  var _nodesAnimatedModulo = require(_dependencyMap[6], "./nodes/AnimatedModulo");
  var AnimatedModulo = _interopDefault(_nodesAnimatedModulo);
  var _nodesAnimatedMultiplication = require(_dependencyMap[7], "./nodes/AnimatedMultiplication");
  var AnimatedMultiplication = _interopDefault(_nodesAnimatedMultiplication);
  var _nodesAnimatedNode = require(_dependencyMap[8], "./nodes/AnimatedNode");
  var AnimatedNode = _interopDefault(_nodesAnimatedNode);
  require(_dependencyMap[9], "./nodes/AnimatedProps");
  var _nodesAnimatedSubtraction = require(_dependencyMap[10], "./nodes/AnimatedSubtraction");
  var AnimatedSubtraction = _interopDefault(_nodesAnimatedSubtraction);
  var _nodesAnimatedTracking = require(_dependencyMap[11], "./nodes/AnimatedTracking");
  var AnimatedTracking = _interopDefault(_nodesAnimatedTracking);
  var _nodesAnimatedValue = require(_dependencyMap[12], "./nodes/AnimatedValue");
  var AnimatedValue = _interopDefault(_nodesAnimatedValue);
  var _nodesAnimatedValueXY = require(_dependencyMap[13], "./nodes/AnimatedValueXY");
  var AnimatedValueXY = _interopDefault(_nodesAnimatedValueXY);
  var _animationsDecayAnimation = require(_dependencyMap[14], "./animations/DecayAnimation");
  var DecayAnimation = _interopDefault(_animationsDecayAnimation);
  var _animationsSpringAnimation = require(_dependencyMap[15], "./animations/SpringAnimation");
  var SpringAnimation = _interopDefault(_animationsSpringAnimation);
  var _animationsTimingAnimation = require(_dependencyMap[16], "./animations/TimingAnimation");
  var TimingAnimation = _interopDefault(_animationsTimingAnimation);
  var _createAnimatedComponent = require(_dependencyMap[17], "./createAnimatedComponent");
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  var _nodesAnimatedColor = require(_dependencyMap[18], "./nodes/AnimatedColor");
  var AnimatedColor = _interopDefault(_nodesAnimatedColor);
  var add = function add(a, b) {
    return new AnimatedAddition.default(a, b);
  };
  var subtract = function subtract(a, b) {
    return new AnimatedSubtraction.default(a, b);
  };
  var divide = function divide(a, b) {
    return new AnimatedDivision.default(a, b);
  };
  var multiply = function multiply(a, b) {
    return new AnimatedMultiplication.default(a, b);
  };
  var modulo = function modulo(a, modulus) {
    return new AnimatedModulo.default(a, modulus);
  };
  var diffClamp = function diffClamp(a, min, max) {
    return new AnimatedDiffClamp.default(a, min, max);
  };
  var _combineCallbacks = function _combineCallbacks(callback, config) {
    if (callback && config.onComplete) {
      return function () {
        config.onComplete && config.onComplete(...arguments);
        callback && callback(...arguments);
      };
    } else {
      return callback || config.onComplete;
    }
  };
  var maybeVectorAnim = function maybeVectorAnim(value, config, anim) {
    if (value instanceof AnimatedValueXY.default) {
      var configX = (0, _objectSpread.default)({}, config);
      var configY = (0, _objectSpread.default)({}, config);
      for (var key in config) {
        var _config$key = config[key],
          x = _config$key.x,
          y = _config$key.y;
        if (x !== undefined && y !== undefined) {
          configX[key] = x;
          configY[key] = y;
        }
      }
      var aX = anim(value.x, configX);
      var aY = anim(value.y, configY);
      // We use `stopTogether: false` here because otherwise tracking will break
      // because the second animation will get stopped before it can update.
      return parallel([aX, aY], {
        stopTogether: false
      });
    } else if (value instanceof AnimatedColor.default) {
      var configR = (0, _objectSpread.default)({}, config);
      var configG = (0, _objectSpread.default)({}, config);
      var configB = (0, _objectSpread.default)({}, config);
      var configA = (0, _objectSpread.default)({}, config);
      for (var _key in config) {
        var _config$_key = config[_key],
          r = _config$_key.r,
          g = _config$_key.g,
          b = _config$_key.b,
          a = _config$_key.a;
        if (r !== undefined && g !== undefined && b !== undefined && a !== undefined) {
          configR[_key] = r;
          configG[_key] = g;
          configB[_key] = b;
          configA[_key] = a;
        }
      }
      var aR = anim(value.r, configR);
      var aG = anim(value.g, configG);
      var aB = anim(value.b, configB);
      var aA = anim(value.a, configA);
      // We use `stopTogether: false` here because otherwise tracking will break
      // because the second animation will get stopped before it can update.
      return parallel([aR, aG, aB, aA], {
        stopTogether: false
      });
    }
    return null;
  };
  var spring = function spring(value, config) {
    var _start = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      if (configuration.toValue instanceof AnimatedNode.default) {
        singleValue.track(new AnimatedTracking.default(singleValue, configuration.toValue, SpringAnimation.default, singleConfig, callback));
      } else {
        singleValue.animate(new SpringAnimation.default(singleConfig), callback);
      }
    };
    return maybeVectorAnim(value, config, spring) || {
      start: function start(callback) {
        _start(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _objectSpread.default)((0, _objectSpread.default)({}, config), {}, {
          iterations
        });
        _start(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };
  var timing = function timing(value, config) {
    var _start2 = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      if (configuration.toValue instanceof AnimatedNode.default) {
        singleValue.track(new AnimatedTracking.default(singleValue, configuration.toValue, TimingAnimation.default, singleConfig, callback));
      } else {
        singleValue.animate(new TimingAnimation.default(singleConfig), callback);
      }
    };
    return maybeVectorAnim(value, config, timing) || {
      start: function start(callback) {
        _start2(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _objectSpread.default)((0, _objectSpread.default)({}, config), {}, {
          iterations
        });
        _start2(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };
  var decay = function decay(value, config) {
    var _start3 = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      singleValue.animate(new DecayAnimation.default(singleConfig), callback);
    };
    return maybeVectorAnim(value, config, decay) || {
      start: function start(callback) {
        _start3(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _objectSpread.default)((0, _objectSpread.default)({}, config), {}, {
          iterations
        });
        _start3(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };
  var sequence = function sequence(animations) {
    var current = 0;
    return {
      start: function start(callback) {
        var onComplete = function onComplete(result) {
          if (!result.finished) {
            callback && callback(result);
            return;
          }
          current++;
          if (current === animations.length) {
            // if the start is called, even without a reset, it should start from the beginning
            current = 0;
            callback && callback(result);
            return;
          }
          animations[current].start(onComplete);
        };
        if (animations.length === 0) {
          callback && callback({
            finished: true
          });
        } else {
          animations[current].start(onComplete);
        }
      },
      stop: function stop() {
        if (current < animations.length) {
          animations[current].stop();
        }
      },
      reset: function reset() {
        animations.forEach((animation, idx) => {
          if (idx <= current) {
            animation.reset();
          }
        });
        current = 0;
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.sequence animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
  };
  var parallel = function parallel(animations, config) {
    var doneCount = 0;
    // Make sure we only call stop() at most once for each animation
    var hasEnded = {};
    var stopTogether = !(config && config.stopTogether === false);
    var result = {
      start: function start(callback) {
        if (doneCount === animations.length) {
          callback && callback({
            finished: true
          });
          return;
        }
        animations.forEach((animation, idx) => {
          var cb = function cb(endResult) {
            hasEnded[idx] = true;
            doneCount++;
            if (doneCount === animations.length) {
              doneCount = 0;
              callback && callback(endResult);
              return;
            }
            if (!endResult.finished && stopTogether) {
              result.stop();
            }
          };
          if (!animation) {
            cb({
              finished: true
            });
          } else {
            animation.start(cb);
          }
        });
      },
      stop: function stop() {
        animations.forEach((animation, idx) => {
          !hasEnded[idx] && animation.stop();
          hasEnded[idx] = true;
        });
      },
      reset: function reset() {
        animations.forEach((animation, idx) => {
          animation.reset();
          hasEnded[idx] = false;
          doneCount = 0;
        });
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.parallel animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
    return result;
  };
  var delay = function delay(time) {
    // Would be nice to make a specialized implementation
    return timing(new AnimatedValue.default(0), {
      toValue: 0,
      delay: time,
      duration: 0,
      useNativeDriver: false
    });
  };
  var stagger = function stagger(time, animations) {
    return parallel(animations.map((animation, i) => {
      return sequence([delay(time * i), animation]);
    }));
  };
  var loop = function loop(animation,
  // $FlowFixMe[prop-missing]
  _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      _ref$iterations = _ref.iterations,
      iterations = _ref$iterations === void 0 ? -1 : _ref$iterations,
      _ref$resetBeforeItera = _ref.resetBeforeIteration,
      resetBeforeIteration = _ref$resetBeforeItera === void 0 ? true : _ref$resetBeforeItera;
    var isFinished = false;
    var iterationsSoFar = 0;
    return {
      start: function start(callback) {
        var restart = function restart(result) {
          if (result === void 0) {
            result = {
              finished: true
            };
          }
          if (isFinished || iterationsSoFar === iterations || result.finished === false) {
            callback && callback(result);
          } else {
            iterationsSoFar++;
            resetBeforeIteration && animation.reset();
            animation.start(restart);
          }
        };
        if (!animation || iterations === 0) {
          callback && callback({
            finished: true
          });
        } else {
          if (animation._isUsingNativeDriver()) {
            animation._startNativeLoop(iterations);
          } else {
            restart(); // Start looping recursively on the js thread
          }
        }
      },
      stop: function stop() {
        isFinished = true;
        animation.stop();
      },
      reset: function reset() {
        iterationsSoFar = 0;
        isFinished = false;
        animation.reset();
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.loop animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return animation._isUsingNativeDriver();
      }
    };
  };
  function forkEvent(event, listener) {
    if (!event) {
      return listener;
    } else if (event instanceof _AnimatedEvent.AnimatedEvent) {
      event.__addListener(listener);
      return event;
    } else {
      return function () {
        typeof event === 'function' && event(...arguments);
        listener(...arguments);
      };
    }
  }
  function unforkEvent(event, listener) {
    if (event && event instanceof _AnimatedEvent.AnimatedEvent) {
      event.__removeListener(listener);
    }
  }
  var event = function event(argMapping, config) {
    var animatedEvent = new _AnimatedEvent.AnimatedEvent(argMapping, config);
    if (animatedEvent.__isNative) {
      return animatedEvent;
    } else {
      return animatedEvent.__getHandler();
    }
  };

  // All types of animated nodes that represent scalar numbers and can be interpolated (etc)

  /**
   * The `Animated` library is designed to make animations fluid, powerful, and
   * easy to build and maintain. `Animated` focuses on declarative relationships
   * between inputs and outputs, with configurable transforms in between, and
   * simple `start`/`stop` methods to control time-based animation execution.
   * If additional transforms are added, be sure to include them in
   * AnimatedMock.js as well.
   *
   * See https://reactnative.dev/docs/animated
   */
  var _default = {
    /**
     * Standard value class for driving animations.  Typically initialized with
     * `new Animated.Value(0);`
     *
     * See https://reactnative.dev/docs/animated#value
     */
    Value: AnimatedValue.default,
    /**
     * 2D value class for driving 2D animations, such as pan gestures.
     *
     * See https://reactnative.dev/docs/animatedvaluexy
     */
    ValueXY: AnimatedValueXY.default,
    /**
     * Value class for driving color animations.
     */
    Color: AnimatedColor.default,
    /**
     * Exported to use the Interpolation type in flow.
     *
     * See https://reactnative.dev/docs/animated#interpolation
     */
    Interpolation: AnimatedInterpolation.default,
    /**
     * Exported for ease of type checking. All animated values derive from this
     * class.
     *
     * See https://reactnative.dev/docs/animated#node
     */
    Node: AnimatedNode.default,
    /**
     * Animates a value from an initial velocity to zero based on a decay
     * coefficient.
     *
     * See https://reactnative.dev/docs/animated#decay
     */
    decay,
    /**
     * Animates a value along a timed easing curve. The Easing module has tons of
     * predefined curves, or you can use your own function.
     *
     * See https://reactnative.dev/docs/animated#timing
     */
    timing,
    /**
     * Animates a value according to an analytical spring model based on
     * damped harmonic oscillation.
     *
     * See https://reactnative.dev/docs/animated#spring
     */
    spring,
    /**
     * Creates a new Animated value composed from two Animated values added
     * together.
     *
     * See https://reactnative.dev/docs/animated#add
     */
    add,
    /**
     * Creates a new Animated value composed by subtracting the second Animated
     * value from the first Animated value.
     *
     * See https://reactnative.dev/docs/animated#subtract
     */
    subtract,
    /**
     * Creates a new Animated value composed by dividing the first Animated value
     * by the second Animated value.
     *
     * See https://reactnative.dev/docs/animated#divide
     */
    divide,
    /**
     * Creates a new Animated value composed from two Animated values multiplied
     * together.
     *
     * See https://reactnative.dev/docs/animated#multiply
     */
    multiply,
    /**
     * Creates a new Animated value that is the (non-negative) modulo of the
     * provided Animated value.
     *
     * See https://reactnative.dev/docs/animated#modulo
     */
    modulo,
    /**
     * Create a new Animated value that is limited between 2 values. It uses the
     * difference between the last value so even if the value is far from the
     * bounds it will start changing when the value starts getting closer again.
     *
     * See https://reactnative.dev/docs/animated#diffclamp
     */
    diffClamp,
    /**
     * Starts an animation after the given delay.
     *
     * See https://reactnative.dev/docs/animated#delay
     */
    delay,
    /**
     * Starts an array of animations in order, waiting for each to complete
     * before starting the next. If the current running animation is stopped, no
     * following animations will be started.
     *
     * See https://reactnative.dev/docs/animated#sequence
     */
    sequence,
    /**
     * Starts an array of animations all at the same time. By default, if one
     * of the animations is stopped, they will all be stopped. You can override
     * this with the `stopTogether` flag.
     *
     * See https://reactnative.dev/docs/animated#parallel
     */
    parallel,
    /**
     * Array of animations may run in parallel (overlap), but are started in
     * sequence with successive delays.  Nice for doing trailing effects.
     *
     * See https://reactnative.dev/docs/animated#stagger
     */
    stagger,
    /**
     * Loops a given animation continuously, so that each time it reaches the
     * end, it resets and begins again from the start.
     *
     * See https://reactnative.dev/docs/animated#loop
     */
    loop,
    /**
     * Takes an array of mappings and extracts values from each arg accordingly,
     * then calls `setValue` on the mapped outputs.
     *
     * See https://reactnative.dev/docs/animated#event
     */
    event,
    /**
     * Make any React component Animatable.  Used to create `Animated.View`, etc.
     *
     * See https://reactnative.dev/docs/animated#createanimatedcomponent
     */
    createAnimatedComponent: createAnimatedComponent.default,
    /**
     * Imperative API to attach an animated value to an event on a view. Prefer
     * using `Animated.event` with `useNativeDrive: true` if possible.
     *
     * See https://reactnative.dev/docs/animated#attachnativeevent
     */
    attachNativeEvent: _AnimatedEvent.attachNativeEvent,
    /**
     * Advanced imperative API for snooping on animated events that are passed in
     * through props. Use values directly where possible.
     *
     * See https://reactnative.dev/docs/animated#forkevent
     */
    forkEvent,
    unforkEvent,
    /**
     * Expose Event class, so it can be used as a type for type checkers.
     */
    Event: _AnimatedEvent.AnimatedEvent
  };
},220,[37,196,221,222,223,198,224,225,200,195,226,227,197,228,229,231,234,193,233],"node_modules/react-native-web/dist/vendor/react-native/Animated/AnimatedImplementation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0], "./AnimatedInterpolation");
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedValue = require(_dependencyMap[1], "./AnimatedValue");
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[2], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedAddition extends AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._a = typeof a === 'number' ? new AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return this._a.__getValue() + this._b.__getValue();
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'addition',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = AnimatedAddition;
},221,[198,197,199],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedAddition.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0], "./AnimatedInterpolation");
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedWithChildren = require(_dependencyMap[1], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedDiffClamp extends AnimatedWithChildren.default {
    constructor(a, min, max) {
      super();
      this._a = a;
      this._min = min;
      this._max = max;
      this._value = this._lastValue = this._a.__getValue();
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __getValue() {
      var value = this._a.__getValue();
      var diff = value - this._lastValue;
      this._lastValue = value;
      this._value = Math.min(Math.max(this._value + diff, this._min), this._max);
      return this._value;
    }
    __attach() {
      this._a.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'diffclamp',
        input: this._a.__getNativeTag(),
        min: this._min,
        max: this._max
      };
    }
  }
  var _default = AnimatedDiffClamp;
},222,[198,199],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedDiffClamp.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0], "./AnimatedInterpolation");
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedNode = require(_dependencyMap[1], "./AnimatedNode");
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _AnimatedValue = require(_dependencyMap[2], "./AnimatedValue");
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[3], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedDivision extends AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._warnedAboutDivideByZero = false;
      if (b === 0 || b instanceof AnimatedNode.default && b.__getValue() === 0) {
        console.error('Detected potential division by zero in AnimatedDivision');
      }
      this._a = typeof a === 'number' ? new AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      var a = this._a.__getValue();
      var b = this._b.__getValue();
      if (b === 0) {
        // Prevent spamming the console/LogBox
        if (!this._warnedAboutDivideByZero) {
          console.error('Detected division by zero in AnimatedDivision');
          this._warnedAboutDivideByZero = true;
        }
        // Passing infinity/NaN to Fabric will cause a native crash
        return 0;
      }
      this._warnedAboutDivideByZero = false;
      return a / b;
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'division',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = AnimatedDivision;
},223,[198,200,197,199],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedDivision.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0], "./AnimatedInterpolation");
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedWithChildren = require(_dependencyMap[1], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedModulo extends AnimatedWithChildren.default {
    constructor(a, modulus) {
      super();
      this._a = a;
      this._modulus = modulus;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return (this._a.__getValue() % this._modulus + this._modulus) % this._modulus;
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'modulus',
        input: this._a.__getNativeTag(),
        modulus: this._modulus
      };
    }
  }
  var _default = AnimatedModulo;
},224,[198,199],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedModulo.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0], "./AnimatedInterpolation");
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedValue = require(_dependencyMap[1], "./AnimatedValue");
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[2], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedMultiplication extends AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._a = typeof a === 'number' ? new AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return this._a.__getValue() * this._b.__getValue();
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'multiplication',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = AnimatedMultiplication;
},225,[198,197,199],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedMultiplication.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0], "./AnimatedInterpolation");
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedValue = require(_dependencyMap[1], "./AnimatedValue");
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[2], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedSubtraction extends AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._a = typeof a === 'number' ? new AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return this._a.__getValue() - this._b.__getValue();
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'subtraction',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = AnimatedSubtraction;
},226,[198,197,199],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedSubtraction.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  require(_dependencyMap[1], "./AnimatedValue");
  var _AnimatedNode = require(_dependencyMap[2], "./AnimatedNode");
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _NativeAnimatedHelper = require(_dependencyMap[3], "../NativeAnimatedHelper");
  class AnimatedTracking extends AnimatedNode.default {
    constructor(value, parent, animationClass, animationConfig, callback) {
      super();
      this._value = value;
      this._parent = parent;
      this._animationClass = animationClass;
      this._animationConfig = animationConfig;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(animationConfig);
      this._callback = callback;
      this.__attach();
    }
    __makeNative() {
      this.__isNative = true;
      this._parent.__makeNative();
      super.__makeNative();
      this._value.__makeNative();
    }
    __getValue() {
      return this._parent.__getValue();
    }
    __attach() {
      this._parent.__addChild(this);
      if (this._useNativeDriver) {
        // when the tracking starts we need to convert this node to a "native node"
        // so that the parent node will be made "native" too. This is necessary as
        // if we don't do this `update` method will get called. At that point it
        // may be too late as it would mean the JS driver has already started
        // updating node values
        this.__makeNative();
      }
    }
    __detach() {
      this._parent.__removeChild(this);
      super.__detach();
    }
    update() {
      this._value.animate(new this._animationClass((0, _objectSpread.default)((0, _objectSpread.default)({}, this._animationConfig), {}, {
        toValue: this._animationConfig.toValue.__getValue()
      })), this._callback);
    }
    __getNativeConfig() {
      var animation = new this._animationClass((0, _objectSpread.default)((0, _objectSpread.default)({}, this._animationConfig), {}, {
        // remove toValue from the config as it's a ref to Animated.Value
        toValue: undefined
      }));
      var animationConfig = animation.__getNativeAnimationConfig();
      return {
        type: 'tracking',
        animationId: (0, _NativeAnimatedHelper.generateNewAnimationId)(),
        animationConfig,
        toValue: this._parent.__getNativeTag(),
        value: this._value.__getNativeTag()
      };
    }
  }
  var _default = AnimatedTracking;
},227,[37,197,200,201],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedTracking.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedValue = require(_dependencyMap[0], "./AnimatedValue");
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[1], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _fbjsLibInvariant = require(_dependencyMap[2], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _uniqueId = 1;

  /**
   * 2D Value for driving 2D animations, such as pan gestures. Almost identical
   * API to normal `Animated.Value`, but multiplexed.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html
   */
  class AnimatedValueXY extends AnimatedWithChildren.default {
    constructor(valueIn) {
      super();
      var value = valueIn || {
        x: 0,
        y: 0
      }; // fixme: shouldn't need `: any`
      if (typeof value.x === 'number' && typeof value.y === 'number') {
        this.x = new AnimatedValue.default(value.x);
        this.y = new AnimatedValue.default(value.y);
      } else {
        (0, invariant.default)(value.x instanceof AnimatedValue.default && value.y instanceof AnimatedValue.default, 'AnimatedValueXY must be initialized with an object of numbers or ' + 'AnimatedValues.');
        this.x = value.x;
        this.y = value.y;
      }
      this._listeners = {};
    }

    /**
     * Directly set the value. This will stop any animations running on the value
     * and update all the bound properties.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#setvalue
     */
    setValue(value) {
      this.x.setValue(value.x);
      this.y.setValue(value.y);
    }

    /**
     * Sets an offset that is applied on top of whatever value is set, whether
     * via `setValue`, an animation, or `Animated.event`. Useful for compensating
     * things like the start of a pan gesture.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#setoffset
     */
    setOffset(offset) {
      this.x.setOffset(offset.x);
      this.y.setOffset(offset.y);
    }

    /**
     * Merges the offset value into the base value and resets the offset to zero.
     * The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#flattenoffset
     */
    flattenOffset() {
      this.x.flattenOffset();
      this.y.flattenOffset();
    }

    /**
     * Sets the offset value to the base value, and resets the base value to
     * zero. The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#extractoffset
     */
    extractOffset() {
      this.x.extractOffset();
      this.y.extractOffset();
    }
    __getValue() {
      return {
        x: this.x.__getValue(),
        y: this.y.__getValue()
      };
    }

    /**
     * Stops any animation and resets the value to its original.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#resetanimation
     */
    resetAnimation(callback) {
      this.x.resetAnimation();
      this.y.resetAnimation();
      callback && callback(this.__getValue());
    }

    /**
     * Stops any running animation or tracking. `callback` is invoked with the
     * final value after stopping the animation, which is useful for updating
     * state to match the animation position with layout.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#stopanimation
     */
    stopAnimation(callback) {
      this.x.stopAnimation();
      this.y.stopAnimation();
      callback && callback(this.__getValue());
    }

    /**
     * Adds an asynchronous listener to the value so you can observe updates from
     * animations.  This is useful because there is no way to synchronously read
     * the value because it might be driven natively.
     *
     * Returns a string that serves as an identifier for the listener.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#addlistener
     */
    addListener(callback) {
      var id = String(_uniqueId++);
      var jointCallback = _ref => {
        var number = _ref.value;
        callback(this.__getValue());
      };
      this._listeners[id] = {
        x: this.x.addListener(jointCallback),
        y: this.y.addListener(jointCallback)
      };
      return id;
    }

    /**
     * Unregister a listener. The `id` param shall match the identifier
     * previously returned by `addListener()`.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#removelistener
     */
    removeListener(id) {
      this.x.removeListener(this._listeners[id].x);
      this.y.removeListener(this._listeners[id].y);
      delete this._listeners[id];
    }

    /**
     * Remove all registered listeners.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#removealllisteners
     */
    removeAllListeners() {
      this.x.removeAllListeners();
      this.y.removeAllListeners();
      this._listeners = {};
    }

    /**
     * Converts `{x, y}` into `{left, top}` for use in style.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#getlayout
     */
    getLayout() {
      return {
        left: this.x,
        top: this.y
      };
    }

    /**
     * Converts `{x, y}` into a useable translation transform.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#gettranslatetransform
     */
    getTranslateTransform() {
      return [{
        translateX: this.x
      }, {
        translateY: this.y
      }];
    }
  }
  var _default = AnimatedValueXY;
},228,[197,199,17],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedValueXY.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _Animation = require(_dependencyMap[0], "./Animation");
  var Animation = _interopDefault(_Animation);
  var _NativeAnimatedHelper = require(_dependencyMap[1], "../NativeAnimatedHelper");
  class DecayAnimation extends Animation.default {
    constructor(config) {
      var _config$deceleration, _config$isInteraction, _config$iterations;
      super();
      this._deceleration = (_config$deceleration = config.deceleration) !== null && _config$deceleration !== void 0 ? _config$deceleration : 0.998;
      this._velocity = config.velocity;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
      this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== void 0 ? _config$isInteraction : !this._useNativeDriver;
      this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== void 0 ? _config$iterations : 1;
    }
    __getNativeAnimationConfig() {
      return {
        type: 'decay',
        deceleration: this._deceleration,
        velocity: this._velocity,
        iterations: this.__iterations
      };
    }
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
      this.__active = true;
      this._lastValue = fromValue;
      this._fromValue = fromValue;
      this._onUpdate = onUpdate;
      this.__onEnd = onEnd;
      this._startTime = Date.now();
      if (this._useNativeDriver) {
        this.__startNativeAnimation(animatedValue);
      } else {
        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }
    onUpdate() {
      var now = Date.now();
      var value = this._fromValue + this._velocity / (1 - this._deceleration) * (1 - Math.exp(-(1 - this._deceleration) * (now - this._startTime)));
      this._onUpdate(value);
      if (Math.abs(this._lastValue - value) < 0.1) {
        this.__debouncedOnEnd({
          finished: true
        });
        return;
      }
      this._lastValue = value;
      if (this.__active) {
        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }
    stop() {
      super.stop();
      this.__active = false;
      global.cancelAnimationFrame(this._animationFrame);
      this.__debouncedOnEnd({
        finished: false
      });
    }
  }
  var _default = DecayAnimation;
},229,[230,201],"node_modules/react-native-web/dist/vendor/react-native/Animated/animations/DecayAnimation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _NativeAnimatedHelper = require(_dependencyMap[0], "../NativeAnimatedHelper");
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var startNativeAnimationNextId = 1;

  // Important note: start() and stop() will only be called at most once.
  // Once an animation has been stopped or finished its course, it will
  // not be reused.
  class Animation {
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {}
    stop() {
      if (this.__nativeId) {
        NativeAnimatedHelper.default.API.stopAnimation(this.__nativeId);
      }
    }
    __getNativeAnimationConfig() {
      // Subclasses that have corresponding animation implementation done in native
      // should override this method
      throw new Error('This animation type cannot be offloaded to native');
    }
    // Helper function for subclasses to make sure onEnd is only called once.
    __debouncedOnEnd(result) {
      var onEnd = this.__onEnd;
      this.__onEnd = null;
      onEnd && onEnd(result);
    }
    __startNativeAnimation(animatedValue) {
      var startNativeAnimationWaitId = startNativeAnimationNextId + ":startAnimation";
      startNativeAnimationNextId += 1;
      NativeAnimatedHelper.default.API.setWaitingForIdentifier(startNativeAnimationWaitId);
      try {
        var config = this.__getNativeAnimationConfig();
        animatedValue.__makeNative(config.platformConfig);
        this.__nativeId = NativeAnimatedHelper.default.generateNewAnimationId();
        NativeAnimatedHelper.default.API.startAnimatingNode(this.__nativeId, animatedValue.__getNativeTag(), config,
        // $FlowFixMe[method-unbinding] added when improving typing for this parameters
        this.__debouncedOnEnd.bind(this));
      } catch (e) {
        throw e;
      } finally {
        NativeAnimatedHelper.default.API.unsetWaitingForIdentifier(startNativeAnimationWaitId);
      }
    }
  }
  var _default = Animation;
},230,[201],"node_modules/react-native-web/dist/vendor/react-native/Animated/animations/Animation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _Animation = require(_dependencyMap[0], "./Animation");
  var Animation = _interopDefault(_Animation);
  var _SpringConfig = require(_dependencyMap[1], "../SpringConfig");
  var SpringConfig = _interopDefault(_SpringConfig);
  var _fbjsLibInvariant = require(_dependencyMap[2], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _NativeAnimatedHelper = require(_dependencyMap[3], "../NativeAnimatedHelper");
  require(_dependencyMap[4], "../nodes/AnimatedColor");
  class SpringAnimation extends Animation.default {
    constructor(config) {
      var _config$overshootClam, _config$restDisplacem, _config$restSpeedThre, _config$velocity, _config$velocity2, _config$delay, _config$isInteraction, _config$iterations;
      super();
      this._overshootClamping = (_config$overshootClam = config.overshootClamping) !== null && _config$overshootClam !== void 0 ? _config$overshootClam : false;
      this._restDisplacementThreshold = (_config$restDisplacem = config.restDisplacementThreshold) !== null && _config$restDisplacem !== void 0 ? _config$restDisplacem : 0.001;
      this._restSpeedThreshold = (_config$restSpeedThre = config.restSpeedThreshold) !== null && _config$restSpeedThre !== void 0 ? _config$restSpeedThre : 0.001;
      this._initialVelocity = (_config$velocity = config.velocity) !== null && _config$velocity !== void 0 ? _config$velocity : 0;
      this._lastVelocity = (_config$velocity2 = config.velocity) !== null && _config$velocity2 !== void 0 ? _config$velocity2 : 0;
      this._toValue = config.toValue;
      this._delay = (_config$delay = config.delay) !== null && _config$delay !== void 0 ? _config$delay : 0;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
      this._platformConfig = config.platformConfig;
      this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== void 0 ? _config$isInteraction : !this._useNativeDriver;
      this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== void 0 ? _config$iterations : 1;
      if (config.stiffness !== undefined || config.damping !== undefined || config.mass !== undefined) {
        var _config$stiffness, _config$damping, _config$mass;
        (0, invariant.default)(config.bounciness === undefined && config.speed === undefined && config.tension === undefined && config.friction === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');
        this._stiffness = (_config$stiffness = config.stiffness) !== null && _config$stiffness !== void 0 ? _config$stiffness : 100;
        this._damping = (_config$damping = config.damping) !== null && _config$damping !== void 0 ? _config$damping : 10;
        this._mass = (_config$mass = config.mass) !== null && _config$mass !== void 0 ? _config$mass : 1;
      } else if (config.bounciness !== undefined || config.speed !== undefined) {
        var _config$bounciness, _config$speed;
        // Convert the origami bounciness/speed values to stiffness/damping
        // We assume mass is 1.
        (0, invariant.default)(config.tension === undefined && config.friction === undefined && config.stiffness === undefined && config.damping === undefined && config.mass === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');
        var springConfig = SpringConfig.default.fromBouncinessAndSpeed((_config$bounciness = config.bounciness) !== null && _config$bounciness !== void 0 ? _config$bounciness : 8, (_config$speed = config.speed) !== null && _config$speed !== void 0 ? _config$speed : 12);
        this._stiffness = springConfig.stiffness;
        this._damping = springConfig.damping;
        this._mass = 1;
      } else {
        var _config$tension, _config$friction;
        // Convert the origami tension/friction values to stiffness/damping
        // We assume mass is 1.
        var _springConfig = SpringConfig.default.fromOrigamiTensionAndFriction((_config$tension = config.tension) !== null && _config$tension !== void 0 ? _config$tension : 40, (_config$friction = config.friction) !== null && _config$friction !== void 0 ? _config$friction : 7);
        this._stiffness = _springConfig.stiffness;
        this._damping = _springConfig.damping;
        this._mass = 1;
      }
      (0, invariant.default)(this._stiffness > 0, 'Stiffness value must be greater than 0');
      (0, invariant.default)(this._damping > 0, 'Damping value must be greater than 0');
      (0, invariant.default)(this._mass > 0, 'Mass value must be greater than 0');
    }
    __getNativeAnimationConfig() {
      var _this$_initialVelocit;
      return {
        type: 'spring',
        overshootClamping: this._overshootClamping,
        restDisplacementThreshold: this._restDisplacementThreshold,
        restSpeedThreshold: this._restSpeedThreshold,
        stiffness: this._stiffness,
        damping: this._damping,
        mass: this._mass,
        initialVelocity: (_this$_initialVelocit = this._initialVelocity) !== null && _this$_initialVelocit !== void 0 ? _this$_initialVelocit : this._lastVelocity,
        toValue: this._toValue,
        iterations: this.__iterations,
        platformConfig: this._platformConfig
      };
    }
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
      this.__active = true;
      this._startPosition = fromValue;
      this._lastPosition = this._startPosition;
      this._onUpdate = onUpdate;
      this.__onEnd = onEnd;
      this._lastTime = Date.now();
      this._frameTime = 0.0;
      if (previousAnimation instanceof SpringAnimation) {
        var internalState = previousAnimation.getInternalState();
        this._lastPosition = internalState.lastPosition;
        this._lastVelocity = internalState.lastVelocity;
        // Set the initial velocity to the last velocity
        this._initialVelocity = this._lastVelocity;
        this._lastTime = internalState.lastTime;
      }
      var start = () => {
        if (this._useNativeDriver) {
          this.__startNativeAnimation(animatedValue);
        } else {
          this.onUpdate();
        }
      };

      //  If this._delay is more than 0, we start after the timeout.
      if (this._delay) {
        this._timeout = setTimeout(start, this._delay);
      } else {
        start();
      }
    }
    getInternalState() {
      return {
        lastPosition: this._lastPosition,
        lastVelocity: this._lastVelocity,
        lastTime: this._lastTime
      };
    }

    /**
     * This spring model is based off of a damped harmonic oscillator
     * (https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator).
     *
     * We use the closed form of the second order differential equation:
     *
     * x'' + (2ζ⍵_0)x' + ⍵^2x = 0
     *
     * where
     *    ⍵_0 = √(k / m) (undamped angular frequency of the oscillator),
     *    ζ = c / 2√mk (damping ratio),
     *    c = damping constant
     *    k = stiffness
     *    m = mass
     *
     * The derivation of the closed form is described in detail here:
     * http://planetmath.org/sites/default/files/texpdf/39745.pdf
     *
     * This algorithm happens to match the algorithm used by CASpringAnimation,
     * a QuartzCore (iOS) API that creates spring animations.
     */
    onUpdate() {
      // If for some reason we lost a lot of frames (e.g. process large payload or
      // stopped in the debugger), we only advance by 4 frames worth of
      // computation and will continue on the next frame. It's better to have it
      // running at faster speed than jumping to the end.
      var MAX_STEPS = 64;
      var now = Date.now();
      if (now > this._lastTime + MAX_STEPS) {
        now = this._lastTime + MAX_STEPS;
      }
      var deltaTime = (now - this._lastTime) / 1000;
      this._frameTime += deltaTime;
      var c = this._damping;
      var m = this._mass;
      var k = this._stiffness;
      var v0 = -this._initialVelocity;
      var zeta = c / (2 * Math.sqrt(k * m)); // damping ratio
      var omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)
      var omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta); // exponential decay
      var x0 = this._toValue - this._startPosition; // calculate the oscillation from x0 = 1 to x = 0

      var position = 0.0;
      var velocity = 0.0;
      var t = this._frameTime;
      if (zeta < 1) {
        // Under damped
        var envelope = Math.exp(-zeta * omega0 * t);
        position = this._toValue - envelope * ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * t) + x0 * Math.cos(omega1 * t));
        // This looks crazy -- it's actually just the derivative of the
        // oscillation function
        velocity = zeta * omega0 * envelope * (Math.sin(omega1 * t) * (v0 + zeta * omega0 * x0) / omega1 + x0 * Math.cos(omega1 * t)) - envelope * (Math.cos(omega1 * t) * (v0 + zeta * omega0 * x0) - omega1 * x0 * Math.sin(omega1 * t));
      } else {
        // Critically damped
        var _envelope = Math.exp(-omega0 * t);
        position = this._toValue - _envelope * (x0 + (v0 + omega0 * x0) * t);
        velocity = _envelope * (v0 * (t * omega0 - 1) + t * x0 * (omega0 * omega0));
      }
      this._lastTime = now;
      this._lastPosition = position;
      this._lastVelocity = velocity;
      this._onUpdate(position);
      if (!this.__active) {
        // a listener might have stopped us in _onUpdate
        return;
      }

      // Conditions for stopping the spring animation
      var isOvershooting = false;
      if (this._overshootClamping && this._stiffness !== 0) {
        if (this._startPosition < this._toValue) {
          isOvershooting = position > this._toValue;
        } else {
          isOvershooting = position < this._toValue;
        }
      }
      var isVelocity = Math.abs(velocity) <= this._restSpeedThreshold;
      var isDisplacement = true;
      if (this._stiffness !== 0) {
        isDisplacement = Math.abs(this._toValue - position) <= this._restDisplacementThreshold;
      }
      if (isOvershooting || isVelocity && isDisplacement) {
        if (this._stiffness !== 0) {
          // Ensure that we end up with a round value
          this._lastPosition = this._toValue;
          this._lastVelocity = 0;
          this._onUpdate(this._toValue);
        }
        this.__debouncedOnEnd({
          finished: true
        });
        return;
      }
      // $FlowFixMe[method-unbinding] added when improving typing for this parameters
      this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
    }
    stop() {
      super.stop();
      this.__active = false;
      clearTimeout(this._timeout);
      global.cancelAnimationFrame(this._animationFrame);
      this.__debouncedOnEnd({
        finished: false
      });
    }
  }
  var _default = SpringAnimation;
},231,[230,232,17,201,233],"node_modules/react-native-web/dist/vendor/react-native/Animated/animations/SpringAnimation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  function stiffnessFromOrigamiValue(oValue) {
    return (oValue - 30) * 3.62 + 194;
  }
  function dampingFromOrigamiValue(oValue) {
    return (oValue - 8) * 3 + 25;
  }
  function fromOrigamiTensionAndFriction(tension, friction) {
    return {
      stiffness: stiffnessFromOrigamiValue(tension),
      damping: dampingFromOrigamiValue(friction)
    };
  }
  function fromBouncinessAndSpeed(bounciness, speed) {
    function normalize(value, startValue, endValue) {
      return (value - startValue) / (endValue - startValue);
    }
    function projectNormal(n, start, end) {
      return start + n * (end - start);
    }
    function linearInterpolation(t, start, end) {
      return t * end + (1 - t) * start;
    }
    function quadraticOutInterpolation(t, start, end) {
      return linearInterpolation(2 * t - t * t, start, end);
    }
    function b3Friction1(x) {
      return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
    }
    function b3Friction2(x) {
      return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
    }
    function b3Friction3(x) {
      return 0.00000045 * Math.pow(x, 3) - 0.000332 * Math.pow(x, 2) + 0.1078 * x + 5.84;
    }
    function b3Nobounce(tension) {
      if (tension <= 18) {
        return b3Friction1(tension);
      } else if (tension > 18 && tension <= 44) {
        return b3Friction2(tension);
      } else {
        return b3Friction3(tension);
      }
    }
    var b = normalize(bounciness / 1.7, 0, 20);
    b = projectNormal(b, 0, 0.8);
    var s = normalize(speed / 1.7, 0, 20);
    var bouncyTension = projectNormal(s, 0.5, 200);
    var bouncyFriction = quadraticOutInterpolation(b, b3Nobounce(bouncyTension), 0.01);
    return {
      stiffness: stiffnessFromOrigamiValue(bouncyTension),
      damping: dampingFromOrigamiValue(bouncyFriction)
    };
  }
  var _default = {
    fromOrigamiTensionAndFriction,
    fromBouncinessAndSpeed
  };
},232,[],"node_modules/react-native-web/dist/vendor/react-native/Animated/SpringConfig.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return AnimatedColor;
    }
  });
  var _AnimatedValue = require(_dependencyMap[0], "./AnimatedValue");
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[1], "./AnimatedWithChildren");
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _reactNativeNormalizeColors = require(_dependencyMap[2], "@react-native/normalize-colors");
  var normalizeColor = _interopDefault(_reactNativeNormalizeColors);
  var _NativeAnimatedHelper = require(_dependencyMap[3], "../NativeAnimatedHelper");
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var NativeAnimatedAPI = NativeAnimatedHelper.default.API;
  var defaultColor = {
    r: 0,
    g: 0,
    b: 0,
    a: 1.0
  };
  var _uniqueId = 1;
  var processColorObject = color => {
    return color;
  };

  /* eslint no-bitwise: 0 */
  function processColor(color) {
    if (color === undefined || color === null) {
      return null;
    }
    if (isRgbaValue(color)) {
      // $FlowIgnore[incompatible-cast] - Type is verified above
      return color;
    }
    var normalizedColor = (0, normalizeColor.default)(
    // $FlowIgnore[incompatible-cast] - Type is verified above
    color);
    if (normalizedColor === undefined || normalizedColor === null) {
      return null;
    }
    if (typeof normalizedColor === 'object') {
      var processedColorObj = processColorObject(normalizedColor);
      if (processedColorObj != null) {
        return processedColorObj;
      }
    } else if (typeof normalizedColor === 'number') {
      var r = (normalizedColor & 0xff000000) >>> 24;
      var g = (normalizedColor & 0x00ff0000) >>> 16;
      var b = (normalizedColor & 0x0000ff00) >>> 8;
      var a = (normalizedColor & 0x000000ff) / 255;
      return {
        r,
        g,
        b,
        a
      };
    }
    return null;
  }
  function isRgbaValue(value) {
    return value && typeof value.r === 'number' && typeof value.g === 'number' && typeof value.b === 'number' && typeof value.a === 'number';
  }
  function isRgbaAnimatedValue(value) {
    return value && value.r instanceof AnimatedValue.default && value.g instanceof AnimatedValue.default && value.b instanceof AnimatedValue.default && value.a instanceof AnimatedValue.default;
  }
  class AnimatedColor extends AnimatedWithChildren.default {
    constructor(valueIn, config) {
      super();
      this._listeners = {};
      var value = valueIn !== null && valueIn !== void 0 ? valueIn : defaultColor;
      if (isRgbaAnimatedValue(value)) {
        // $FlowIgnore[incompatible-cast] - Type is verified above
        var rgbaAnimatedValue = value;
        this.r = rgbaAnimatedValue.r;
        this.g = rgbaAnimatedValue.g;
        this.b = rgbaAnimatedValue.b;
        this.a = rgbaAnimatedValue.a;
      } else {
        var _processColor;
        var processedColor =
        // $FlowIgnore[incompatible-cast] - Type is verified above
        (_processColor = processColor(value)) !== null && _processColor !== void 0 ? _processColor : defaultColor;
        var initColor = defaultColor;
        if (isRgbaValue(processedColor)) {
          // $FlowIgnore[incompatible-cast] - Type is verified above
          initColor = processedColor;
        } else {
          // $FlowIgnore[incompatible-cast] - Type is verified above
          this.nativeColor = processedColor;
        }
        this.r = new AnimatedValue.default(initColor.r);
        this.g = new AnimatedValue.default(initColor.g);
        this.b = new AnimatedValue.default(initColor.b);
        this.a = new AnimatedValue.default(initColor.a);
      }
      if (this.nativeColor || config && config.useNativeDriver) {
        this.__makeNative();
      }
    }

    /**
     * Directly set the value. This will stop any animations running on the value
     * and update all the bound properties.
     */
    setValue(value) {
      var _processColor2;
      var shouldUpdateNodeConfig = false;
      if (this.__isNative) {
        var nativeTag = this.__getNativeTag();
        NativeAnimatedAPI.setWaitingForIdentifier(nativeTag.toString());
      }
      var processedColor = (_processColor2 = processColor(value)) !== null && _processColor2 !== void 0 ? _processColor2 : defaultColor;
      if (isRgbaValue(processedColor)) {
        // $FlowIgnore[incompatible-type] - Type is verified above
        var rgbaValue = processedColor;
        this.r.setValue(rgbaValue.r);
        this.g.setValue(rgbaValue.g);
        this.b.setValue(rgbaValue.b);
        this.a.setValue(rgbaValue.a);
        if (this.nativeColor != null) {
          this.nativeColor = null;
          shouldUpdateNodeConfig = true;
        }
      } else {
        // $FlowIgnore[incompatible-type] - Type is verified above
        var nativeColor = processedColor;
        if (this.nativeColor !== nativeColor) {
          this.nativeColor = nativeColor;
          shouldUpdateNodeConfig = true;
        }
      }
      if (this.__isNative) {
        var _nativeTag = this.__getNativeTag();
        if (shouldUpdateNodeConfig) {
          NativeAnimatedAPI.updateAnimatedNodeConfig(_nativeTag, this.__getNativeConfig());
        }
        NativeAnimatedAPI.unsetWaitingForIdentifier(_nativeTag.toString());
      }
    }

    /**
     * Sets an offset that is applied on top of whatever value is set, whether
     * via `setValue`, an animation, or `Animated.event`. Useful for compensating
     * things like the start of a pan gesture.
     */
    setOffset(offset) {
      this.r.setOffset(offset.r);
      this.g.setOffset(offset.g);
      this.b.setOffset(offset.b);
      this.a.setOffset(offset.a);
    }

    /**
     * Merges the offset value into the base value and resets the offset to zero.
     * The final output of the value is unchanged.
     */
    flattenOffset() {
      this.r.flattenOffset();
      this.g.flattenOffset();
      this.b.flattenOffset();
      this.a.flattenOffset();
    }

    /**
     * Sets the offset value to the base value, and resets the base value to
     * zero. The final output of the value is unchanged.
     */
    extractOffset() {
      this.r.extractOffset();
      this.g.extractOffset();
      this.b.extractOffset();
      this.a.extractOffset();
    }

    /**
     * Adds an asynchronous listener to the value so you can observe updates from
     * animations.  This is useful because there is no way to synchronously read
     * the value because it might be driven natively.
     *
     * Returns a string that serves as an identifier for the listener.
     */
    addListener(callback) {
      var id = String(_uniqueId++);
      var jointCallback = _ref => {
        var number = _ref.value;
        callback(this.__getValue());
      };
      this._listeners[id] = {
        r: this.r.addListener(jointCallback),
        g: this.g.addListener(jointCallback),
        b: this.b.addListener(jointCallback),
        a: this.a.addListener(jointCallback)
      };
      return id;
    }

    /**
     * Unregister a listener. The `id` param shall match the identifier
     * previously returned by `addListener()`.
     */
    removeListener(id) {
      this.r.removeListener(this._listeners[id].r);
      this.g.removeListener(this._listeners[id].g);
      this.b.removeListener(this._listeners[id].b);
      this.a.removeListener(this._listeners[id].a);
      delete this._listeners[id];
    }

    /**
     * Remove all registered listeners.
     */
    removeAllListeners() {
      this.r.removeAllListeners();
      this.g.removeAllListeners();
      this.b.removeAllListeners();
      this.a.removeAllListeners();
      this._listeners = {};
    }

    /**
     * Stops any running animation or tracking. `callback` is invoked with the
     * final value after stopping the animation, which is useful for updating
     * state to match the animation position with layout.
     */
    stopAnimation(callback) {
      this.r.stopAnimation();
      this.g.stopAnimation();
      this.b.stopAnimation();
      this.a.stopAnimation();
      callback && callback(this.__getValue());
    }

    /**
     * Stops any animation and resets the value to its original.
     */
    resetAnimation(callback) {
      this.r.resetAnimation();
      this.g.resetAnimation();
      this.b.resetAnimation();
      this.a.resetAnimation();
      callback && callback(this.__getValue());
    }
    __getValue() {
      if (this.nativeColor != null) {
        return this.nativeColor;
      } else {
        return "rgba(" + this.r.__getValue() + ", " + this.g.__getValue() + ", " + this.b.__getValue() + ", " + this.a.__getValue() + ")";
      }
    }
    __attach() {
      this.r.__addChild(this);
      this.g.__addChild(this);
      this.b.__addChild(this);
      this.a.__addChild(this);
      super.__attach();
    }
    __detach() {
      this.r.__removeChild(this);
      this.g.__removeChild(this);
      this.b.__removeChild(this);
      this.a.__removeChild(this);
      super.__detach();
    }
    __makeNative(platformConfig) {
      this.r.__makeNative(platformConfig);
      this.g.__makeNative(platformConfig);
      this.b.__makeNative(platformConfig);
      this.a.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getNativeConfig() {
      return {
        type: 'color',
        r: this.r.__getNativeTag(),
        g: this.g.__getNativeTag(),
        b: this.b.__getNativeTag(),
        a: this.a.__getNativeTag(),
        nativeColor: this.nativeColor
      };
    }
  }
},233,[197,199,63,201],"node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedColor.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  require(_dependencyMap[0], "../nodes/AnimatedValue");
  require(_dependencyMap[1], "../nodes/AnimatedValueXY");
  require(_dependencyMap[2], "../nodes/AnimatedInterpolation");
  var _exportsEasing = require(_dependencyMap[3], "../../../../exports/Easing");
  var Easing = _interopDefault(_exportsEasing);
  var _Animation = require(_dependencyMap[4], "./Animation");
  var Animation = _interopDefault(_Animation);
  var _NativeAnimatedHelper = require(_dependencyMap[5], "../NativeAnimatedHelper");
  require(_dependencyMap[6], "../nodes/AnimatedColor");
  var _easeInOut;
  function easeInOut() {
    if (!_easeInOut) {
      _easeInOut = Easing.default.inOut(Easing.default.ease);
    }
    return _easeInOut;
  }
  class TimingAnimation extends Animation.default {
    constructor(config) {
      var _config$easing, _config$duration, _config$delay, _config$iterations, _config$isInteraction;
      super();
      this._toValue = config.toValue;
      this._easing = (_config$easing = config.easing) !== null && _config$easing !== void 0 ? _config$easing : easeInOut();
      this._duration = (_config$duration = config.duration) !== null && _config$duration !== void 0 ? _config$duration : 500;
      this._delay = (_config$delay = config.delay) !== null && _config$delay !== void 0 ? _config$delay : 0;
      this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== void 0 ? _config$iterations : 1;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
      this._platformConfig = config.platformConfig;
      this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== void 0 ? _config$isInteraction : !this._useNativeDriver;
    }
    __getNativeAnimationConfig() {
      var frameDuration = 1000.0 / 60.0;
      var frames = [];
      var numFrames = Math.round(this._duration / frameDuration);
      for (var frame = 0; frame < numFrames; frame++) {
        frames.push(this._easing(frame / numFrames));
      }
      frames.push(this._easing(1));
      return {
        type: 'frames',
        frames,
        toValue: this._toValue,
        iterations: this.__iterations,
        platformConfig: this._platformConfig
      };
    }
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
      this.__active = true;
      this._fromValue = fromValue;
      this._onUpdate = onUpdate;
      this.__onEnd = onEnd;
      var start = () => {
        // Animations that sometimes have 0 duration and sometimes do not
        // still need to use the native driver when duration is 0 so as to
        // not cause intermixed JS and native animations.
        if (this._duration === 0 && !this._useNativeDriver) {
          this._onUpdate(this._toValue);
          this.__debouncedOnEnd({
            finished: true
          });
        } else {
          this._startTime = Date.now();
          if (this._useNativeDriver) {
            this.__startNativeAnimation(animatedValue);
          } else {
            this._animationFrame = requestAnimationFrame(
            // $FlowFixMe[method-unbinding] added when improving typing for this parameters
            this.onUpdate.bind(this));
          }
        }
      };
      if (this._delay) {
        this._timeout = setTimeout(start, this._delay);
      } else {
        start();
      }
    }
    onUpdate() {
      var now = Date.now();
      if (now >= this._startTime + this._duration) {
        if (this._duration === 0) {
          this._onUpdate(this._toValue);
        } else {
          this._onUpdate(this._fromValue + this._easing(1) * (this._toValue - this._fromValue));
        }
        this.__debouncedOnEnd({
          finished: true
        });
        return;
      }
      this._onUpdate(this._fromValue + this._easing((now - this._startTime) / this._duration) * (this._toValue - this._fromValue));
      if (this.__active) {
        // $FlowFixMe[method-unbinding] added when improving typing for this parameters
        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }
    stop() {
      super.stop();
      this.__active = false;
      clearTimeout(this._timeout);
      global.cancelAnimationFrame(this._animationFrame);
      this.__debouncedOnEnd({
        finished: false
      });
    }
  }
  var _default = TimingAnimation;
},234,[197,228,198,235,230,201,233],"node_modules/react-native-web/dist/vendor/react-native/Animated/animations/TimingAnimation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeAnimatedEasing = require(_dependencyMap[0], "../../vendor/react-native/Animated/Easing");
  var Easing = _interopDefault(_vendorReactNativeAnimatedEasing);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _default = Easing.default;
},235,[236],"node_modules/react-native-web/dist/exports/Easing/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _bezier2 = require(_dependencyMap[0], "./bezier");
  var _bezier = _interopDefault(_bezier2);
  var ease;

  /**
   * The `Easing` module implements common easing functions. This module is used
   * by [Animate.timing()](docs/animate.html#timing) to convey physically
   * believable motion in animations.
   *
   * You can find a visualization of some common easing functions at
   * http://easings.net/
   *
   * ### Predefined animations
   *
   * The `Easing` module provides several predefined animations through the
   * following methods:
   *
   * - [`back`](docs/easing.html#back) provides a simple animation where the
   *   object goes slightly back before moving forward
   * - [`bounce`](docs/easing.html#bounce) provides a bouncing animation
   * - [`ease`](docs/easing.html#ease) provides a simple inertial animation
   * - [`elastic`](docs/easing.html#elastic) provides a simple spring interaction
   *
   * ### Standard functions
   *
   * Three standard easing functions are provided:
   *
   * - [`linear`](docs/easing.html#linear)
   * - [`quad`](docs/easing.html#quad)
   * - [`cubic`](docs/easing.html#cubic)
   *
   * The [`poly`](docs/easing.html#poly) function can be used to implement
   * quartic, quintic, and other higher power functions.
   *
   * ### Additional functions
   *
   * Additional mathematical functions are provided by the following methods:
   *
   * - [`bezier`](docs/easing.html#bezier) provides a cubic bezier curve
   * - [`circle`](docs/easing.html#circle) provides a circular function
   * - [`sin`](docs/easing.html#sin) provides a sinusoidal function
   * - [`exp`](docs/easing.html#exp) provides an exponential function
   *
   * The following helpers are used to modify other easing functions.
   *
   * - [`in`](docs/easing.html#in) runs an easing function forwards
   * - [`inOut`](docs/easing.html#inout) makes any easing function symmetrical
   * - [`out`](docs/easing.html#out) runs an easing function backwards
   */
  class Easing {
    /**
     * A stepping function, returns 1 for any positive value of `n`.
     */
    static step0(n) {
      return n > 0 ? 1 : 0;
    }

    /**
     * A stepping function, returns 1 if `n` is greater than or equal to 1.
     */
    static step1(n) {
      return n >= 1 ? 1 : 0;
    }

    /**
     * A linear function, `f(t) = t`. Position correlates to elapsed time one to
     * one.
     *
     * http://cubic-bezier.com/#0,0,1,1
     */
    static linear(t) {
      return t;
    }

    /**
     * A simple inertial interaction, similar to an object slowly accelerating to
     * speed.
     *
     * http://cubic-bezier.com/#.42,0,1,1
     */
    static ease(t) {
      if (!ease) {
        ease = Easing.bezier(0.42, 0, 1, 1);
      }
      return ease(t);
    }

    /**
     * A quadratic function, `f(t) = t * t`. Position equals the square of elapsed
     * time.
     *
     * http://easings.net/#easeInQuad
     */
    static quad(t) {
      return t * t;
    }

    /**
     * A cubic function, `f(t) = t * t * t`. Position equals the cube of elapsed
     * time.
     *
     * http://easings.net/#easeInCubic
     */
    static cubic(t) {
      return t * t * t;
    }

    /**
     * A power function. Position is equal to the Nth power of elapsed time.
     *
     * n = 4: http://easings.net/#easeInQuart
     * n = 5: http://easings.net/#easeInQuint
     */
    static poly(n) {
      return t => Math.pow(t, n);
    }

    /**
     * A sinusoidal function.
     *
     * http://easings.net/#easeInSine
     */
    static sin(t) {
      return 1 - Math.cos(t * Math.PI / 2);
    }

    /**
     * A circular function.
     *
     * http://easings.net/#easeInCirc
     */
    static circle(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    /**
     * An exponential function.
     *
     * http://easings.net/#easeInExpo
     */
    static exp(t) {
      return Math.pow(2, 10 * (t - 1));
    }

    /**
     * A simple elastic interaction, similar to a spring oscillating back and
     * forth.
     *
     * Default bounciness is 1, which overshoots a little bit once. 0 bounciness
     * doesn't overshoot at all, and bounciness of N > 1 will overshoot about N
     * times.
     *
     * http://easings.net/#easeInElastic
     */
    static elastic(bounciness) {
      if (bounciness === void 0) {
        bounciness = 1;
      }
      var p = bounciness * Math.PI;
      return t => 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * p);
    }

    /**
     * Use with `Animated.parallel()` to create a simple effect where the object
     * animates back slightly as the animation starts.
     *
     * Wolfram Plot:
     *
     * - http://tiny.cc/back_default (s = 1.70158, default)
     */
    static back(s) {
      if (s === void 0) {
        s = 1.70158;
      }
      return t => t * t * ((s + 1) * t - s);
    }

    /**
     * Provides a simple bouncing effect.
     *
     * http://easings.net/#easeInBounce
     */
    static bounce(t) {
      if (t < 1 / 2.75) {
        return 7.5625 * t * t;
      }
      if (t < 2 / 2.75) {
        var _t = t - 1.5 / 2.75;
        return 7.5625 * _t * _t + 0.75;
      }
      if (t < 2.5 / 2.75) {
        var _t2 = t - 2.25 / 2.75;
        return 7.5625 * _t2 * _t2 + 0.9375;
      }
      var t2 = t - 2.625 / 2.75;
      return 7.5625 * t2 * t2 + 0.984375;
    }

    /**
     * Provides a cubic bezier curve, equivalent to CSS Transitions'
     * `transition-timing-function`.
     *
     * A useful tool to visualize cubic bezier curves can be found at
     * http://cubic-bezier.com/
     */
    static bezier(x1, y1, x2, y2) {
      return (0, _bezier.default)(x1, y1, x2, y2);
    }

    /**
     * Runs an easing function forwards.
     */
    static in(easing) {
      return easing;
    }

    /**
     * Runs an easing function backwards.
     */
    static out(easing) {
      return t => 1 - easing(1 - t);
    }

    /**
     * Makes any easing function symmetrical. The easing function will run
     * forwards for half of the duration, then backwards for the rest of the
     * duration.
     */
    static inOut(easing) {
      return t => {
        if (t < 0.5) {
          return easing(t * 2) / 2;
        }
        return 1 - easing((1 - t) * 2) / 2;
      };
    }
  }
  var _default = Easing;
},236,[237],"node_modules/react-native-web/dist/vendor/react-native/Animated/Easing.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Portions Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * BezierEasing - use bezier curve for transition easing function
   * https://github.com/gre/bezier-easing
   * @copyright 2014-2015 Gaëtan Renaudeau. MIT License.
   */

  'use strict';

  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return bezier;
    }
  });
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
  var float32ArraySupported = typeof Float32Array === 'function';
  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }
  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }
  function C(aA1) {
    return 3.0 * aA1;
  }

  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }
  function binarySubdivide(aX, _aA, _aB, mX1, mX2) {
    var currentX,
      currentT,
      i = 0,
      aA = _aA,
      aB = _aB;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
  }
  function newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {
    var aGuessT = _aGuessT;
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) {
        return aGuessT;
      }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }
  function bezier(mX1, mY1, mX2, mY2) {
    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {
      throw new Error('bezier x values must be in [0, 1] range');
    }

    // Precompute samples table
    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }
    function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;
      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }
      --currentSample;

      // Interpolate to provide an initial guess for t
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);
      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }
    return function BezierEasing(x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x; // linear
      }
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
      if (x === 0) {
        return 0;
      }
      if (x === 1) {
        return 1;
      }
      return calcBezier(getTForX(x), mY1, mY2);
    };
  }
  ;
},237,[],"node_modules/react-native-web/dist/vendor/react-native/Animated/bezier.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fmetro-runtime%2Fassets/alert-triangle.png",
    width: 48,
    height: 42
  };
},238,[],"node_modules/@expo/metro-runtime/assets/alert-triangle.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fmetro-runtime%2Fassets/loader.png",
    width: 44,
    height: 44
  };
},239,[],"node_modules/@expo/metro-runtime/assets/loader.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\overlay\\LogBoxInspectorStackFrame.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.LogBoxInspectorStackFrame = LogBoxInspectorStackFrame;
  require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[1], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[2], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsView = require(_dependencyMap[3], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _UILogBoxButton = require(_dependencyMap[4], "../UI/LogBoxButton");
  var _UILogBoxStyle = require(_dependencyMap[5], "../UI/LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_UILogBoxStyle);
  var _UIConstants = require(_dependencyMap[6], "../UI/constants");
  var _formatProjectFilePath = require(_dependencyMap[7], "../formatProjectFilePath");
  var _reactJsxDevRuntime = require(_dependencyMap[8], "react/jsx-dev-runtime");
  function LogBoxInspectorStackFrame(props) {
    const {
      frame,
      onPress
    } = props;
    const location = (0, _formatProjectFilePath.getStackFormattedLocation)("C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot", frame);
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: styles.frameContainer,
      children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_UILogBoxButton.LogBoxButton, {
        backgroundColor: {
          default: 'transparent',
          pressed: onPress ? LogBoxStyle.getBackgroundColor(1) : 'transparent'
        },
        onPress: onPress,
        style: styles.frame,
        children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
          style: [styles.name, frame.collapse === true && styles.dim],
          children: frame.methodName
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 37,
          columnNumber: 9
        }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
          ellipsizeMode: "middle",
          numberOfLines: 1,
          style: [styles.location, frame.collapse === true && styles.dim],
          children: location
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 38,
          columnNumber: 9
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 30,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 29,
      columnNumber: 5
    }, this);
  }
  const styles = StyleSheet.default.create({
    frameContainer: {
      flexDirection: 'row',
      paddingHorizontal: 15
    },
    frame: {
      flex: 1,
      paddingVertical: 4,
      paddingHorizontal: 10,
      borderRadius: 5
    },
    lineLocation: {
      flexDirection: 'row'
    },
    name: {
      color: LogBoxStyle.getTextColor(1),
      fontSize: 14,
      includeFontPadding: false,
      lineHeight: 18,
      fontWeight: '400',
      fontFamily: _UIConstants.CODE_FONT
    },
    location: {
      color: LogBoxStyle.getTextColor(0.8),
      fontSize: 12,
      fontWeight: '300',
      includeFontPadding: false,
      lineHeight: 16,
      paddingLeft: 10
    },
    dim: {
      color: LogBoxStyle.getTextColor(0.4),
      fontWeight: '300'
    },
    line: {
      color: LogBoxStyle.getTextColor(0.8),
      fontSize: 12,
      fontWeight: '300',
      includeFontPadding: false,
      lineHeight: 16
    }
  });
},240,[9,55,138,110,142,136,150,151,33],"node_modules/@expo/metro-runtime/src/error-overlay/overlay/LogBoxInspectorStackFrame.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _parseErrorStack = require(_dependencyMap[0], "../parseErrorStack");
  var parseErrorStack = _interopDefault(_parseErrorStack);
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  class SyntheticError extends Error {
    name = '';
  }

  /**
   * Handles the developer-visible aspect of errors and exceptions
   */
  let exceptionID = 0;
  function parseException(e, isFatal) {
    const stack = (0, parseErrorStack.default)(e?.stack);
    const currentExceptionID = ++exceptionID;
    const originalMessage = e.message || '';
    let message = originalMessage;
    if (e.componentStack != null) {
      message += `\n\nThis error is located at:${e.componentStack}`;
    }
    const namePrefix = e.name == null || e.name === '' ? '' : `${e.name}: `;
    if (!message.startsWith(namePrefix)) {
      message = namePrefix + message;
    }
    message = e.jsEngine == null ? message : `${message}, js engine: ${e.jsEngine}`;
    const data = {
      message,
      originalMessage: message === originalMessage ? null : originalMessage,
      name: e.name == null || e.name === '' ? null : e.name,
      componentStack: typeof e.componentStack === 'string' ? e.componentStack : null,
      stack,
      id: currentExceptionID,
      isFatal,
      extraData: {
        jsEngine: e.jsEngine,
        rawStack: e.stack
      }
    };
    return Object.assign({}, data, {
      isComponentError: !!e.isComponentError
    });
  }

  /**
   * Logs exceptions to the (native) console and displays them
   */
  function handleException(e) {
    let error;
    if (e instanceof Error) {
      error = e;
    } else {
      // Workaround for reporting errors caused by `throw 'some string'`
      // Unfortunately there is no way to figure out the stacktrace in this
      // case, so if you ended up here trying to trace an error, look for
      // `throw '<error message>'` somewhere in your codebase.
      error = new SyntheticError(e);
    }
    require(_dependencyMap[1], "../../LogBox").default.addException(parseException(error, true));
  }
  const ErrorUtils = {
    parseException,
    handleException,
    SyntheticError
  };
  var _default = ErrorUtils;
},241,[23,7],"node_modules/@expo/metro-runtime/src/error-overlay/modules/ExceptionsManager/index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // The entry component (one that uses context modules) cannot be in the same file as the
  // entry side-effects, otherwise they'll be updated when files are added/removed from the
  // app directory. This will cause a lot of unfortunate errors regarding HMR and Fast Refresh.
  // This is because Fast Refresh is sending the entire file containing an updated component.
  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\qualified-entry.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.App = App;
  // This has to be the string "expo-router/_ctx" as we resolve the exact string to
  // a different file in a custom resolver for bundle splitting in Node.js.
  const _ctx_1 = require(_dependencyMap[1], "expo-router/_ctx");
  const react_1 = __importDefault(require(_dependencyMap[2], "react"));
  const ExpoRoot_1 = require(_dependencyMap[3], "./ExpoRoot");
  const head_1 = require(_dependencyMap[4], "./head");
  require(_dependencyMap[5], "./fast-refresh");
  // Must be exported or Fast Refresh won't update the context
  function App() {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(head_1.Head.Provider, {
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(ExpoRoot_1.ExpoRoot, {
        context: _ctx_1.ctx
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 21,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 13
    }, this);
  }
},242,[33,243,9,720,736,741],"node_modules/expo-router/build/qualified-entry.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "ctx", {
    enumerable: true,
    get: function () {
      return ctx;
    }
  });
  const ctx = require(_dependencyMap[0], "..\\..\\app");
},243,[244],"node_modules/expo-router/_ctx.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // All of the requested modules are loaded behind enumerable getters.
  const map = Object.defineProperties({}, {
    "./_layout.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[0], "C:\\Users\\kauan math\\Desktop\\ApiNoExpo\\app\\_layout.tsx");
      }
    },
    "./index.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[1], "C:\\Users\\kauan math\\Desktop\\ApiNoExpo\\app\\index.tsx");
      }
    },
    "./list.tsx": {
      enumerable: true,
      get() {
        return require(_dependencyMap[2], "C:\\Users\\kauan math\\Desktop\\ApiNoExpo\\app\\list.tsx");
      }
    }
  });
  function metroContext(request) {
    return map[request];
  }

  // Return the keys that can be resolved.
  metroContext.keys = function metroContextKeys() {
    return Object.keys(map);
  };

  // Return the module identifier for a user request.
  metroContext.resolve = function metroContextResolve(request) {
    throw new Error('Unimplemented Metro module context functionality');
  };
  module.exports = metroContext;
},244,[245,732,734],"app?ctx=c9915d5ced2b656047aa496292a87964b21f4221");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\ApiNoExpo\\app\\_layout.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return RootLayout;
    }
  });
  var _reactCompilerRuntime = require(_dependencyMap[0], "react/compiler-runtime");
  var _expoRouter = require(_dependencyMap[1], "expo-router");
  var _reactJsxDevRuntime = require(_dependencyMap[2], "react/jsx-dev-runtime");
  function RootLayout() {
    const $ = (0, _reactCompilerRuntime.c)(3);
    if ($[0] !== "107fa3cd9baf051a339204b19858928f265d9a8c4a0b38e70bdec46809d358a5") {
      for (let $i = 0; $i < 3; $i += 1) {
        $[$i] = Symbol.for("react.memo_cache_sentinel");
      }
      $[0] = "107fa3cd9baf051a339204b19858928f265d9a8c4a0b38e70bdec46809d358a5";
    }
    let t0;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_expoRouter.Stack.Screen, {
        name: "index",
        options: {
          headerShown: false
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 6,
        columnNumber: 7
      }, this);
      $[1] = t0;
    } else {
      t0 = $[1];
    }
    let t1;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_expoRouter.Stack, {
        children: [t0, /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_expoRouter.Stack.Screen, {
          name: "list",
          options: {
            headerShown: false
          }
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 7,
          columnNumber: 7
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 5,
        columnNumber: 5
      }, this);
      $[2] = t1;
    } else {
      t1 = $[2];
    }
    return t1;
  }
  _c2 = RootLayout;
  var _c2;
  $RefreshReg$(_c2, "RootLayout");
},245,[246,248,33],"app/_layout.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react-compiler-runtime.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-compiler-runtime.development.js");
  }
},246,[10,247],"node_modules/react/compiler-runtime.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-compiler-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    var ReactSharedInternals = require(_dependencyMap[0], "react").__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    exports.c = function (size) {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
      return dispatcher.useMemoCache(size);
    };
  }();
},247,[9],"node_modules/react/cjs/react-compiler-runtime.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = this && this.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Tabs = exports.Stack = void 0;
  var Stack_1 = require(_dependencyMap[0], "./layouts/Stack");
  Object.defineProperty(exports, "Stack", {
    enumerable: true,
    get: function () {
      return Stack_1.Stack;
    }
  });
  var Tabs_1 = require(_dependencyMap[1], "./layouts/Tabs");
  Object.defineProperty(exports, "Tabs", {
    enumerable: true,
    get: function () {
      return Tabs_1.Tabs;
    }
  });
  __exportStar(require(_dependencyMap[2], "./exports"), exports);
},248,[249,649,719],"node_modules/expo-router/build/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Stack = void 0;
  // This will be changed to `ExperimentalModalStack` in @expo/cli/src/start/server/metro/withMetroMultiPlatform.ts
  // When the `EXPO_UNSTABLE_WEB_MODAL` env variable is truthy.
  const _web_modal_1 = __importDefault(require(_dependencyMap[0], "./_web-modal"));
  exports.Stack = _web_modal_1.default;
  const Screen_1 = require(_dependencyMap[1], "../views/Screen");
  _web_modal_1.default.Screen = Screen_1.Screen;
  exports.default = _web_modal_1.default;
},249,[250,633],"node_modules/expo-router/build/layouts/Stack.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const BaseStack_1 = __importDefault(require(_dependencyMap[0], "./BaseStack"));
  exports.default = BaseStack_1.default;
},250,[251],"node_modules/expo-router/build/layouts/_web-modal.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const StackClient_1 = __importDefault(require(_dependencyMap[0], "./StackClient"));
  exports.default = StackClient_1.default;
},251,[252],"node_modules/expo-router/build/layouts/BaseStack.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\layouts\\StackClient.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StackRouter = exports.stackRouterOverride = void 0;
  const native_1 = require(_dependencyMap[1], "@react-navigation/native");
  const non_secure_1 = require(_dependencyMap[2], "nanoid/non-secure");
  const react_1 = require(_dependencyMap[3], "react");
  const withLayoutContext_1 = require(_dependencyMap[4], "./withLayoutContext");
  const createNativeStackNavigator_1 = require(_dependencyMap[5], "../fork/native-stack/createNativeStackNavigator");
  const LinkPreviewContext_1 = require(_dependencyMap[6], "../link/preview/LinkPreviewContext");
  const navigationParams_1 = require(_dependencyMap[7], "../navigationParams");
  const useScreens_1 = require(_dependencyMap[8], "../useScreens");
  const Protected_1 = require(_dependencyMap[9], "../views/Protected");
  const NativeStackNavigator = (0, createNativeStackNavigator_1.createNativeStackNavigator)().Navigator;
  const RNStack = (0, withLayoutContext_1.withLayoutContext)(NativeStackNavigator);
  function isStackAction(action) {
    return action.type === 'PUSH' || action.type === 'NAVIGATE' || action.type === 'POP' || action.type === 'POP_TO_TOP' || action.type === 'REPLACE' || action.type === 'PRELOAD';
  }
  const isPreviewAction = action => !!action.payload && 'params' in action.payload && typeof action.payload.params === 'object' && !!(0, navigationParams_1.getInternalExpoRouterParams)(action.payload?.params ?? undefined)['__internal__expo_router_is_preview_navigation'];
  /**
   * React Navigation matches a screen by its name or a 'getID' function that uniquely identifies a screen.
   * When a screen has been uniquely identified, the Stack can only have one instance of that screen.
   *
   * Expo Router allows for a screen to be matched by name and path params, a 'getID' function or a singular id.
   *
   * Instead of reimplementing the entire StackRouter, we can override the getStateForAction method to handle the singular screen logic.
   *
   */
  const stackRouterOverride = original => {
    return {
      getStateForAction: (state, action, options) => {
        if (action.target && action.target !== state.key) {
          return null;
        }
        if (!isStackAction(action)) {
          return original.getStateForAction(state, action, options);
        }
        // The dynamic getId added to an action, `router.push('screen', { singular: true })`
        const actionSingularOptions = action.payload && 'singular' in action.payload ? action.payload.singular : undefined;
        // Handle if 'getID' or 'singular' is set.
        function getIdFunction() {
          // Actions can be fired by the user, so we do need to validate their structure.
          if (!('payload' in action) || !action.payload || !('name' in action.payload) || typeof action.payload.name !== 'string') {
            return;
          }
          const actionName = action.payload.name;
          return (
            // The dynamic singular added to an action, `router.push('screen', { singular: () => 'id' })`
            getActionSingularIdFn(actionSingularOptions, actionName) ||
            // The static getId added as a prop to `<Screen singular />` or `<Screen getId={} />`
            options.routeGetIdList[actionName]
          );
        }
        const {
          routeParamList
        } = options;
        switch (action.type) {
          case 'PUSH':
          case 'NAVIGATE':
            {
              if (!state.routeNames.includes(action.payload.name)) {
                return null;
              }
              // START FORK
              const getId = getIdFunction();
              // const getId = options.routeGetIdList[action.payload.name];
              // END FORK
              const id = getId?.({
                params: action.payload.params
              });
              let route;
              if (id !== undefined) {
                route = state.routes.findLast(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              } else if (action.type === 'NAVIGATE') {
                const currentRoute = state.routes[state.index];
                // If the route matches the current one, then navigate to it
                if (action.payload.name === currentRoute.name && !isPreviewAction(action)) {
                  route = currentRoute;
                } else if (action.payload.pop) {
                  route = state.routes.findLast(route => route.name === action.payload.name);
                }
              }
              // START FORK
              if (isPreviewAction(action) && !route) {
                route = state.preloadedRoutes.find(route => route.name === action.payload.name && id === route.key);
              }
              // END FORK
              if (!route) {
                route = state.preloadedRoutes.find(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              }
              let params;
              if (action.type === 'NAVIGATE' && action.payload.merge && route) {
                params = action.payload.params !== undefined || routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], route.params, action.payload.params) : route.params;
              } else {
                params = routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params;
              }
              let routes;
              if (route) {
                if (action.type === 'NAVIGATE' && action.payload.pop) {
                  routes = [];
                  // Get all routes until the matching one
                  for (const r of state.routes) {
                    if (r.key === route.key) {
                      routes.push(Object.assign({}, route, {
                        path: action.payload.path !== undefined ? action.payload.path : route.path,
                        params
                      }));
                      break;
                    }
                    routes.push(r);
                  }
                } else {
                  // START FORK
                  // If there is an id, then filter out the existing route with the same id.
                  // THIS ACTION IS DANGEROUS. This can cause React Native Screens to freeze
                  if (id !== undefined) {
                    routes = state.routes.filter(r => r.key !== route.key);
                  } else if (action.type === 'NAVIGATE' && state.routes.length > 0) {
                    // The navigation action should only replace the last route if it has the same name and path params.
                    const lastRoute = state.routes[state.routes.length - 1];
                    if ((0, useScreens_1.getSingularId)(lastRoute.name, {
                      params: lastRoute.params
                    }) === (0, useScreens_1.getSingularId)(route.name, {
                      params
                    })) {
                      routes = state.routes.slice(0, -1);
                    } else {
                      routes = [...state.routes];
                    }
                  } else {
                    routes = [...state.routes];
                  }
                  // If the routes length is the same as the state routes length, then we are navigating to a new route.
                  // Otherwise we are replacing an existing route.
                  const key = routes.length === state.routes.length && !isPreviewAction(action) ? `${action.payload.name}-${(0, non_secure_1.nanoid)()}` : route.key;
                  routes.push(Object.assign({}, route, {
                    key,
                    path: action.type === 'NAVIGATE' && action.payload.path !== undefined ? action.payload.path : route.path,
                    params
                  }));
                  // routes = state.routes.filter((r) => r.key !== route.key);
                  // routes.push({
                  //   ...route,
                  //   path:
                  //     action.type === 'NAVIGATE' && action.payload.path !== undefined
                  //       ? action.payload.path
                  //       : route.path,
                  //   params,
                  // });
                  // END FORK
                }
              } else {
                routes = [...state.routes, {
                  key: `${action.payload.name}-${(0, non_secure_1.nanoid)()}`,
                  name: action.payload.name,
                  path: action.type === 'NAVIGATE' ? action.payload.path : undefined,
                  params
                }];
              }
              // START FORK
              // return filterSingular(
              const result = Object.assign({}, state, {
                index: routes.length - 1,
                preloadedRoutes: state.preloadedRoutes.filter(route => routes[routes.length - 1].key !== route.key),
                routes
              });
              if (actionSingularOptions) {
                return filterSingular(result, getId);
              }
              return result;
              // return {
              //   ...state,
              //   index: routes.length - 1,
              //   preloadedRoutes: state.preloadedRoutes.filter(
              //     (route) => routes[routes.length - 1].key !== route.key
              //   ),
              //   routes,
              // };
              // END FORK
            }
          case 'PRELOAD':
            {
              // START FORK
              // This will be the case for example for protected route
              if (!state.routeNames.includes(action.payload.name)) {
                return null;
              }
              // END FORK
              const getId = options.routeGetIdList[action.payload.name];
              const id = getId?.({
                params: action.payload.params
              });
              let route;
              if (id !== undefined) {
                route = state.routes.find(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              }
              if (route) {
                return Object.assign({}, state, {
                  routes: state.routes.map(r => {
                    if (r.key !== route?.key) {
                      return r;
                    }
                    return Object.assign({}, r, {
                      params: routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                    });
                  })
                });
              } else {
                // START FORK
                const currentPreloadedRoute = {
                  key: `${action.payload.name}-${(0, non_secure_1.nanoid)()}`,
                  name: action.payload.name,
                  params: routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                };
                // END FORK
                return Object.assign({}, state, {
                  // START FORK
                  // Adding the current preloaded route to the beginning of the preloadedRoutes array
                  // This ensures that the preloaded route will be the next one after the visible route
                  // and when navigation will happen, there will be no reshuffling
                  // This is a workaround for the link preview navigation issue, when screen would freeze after navigation from native side
                  // and reshuffling from react-navigation
                  preloadedRoutes: [currentPreloadedRoute].concat(state.preloadedRoutes.filter(r => r.name !== action.payload.name || id !== getId?.({
                    params: r.params
                  })))
                  // preloadedRoutes: state.preloadedRoutes
                  //   .filter(
                  //     (r) =>
                  //       r.name !== action.payload.name ||
                  //       id !== getId?.({ params: r.params })
                  //   )
                  //   .concat({
                  //     key: `${action.payload.name}-${nanoid()}`,
                  //     name: action.payload.name,
                  //     params:
                  //       routeParamList[action.payload.name] !== undefined
                  //         ? {
                  //             ...routeParamList[action.payload.name],
                  //             ...action.payload.params,
                  //           }
                  //         : action.payload.params,
                  //   }),
                  // END FORK
                });
              }
            }
          default:
            {
              return original.getStateForAction(state, action, options);
            }
        }
      }
    };
  };
  exports.stackRouterOverride = stackRouterOverride;
  function getActionSingularIdFn(actionGetId, name) {
    if (typeof actionGetId === 'function') {
      return options => actionGetId(name, options.params ?? {});
    } else if (actionGetId === true) {
      return options => (0, useScreens_1.getSingularId)(name, options);
    }
    return undefined;
  }
  /**
   * If there is a dynamic singular on an action, then we need to filter the state to only have singular screens.
   * As multiples may have been added before we did the singular navigation.
   */
  function filterSingular(state, getId) {
    if (!state) {
      return state;
    }
    if (!state.routes) {
      return state;
    }
    const currentIndex = state.index || state.routes.length - 1;
    const current = state.routes[currentIndex];
    const name = current.name;
    const id = getId?.({
      params: current.params
    });
    if (!id) {
      return state;
    }
    // TypeScript needs a type assertion here for the filter to work.
    let routes = state.routes;
    routes = routes.filter((route, index) => {
      // If the route is the current route, keep it.
      if (index === currentIndex) {
        return true;
      }
      // Remove all other routes with the same name and id.
      return name !== route.name || id !== getId?.({
        params: route.params
      });
    });
    return Object.assign({}, state, {
      index: routes.length - 1,
      routes
    });
  }
  const Stack = Object.assign(props => {
    const {
      isStackAnimationDisabled
    } = (0, LinkPreviewContext_1.useLinkPreviewContext)();
    const screenOptions = (0, react_1.useMemo)(() => {
      const condition = isStackAnimationDisabled ? () => true : shouldDisableAnimationBasedOnParams;
      return disableAnimationInScreenOptions(props.screenOptions, condition);
    }, [props.screenOptions, isStackAnimationDisabled]);
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(RNStack, Object.assign({}, props, {
      screenOptions: screenOptions,
      UNSTABLE_router: exports.stackRouterOverride
    }), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 349,
      columnNumber: 13
    }, this);
  }, {
    Screen: RNStack.Screen,
    Protected: Protected_1.Protected
  });
  function disableAnimationInScreenOptions(options, condition) {
    if (options && typeof options === 'function') {
      return props => {
        const oldOptions = options(props);
        if (condition(props.route)) {
          return Object.assign({}, oldOptions, {
            animation: 'none'
          });
        }
        return oldOptions ?? {};
      };
    }
    return props => {
      if (condition(props.route)) {
        return Object.assign({}, options ?? {}, {
          animation: 'none'
        });
      }
      return options ?? {};
    };
  }
  function shouldDisableAnimationBasedOnParams(route) {
    const expoParams = (0, navigationParams_1.getInternalExpoRouterParams)(route.params);
    return !!expoParams.__internal_expo_router_no_animation;
  }
  exports.default = Stack;
  const StackRouter = options => {
    const router = (0, native_1.StackRouter)(options);
    return Object.assign({}, router, (0, exports.stackRouterOverride)(router));
  };
  exports.StackRouter = StackRouter;
},252,[33,253,260,9,378,642,647,648,388,632],"node_modules/expo-router/build/layouts/StackClient.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "createStaticNavigation", {
    enumerable: true,
    get: function () {
      return _createStaticNavigationJs.createStaticNavigation;
    }
  });
  Object.defineProperty(exports, "Link", {
    enumerable: true,
    get: function () {
      return _LinkJs.Link;
    }
  });
  Object.defineProperty(exports, "LinkingContext", {
    enumerable: true,
    get: function () {
      return _LinkingContextJs.LinkingContext;
    }
  });
  Object.defineProperty(exports, "LocaleDirContext", {
    enumerable: true,
    get: function () {
      return _LocaleDirContextJs.LocaleDirContext;
    }
  });
  Object.defineProperty(exports, "NavigationContainer", {
    enumerable: true,
    get: function () {
      return _NavigationContainerJs.NavigationContainer;
    }
  });
  Object.defineProperty(exports, "ServerContainer", {
    enumerable: true,
    get: function () {
      return _ServerContainerJs.ServerContainer;
    }
  });
  Object.defineProperty(exports, "DarkTheme", {
    enumerable: true,
    get: function () {
      return _themingDarkThemeJs.DarkTheme;
    }
  });
  Object.defineProperty(exports, "DefaultTheme", {
    enumerable: true,
    get: function () {
      return _themingDefaultThemeJs.DefaultTheme;
    }
  });
  Object.defineProperty(exports, "UNSTABLE_UnhandledLinkingContext", {
    enumerable: true,
    get: function () {
      return _UnhandledLinkingContextJs.UnhandledLinkingContext;
    }
  });
  Object.defineProperty(exports, "useLinkBuilder", {
    enumerable: true,
    get: function () {
      return _useLinkBuilderJs.useLinkBuilder;
    }
  });
  Object.defineProperty(exports, "useLinkProps", {
    enumerable: true,
    get: function () {
      return _useLinkPropsJs.useLinkProps;
    }
  });
  Object.defineProperty(exports, "useLinkTo", {
    enumerable: true,
    get: function () {
      return _useLinkToJs.useLinkTo;
    }
  });
  Object.defineProperty(exports, "useLocale", {
    enumerable: true,
    get: function () {
      return _useLocaleJs.useLocale;
    }
  });
  Object.defineProperty(exports, "useRoutePath", {
    enumerable: true,
    get: function () {
      return _useRoutePathJs.useRoutePath;
    }
  });
  Object.defineProperty(exports, "useScrollToTop", {
    enumerable: true,
    get: function () {
      return _useScrollToTopJs.useScrollToTop;
    }
  });
  var _createStaticNavigationJs = require(_dependencyMap[0], "./createStaticNavigation.js");
  var _LinkJs = require(_dependencyMap[1], "./Link.js");
  var _LinkingContextJs = require(_dependencyMap[2], "./LinkingContext.js");
  var _LocaleDirContextJs = require(_dependencyMap[3], "./LocaleDirContext.js");
  var _NavigationContainerJs = require(_dependencyMap[4], "./NavigationContainer.js");
  var _ServerContainerJs = require(_dependencyMap[5], "./ServerContainer.js");
  var _themingDarkThemeJs = require(_dependencyMap[6], "./theming/DarkTheme.js");
  var _themingDefaultThemeJs = require(_dependencyMap[7], "./theming/DefaultTheme.js");
  var _typesJs = require(_dependencyMap[8], "./types.js");
  Object.keys(_typesJs).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _typesJs[k];
        }
      });
    }
  });
  var _UnhandledLinkingContextJs = require(_dependencyMap[9], "./UnhandledLinkingContext.js");
  var _useLinkBuilderJs = require(_dependencyMap[10], "./useLinkBuilder.js");
  var _useLinkPropsJs = require(_dependencyMap[11], "./useLinkProps.js");
  var _useLinkToJs = require(_dependencyMap[12], "./useLinkTo.js");
  var _useLocaleJs = require(_dependencyMap[13], "./useLocale.js");
  var _useRoutePathJs = require(_dependencyMap[14], "./useRoutePath.js");
  var _useScrollToTopJs = require(_dependencyMap[15], "./useScrollToTop.js");
  var _reactNavigationCore = require(_dependencyMap[16], "@react-navigation/core");
  Object.keys(_reactNavigationCore).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _reactNavigationCore[k];
        }
      });
    }
  });
},253,[254,368,357,358,355,370,371,359,372,361,373,369,374,375,376,377,255],"node_modules/@react-navigation/native/lib/module/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["linking"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.createStaticNavigation = createStaticNavigation;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationCore = require(_dependencyMap[1], "@react-navigation/core");
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _NavigationContainerJs = require(_dependencyMap[3], "./NavigationContainer.js");
  var _reactJsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  /**
   * Create a navigation component from a static navigation config.
   * The returned component is a wrapper around `NavigationContainer`.
   *
   * @param tree Static navigation config.
   * @returns Navigation component to use in your app.
   */
  function createStaticNavigation(tree) {
    const Component = (0, _reactNavigationCore.createComponentForStaticNavigation)(tree, 'RootNavigator');
    function Navigation(_ref, ref) {
      let {
          linking
        } = _ref,
        rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
      const linkingConfig = React.useMemo(() => {
        const screens = (0, _reactNavigationCore.createPathConfigForStaticNavigation)(tree, {
          initialRouteName: linking?.config?.initialRouteName
        }, linking?.enabled === 'auto');
        if (!screens) return;
        return {
          path: linking?.config?.path,
          initialRouteName: linking?.config?.initialRouteName,
          screens
        };
      }, [linking?.enabled, linking?.config?.path, linking?.config?.initialRouteName]);
      const memoizedLinking = React.useMemo(() => {
        if (!linking) {
          return undefined;
        }
        const enabled = typeof linking.enabled === 'boolean' ? linking.enabled : linkingConfig?.screens != null;
        return Object.assign({}, linking, {
          enabled,
          config: linkingConfig
        });
      }, [linking, linkingConfig]);
      if (linking?.enabled === true && linkingConfig?.screens == null) {
        throw new Error('Linking is enabled but no linking configuration was found for the screens.\n\n' + 'To solve this:\n' + "- Specify a 'linking' property for the screens you want to link to.\n" + "- Or set 'linking.enabled' to 'auto' to generate paths automatically.\n\n" + 'See usage guide: https://reactnavigation.org/docs/static-configuration#linking');
      }
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationContainerJs.NavigationContainer, Object.assign({}, rest, {
        ref: ref,
        linking: memoizedLinking,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Component, {})
      }));
    }
    return /*#__PURE__*/React.forwardRef(Navigation);
  }
},254,[759,255,9,355,274],"node_modules/@react-navigation/native/lib/module/createStaticNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "BaseNavigationContainer", {
    enumerable: true,
    get: function () {
      return _BaseNavigationContainerJs.BaseNavigationContainer;
    }
  });
  Object.defineProperty(exports, "createNavigationContainerRef", {
    enumerable: true,
    get: function () {
      return _createNavigationContainerRefJs.createNavigationContainerRef;
    }
  });
  Object.defineProperty(exports, "createNavigatorFactory", {
    enumerable: true,
    get: function () {
      return _createNavigatorFactoryJs.createNavigatorFactory;
    }
  });
  Object.defineProperty(exports, "CurrentRenderContext", {
    enumerable: true,
    get: function () {
      return _CurrentRenderContextJs.CurrentRenderContext;
    }
  });
  Object.defineProperty(exports, "findFocusedRoute", {
    enumerable: true,
    get: function () {
      return _findFocusedRouteJs.findFocusedRoute;
    }
  });
  Object.defineProperty(exports, "getActionFromState", {
    enumerable: true,
    get: function () {
      return _getActionFromStateJs.getActionFromState;
    }
  });
  Object.defineProperty(exports, "getFocusedRouteNameFromRoute", {
    enumerable: true,
    get: function () {
      return _getFocusedRouteNameFromRouteJs.getFocusedRouteNameFromRoute;
    }
  });
  Object.defineProperty(exports, "getPathFromState", {
    enumerable: true,
    get: function () {
      return _getPathFromStateJs.getPathFromState;
    }
  });
  Object.defineProperty(exports, "getStateFromPath", {
    enumerable: true,
    get: function () {
      return _getStateFromPathJs.getStateFromPath;
    }
  });
  Object.defineProperty(exports, "NavigationContainerRefContext", {
    enumerable: true,
    get: function () {
      return _NavigationContainerRefContextJs.NavigationContainerRefContext;
    }
  });
  Object.defineProperty(exports, "NavigationContext", {
    enumerable: true,
    get: function () {
      return _NavigationContextJs.NavigationContext;
    }
  });
  Object.defineProperty(exports, "NavigationHelpersContext", {
    enumerable: true,
    get: function () {
      return _NavigationHelpersContextJs.NavigationHelpersContext;
    }
  });
  Object.defineProperty(exports, "NavigationIndependentTree", {
    enumerable: true,
    get: function () {
      return _NavigationIndependentTreeJs.NavigationIndependentTree;
    }
  });
  Object.defineProperty(exports, "NavigationMetaContext", {
    enumerable: true,
    get: function () {
      return _NavigationMetaContextJs.NavigationMetaContext;
    }
  });
  Object.defineProperty(exports, "NavigationRouteContext", {
    enumerable: true,
    get: function () {
      return _NavigationRouteContextJs.NavigationRouteContext;
    }
  });
  Object.defineProperty(exports, "PreventRemoveContext", {
    enumerable: true,
    get: function () {
      return _PreventRemoveContextJs.PreventRemoveContext;
    }
  });
  Object.defineProperty(exports, "PreventRemoveProvider", {
    enumerable: true,
    get: function () {
      return _PreventRemoveProviderJs.PreventRemoveProvider;
    }
  });
  Object.defineProperty(exports, "createComponentForStaticNavigation", {
    enumerable: true,
    get: function () {
      return _StaticNavigationJs.createComponentForStaticNavigation;
    }
  });
  Object.defineProperty(exports, "createPathConfigForStaticNavigation", {
    enumerable: true,
    get: function () {
      return _StaticNavigationJs.createPathConfigForStaticNavigation;
    }
  });
  Object.defineProperty(exports, "ThemeContext", {
    enumerable: true,
    get: function () {
      return _themingThemeContextJs.ThemeContext;
    }
  });
  Object.defineProperty(exports, "ThemeProvider", {
    enumerable: true,
    get: function () {
      return _themingThemeProviderJs.ThemeProvider;
    }
  });
  Object.defineProperty(exports, "useTheme", {
    enumerable: true,
    get: function () {
      return _themingUseThemeJs.useTheme;
    }
  });
  Object.defineProperty(exports, "useFocusEffect", {
    enumerable: true,
    get: function () {
      return _useFocusEffectJs.useFocusEffect;
    }
  });
  Object.defineProperty(exports, "useIsFocused", {
    enumerable: true,
    get: function () {
      return _useIsFocusedJs.useIsFocused;
    }
  });
  Object.defineProperty(exports, "useNavigation", {
    enumerable: true,
    get: function () {
      return _useNavigationJs.useNavigation;
    }
  });
  Object.defineProperty(exports, "useNavigationBuilder", {
    enumerable: true,
    get: function () {
      return _useNavigationBuilderJs.useNavigationBuilder;
    }
  });
  Object.defineProperty(exports, "useNavigationContainerRef", {
    enumerable: true,
    get: function () {
      return _useNavigationContainerRefJs.useNavigationContainerRef;
    }
  });
  Object.defineProperty(exports, "useNavigationIndependentTree", {
    enumerable: true,
    get: function () {
      return _useNavigationIndependentTreeJs.useNavigationIndependentTree;
    }
  });
  Object.defineProperty(exports, "useNavigationState", {
    enumerable: true,
    get: function () {
      return _useNavigationStateJs.useNavigationState;
    }
  });
  Object.defineProperty(exports, "usePreventRemove", {
    enumerable: true,
    get: function () {
      return _usePreventRemoveJs.usePreventRemove;
    }
  });
  Object.defineProperty(exports, "usePreventRemoveContext", {
    enumerable: true,
    get: function () {
      return _usePreventRemoveContextJs.usePreventRemoveContext;
    }
  });
  Object.defineProperty(exports, "useRoute", {
    enumerable: true,
    get: function () {
      return _useRouteJs.useRoute;
    }
  });
  Object.defineProperty(exports, "useStateForPath", {
    enumerable: true,
    get: function () {
      return _useStateForPathJs.useStateForPath;
    }
  });
  Object.defineProperty(exports, "validatePathConfig", {
    enumerable: true,
    get: function () {
      return _validatePathConfigJs.validatePathConfig;
    }
  });
  var _BaseNavigationContainerJs = require(_dependencyMap[0], "./BaseNavigationContainer.js");
  var _createNavigationContainerRefJs = require(_dependencyMap[1], "./createNavigationContainerRef.js");
  var _createNavigatorFactoryJs = require(_dependencyMap[2], "./createNavigatorFactory.js");
  var _CurrentRenderContextJs = require(_dependencyMap[3], "./CurrentRenderContext.js");
  var _findFocusedRouteJs = require(_dependencyMap[4], "./findFocusedRoute.js");
  var _getActionFromStateJs = require(_dependencyMap[5], "./getActionFromState.js");
  var _getFocusedRouteNameFromRouteJs = require(_dependencyMap[6], "./getFocusedRouteNameFromRoute.js");
  var _getPathFromStateJs = require(_dependencyMap[7], "./getPathFromState.js");
  var _getStateFromPathJs = require(_dependencyMap[8], "./getStateFromPath.js");
  var _NavigationContainerRefContextJs = require(_dependencyMap[9], "./NavigationContainerRefContext.js");
  var _NavigationContextJs = require(_dependencyMap[10], "./NavigationContext.js");
  var _NavigationHelpersContextJs = require(_dependencyMap[11], "./NavigationHelpersContext.js");
  var _NavigationIndependentTreeJs = require(_dependencyMap[12], "./NavigationIndependentTree.js");
  var _NavigationMetaContextJs = require(_dependencyMap[13], "./NavigationMetaContext.js");
  var _NavigationRouteContextJs = require(_dependencyMap[14], "./NavigationRouteContext.js");
  var _PreventRemoveContextJs = require(_dependencyMap[15], "./PreventRemoveContext.js");
  var _PreventRemoveProviderJs = require(_dependencyMap[16], "./PreventRemoveProvider.js");
  var _StaticNavigationJs = require(_dependencyMap[17], "./StaticNavigation.js");
  var _themingThemeContextJs = require(_dependencyMap[18], "./theming/ThemeContext.js");
  var _themingThemeProviderJs = require(_dependencyMap[19], "./theming/ThemeProvider.js");
  var _themingUseThemeJs = require(_dependencyMap[20], "./theming/useTheme.js");
  var _typesJs = require(_dependencyMap[21], "./types.js");
  Object.keys(_typesJs).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _typesJs[k];
        }
      });
    }
  });
  var _useFocusEffectJs = require(_dependencyMap[22], "./useFocusEffect.js");
  var _useIsFocusedJs = require(_dependencyMap[23], "./useIsFocused.js");
  var _useNavigationJs = require(_dependencyMap[24], "./useNavigation.js");
  var _useNavigationBuilderJs = require(_dependencyMap[25], "./useNavigationBuilder.js");
  var _useNavigationContainerRefJs = require(_dependencyMap[26], "./useNavigationContainerRef.js");
  var _useNavigationIndependentTreeJs = require(_dependencyMap[27], "./useNavigationIndependentTree.js");
  var _useNavigationStateJs = require(_dependencyMap[28], "./useNavigationState.js");
  var _usePreventRemoveJs = require(_dependencyMap[29], "./usePreventRemove.js");
  var _usePreventRemoveContextJs = require(_dependencyMap[30], "./usePreventRemoveContext.js");
  var _useRouteJs = require(_dependencyMap[31], "./useRoute.js");
  var _useStateForPathJs = require(_dependencyMap[32], "./useStateForPath.js");
  var _validatePathConfigJs = require(_dependencyMap[33], "./validatePathConfig.js");
  var _reactNavigationRouters = require(_dependencyMap[34], "@react-navigation/routers");
  Object.keys(_reactNavigationRouters).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _reactNavigationRouters[k];
        }
      });
    }
  });
},255,[256,271,291,294,276,295,296,299,307,278,311,312,313,315,314,316,317,318,282,281,322,323,324,326,325,327,351,287,341,352,353,321,354,306,257],"node_modules/@react-navigation/core/lib/module/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["key", "routeNames"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "BaseNavigationContainer", {
    enumerable: true,
    get: function () {
      return BaseNavigationContainer;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationRouters = require(_dependencyMap[1], "@react-navigation/routers");
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _useLatestCallback = require(_dependencyMap[3], "use-latest-callback");
  var useLatestCallback = _interopDefault(_useLatestCallback);
  var _checkDuplicateRouteNamesJs = require(_dependencyMap[4], "./checkDuplicateRouteNames.js");
  var _checkSerializableJs = require(_dependencyMap[5], "./checkSerializable.js");
  var _createNavigationContainerRefJs = require(_dependencyMap[6], "./createNavigationContainerRef.js");
  var _DeprecatedNavigationInChildContextJs = require(_dependencyMap[7], "./DeprecatedNavigationInChildContext.js");
  var _EnsureSingleNavigatorJs = require(_dependencyMap[8], "./EnsureSingleNavigator.js");
  var _findFocusedRouteJs = require(_dependencyMap[9], "./findFocusedRoute.js");
  var _NavigationBuilderContextJs = require(_dependencyMap[10], "./NavigationBuilderContext.js");
  var _NavigationContainerRefContextJs = require(_dependencyMap[11], "./NavigationContainerRefContext.js");
  var _NavigationIndependentTreeContextJs = require(_dependencyMap[12], "./NavigationIndependentTreeContext.js");
  var _NavigationStateContextJs = require(_dependencyMap[13], "./NavigationStateContext.js");
  var _themingThemeProviderJs = require(_dependencyMap[14], "./theming/ThemeProvider.js");
  var _UnhandledActionContextJs = require(_dependencyMap[15], "./UnhandledActionContext.js");
  var _useChildListenersJs = require(_dependencyMap[16], "./useChildListeners.js");
  var _useEventEmitterJs = require(_dependencyMap[17], "./useEventEmitter.js");
  var _useKeyedChildListenersJs = require(_dependencyMap[18], "./useKeyedChildListeners.js");
  var _useNavigationIndependentTreeJs = require(_dependencyMap[19], "./useNavigationIndependentTree.js");
  var _useOptionsGettersJs = require(_dependencyMap[20], "./useOptionsGetters.js");
  var _useSyncStateJs = require(_dependencyMap[21], "./useSyncState.js");
  var _reactJsxRuntime = require(_dependencyMap[22], "react/jsx-runtime");
  const serializableWarnings = [];
  const duplicateNameWarnings = [];

  /**
   * Remove `key` and `routeNames` from the state objects recursively to get partial state.
   *
   * @param state Initial state object.
   */
  const getPartialState = state => {
    if (state === undefined) {
      return;
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const partialState = (0, _objectWithoutPropertiesLoose.default)(state, _excluded);
    return Object.assign({}, partialState, {
      stale: true,
      routes: state.routes.map(route => {
        if (route.state === undefined) {
          return route;
        }
        return Object.assign({}, route, {
          state: getPartialState(route.state)
        });
      })
    });
  };

  /**
   * Container component which holds the navigation state.
   * This should be rendered at the root wrapping the whole app.
   *
   * @param props.initialState Initial state object for the navigation tree.
   * @param props.onReady Callback which is called after the navigation tree mounts.
   * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
   * @param props.onUnhandledAction Callback which is called when an action is not handled.
   * @param props.theme Theme object for the UI elements.
   * @param props.children Child elements to render the content.
   * @param props.ref Ref object which refers to the navigation object containing helper methods.
   */
  const BaseNavigationContainer = /*#__PURE__*/React.forwardRef(function BaseNavigationContainer({
    initialState,
    onStateChange,
    onReady,
    onUnhandledAction,
    navigationInChildEnabled = false,
    theme,
    children
  }, ref) {
    const parent = React.useContext(_NavigationStateContextJs.NavigationStateContext);
    const independent = (0, _useNavigationIndependentTreeJs.useNavigationIndependentTree)();
    if (!parent.isDefault && !independent) {
      throw new Error("Looks like you have nested a 'NavigationContainer' inside another. Normally you need only one container at the root of the app, so this was probably an error. If this was intentional, wrap the container in 'NavigationIndependentTree' explicitly. Note that this will make the child navigators disconnected from the parent and you won't be able to navigate between them.");
    }
    const {
      state,
      getState,
      setState,
      scheduleUpdate,
      flushUpdates
    } = (0, _useSyncStateJs.useSyncState)(() => getPartialState(initialState == null ? undefined : initialState));
    const isFirstMountRef = React.useRef(true);
    const navigatorKeyRef = React.useRef(undefined);
    const getKey = React.useCallback(() => navigatorKeyRef.current, []);
    const setKey = React.useCallback(key => {
      navigatorKeyRef.current = key;
    }, []);
    const {
      listeners,
      addListener
    } = (0, _useChildListenersJs.useChildListeners)();
    const {
      keyedListeners,
      addKeyedListener
    } = (0, _useKeyedChildListenersJs.useKeyedChildListeners)();
    const dispatch = (0, useLatestCallback.default)(action => {
      if (listeners.focus[0] == null) {
        console.error(_createNavigationContainerRefJs.NOT_INITIALIZED_ERROR);
      } else {
        listeners.focus[0](navigation => navigation.dispatch(action));
      }
    });
    const canGoBack = (0, useLatestCallback.default)(() => {
      if (listeners.focus[0] == null) {
        return false;
      }
      const {
        result,
        handled
      } = listeners.focus[0](navigation => navigation.canGoBack());
      if (handled) {
        return result;
      } else {
        return false;
      }
    });
    const resetRoot = (0, useLatestCallback.default)(state => {
      const target = state?.key ?? keyedListeners.getState.root?.().key;
      if (target == null) {
        console.error(_createNavigationContainerRefJs.NOT_INITIALIZED_ERROR);
      } else {
        listeners.focus[0](navigation => navigation.dispatch(Object.assign({}, _reactNavigationRouters.CommonActions.reset(state), {
          target
        })));
      }
    });
    const getRootState = (0, useLatestCallback.default)(() => {
      return keyedListeners.getState.root?.();
    });
    const getCurrentRoute = (0, useLatestCallback.default)(() => {
      const state = getRootState();
      if (state == null) {
        return undefined;
      }
      const route = (0, _findFocusedRouteJs.findFocusedRoute)(state);
      return route;
    });
    const isReady = (0, useLatestCallback.default)(() => listeners.focus[0] != null);
    const emitter = (0, _useEventEmitterJs.useEventEmitter)();
    const {
      addOptionsGetter,
      getCurrentOptions
    } = (0, _useOptionsGettersJs.useOptionsGetters)({});
    const navigation = React.useMemo(() => Object.assign({}, Object.keys(_reactNavigationRouters.CommonActions).reduce((acc, name) => {
      acc[name] = (...args) =>
      // @ts-expect-error: this is ok
      dispatch(_reactNavigationRouters.CommonActions[name](...args));
      return acc;
    }, {}), emitter.create('root'), {
      dispatch,
      resetRoot,
      isFocused: () => true,
      canGoBack,
      getParent: () => undefined,
      getState,
      getRootState,
      getCurrentRoute,
      getCurrentOptions,
      isReady,
      setOptions: () => {
        throw new Error('Cannot call setOptions outside a screen');
      }
    }), [canGoBack, dispatch, emitter, getCurrentOptions, getCurrentRoute, getRootState, getState, isReady, resetRoot]);
    React.useImperativeHandle(ref, () => navigation, [navigation]);
    const onDispatchAction = (0, useLatestCallback.default)((action, noop) => {
      emitter.emit({
        type: '__unsafe_action__',
        data: {
          action,
          noop,
          stack: stackRef.current
        }
      });
    });
    const lastEmittedOptionsRef = React.useRef(undefined);
    const onOptionsChange = (0, useLatestCallback.default)(options => {
      if (lastEmittedOptionsRef.current === options) {
        return;
      }
      lastEmittedOptionsRef.current = options;
      emitter.emit({
        type: 'options',
        data: {
          options
        }
      });
    });
    const stackRef = React.useRef(undefined);
    const builderContext = React.useMemo(() => ({
      addListener,
      addKeyedListener,
      onDispatchAction,
      onOptionsChange,
      scheduleUpdate,
      flushUpdates,
      stackRef
    }), [addListener, addKeyedListener, onDispatchAction, onOptionsChange, scheduleUpdate, flushUpdates]);
    const isInitialRef = React.useRef(true);
    const getIsInitial = React.useCallback(() => isInitialRef.current, []);
    const context = React.useMemo(() => ({
      state,
      getState,
      setState,
      getKey,
      setKey,
      getIsInitial,
      addOptionsGetter
    }), [state, getState, setState, getKey, setKey, getIsInitial, addOptionsGetter]);
    const onReadyRef = React.useRef(onReady);
    const onStateChangeRef = React.useRef(onStateChange);
    React.useEffect(() => {
      isInitialRef.current = false;
      onStateChangeRef.current = onStateChange;
      onReadyRef.current = onReady;
    });
    const onReadyCalledRef = React.useRef(false);
    React.useEffect(() => {
      if (!onReadyCalledRef.current && isReady()) {
        onReadyCalledRef.current = true;
        onReadyRef.current?.();
        emitter.emit({
          type: 'ready'
        });
      }
    }, [state, isReady, emitter]);
    React.useEffect(() => {
      const hydratedState = getRootState();
      if (process.env.NODE_ENV !== 'production') {
        if (hydratedState !== undefined) {
          const serializableResult = (0, _checkSerializableJs.checkSerializable)(hydratedState);
          if (!serializableResult.serializable) {
            const {
              location,
              reason
            } = serializableResult;
            let path = '';
            let pointer = hydratedState;
            let params = false;
            for (let i = 0; i < location.length; i++) {
              const curr = location[i];
              const prev = location[i - 1];
              pointer = pointer[curr];
              if (!params && curr === 'state') {
                continue;
              } else if (!params && curr === 'routes') {
                if (path) {
                  path += ' > ';
                }
              } else if (!params && typeof curr === 'number' && prev === 'routes') {
                path += pointer?.name;
              } else if (!params) {
                path += ` > ${curr}`;
                params = true;
              } else {
                if (typeof curr === 'number' || /^[0-9]+$/.test(curr)) {
                  path += `[${curr}]`;
                } else if (/^[a-z$_]+$/i.test(curr)) {
                  path += `.${curr}`;
                } else {
                  path += `[${JSON.stringify(curr)}]`;
                }
              }
            }
            const message = `Non-serializable values were found in the navigation state. Check:\n\n${path} (${reason})\n\nThis can break usage such as persisting and restoring state. This might happen if you passed non-serializable values such as function, class instances etc. in params. If you need to use components with callbacks in your options, you can use 'navigation.setOptions' instead. See https://reactnavigation.org/docs/troubleshooting#i-get-the-warning-non-serializable-values-were-found-in-the-navigation-state for more details.`;
            if (!serializableWarnings.includes(message)) {
              serializableWarnings.push(message);
              console.warn(message);
            }
          }
          const duplicateRouteNamesResult = (0, _checkDuplicateRouteNamesJs.checkDuplicateRouteNames)(hydratedState);
          if (duplicateRouteNamesResult.length) {
            const message = `Found screens with the same name nested inside one another. Check:\n${duplicateRouteNamesResult.map(locations => `\n${locations.join(', ')}`)}\n\nThis can cause confusing behavior during navigation. Consider using unique names for each screen instead.`;
            if (!duplicateNameWarnings.includes(message)) {
              duplicateNameWarnings.push(message);
              console.warn(message);
            }
          }
        }
      }
      emitter.emit({
        type: 'state',
        data: {
          state
        }
      });
      if (!isFirstMountRef.current && onStateChangeRef.current) {
        onStateChangeRef.current(hydratedState);
      }
      isFirstMountRef.current = false;
    }, [getRootState, emitter, state]);
    const defaultOnUnhandledAction = (0, useLatestCallback.default)(action => {
      if (process.env.NODE_ENV === 'production') {
        return;
      }
      const payload = action.payload;
      let message = `The action '${action.type}'${payload ? ` with payload ${JSON.stringify(action.payload)}` : ''} was not handled by any navigator.`;
      switch (action.type) {
        case 'PRELOAD':
        case 'NAVIGATE':
        case 'PUSH':
        case 'REPLACE':
        case 'POP_TO':
        case 'JUMP_TO':
          if (payload?.name) {
            message += `\n\nDo you have a screen named '${payload.name}'?\n\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.\n\nIf you're using conditional rendering, navigation will happen automatically and you shouldn't navigate manually, see.`;
          } else {
            message += `\n\nYou need to pass the name of the screen to navigate to.\n\nSee https://reactnavigation.org/docs/navigation-actions for usage.`;
          }
          break;
        case 'GO_BACK':
        case 'POP':
        case 'POP_TO_TOP':
          message += `\n\nIs there any screen to go back to?`;
          break;
        case 'OPEN_DRAWER':
        case 'CLOSE_DRAWER':
        case 'TOGGLE_DRAWER':
          message += `\n\nIs your screen inside a Drawer navigator?`;
          break;
      }
      message += `\n\nThis is a development-only warning and won't be shown in production.`;
      console.error(message);
    });
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationIndependentTreeContextJs.NavigationIndependentTreeContext.Provider, {
      value: false,
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationContainerRefContextJs.NavigationContainerRefContext.Provider, {
        value: navigation,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationBuilderContextJs.NavigationBuilderContext.Provider, {
          value: builderContext,
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationStateContextJs.NavigationStateContext.Provider, {
            value: context,
            children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_UnhandledActionContextJs.UnhandledActionContext.Provider, {
              value: onUnhandledAction ?? defaultOnUnhandledAction,
              children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_DeprecatedNavigationInChildContextJs.DeprecatedNavigationInChildContext.Provider, {
                value: navigationInChildEnabled,
                children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_EnsureSingleNavigatorJs.EnsureSingleNavigator, {
                  children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_themingThemeProviderJs.ThemeProvider, {
                    value: theme,
                    children: children
                  })
                })
              })
            })
          })
        })
      })
    });
  });
},256,[759,257,9,267,269,270,271,272,273,276,277,278,279,280,281,283,284,285,286,287,288,289,274],"node_modules/@react-navigation/core/lib/module/BaseNavigationContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "BaseRouter", {
    enumerable: true,
    get: function () {
      return _BaseRouterJs.BaseRouter;
    }
  });
  Object.defineProperty(exports, "DrawerActions", {
    enumerable: true,
    get: function () {
      return _DrawerRouterJs.DrawerActions;
    }
  });
  Object.defineProperty(exports, "DrawerRouter", {
    enumerable: true,
    get: function () {
      return _DrawerRouterJs.DrawerRouter;
    }
  });
  Object.defineProperty(exports, "StackActions", {
    enumerable: true,
    get: function () {
      return _StackRouterJs.StackActions;
    }
  });
  Object.defineProperty(exports, "StackRouter", {
    enumerable: true,
    get: function () {
      return _StackRouterJs.StackRouter;
    }
  });
  Object.defineProperty(exports, "TabActions", {
    enumerable: true,
    get: function () {
      return _TabRouterJs.TabActions;
    }
  });
  Object.defineProperty(exports, "TabRouter", {
    enumerable: true,
    get: function () {
      return _TabRouterJs.TabRouter;
    }
  });
  Object.defineProperty(exports, "CommonActions", {
    enumerable: true,
    get: function () {
      return CommonActions;
    }
  });
  var _CommonActionsJs = require(_dependencyMap[0], "./CommonActions.js");
  var CommonActions = _interopNamespace(_CommonActionsJs);
  var _BaseRouterJs = require(_dependencyMap[1], "./BaseRouter.js");
  var _DrawerRouterJs = require(_dependencyMap[2], "./DrawerRouter.js");
  var _StackRouterJs = require(_dependencyMap[3], "./StackRouter.js");
  var _TabRouterJs = require(_dependencyMap[4], "./TabRouter.js");
  var _typesJs = require(_dependencyMap[5], "./types.js");
  Object.keys(_typesJs).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _typesJs[k];
        }
      });
    }
  });
},257,[258,259,261,264,262,266],"node_modules/@react-navigation/routers/lib/module/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.goBack = goBack;
  exports.navigate = navigate;
  exports.navigateDeprecated = navigateDeprecated;
  exports.reset = reset;
  exports.setParams = setParams;
  exports.replaceParams = replaceParams;
  exports.preload = preload;
  function goBack() {
    return {
      type: 'GO_BACK'
    };
  }
  function navigate(...args) {
    if (typeof args[0] === 'string') {
      const [name, params, options] = args;
      if (typeof options === 'boolean') {
        console.warn(`Passing a boolean as the third argument to 'navigate' is deprecated. Pass '{ merge: true }' instead.`);
      }
      return {
        type: 'NAVIGATE',
        payload: {
          name,
          params,
          merge: typeof options === 'boolean' ? options : options?.merge,
          pop: options?.pop
        }
      };
    } else {
      const payload = args[0] || {};
      if (!('name' in payload)) {
        throw new Error('You need to specify a name when calling navigate with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigate for usage.');
      }
      return {
        type: 'NAVIGATE',
        payload
      };
    }
  }
  function navigateDeprecated(...args) {
    if (typeof args[0] === 'string') {
      return {
        type: 'NAVIGATE_DEPRECATED',
        payload: {
          name: args[0],
          params: args[1]
        }
      };
    } else {
      const payload = args[0] || {};
      if (!('name' in payload)) {
        throw new Error('You need to specify a name when calling navigateDeprecated with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigatelegacy for usage.');
      }
      return {
        type: 'NAVIGATE_DEPRECATED',
        payload
      };
    }
  }
  function reset(state) {
    return {
      type: 'RESET',
      payload: state
    };
  }
  function setParams(params) {
    return {
      type: 'SET_PARAMS',
      payload: {
        params
      }
    };
  }
  function replaceParams(params) {
    return {
      type: 'REPLACE_PARAMS',
      payload: {
        params
      }
    };
  }
  function preload(name, params) {
    return {
      type: 'PRELOAD',
      payload: {
        name,
        params
      }
    };
  }
},258,[],"node_modules/@react-navigation/routers/lib/module/CommonActions.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "BaseRouter", {
    enumerable: true,
    get: function () {
      return BaseRouter;
    }
  });
  var _nanoidNonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  /**
   * Base router object that can be used when writing custom routers.
   * This provides few helper methods to handle common actions such as `RESET`.
   */
  const BaseRouter = {
    getStateForAction(state, action) {
      switch (action.type) {
        case 'SET_PARAMS':
        case 'REPLACE_PARAMS':
          {
            const index = action.source ? state.routes.findIndex(r => r.key === action.source) : state.index;
            if (index === -1) {
              return null;
            }
            return Object.assign({}, state, {
              routes: state.routes.map((r, i) => i === index ? Object.assign({}, r, {
                params: action.type === 'REPLACE_PARAMS' ? action.payload.params : Object.assign({}, r.params, action.payload.params)
              }) : r)
            });
          }
        case 'RESET':
          {
            const nextState = action.payload;
            if (nextState.routes.length === 0 || nextState.routes.some(route => !state.routeNames.includes(route.name))) {
              return null;
            }
            if (nextState.stale === false) {
              if (state.routeNames.length !== nextState.routeNames.length || nextState.routeNames.some(name => !state.routeNames.includes(name))) {
                return null;
              }
              return Object.assign({}, nextState, {
                routes: nextState.routes.map(route => route.key ? route : Object.assign({}, route, {
                  key: `${route.name}-${(0, _nanoidNonSecure.nanoid)()}`
                }))
              });
            }
            return nextState;
          }
        default:
          return null;
      }
    },
    shouldActionChangeFocus(action) {
      return action.type === 'NAVIGATE' || action.type === 'NAVIGATE_DEPRECATED';
    }
  };
},259,[260],"node_modules/@react-navigation/routers/lib/module/BaseRouter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "nanoid", {
    enumerable: true,
    get: function () {
      return nanoid;
    }
  });
  Object.defineProperty(exports, "customAlphabet", {
    enumerable: true,
    get: function () {
      return customAlphabet;
    }
  });
  let urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
  let customAlphabet = (alphabet, defaultSize = 21) => {
    return (size = defaultSize) => {
      let id = '';
      let i = size | 0;
      while (i--) {
        id += alphabet[Math.random() * alphabet.length | 0];
      }
      return id;
    };
  };
  let nanoid = (size = 21) => {
    let id = '';
    let i = size | 0;
    while (i--) {
      id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
  };
},260,[],"node_modules/nanoid/non-secure/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["defaultStatus"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "DrawerActions", {
    enumerable: true,
    get: function () {
      return DrawerActions;
    }
  });
  exports.DrawerRouter = DrawerRouter;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _nanoidNonSecure = require(_dependencyMap[1], "nanoid/non-secure");
  var _TabRouterJs = require(_dependencyMap[2], "./TabRouter.js");
  const DrawerActions = Object.assign({}, _TabRouterJs.TabActions, {
    openDrawer() {
      return {
        type: 'OPEN_DRAWER'
      };
    },
    closeDrawer() {
      return {
        type: 'CLOSE_DRAWER'
      };
    },
    toggleDrawer() {
      return {
        type: 'TOGGLE_DRAWER'
      };
    }
  });
  function DrawerRouter(_ref) {
    let {
        defaultStatus = 'closed'
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const router = (0, _TabRouterJs.TabRouter)(rest);
    const isDrawerInHistory = state => Boolean(state.history?.some(it => it.type === 'drawer'));
    const addDrawerToHistory = state => {
      if (isDrawerInHistory(state)) {
        return state;
      }
      return Object.assign({}, state, {
        history: [...state.history, {
          type: 'drawer',
          status: defaultStatus === 'open' ? 'closed' : 'open'
        }]
      });
    };
    const removeDrawerFromHistory = state => {
      if (!isDrawerInHistory(state)) {
        return state;
      }
      return Object.assign({}, state, {
        history: state.history.filter(it => it.type !== 'drawer')
      });
    };
    const openDrawer = state => {
      if (defaultStatus === 'open') {
        return removeDrawerFromHistory(state);
      }
      return addDrawerToHistory(state);
    };
    const closeDrawer = state => {
      if (defaultStatus === 'open') {
        return addDrawerToHistory(state);
      }
      return removeDrawerFromHistory(state);
    };
    return Object.assign({}, router, {
      type: 'drawer',
      getInitialState({
        routeNames,
        routeParamList,
        routeGetIdList
      }) {
        const state = router.getInitialState({
          routeNames,
          routeParamList,
          routeGetIdList
        });
        return Object.assign({}, state, {
          default: defaultStatus,
          stale: false,
          type: 'drawer',
          key: `drawer-${(0, _nanoidNonSecure.nanoid)()}`
        });
      },
      getRehydratedState(partialState, {
        routeNames,
        routeParamList,
        routeGetIdList
      }) {
        if (partialState.stale === false) {
          return partialState;
        }
        let state = router.getRehydratedState(partialState, {
          routeNames,
          routeParamList,
          routeGetIdList
        });
        if (isDrawerInHistory(partialState)) {
          // Re-sync the drawer entry in history to correct it if it was wrong
          state = removeDrawerFromHistory(state);
          state = addDrawerToHistory(state);
        }
        return Object.assign({}, state, {
          default: defaultStatus,
          type: 'drawer',
          key: `drawer-${(0, _nanoidNonSecure.nanoid)()}`
        });
      },
      getStateForRouteFocus(state, key) {
        const result = router.getStateForRouteFocus(state, key);
        return closeDrawer(result);
      },
      getStateForAction(state, action, options) {
        switch (action.type) {
          case 'OPEN_DRAWER':
            return openDrawer(state);
          case 'CLOSE_DRAWER':
            return closeDrawer(state);
          case 'TOGGLE_DRAWER':
            if (isDrawerInHistory(state)) {
              return removeDrawerFromHistory(state);
            }
            return addDrawerToHistory(state);
          case 'JUMP_TO':
          case 'NAVIGATE':
          case 'NAVIGATE_DEPRECATED':
            {
              const result = router.getStateForAction(state, action, options);
              if (result != null && result.index !== state.index) {
                return closeDrawer(result);
              }
              return result;
            }
          case 'GO_BACK':
            if (isDrawerInHistory(state)) {
              return removeDrawerFromHistory(state);
            }
            return router.getStateForAction(state, action, options);
          default:
            return router.getStateForAction(state, action, options);
        }
      },
      actionCreators: DrawerActions
    });
  }
},261,[759,260,262],"node_modules/@react-navigation/routers/lib/module/DrawerRouter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "TabActions", {
    enumerable: true,
    get: function () {
      return TabActions;
    }
  });
  exports.TabRouter = TabRouter;
  var _nanoidNonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  var _BaseRouterJs = require(_dependencyMap[1], "./BaseRouter.js");
  var _createParamsFromActionJs = require(_dependencyMap[2], "./createParamsFromAction.js");
  const TYPE_ROUTE = 'route';
  const TabActions = {
    jumpTo(name, params) {
      return {
        type: 'JUMP_TO',
        payload: {
          name,
          params
        }
      };
    }
  };
  const getRouteHistory = (routes, index, backBehavior, initialRouteName) => {
    const history = [{
      type: TYPE_ROUTE,
      key: routes[index].key
    }];
    let initialRouteIndex;
    switch (backBehavior) {
      case 'order':
        for (let i = index; i > 0; i--) {
          history.unshift({
            type: TYPE_ROUTE,
            key: routes[i - 1].key
          });
        }
        break;
      case 'firstRoute':
        if (index !== 0) {
          history.unshift({
            type: TYPE_ROUTE,
            key: routes[0].key
          });
        }
        break;
      case 'initialRoute':
        initialRouteIndex = routes.findIndex(route => route.name === initialRouteName);
        initialRouteIndex = initialRouteIndex === -1 ? 0 : initialRouteIndex;
        if (index !== initialRouteIndex) {
          history.unshift({
            type: TYPE_ROUTE,
            key: routes[initialRouteIndex].key
          });
        }
        break;
      case 'history':
      case 'fullHistory':
        // The history will fill up on navigation
        break;
    }
    return history;
  };
  const changeIndex = (state, index, backBehavior, initialRouteName) => {
    let history = state.history;
    if (backBehavior === 'history' || backBehavior === 'fullHistory') {
      const currentRoute = state.routes[index];
      if (backBehavior === 'history') {
        // Remove the existing key from the history to de-duplicate it
        history = history.filter(it => it.type === 'route' ? it.key !== currentRoute.key : false);
      } else if (backBehavior === 'fullHistory') {
        const lastHistoryRouteItemIndex = history.findLastIndex(item => item.type === 'route');
        if (currentRoute.key === history[lastHistoryRouteItemIndex]?.key) {
          // For full-history, only remove if it matches the last route
          // Useful for drawer, if current route was in history, then drawer state changed
          // Then we only need to move the route to the front
          history = [...history.slice(0, lastHistoryRouteItemIndex), ...history.slice(lastHistoryRouteItemIndex + 1)];
        }
      }
      history = history.concat({
        type: TYPE_ROUTE,
        key: currentRoute.key,
        params: backBehavior === 'fullHistory' ? currentRoute.params : undefined
      });
    } else {
      history = getRouteHistory(state.routes, index, backBehavior, initialRouteName);
    }
    return Object.assign({}, state, {
      index,
      history
    });
  };
  function TabRouter({
    initialRouteName,
    backBehavior = 'firstRoute'
  }) {
    const router = Object.assign({}, _BaseRouterJs.BaseRouter, {
      type: 'tab',
      getInitialState({
        routeNames,
        routeParamList
      }) {
        const index = initialRouteName !== undefined && routeNames.includes(initialRouteName) ? routeNames.indexOf(initialRouteName) : 0;
        const routes = routeNames.map(name => ({
          name,
          key: `${name}-${(0, _nanoidNonSecure.nanoid)()}`,
          params: routeParamList[name]
        }));
        const history = getRouteHistory(routes, index, backBehavior, initialRouteName);
        return {
          stale: false,
          type: 'tab',
          key: `tab-${(0, _nanoidNonSecure.nanoid)()}`,
          index,
          routeNames,
          history,
          routes,
          preloadedRouteKeys: []
        };
      },
      getRehydratedState(partialState, {
        routeNames,
        routeParamList
      }) {
        const state = partialState;
        if (state.stale === false) {
          return state;
        }
        const routes = routeNames.map(name => {
          const route = state.routes.find(r => r.name === name);
          return Object.assign({}, route, {
            name,
            key: route && route.name === name && route.key ? route.key : `${name}-${(0, _nanoidNonSecure.nanoid)()}`,
            params: routeParamList[name] !== undefined ? Object.assign({}, routeParamList[name], route ? route.params : undefined) : route ? route.params : undefined
          });
        });
        const index = Math.min(Math.max(routeNames.indexOf(state.routes[state?.index ?? 0]?.name), 0), routes.length - 1);
        const routeKeys = routes.map(route => route.key);
        const history = state.history?.filter(it => routeKeys.includes(it.key)) ?? [];
        return changeIndex({
          stale: false,
          type: 'tab',
          key: `tab-${(0, _nanoidNonSecure.nanoid)()}`,
          index,
          routeNames,
          history,
          routes,
          preloadedRouteKeys: state.preloadedRouteKeys?.filter(key => routeKeys.includes(key)) ?? []
        }, index, backBehavior, initialRouteName);
      },
      getStateForRouteNamesChange(state, {
        routeNames,
        routeParamList,
        routeKeyChanges
      }) {
        const routes = routeNames.map(name => state.routes.find(r => r.name === name && !routeKeyChanges.includes(r.name)) || {
          name,
          key: `${name}-${(0, _nanoidNonSecure.nanoid)()}`,
          params: routeParamList[name]
        });
        const index = Math.max(0, routeNames.indexOf(state.routes[state.index].name));
        let history = state.history.filter(
        // Type will always be 'route' for tabs, but could be different in a router extending this (e.g. drawer)
        it => it.type !== 'route' || routes.find(r => r.key === it.key));
        if (!history.length) {
          history = getRouteHistory(routes, index, backBehavior, initialRouteName);
        }
        return Object.assign({}, state, {
          history,
          routeNames,
          routes,
          index
        });
      },
      getStateForRouteFocus(state, key) {
        const index = state.routes.findIndex(r => r.key === key);
        if (index === -1 || index === state.index) {
          return state;
        }
        return changeIndex(state, index, backBehavior, initialRouteName);
      },
      getStateForAction(state, action, {
        routeParamList,
        routeGetIdList
      }) {
        switch (action.type) {
          case 'JUMP_TO':
          case 'NAVIGATE':
          case 'NAVIGATE_DEPRECATED':
            {
              const index = state.routes.findIndex(route => route.name === action.payload.name);
              if (index === -1) {
                return null;
              }
              const updatedState = changeIndex(Object.assign({}, state, {
                routes: state.routes.map(route => {
                  if (route.name !== action.payload.name) {
                    return route;
                  }
                  const getId = routeGetIdList[route.name];
                  const currentId = getId?.({
                    params: route.params
                  });
                  const nextId = getId?.({
                    params: action.payload.params
                  });
                  const key = currentId === nextId ? route.key : `${route.name}-${(0, _nanoidNonSecure.nanoid)()}`;
                  let params;
                  if ((action.type === 'NAVIGATE' || action.type === 'NAVIGATE_DEPRECATED') && action.payload.merge && currentId === nextId) {
                    params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], route.params, action.payload.params) : route.params;
                  } else {
                    params = (0, _createParamsFromActionJs.createParamsFromAction)({
                      action,
                      routeParamList
                    });
                  }
                  const path = action.type === 'NAVIGATE' && action.payload.path != null ? action.payload.path : route.path;
                  return params !== route.params || path !== route.path ? Object.assign({}, route, {
                    key,
                    path,
                    params
                  }) : route;
                })
              }), index, backBehavior, initialRouteName);
              return Object.assign({}, updatedState, {
                preloadedRouteKeys: updatedState.preloadedRouteKeys.filter(key => key !== state.routes[updatedState.index].key)
              });
            }
          case 'SET_PARAMS':
          case 'REPLACE_PARAMS':
            {
              const nextState = _BaseRouterJs.BaseRouter.getStateForAction(state, action);
              if (nextState !== null) {
                const index = nextState.index;
                if (index != null) {
                  const focusedRoute = nextState.routes[index];
                  const historyItemIndex = state.history.findLastIndex(item => item.key === focusedRoute.key);
                  let updatedHistory = state.history;
                  if (historyItemIndex !== -1) {
                    updatedHistory = [...state.history];
                    updatedHistory[historyItemIndex] = Object.assign({}, updatedHistory[historyItemIndex], {
                      params: focusedRoute.params
                    });
                  }
                  return Object.assign({}, nextState, {
                    history: updatedHistory
                  });
                }
              }
              return nextState;
            }
          case 'GO_BACK':
            {
              if (state.history.length === 1) {
                return null;
              }
              const previousHistoryItem = state.history[state.history.length - 2];
              const previousKey = previousHistoryItem?.key;
              const index = state.routes.findLastIndex(route => route.key === previousKey);
              if (index === -1) {
                return null;
              }
              let routes = state.routes;
              if (backBehavior === 'fullHistory' && routes[index].params !== previousHistoryItem.params) {
                routes = [...state.routes];
                routes[index] = Object.assign({}, routes[index], {
                  params: previousHistoryItem.params
                });
              }
              return Object.assign({}, state, {
                routes,
                preloadedRouteKeys: state.preloadedRouteKeys.filter(key => key !== state.routes[index].key),
                history: state.history.slice(0, -1),
                index
              });
            }
          case 'PRELOAD':
            {
              const routeIndex = state.routes.findIndex(route => route.name === action.payload.name);
              if (routeIndex === -1) {
                return null;
              }
              const route = state.routes[routeIndex];
              const getId = routeGetIdList[route.name];
              const currentId = getId?.({
                params: route.params
              });
              const nextId = getId?.({
                params: action.payload.params
              });
              const key = currentId === nextId ? route.key : `${route.name}-${(0, _nanoidNonSecure.nanoid)()}`;
              const params = (0, _createParamsFromActionJs.createParamsFromAction)({
                action,
                routeParamList
              });
              const newRoute = params !== route.params ? Object.assign({}, route, {
                key,
                params
              }) : route;
              return Object.assign({}, state, {
                preloadedRouteKeys: state.preloadedRouteKeys.filter(key => key !== route.key).concat(newRoute.key),
                routes: state.routes.map((route, index) => index === routeIndex ? newRoute : route),
                history: key === route.key ? state.history : state.history.filter(record => record.key !== route.key)
              });
            }
          default:
            return _BaseRouterJs.BaseRouter.getStateForAction(state, action);
        }
      },
      actionCreators: TabActions
    });
    return router;
  }
},262,[260,259,263],"node_modules/@react-navigation/routers/lib/module/TabRouter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.createParamsFromAction = createParamsFromAction;
  function createParamsFromAction({
    action,
    routeParamList
  }) {
    const {
      name,
      params
    } = action.payload;
    return routeParamList[name] !== undefined ? Object.assign({}, routeParamList[name], params) : params;
  }
},263,[],"node_modules/@react-navigation/routers/lib/module/createParamsFromAction.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "StackActions", {
    enumerable: true,
    get: function () {
      return StackActions;
    }
  });
  exports.StackRouter = StackRouter;
  var _nanoidNonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  var _BaseRouterJs = require(_dependencyMap[1], "./BaseRouter.js");
  var _createParamsFromActionJs = require(_dependencyMap[2], "./createParamsFromAction.js");
  var _createRouteFromActionJs = require(_dependencyMap[3], "./createRouteFromAction.js");
  const StackActions = {
    replace(name, params) {
      return {
        type: 'REPLACE',
        payload: {
          name,
          params
        }
      };
    },
    push(name, params) {
      return {
        type: 'PUSH',
        payload: {
          name,
          params
        }
      };
    },
    pop(count = 1) {
      return {
        type: 'POP',
        payload: {
          count
        }
      };
    },
    popToTop() {
      return {
        type: 'POP_TO_TOP'
      };
    },
    popTo(name, params, options) {
      if (typeof options === 'boolean') {
        console.warn(`Passing a boolean as the third argument to 'popTo' is deprecated. Pass '{ merge: true }' instead.`);
      }
      return {
        type: 'POP_TO',
        payload: {
          name,
          params,
          merge: typeof options === 'boolean' ? options : options?.merge
        }
      };
    }
  };
  function StackRouter(options) {
    const router = Object.assign({}, _BaseRouterJs.BaseRouter, {
      type: 'stack',
      getInitialState({
        routeNames,
        routeParamList
      }) {
        const initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
        return {
          stale: false,
          type: 'stack',
          key: `stack-${(0, _nanoidNonSecure.nanoid)()}`,
          index: 0,
          routeNames,
          preloadedRoutes: [],
          routes: [{
            key: `${initialRouteName}-${(0, _nanoidNonSecure.nanoid)()}`,
            name: initialRouteName,
            params: routeParamList[initialRouteName]
          }]
        };
      },
      getRehydratedState(partialState, {
        routeNames,
        routeParamList
      }) {
        const state = partialState;
        if (state.stale === false) {
          return state;
        }
        const routes = state.routes.filter(route => routeNames.includes(route.name)).map(route => Object.assign({}, route, {
          key: route.key || `${route.name}-${(0, _nanoidNonSecure.nanoid)()}`,
          params: routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], route.params) : route.params
        }));
        const preloadedRoutes = state.preloadedRoutes?.filter(route => routeNames.includes(route.name)).map(route => Object.assign({}, route, {
          key: route.key || `${route.name}-${(0, _nanoidNonSecure.nanoid)()}`,
          params: routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], route.params) : route.params
        })) ?? [];
        if (routes.length === 0) {
          const initialRouteName = options.initialRouteName !== undefined ? options.initialRouteName : routeNames[0];
          routes.push({
            key: `${initialRouteName}-${(0, _nanoidNonSecure.nanoid)()}`,
            name: initialRouteName,
            params: routeParamList[initialRouteName]
          });
        }
        return {
          stale: false,
          type: 'stack',
          key: `stack-${(0, _nanoidNonSecure.nanoid)()}`,
          index: routes.length - 1,
          routeNames,
          routes,
          preloadedRoutes
        };
      },
      getStateForRouteNamesChange(state, {
        routeNames,
        routeParamList,
        routeKeyChanges
      }) {
        const routes = state.routes.filter(route => routeNames.includes(route.name) && !routeKeyChanges.includes(route.name));
        if (routes.length === 0) {
          const initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
          routes.push({
            key: `${initialRouteName}-${(0, _nanoidNonSecure.nanoid)()}`,
            name: initialRouteName,
            params: routeParamList[initialRouteName]
          });
        }
        return Object.assign({}, state, {
          routeNames,
          routes,
          index: Math.min(state.index, routes.length - 1)
        });
      },
      getStateForRouteFocus(state, key) {
        const index = state.routes.findIndex(r => r.key === key);
        if (index === -1 || index === state.index) {
          return state;
        }
        return Object.assign({}, state, {
          index,
          routes: state.routes.slice(0, index + 1)
        });
      },
      getStateForAction(state, action, options) {
        const {
          routeParamList
        } = options;
        switch (action.type) {
          case 'REPLACE':
            {
              const currentIndex = action.target === state.key && action.source ? state.routes.findIndex(r => r.key === action.source) : state.index;
              if (currentIndex === -1) {
                return null;
              }
              if (!state.routeNames.includes(action.payload.name)) {
                return null;
              }
              const getId = options.routeGetIdList[action.payload.name];
              const id = getId?.({
                params: action.payload.params
              });

              // Re-use preloaded route if available
              let route = state.preloadedRoutes.find(route => route.name === action.payload.name && id === getId?.({
                params: route.params
              }));
              if (!route) {
                route = (0, _createRouteFromActionJs.createRouteFromAction)({
                  action,
                  routeParamList
                });
              }
              return Object.assign({}, state, {
                routes: state.routes.map((r, i) => i === currentIndex ? route : r),
                preloadedRoutes: state.preloadedRoutes.filter(r => r.key !== route.key)
              });
            }
          case 'PUSH':
          case 'NAVIGATE':
            {
              if (!state.routeNames.includes(action.payload.name)) {
                return null;
              }
              const getId = options.routeGetIdList[action.payload.name];
              const id = getId?.({
                params: action.payload.params
              });
              let route;
              if (id !== undefined) {
                route = state.routes.findLast(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              } else if (action.type === 'NAVIGATE') {
                const currentRoute = state.routes[state.index];

                // If the route matches the current one, then navigate to it
                if (action.payload.name === currentRoute.name) {
                  route = currentRoute;
                } else if (action.payload.pop) {
                  route = state.routes.findLast(route => route.name === action.payload.name);
                }
              }
              if (!route) {
                route = state.preloadedRoutes.find(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              }
              let params;
              if (action.type === 'NAVIGATE' && action.payload.merge && route) {
                params = action.payload.params !== undefined || routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], route.params, action.payload.params) : route.params;
              } else {
                params = (0, _createParamsFromActionJs.createParamsFromAction)({
                  action,
                  routeParamList
                });
              }
              let routes;
              if (route) {
                if (action.type === 'NAVIGATE' && action.payload.pop) {
                  routes = [];

                  // Get all routes until the matching one
                  for (const r of state.routes) {
                    if (r.key === route.key) {
                      routes.push(Object.assign({}, route, {
                        path: action.payload.path !== undefined ? action.payload.path : route.path,
                        params
                      }));
                      break;
                    }
                    routes.push(r);
                  }
                } else {
                  routes = state.routes.filter(r => r.key !== route.key);
                  routes.push(Object.assign({}, route, {
                    path: action.type === 'NAVIGATE' && action.payload.path !== undefined ? action.payload.path : route.path,
                    params
                  }));
                }
              } else {
                routes = [...state.routes, {
                  key: `${action.payload.name}-${(0, _nanoidNonSecure.nanoid)()}`,
                  name: action.payload.name,
                  path: action.type === 'NAVIGATE' ? action.payload.path : undefined,
                  params
                }];
              }
              return Object.assign({}, state, {
                index: routes.length - 1,
                preloadedRoutes: state.preloadedRoutes.filter(route => routes[routes.length - 1].key !== route.key),
                routes
              });
            }
          case 'NAVIGATE_DEPRECATED':
            {
              if (!state.routeNames.includes(action.payload.name)) {
                return null;
              }
              if (state.preloadedRoutes.find(route => route.name === action.payload.name && id === getId?.({
                params: route.params
              }))) {
                return null;
              }

              // If the route already exists, navigate to that
              let index = -1;
              const getId = options.routeGetIdList[action.payload.name];
              const id = getId?.({
                params: action.payload.params
              });
              if (id !== undefined) {
                index = state.routes.findIndex(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              } else if (state.routes[state.index].name === action.payload.name) {
                index = state.index;
              } else {
                index = state.routes.findLastIndex(route => route.name === action.payload.name);
              }
              if (index === -1) {
                const routes = [...state.routes, (0, _createRouteFromActionJs.createRouteFromAction)({
                  action,
                  routeParamList
                })];
                return Object.assign({}, state, {
                  routes,
                  index: routes.length - 1
                });
              }
              const route = state.routes[index];
              let params;
              if (action.payload.merge) {
                params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], route.params, action.payload.params) : route.params;
              } else {
                params = (0, _createParamsFromActionJs.createParamsFromAction)({
                  action,
                  routeParamList
                });
              }
              return Object.assign({}, state, {
                index,
                routes: [...state.routes.slice(0, index), params !== route.params ? Object.assign({}, route, {
                  params
                }) : state.routes[index]]
              });
            }
          case 'POP':
            {
              const currentIndex = action.target === state.key && action.source ? state.routes.findIndex(r => r.key === action.source) : state.index;
              if (currentIndex > 0) {
                const count = Math.max(currentIndex - action.payload.count + 1, 1);
                const routes = state.routes.slice(0, count).concat(state.routes.slice(currentIndex + 1));
                return Object.assign({}, state, {
                  index: routes.length - 1,
                  routes
                });
              }
              return null;
            }
          case 'POP_TO_TOP':
            return router.getStateForAction(state, {
              type: 'POP',
              payload: {
                count: state.routes.length - 1
              }
            }, options);
          case 'POP_TO':
            {
              const currentIndex = action.target === state.key && action.source ? state.routes.findLastIndex(r => r.key === action.source) : state.index;
              if (currentIndex === -1) {
                return null;
              }
              if (!state.routeNames.includes(action.payload.name)) {
                return null;
              }

              // If the route already exists, navigate to it
              let index = -1;
              const getId = options.routeGetIdList[action.payload.name];
              const id = getId?.({
                params: action.payload.params
              });
              if (id !== undefined) {
                index = state.routes.findIndex(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              } else if (state.routes[currentIndex].name === action.payload.name) {
                index = currentIndex;
              } else {
                for (let i = currentIndex; i >= 0; i--) {
                  if (state.routes[i].name === action.payload.name) {
                    index = i;
                    break;
                  }
                }
              }

              // If the route doesn't exist, remove the current route and add the new one
              if (index === -1) {
                // Re-use preloaded route if available
                let route = state.preloadedRoutes.find(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
                if (!route) {
                  route = (0, _createRouteFromActionJs.createRouteFromAction)({
                    action,
                    routeParamList
                  });
                }
                const routes = state.routes.slice(0, currentIndex).concat(route);
                return Object.assign({}, state, {
                  index: routes.length - 1,
                  routes,
                  preloadedRoutes: state.preloadedRoutes.filter(r => r.key !== route.key)
                });
              }
              const route = state.routes[index];
              let params;
              if (action.payload.merge) {
                params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? Object.assign({}, routeParamList[route.name], route.params, action.payload.params) : route.params;
              } else {
                params = (0, _createParamsFromActionJs.createParamsFromAction)({
                  action,
                  routeParamList
                });
              }
              return Object.assign({}, state, {
                index,
                routes: [...state.routes.slice(0, index), params !== route.params ? Object.assign({}, route, {
                  params
                }) : state.routes[index]]
              });
            }
          case 'GO_BACK':
            if (state.index > 0) {
              return router.getStateForAction(state, {
                type: 'POP',
                payload: {
                  count: 1
                },
                target: action.target,
                source: action.source
              }, options);
            }
            return null;
          case 'PRELOAD':
            {
              const getId = options.routeGetIdList[action.payload.name];
              const id = getId?.({
                params: action.payload.params
              });
              let route;
              if (id !== undefined) {
                route = state.routes.find(route => route.name === action.payload.name && id === getId?.({
                  params: route.params
                }));
              }
              if (route) {
                return Object.assign({}, state, {
                  routes: state.routes.map(r => {
                    if (r.key !== route?.key) {
                      return r;
                    }
                    return Object.assign({}, r, {
                      params: (0, _createParamsFromActionJs.createParamsFromAction)({
                        action,
                        routeParamList
                      })
                    });
                  })
                });
              } else {
                return Object.assign({}, state, {
                  preloadedRoutes: state.preloadedRoutes.filter(r => r.name !== action.payload.name || id !== getId?.({
                    params: r.params
                  })).concat((0, _createRouteFromActionJs.createRouteFromAction)({
                    action,
                    routeParamList
                  }))
                });
              }
            }
          default:
            return _BaseRouterJs.BaseRouter.getStateForAction(state, action);
        }
      },
      actionCreators: StackActions
    });
    return router;
  }
},264,[260,259,263,265],"node_modules/@react-navigation/routers/lib/module/StackRouter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.createRouteFromAction = createRouteFromAction;
  var _nanoidNonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  var _createParamsFromActionJs = require(_dependencyMap[1], "./createParamsFromAction.js");
  function createRouteFromAction({
    action,
    routeParamList
  }) {
    const {
      name
    } = action.payload;
    return {
      key: `${name}-${(0, _nanoidNonSecure.nanoid)()}`,
      name,
      params: (0, _createParamsFromActionJs.createParamsFromAction)({
        action,
        routeParamList
      })
    };
  }
},265,[260,263],"node_modules/@react-navigation/routers/lib/module/createRouteFromAction.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},266,[],"node_modules/@react-navigation/routers/lib/module/types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _libSrcIndexJs = require(_dependencyMap[0], "./lib/src/index.js");
  var useLatestCallback = _interopDefault(_libSrcIndexJs);
  // eslint-disable-next-line import/extensions

  var _default = useLatestCallback.default;
},267,[268],"node_modules/use-latest-callback/esm.mjs");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var React = require(_dependencyMap[0], "react");
  /**
   * Use `useEffect` during SSR and `useLayoutEffect` in the Browser & React Native to avoid warnings.
   */
  var useClientLayoutEffect = typeof document !== 'undefined' || typeof navigator !== 'undefined' && navigator.product === 'ReactNative' ? React.useLayoutEffect : React.useEffect;
  /**
   * React hook which returns the latest callback without changing the reference.
   */
  // eslint-disable-next-line @typescript-eslint/ban-types
  function useLatestCallback(callback) {
    var ref = React.useRef(callback);
    var latestCallback = React.useRef(function latestCallback() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return ref.current.apply(this, args);
    }).current;
    useClientLayoutEffect(function () {
      ref.current = callback;
    });
    return latestCallback;
  }
  module.exports = useLatestCallback;
},268,[9],"node_modules/use-latest-callback/lib/src/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.checkDuplicateRouteNames = checkDuplicateRouteNames;
  function checkDuplicateRouteNames(state) {
    const duplicates = [];
    const getRouteNames = (location, state) => {
      state.routes.forEach(route => {
        const currentLocation = location ? `${location} > ${route.name}` : route.name;
        route.state?.routeNames?.forEach(routeName => {
          if (routeName === route.name) {
            duplicates.push([currentLocation, `${currentLocation} > ${route.name}`]);
          }
        });
        if (route.state) {
          getRouteNames(currentLocation, route.state);
        }
      });
    };
    getRouteNames('', state);
    return duplicates;
  }
},269,[],"node_modules/@react-navigation/core/lib/module/checkDuplicateRouteNames.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.checkSerializable = checkSerializable;
  const checkSerializableWithoutCircularReference = (o, seen, location) => {
    if (o === undefined || o === null || typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string') {
      return {
        serializable: true
      };
    }
    if (Object.prototype.toString.call(o) !== '[object Object]' && !Array.isArray(o)) {
      return {
        serializable: false,
        location,
        reason: typeof o === 'function' ? 'Function' : String(o)
      };
    }
    if (seen.has(o)) {
      return {
        serializable: false,
        reason: 'Circular reference',
        location
      };
    }
    seen.add(o);
    if (Array.isArray(o)) {
      for (let i = 0; i < o.length; i++) {
        const childResult = checkSerializableWithoutCircularReference(o[i], new Set(seen), [...location, i]);
        if (!childResult.serializable) {
          return childResult;
        }
      }
    } else {
      for (const key in o) {
        const childResult = checkSerializableWithoutCircularReference(o[key], new Set(seen), [...location, key]);
        if (!childResult.serializable) {
          return childResult;
        }
      }
    }
    return {
      serializable: true
    };
  };
  function checkSerializable(o) {
    return checkSerializableWithoutCircularReference(o, new Set(), []);
  }
},270,[],"node_modules/@react-navigation/core/lib/module/checkSerializable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "NOT_INITIALIZED_ERROR", {
    enumerable: true,
    get: function () {
      return NOT_INITIALIZED_ERROR;
    }
  });
  exports.createNavigationContainerRef = createNavigationContainerRef;
  var _reactNavigationRouters = require(_dependencyMap[0], "@react-navigation/routers");
  const NOT_INITIALIZED_ERROR = "The 'navigation' object hasn't been initialized yet. This might happen if you don't have a navigator mounted, or if the navigator hasn't finished mounting. See https://reactnavigation.org/docs/navigating-without-navigation-prop#handling-initialization for more details.";
  function createNavigationContainerRef() {
    const methods = [...Object.keys(_reactNavigationRouters.CommonActions), 'addListener', 'removeListener', 'resetRoot', 'dispatch', 'isFocused', 'canGoBack', 'getRootState', 'getState', 'getParent', 'getCurrentRoute', 'getCurrentOptions'];
    const listeners = {};
    const removeListener = (event, callback) => {
      if (listeners[event]) {
        listeners[event] = listeners[event].filter(cb => cb !== callback);
      }
    };
    let current = null;
    const ref = Object.assign({
      get current() {
        return current;
      },
      set current(value) {
        current = value;
        if (value != null) {
          Object.entries(listeners).forEach(([event, callbacks]) => {
            callbacks.forEach(callback => {
              value.addListener(event, callback);
            });
          });
        }
      },
      isReady: () => {
        if (current == null) {
          return false;
        }
        return current.isReady();
      }
    }, methods.reduce((acc, name) => {
      acc[name] = (...args) => {
        if (current == null) {
          switch (name) {
            case 'addListener':
              {
                const [event, callback] = args;
                listeners[event] = listeners[event] || [];
                listeners[event].push(callback);
                return () => removeListener(event, callback);
              }
            case 'removeListener':
              {
                const [event, callback] = args;
                removeListener(event, callback);
                break;
              }
            default:
              console.error(NOT_INITIALIZED_ERROR);
          }
        } else {
          // @ts-expect-error: this is ok
          return current[name](...args);
        }
      };
      return acc;
    }, {}));
    return ref;
  }
},271,[257],"node_modules/@react-navigation/core/lib/module/createNavigationContainerRef.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "DeprecatedNavigationInChildContext", {
    enumerable: true,
    get: function () {
      return DeprecatedNavigationInChildContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Context which enables deprecated bubbling to child navigators.
   */
  const DeprecatedNavigationInChildContext = /*#__PURE__*/React.createContext(false);
},272,[9],"node_modules/@react-navigation/core/lib/module/DeprecatedNavigationInChildContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "SingleNavigatorContext", {
    enumerable: true,
    get: function () {
      return SingleNavigatorContext;
    }
  });
  exports.EnsureSingleNavigator = EnsureSingleNavigator;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _reactJsxRuntime = require(_dependencyMap[1], "react/jsx-runtime");
  const MULTIPLE_NAVIGATOR_ERROR = `Another navigator is already registered for this container. You likely have multiple navigators under a single "NavigationContainer" or "Screen". Make sure each navigator is under a separate "Screen" container. See https://reactnavigation.org/docs/nesting-navigators for a guide on nesting.`;
  const SingleNavigatorContext = /*#__PURE__*/React.createContext(undefined);

  /**
   * Component which ensures that there's only one navigator nested under it.
   */
  function EnsureSingleNavigator({
    children
  }) {
    const navigatorKeyRef = React.useRef(undefined);
    const value = React.useMemo(() => ({
      register(key) {
        const currentKey = navigatorKeyRef.current;
        if (currentKey !== undefined && key !== currentKey) {
          throw new Error(MULTIPLE_NAVIGATOR_ERROR);
        }
        navigatorKeyRef.current = key;
      },
      unregister(key) {
        const currentKey = navigatorKeyRef.current;
        if (key !== currentKey) {
          return;
        }
        navigatorKeyRef.current = undefined;
      }
    }), []);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(SingleNavigatorContext.Provider, {
      value: value,
      children: children
    });
  }
},273,[9,274],"node_modules/@react-navigation/core/lib/module/EnsureSingleNavigator.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react-jsx-runtime.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-jsx-runtime.development.js");
  }
},274,[10,275],"node_modules/react/jsx-runtime.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_CONTEXT_TYPE:
          return (type.displayName || "Context") + ".Provider";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x) {}
      }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = !1;
      } catch (e) {
        JSCompiler_inline_result = !0;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE) return "<>";
      if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return !1;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = !0;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: !0
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
      self = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        props: props,
        _owner: owner
      };
      null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
        enumerable: !1,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", {
        enumerable: !1,
        value: null
      });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
      var children = config.children;
      if (void 0 !== children) if (isStaticChildren) {
        if (isArrayImpl(children)) {
          for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++) validateChildKeys(children[isStaticChildren]);
          Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
      } else validateChildKeys(children);
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function (k) {
          return "key" !== k;
        });
        isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
      }
      children = null;
      void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config) "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
      return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
      "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = require(_dependencyMap[0], "react"),
      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
      ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      isArrayImpl = Array.isArray,
      createTask = console.createTask ? console.createTask : function () {
        return null;
      };
    React = {
      "react-stack-bottom-frame": function (callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = function (type, config, maybeKey, source, self) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config, maybeKey, !1, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.jsxs = function (type, config, maybeKey, source, self) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config, maybeKey, !0, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
  }();
},275,[9],"node_modules/react/cjs/react-jsx-runtime.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.findFocusedRoute = findFocusedRoute;
  function findFocusedRoute(state) {
    let current = state;
    while (current?.routes[current.index ?? 0].state != null) {
      current = current.routes[current.index ?? 0].state;
    }
    const route = current?.routes[current?.index ?? 0];
    return route;
  }
},276,[],"node_modules/@react-navigation/core/lib/module/findFocusedRoute.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "NavigationBuilderContext", {
    enumerable: true,
    get: function () {
      return NavigationBuilderContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Context which holds the required helpers needed to build nested navigators.
   */
  const NavigationBuilderContext = /*#__PURE__*/React.createContext({
    onDispatchAction: () => undefined,
    onOptionsChange: () => undefined,
    scheduleUpdate: () => {
      throw new Error("Couldn't find a context for scheduling updates.");
    },
    flushUpdates: () => {
      throw new Error("Couldn't find a context for flushing updates.");
    }
  });
},277,[9],"node_modules/@react-navigation/core/lib/module/NavigationBuilderContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "NavigationContainerRefContext", {
    enumerable: true,
    get: function () {
      return NavigationContainerRefContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Context which holds the route prop for a screen.
   */
  const NavigationContainerRefContext = /*#__PURE__*/React.createContext(undefined);
},278,[9],"node_modules/@react-navigation/core/lib/module/NavigationContainerRefContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "NavigationIndependentTreeContext", {
    enumerable: true,
    get: function () {
      return NavigationIndependentTreeContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Context which marks the navigation tree as independent.
   */
  const NavigationIndependentTreeContext = /*#__PURE__*/React.createContext(false);
},279,[9],"node_modules/@react-navigation/core/lib/module/NavigationIndependentTreeContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "NavigationStateContext", {
    enumerable: true,
    get: function () {
      return NavigationStateContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  const MISSING_CONTEXT_ERROR = "Couldn't find a navigation context. Have you wrapped your app with 'NavigationContainer'? See https://reactnavigation.org/docs/getting-started for setup instructions.";
  const NavigationStateContext = /*#__PURE__*/React.createContext({
    isDefault: true,
    get getKey() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setKey() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },
    get getState() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setState() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },
    get getIsInitial() {
      throw new Error(MISSING_CONTEXT_ERROR);
    }
  });
},280,[9],"node_modules/@react-navigation/core/lib/module/NavigationStateContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.ThemeProvider = ThemeProvider;
  require(_dependencyMap[0], "react");
  var _ThemeContextJs = require(_dependencyMap[1], "./ThemeContext.js");
  var _reactJsxRuntime = require(_dependencyMap[2], "react/jsx-runtime");
  function ThemeProvider({
    value,
    children
  }) {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_ThemeContextJs.ThemeContext.Provider, {
      value: value,
      children: children
    });
  }
},281,[9,282,274],"node_modules/@react-navigation/core/lib/module/theming/ThemeProvider.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "ThemeContext", {
    enumerable: true,
    get: function () {
      return ThemeContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  const ThemeContext = /*#__PURE__*/React.createContext(undefined);
  ThemeContext.displayName = 'ThemeContext';
},282,[9],"node_modules/@react-navigation/core/lib/module/theming/ThemeContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "UnhandledActionContext", {
    enumerable: true,
    get: function () {
      return UnhandledActionContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  const UnhandledActionContext = /*#__PURE__*/React.createContext(undefined);
},283,[9],"node_modules/@react-navigation/core/lib/module/UnhandledActionContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useChildListeners = useChildListeners;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Hook which lets child navigators add action listeners.
   */
  function useChildListeners() {
    const {
      current: listeners
    } = React.useRef({
      action: [],
      focus: []
    });
    const addListener = React.useCallback((type, listener) => {
      listeners[type].push(listener);
      let removed = false;
      return () => {
        const index = listeners[type].indexOf(listener);
        if (!removed && index > -1) {
          removed = true;
          listeners[type].splice(index, 1);
        }
      };
    }, [listeners]);
    return {
      listeners,
      addListener
    };
  }
},284,[9],"node_modules/@react-navigation/core/lib/module/useChildListeners.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useEventEmitter = useEventEmitter;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Hook to manage the event system used by the navigator to notify screens of various events.
   */
  function useEventEmitter(listen) {
    const listenRef = React.useRef(listen);
    React.useEffect(() => {
      listenRef.current = listen;
    });
    const listeners = React.useRef(Object.create(null));
    const create = React.useCallback(target => {
      const removeListener = (type, callback) => {
        const callbacks = listeners.current[type] ? listeners.current[type][target] : undefined;
        if (!callbacks) {
          return;
        }
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      };
      const addListener = (type, callback) => {
        listeners.current[type] = listeners.current[type] || {};
        listeners.current[type][target] = listeners.current[type][target] || [];
        listeners.current[type][target].push(callback);
        let removed = false;
        return () => {
          // Prevent removing other listeners when unsubscribing same listener multiple times
          if (!removed) {
            removed = true;
            removeListener(type, callback);
          }
        };
      };
      return {
        addListener,
        removeListener
      };
    }, []);
    const emit = React.useCallback(({
      type,
      data,
      target,
      canPreventDefault
    }) => {
      const items = listeners.current[type] || {};

      // Copy the current list of callbacks in case they are mutated during execution
      const callbacks = target !== undefined ? items[target]?.slice() : [].concat(...Object.keys(items).map(t => items[t])).filter((cb, i, self) => self.lastIndexOf(cb) === i);
      const event = {
        get type() {
          return type;
        }
      };
      if (target !== undefined) {
        Object.defineProperty(event, 'target', {
          enumerable: true,
          get() {
            return target;
          }
        });
      }
      if (data !== undefined) {
        Object.defineProperty(event, 'data', {
          enumerable: true,
          get() {
            return data;
          }
        });
      }
      if (canPreventDefault) {
        let defaultPrevented = false;
        Object.defineProperties(event, {
          defaultPrevented: {
            enumerable: true,
            get() {
              return defaultPrevented;
            }
          },
          preventDefault: {
            enumerable: true,
            value() {
              defaultPrevented = true;
            }
          }
        });
      }
      listenRef.current?.(event);
      callbacks?.forEach(cb => cb(event));
      return event;
    }, []);
    return React.useMemo(() => ({
      create,
      emit
    }), [create, emit]);
  }
},285,[9],"node_modules/@react-navigation/core/lib/module/useEventEmitter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useKeyedChildListeners = useKeyedChildListeners;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Hook which lets child navigators add getters to be called for obtaining rehydrated state.
   */
  function useKeyedChildListeners() {
    const {
      current: keyedListeners
    } = React.useRef(Object.assign(Object.create(null), {
      getState: {},
      beforeRemove: {}
    }));
    const addKeyedListener = React.useCallback((type, key, listener) => {
      // @ts-expect-error: according to ref stated above you can use `key` to index type
      keyedListeners[type][key] = listener;
      return () => {
        // @ts-expect-error: according to ref stated above you can use `key` to index type
        keyedListeners[type][key] = undefined;
      };
    }, [keyedListeners]);
    return {
      keyedListeners,
      addKeyedListener
    };
  }
},286,[9],"node_modules/@react-navigation/core/lib/module/useKeyedChildListeners.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useNavigationIndependentTree = useNavigationIndependentTree;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _NavigationIndependentTreeContextJs = require(_dependencyMap[1], "./NavigationIndependentTreeContext.js");
  function useNavigationIndependentTree() {
    return React.useContext(_NavigationIndependentTreeContextJs.NavigationIndependentTreeContext);
  }
},287,[9,279],"node_modules/@react-navigation/core/lib/module/useNavigationIndependentTree.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useOptionsGetters = useOptionsGetters;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _NavigationBuilderContextJs = require(_dependencyMap[1], "./NavigationBuilderContext.js");
  var _NavigationStateContextJs = require(_dependencyMap[2], "./NavigationStateContext.js");
  function useOptionsGetters({
    key,
    options,
    navigation
  }) {
    const optionsRef = React.useRef(options);
    const optionsGettersFromChildRef = React.useRef({});
    const {
      onOptionsChange
    } = React.useContext(_NavigationBuilderContextJs.NavigationBuilderContext);
    const {
      addOptionsGetter: parentAddOptionsGetter
    } = React.useContext(_NavigationStateContextJs.NavigationStateContext);
    const optionsChangeListener = React.useCallback(() => {
      const isFocused = navigation?.isFocused() ?? true;
      const hasChildren = Object.keys(optionsGettersFromChildRef.current).length;
      if (isFocused && !hasChildren) {
        onOptionsChange(optionsRef.current ?? {});
      }
    }, [navigation, onOptionsChange]);
    React.useEffect(() => {
      optionsRef.current = options;
      optionsChangeListener();
      return navigation?.addListener('focus', optionsChangeListener);
    }, [navigation, options, optionsChangeListener]);
    const getOptionsFromListener = React.useCallback(() => {
      for (const key in optionsGettersFromChildRef.current) {
        if (key in optionsGettersFromChildRef.current) {
          const result = optionsGettersFromChildRef.current[key]?.();

          // null means unfocused route
          if (result !== null) {
            return result;
          }
        }
      }
      return null;
    }, []);
    const getCurrentOptions = React.useCallback(() => {
      const isFocused = navigation?.isFocused() ?? true;
      if (!isFocused) {
        return null;
      }
      const optionsFromListener = getOptionsFromListener();
      if (optionsFromListener !== null) {
        return optionsFromListener;
      }
      return optionsRef.current;
    }, [navigation, getOptionsFromListener]);
    React.useEffect(() => {
      return parentAddOptionsGetter?.(key, getCurrentOptions);
    }, [getCurrentOptions, parentAddOptionsGetter, key]);
    const addOptionsGetter = React.useCallback((key, getter) => {
      optionsGettersFromChildRef.current[key] = getter;
      optionsChangeListener();
      return () => {
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete optionsGettersFromChildRef.current[key];
        optionsChangeListener();
      };
    }, [optionsChangeListener]);
    return {
      addOptionsGetter,
      getCurrentOptions
    };
  }
},288,[9,277,280],"node_modules/@react-navigation/core/lib/module/useOptionsGetters.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.useSyncState = useSyncState;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _useLatestCallback = require(_dependencyMap[1], "use-latest-callback");
  var useLatestCallback = _interopDefault(_useLatestCallback);
  var _deepFreezeJs = require(_dependencyMap[2], "./deepFreeze.js");
  const createStore = getInitialState => {
    const listeners = [];
    let initialized = false;
    let state;
    const getState = () => {
      if (initialized) {
        return state;
      }
      initialized = true;
      state = (0, _deepFreezeJs.deepFreeze)(getInitialState());
      return state;
    };
    let isBatching = false;
    let didUpdate = false;
    const setState = newState => {
      state = (0, _deepFreezeJs.deepFreeze)(newState);
      didUpdate = true;
      if (!isBatching) {
        listeners.forEach(listener => listener());
      }
    };
    const subscribe = callback => {
      listeners.push(callback);
      return () => {
        const index = listeners.indexOf(callback);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      };
    };
    const batchUpdates = callback => {
      isBatching = true;
      callback();
      isBatching = false;
      if (didUpdate) {
        didUpdate = false;
        listeners.forEach(listener => listener());
      }
    };
    return {
      getState,
      setState,
      batchUpdates,
      subscribe
    };
  };
  function useSyncState(getInitialState) {
    const store = React.useRef(createStore(getInitialState)).current;
    const state = React.useSyncExternalStore(store.subscribe, store.getState, store.getState);
    React.useDebugValue(state);
    const pendingUpdatesRef = React.useRef([]);
    const scheduleUpdate = (0, useLatestCallback.default)(callback => {
      pendingUpdatesRef.current.push(callback);
    });
    const flushUpdates = (0, useLatestCallback.default)(() => {
      const pendingUpdates = pendingUpdatesRef.current;
      pendingUpdatesRef.current = [];
      if (pendingUpdates.length !== 0) {
        store.batchUpdates(() => {
          // Flush all the pending updates
          for (const update of pendingUpdates) {
            update();
          }
        });
      }
    });
    return {
      state,
      getState: store.getState,
      setState: store.setState,
      scheduleUpdate,
      flushUpdates
    };
  }
},289,[9,267,290],"node_modules/@react-navigation/core/lib/module/useSyncState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "isPlainObject", {
    enumerable: true,
    get: function () {
      return isPlainObject;
    }
  });
  Object.defineProperty(exports, "deepFreeze", {
    enumerable: true,
    get: function () {
      return deepFreeze;
    }
  });
  const isPlainObject = value => {
    if (typeof value === 'object' && value !== null) {
      return Object.getPrototypeOf(value) === Object.prototype;
    }
    return false;
  };
  const deepFreeze = object => {
    // We only freeze in development to catch issues early
    // Don't freeze in production to avoid unnecessary performance overhead
    if (process.env.NODE_ENV === 'production') {
      return object;
    }
    if (Object.isFrozen(object)) {
      return object;
    }
    if (!isPlainObject(object) && !Array.isArray(object)) {
      return object;
    }

    // Freeze properties before freezing self
    for (const key in object) {
      // Don't freeze objects in params since they are passed by the user
      if (key !== 'params') {
        if (Object.getOwnPropertyDescriptor(object, key)?.configurable) {
          const value = object[key];
          deepFreeze(value);
        }
      }
    }
    return Object.freeze(object);
  };
},290,[],"node_modules/@react-navigation/core/lib/module/deepFreeze.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.createNavigatorFactory = createNavigatorFactory;
  var _GroupJs = require(_dependencyMap[0], "./Group.js");
  var _ScreenJs = require(_dependencyMap[1], "./Screen.js");
  /**
   * Higher order component to create a `Navigator` and `Screen` pair.
   * Custom navigators should wrap the navigator component in `createNavigator` before exporting.
   *
   * @param Navigator The navigator component to wrap.
   * @returns Factory method to create a `Navigator` and `Screen` pair.
   */
  function createNavigatorFactory(Navigator) {
    function createNavigator(config) {
      if (config != null) {
        return {
          Navigator,
          Screen: _ScreenJs.Screen,
          Group: _GroupJs.Group,
          config
        };
      }
      return {
        Navigator,
        Screen: _ScreenJs.Screen,
        Group: _GroupJs.Group
      };
    }
    return createNavigator;
  }
},291,[292,293],"node_modules/@react-navigation/core/lib/module/createNavigatorFactory.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Empty component used for grouping screen configs.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.Group = Group;
  function Group(_) {
    /* istanbul ignore next */
    return null;
  }
},292,[],"node_modules/@react-navigation/core/lib/module/Group.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Empty component used for specifying route configuration.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.Screen = Screen;
  function Screen(_) {
    /* istanbul ignore next */
    return null;
  }
},293,[],"node_modules/@react-navigation/core/lib/module/Screen.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "CurrentRenderContext", {
    enumerable: true,
    get: function () {
      return CurrentRenderContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Context which holds the values for the current navigation tree.
   * Intended for use in SSR. This is not safe to use on the client.
   */
  const CurrentRenderContext = /*#__PURE__*/React.createContext(undefined);
},294,[9],"node_modules/@react-navigation/core/lib/module/CurrentRenderContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.getActionFromState = getActionFromState;
  function getActionFromState(state, options) {
    // Create a normalized configs object which will be easier to use
    const normalizedConfig = options ? createNormalizedConfigItem(options) : {};
    const routes = state.index != null ? state.routes.slice(0, state.index + 1) : state.routes;
    if (routes.length === 0) {
      return undefined;
    }
    if (!(routes.length === 1 && routes[0].key === undefined || routes.length === 2 && routes[0].key === undefined && routes[0].name === normalizedConfig?.initialRouteName && routes[1].key === undefined)) {
      return {
        type: 'RESET',
        payload: state
      };
    }
    const route = state.routes[state.index ?? state.routes.length - 1];
    let current = route?.state;
    let config = normalizedConfig?.screens?.[route?.name];
    let params = Object.assign({}, route.params);
    const payload = route ? {
      name: route.name,
      path: route.path,
      params
    } : undefined;

    // If the screen contains a navigator, pop other screens to navigate to it
    // This avoid pushing multiple instances of navigators onto a stack
    //
    // For example:
    // - RootStack
    //   - BottomTabs
    //   - SomeScreen
    //
    // In this case, if deep linking to `BottomTabs`, we should pop `SomeScreen`
    // Otherwise, we'll end up with 2 instances of `BottomTabs` in the stack
    //
    // There are 2 ways we can detect if a screen contains a navigator:
    // - The route contains nested state in `route.state`
    // - Nested screens are defined in the config
    if (payload && config?.screens && Object.keys(config.screens).length) {
      payload.pop = true;
    }
    while (current) {
      if (current.routes.length === 0) {
        return undefined;
      }
      const routes = current.index != null ? current.routes.slice(0, current.index + 1) : current.routes;
      const route = routes[routes.length - 1];

      // Explicitly set to override existing value when merging params
      Object.assign(params, {
        initial: undefined,
        screen: undefined,
        params: undefined,
        state: undefined
      });
      if (routes.length === 1 && routes[0].key === undefined) {
        params.initial = true;
        params.screen = route.name;
      } else if (routes.length === 2 && routes[0].key === undefined && routes[0].name === config?.initialRouteName && routes[1].key === undefined) {
        params.initial = false;
        params.screen = route.name;
      } else {
        params.state = current;
        break;
      }
      if (route.state) {
        params.params = Object.assign({}, route.params);
        params.pop = true;
        params = params.params;
      } else {
        params.path = route.path;
        params.params = route.params;
      }
      current = route.state;
      config = config?.screens?.[route.name];
      if (config?.screens && Object.keys(config.screens).length) {
        params.pop = true;
      }
    }
    if (payload?.params.screen || payload?.params.state) {
      payload.pop = true;
    }
    if (!payload) {
      return;
    }

    // Try to construct payload for a `NAVIGATE` action from the state
    // This lets us preserve the navigation state and not lose it
    return {
      type: 'NAVIGATE',
      payload
    };
  }
  const createNormalizedConfigItem = config => typeof config === 'object' && config != null ? {
    initialRouteName: config.initialRouteName,
    screens: config.screens != null ? createNormalizedConfigs(config.screens) : undefined
  } : {};
  const createNormalizedConfigs = options => Object.entries(options).reduce((acc, [k, v]) => {
    acc[k] = createNormalizedConfigItem(v);
    return acc;
  }, {});
},295,[],"node_modules/@react-navigation/core/lib/module/getActionFromState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.getFocusedRouteNameFromRoute = getFocusedRouteNameFromRoute;
  var _useRouteCacheJs = require(_dependencyMap[0], "./useRouteCache.js");
  function getFocusedRouteNameFromRoute(route) {
    // @ts-expect-error: this isn't in type definitions coz we want this private
    const state = route[_useRouteCacheJs.CHILD_STATE] ?? route.state;
    const params = route.params;
    const routeName = state ?
    // Get the currently active route name in the nested navigator
    state.routes[
    // If we have a partial state without index, for tab/drawer, first screen will be focused one, and last for stack
    // The type property will only exist for rehydrated state and not for state from deep link
    state.index ?? (typeof state.type === 'string' && state.type !== 'stack' ? 0 : state.routes.length - 1)].name :
    // If state doesn't exist, we need to default to `screen` param if available
    typeof params?.screen === 'string' ? params.screen : undefined;
    return routeName;
  }
},296,[297],"node_modules/@react-navigation/core/lib/module/getFocusedRouteNameFromRoute.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["state"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "CHILD_STATE", {
    enumerable: true,
    get: function () {
      return CHILD_STATE;
    }
  });
  exports.useRouteCache = useRouteCache;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _isRecordEqualJs = require(_dependencyMap[2], "./isRecordEqual.js");
  /**
   * Utilities such as `getFocusedRouteNameFromRoute` need to access state.
   * So we need a way to suppress the warning for those use cases.
   * This is fine since they are internal utilities and this is not public API.
   */
  const CHILD_STATE = Symbol('CHILD_STATE');

  /**
   * Hook to cache route props for each screen in the navigator.
   * This lets add warnings and modifications to the route object but keep references between renders.
   */
  function useRouteCache(routes) {
    // Cache object which holds route objects for each screen
    const cache = React.useMemo(() => ({
      current: new Map()
    }), []);
    cache.current = routes.reduce((acc, route) => {
      const previous = cache.current.get(route.key);
      const {
          state
        } = route,
        routeWithoutState = (0, _objectWithoutPropertiesLoose.default)(route, _excluded);
      let proxy;
      if (previous && (0, _isRecordEqualJs.isRecordEqual)(previous, routeWithoutState)) {
        // If a cached route object already exists, reuse it
        proxy = previous;
      } else {
        proxy = routeWithoutState;
      }
      if (process.env.NODE_ENV !== 'production') {
        // FIXME: since the state is updated with mutation, the route object cannot be frozen
        // As a workaround, loop through the object and make the properties readonly
        for (const key in proxy) {
          // @ts-expect-error: this is fine since we are looping through the object
          const value = proxy[key];
          Object.defineProperty(proxy, key, {
            enumerable: true,
            configurable: true,
            writable: false,
            value
          });
        }
      }
      Object.defineProperty(proxy, CHILD_STATE, {
        enumerable: false,
        configurable: true,
        value: state
      });
      acc.set(route.key, proxy);
      return acc;
    }, new Map());
    return Array.from(cache.current.values());
  }
},297,[759,9,298],"node_modules/@react-navigation/core/lib/module/useRouteCache.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Compare two records with primitive values as the content.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.isRecordEqual = isRecordEqual;
  function isRecordEqual(a, b) {
    if (a === b) {
      return true;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    return aKeys.every(key => Object.is(a[key], b[key]));
  }
},298,[],"node_modules/@react-navigation/core/lib/module/isRecordEqual.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.getPathFromState = getPathFromState;
  var _queryString = require(_dependencyMap[0], "query-string");
  var queryString = _interopNamespace(_queryString);
  var _getPatternPartsJs = require(_dependencyMap[1], "./getPatternParts.js");
  var _validatePathConfigJs = require(_dependencyMap[2], "./validatePathConfig.js");
  const getActiveRoute = state => {
    const route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];
    if (route.state) {
      return getActiveRoute(route.state);
    }
    return route;
  };
  const cachedNormalizedConfigs = new WeakMap();
  const getNormalizedConfigs = options => {
    if (!options?.screens) return {};
    const cached = cachedNormalizedConfigs.get(options?.screens);
    if (cached) return cached;
    const normalizedConfigs = createNormalizedConfigs(options.screens);
    cachedNormalizedConfigs.set(options.screens, normalizedConfigs);
    return normalizedConfigs;
  };

  /**
   * Utility to serialize a navigation state object to a path string.
   *
   * @example
   * ```js
   * getPathFromState(
   *   {
   *     routes: [
   *       {
   *         name: 'Chat',
   *         params: { author: 'Jane', id: 42 },
   *       },
   *     ],
   *   },
   *   {
   *     screens: {
   *       Chat: {
   *         path: 'chat/:author/:id',
   *         stringify: { author: author => author.toLowerCase() }
   *       }
   *     }
   *   }
   * )
   * ```
   *
   * @param state Navigation state to serialize.
   * @param options Extra options to fine-tune how to serialize the path.
   * @returns Path representing the state, e.g. /foo/bar?count=42.
   */
  function getPathFromState(state, options) {
    if (state == null) {
      throw Error(`Got '${String(state)}' for the navigation state. You must pass a valid state object.`);
    }
    if (options) {
      (0, _validatePathConfigJs.validatePathConfig)(options);
    }
    const configs = getNormalizedConfigs(options);
    let path = '/';
    let current = state;
    const allParams = {};
    while (current) {
      let index = typeof current.index === 'number' ? current.index : 0;
      let route = current.routes[index];
      let parts;
      let focusedParams;
      let currentOptions = configs;
      const focusedRoute = getActiveRoute(state);

      // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined
      const nestedRouteNames = [];
      let hasNext = true;
      while (route.name in currentOptions && hasNext) {
        parts = currentOptions[route.name].parts;
        nestedRouteNames.push(route.name);
        if (route.params) {
          const options = currentOptions[route.name];
          const currentParams = Object.fromEntries(Object.entries(route.params).map(([key, value]) => {
            if (value === undefined) {
              if (options) {
                const optional = options.parts?.find(part => part.param === key)?.optional;
                if (optional) {
                  return null;
                }
              } else {
                return null;
              }
            }
            const stringify = options?.stringify?.[key] ?? String;
            return [key, stringify(value)];
          }).filter(entry => entry != null));
          if (parts?.length) {
            Object.assign(allParams, currentParams);
          }
          if (focusedRoute === route) {
            // If this is the focused route, keep the params for later use
            // We save it here since it's been stringified already
            focusedParams = Object.assign({}, currentParams);
            parts
            // eslint-disable-next-line no-loop-func
            ?.forEach(({
              param
            }) => {
              if (param) {
                // Remove the params present in the pattern since we'll only use the rest for query string
                if (focusedParams) {
                  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                  delete focusedParams[param];
                }
              }
            });
          }
        }

        // If there is no `screens` property or no nested state, we return pattern
        if (!currentOptions[route.name].screens || route.state === undefined) {
          hasNext = false;
        } else {
          index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;
          const nextRoute = route.state.routes[index];
          const nestedConfig = currentOptions[route.name].screens;

          // if there is config for next route name, we go deeper
          if (nestedConfig && nextRoute.name in nestedConfig) {
            route = nextRoute;
            currentOptions = nestedConfig;
          } else {
            // If not, there is no sense in going deeper in config
            hasNext = false;
          }
        }
      }
      if (currentOptions[route.name] !== undefined) {
        path += parts?.map(({
          segment,
          param,
          optional
        }) => {
          // We don't know what to show for wildcard patterns
          // Showing the route name seems ok, though whatever we show here will be incorrect
          // Since the page doesn't actually exist
          if (segment === '*') {
            return route.name;
          }

          // If the path has a pattern for a param, put the param in the path
          if (param) {
            const value = allParams[param];
            if (value === undefined && optional) {
              // Optional params without value assigned in route.params should be ignored
              return '';
            }

            // Valid characters according to
            // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)
            return Array.from(String(value)).map(char => /[^A-Za-z0-9\-._~!$&'()*+,;=:@]/g.test(char) ? encodeURIComponent(char) : char).join('');
          }
          return encodeURIComponent(segment);
        }).join('/');
      } else {
        path += encodeURIComponent(route.name);
      }
      if (!focusedParams && focusedRoute.params) {
        focusedParams = Object.fromEntries(Object.entries(focusedRoute.params).map(([key, value]) => [key, String(value)]));
      }
      if (route.state) {
        path += '/';
      } else if (focusedParams) {
        for (const param in focusedParams) {
          if (focusedParams[param] === 'undefined') {
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete focusedParams[param];
          }
        }
        const query = queryString.stringify(focusedParams, {
          sort: false
        });
        if (query) {
          path += `?${query}`;
        }
      }
      current = route.state;
    }

    // Include the root path if specified
    if (options?.path) {
      path = `${options.path}/${path}`;
    }

    // Remove multiple as well as trailing slashes
    path = path.replace(/\/+/g, '/');
    path = path.length > 1 ? path.replace(/\/$/, '') : path;

    // If path doesn't start with a slash, add it
    // This makes sure that history.pushState will update the path correctly instead of appending
    if (!path.startsWith('/')) {
      path = `/${path}`;
    }
    return path;
  }
  const createConfigItem = (config, parentParts) => {
    if (typeof config === 'string') {
      // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
      const parts = (0, _getPatternPartsJs.getPatternParts)(config);
      if (parentParts) {
        return {
          parts: [...parentParts, ...parts]
        };
      }
      return {
        parts
      };
    }
    if (config.exact && config.path === undefined) {
      throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
    }

    // If an object is specified as the value (e.g. Foo: { ... }),
    // It can have `path` property and `screens` prop which has nested configs
    const parts = config.exact !== true ? [...(parentParts || []), ...(config.path ? (0, _getPatternPartsJs.getPatternParts)(config.path) : [])] : config.path ? (0, _getPatternPartsJs.getPatternParts)(config.path) : undefined;
    const screens = config.screens ? createNormalizedConfigs(config.screens, parts) : undefined;
    return {
      parts,
      stringify: config.stringify,
      screens
    };
  };
  const createNormalizedConfigs = (options, parts) => Object.fromEntries(Object.entries(options).map(([name, c]) => {
    const result = createConfigItem(c, parts);
    return [name, result];
  }));
},299,[300,305,306],"node_modules/@react-navigation/core/lib/module/getPathFromState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  const strictUriEncode = require(_dependencyMap[0], "strict-uri-encode");
  const decodeComponent = require(_dependencyMap[1], "decode-uri-component");
  const splitOnFirst = require(_dependencyMap[2], "split-on-first");
  const filterObject = require(_dependencyMap[3], "filter-obj");
  const isNullOrUndefined = value => value === null || value === undefined;
  const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case 'index':
        return key => (result, value) => {
          const index = result.length;
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }
          if (value === null) {
            return [...result, [encode(key, options), '[', index, ']'].join('')];
          }
          return [...result, [encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')];
        };
      case 'bracket':
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }
          if (value === null) {
            return [...result, [encode(key, options), '[]'].join('')];
          }
          return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
        };
      case 'colon-list-separator':
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }
          if (value === null) {
            return [...result, [encode(key, options), ':list='].join('')];
          }
          return [...result, [encode(key, options), ':list=', encode(value, options)].join('')];
        };
      case 'comma':
      case 'separator':
      case 'bracket-separator':
        {
          const keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
          return key => (result, value) => {
            if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
              return result;
            }

            // Translate null to an empty string so that it doesn't serialize as 'null'
            value = value === null ? '' : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
      default:
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }
          if (value === null) {
            return [...result, encode(key, options)];
          }
          return [...result, [encode(key, options), '=', encode(value, options)].join('')];
        };
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case 'index':
        return (key, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key);
          key = key.replace(/\[\d*\]$/, '');
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === undefined) {
            accumulator[key] = {};
          }
          accumulator[key][result[1]] = value;
        };
      case 'bracket':
        return (key, value, accumulator) => {
          result = /(\[\])$/.exec(key);
          key = key.replace(/\[\]$/, '');
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === undefined) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case 'colon-list-separator':
        return (key, value, accumulator) => {
          result = /(:list)$/.exec(key);
          key = key.replace(/:list$/, '');
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === undefined) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case 'comma':
      case 'separator':
        return (key, value, accumulator) => {
          const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode(value, options) : value;
          const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
          accumulator[key] = newValue;
        };
      case 'bracket-separator':
        return (key, value, accumulator) => {
          const isArray = /(\[\])$/.test(key);
          key = key.replace(/\[\]$/, '');
          if (!isArray) {
            accumulator[key] = value ? decode(value, options) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map(item => decode(item, options));
          if (accumulator[key] === undefined) {
            accumulator[key] = arrayValue;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], arrayValue);
        };
      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === undefined) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== 'string' || value.length !== 1) {
      throw new TypeError('arrayFormatSeparator must be single character string');
    }
  }
  function encode(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === 'object') {
      return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map(key => input[key]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf('#');
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url) {
    let hash = '';
    const hashStart = url.indexOf('#');
    if (hashStart !== -1) {
      hash = url.slice(hashStart);
    }
    return hash;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf('?');
    if (queryStart === -1) {
      return '';
    }
    return input.slice(queryStart + 1);
  }
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
      value = value.toLowerCase() === 'true';
    }
    return value;
  }
  function parse(query, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ',',
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);

    // Create an object with no prototype
    const ret = Object.create(null);
    if (typeof query !== 'string') {
      return ret;
    }
    query = query.trim().replace(/^[?#&]/, '');
    if (!query) {
      return ret;
    }
    for (const param of query.split('&')) {
      if (param === '') {
        continue;
      }
      let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

      // Missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
      value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
      formatter(decode(key, options), value, ret);
    }
    for (const key of Object.keys(ret)) {
      const value = ret[key];
      if (typeof value === 'object' && value !== null) {
        for (const k of Object.keys(value)) {
          value[k] = parseValue(value[k], options);
        }
      } else {
        ret[key] = parseValue(value, options);
      }
    }
    if (options.sort === false) {
      return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
      const value = ret[key];
      if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
        // Sort object keys, not values
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }
      return result;
    }, Object.create(null));
  }
  exports.extract = extract;
  exports.parse = parse;
  exports.stringify = (object, options) => {
    if (!object) {
      return '';
    }
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ','
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = key => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key of Object.keys(object)) {
      if (!shouldFilter(key)) {
        objectCopy[key] = object[key];
      }
    }
    const keys = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys.sort(options.sort);
    }
    return keys.map(key => {
      const value = object[key];
      if (value === undefined) {
        return '';
      }
      if (value === null) {
        return encode(key, options);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
          return encode(key, options) + '[]';
        }
        return value.reduce(formatter(key), []).join('&');
      }
      return encode(key, options) + '=' + encode(value, options);
    }).filter(x => x.length > 0).join('&');
  };
  exports.parseUrl = (url, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url_, hash] = splitOnFirst(url, '#');
    return Object.assign({
      url: url_.split('?')[0] || '',
      query: parse(extract(url), options)
    }, options && options.parseFragmentIdentifier && hash ? {
      fragmentIdentifier: decode(hash, options)
    } : {});
  };
  exports.stringifyUrl = (object, options) => {
    options = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options);
    const url = removeHash(object.url).split('?')[0] || '';
    const queryFromUrl = exports.extract(object.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, {
      sort: false
    });
    const query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString = exports.stringify(query, options);
    if (queryString) {
      queryString = `?${queryString}`;
    }
    let hash = getHash(object.url);
    if (object.fragmentIdentifier) {
      hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString}${hash}`;
  };
  exports.pick = (input, filter, options) => {
    options = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options);
    const {
      url,
      query,
      fragmentIdentifier
    } = exports.parseUrl(input, options);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter),
      fragmentIdentifier
    }, options);
  };
  exports.exclude = (input, filter, options) => {
    const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);
    return exports.pick(input, exclusionFilter, options);
  };
},300,[301,302,303,304],"node_modules/query-string/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
},301,[],"node_modules/strict-uri-encode/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var token = '%[a-f0-9]{2}';
  var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
  var multiMatcher = new RegExp('(' + token + ')+', 'gi');
  function decodeComponents(components, split) {
    try {
      // Try to decode the entire string first
      return [decodeURIComponent(components.join(''))];
    } catch (err) {
      // Do nothing
    }
    if (components.length === 1) {
      return components;
    }
    split = split || 1;

    // Split the array in 2 parts
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }
  function decode(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher) || [];
      for (var i = 1; i < tokens.length; i++) {
        input = decodeComponents(tokens, i).join('');
        tokens = input.match(singleMatcher) || [];
      }
      return input;
    }
  }
  function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
      '%FE%FF': '\uFFFD\uFFFD',
      '%FF%FE': '\uFFFD\uFFFD'
    };
    var match = multiMatcher.exec(input);
    while (match) {
      try {
        // Decode as big chunks as possible
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode(match[0]);
        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }
      match = multiMatcher.exec(input);
    }

    // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    replaceMap['%C2'] = '\uFFFD';
    var entries = Object.keys(replaceMap);
    for (var i = 0; i < entries.length; i++) {
      // Replace all decoded components
      var key = entries[i];
      input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }
    return input;
  }
  module.exports = function (encodedURI) {
    if (typeof encodedURI !== 'string') {
      throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }
    try {
      encodedURI = encodedURI.replace(/\+/g, ' ');

      // Try the built in decoder first
      return decodeURIComponent(encodedURI);
    } catch (err) {
      // Fallback to a more advanced decoder
      return customDecodeURIComponent(encodedURI);
    }
  };
},302,[],"node_modules/decode-uri-component/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = (string, separator) => {
    if (!(typeof string === 'string' && typeof separator === 'string')) {
      throw new TypeError('Expected the arguments to be of type `string`');
    }
    if (separator === '') {
      return [string];
    }
    const separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
      return [string];
    }
    return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
  };
},303,[],"node_modules/split-on-first/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = function (obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var val = obj[key];
      if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
        ret[key] = val;
      }
    }
    return ret;
  };
},304,[],"node_modules/filter-obj/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Parse a path into an array of parts with information about each segment.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.getPatternParts = getPatternParts;
  function getPatternParts(path) {
    const parts = [];
    let current = {
      segment: ''
    };
    let isRegex = false;
    let isParam = false;
    let regexInnerParens = 0;

    // One extra iteration to add the last character
    for (let i = 0; i <= path.length; i++) {
      const char = path[i];
      if (char != null) {
        current.segment += char;
      }
      if (char === ':') {
        // The segment must start with a colon if it's a param
        if (current.segment === ':') {
          isParam = true;
        } else if (!isRegex) {
          throw new Error(`Encountered ':' in the middle of a segment in path: ${path}`);
        }
      } else if (char === '(') {
        if (isParam) {
          if (isRegex) {
            // The '(' is part of the regex if we're already inside one
            regexInnerParens++;
          } else {
            isRegex = true;
          }
        } else {
          throw new Error(`Encountered '(' without preceding ':' in path: ${path}`);
        }
      } else if (char === ')') {
        if (isParam && isRegex) {
          if (regexInnerParens) {
            // The ')' is part of the regex if we're already inside one
            regexInnerParens--;
            current.regex += char;
          } else {
            isRegex = false;
            isParam = false;
          }
        } else {
          throw new Error(`Encountered ')' without preceding '(' in path: ${path}`);
        }
      } else if (char === '?') {
        if (current.param) {
          isParam = false;
          current.optional = true;
        } else {
          throw new Error(`Encountered '?' without preceding ':' in path: ${path}`);
        }
      } else if (char == null || char === '/' && !isRegex) {
        isParam = false;

        // Remove trailing slash from segment
        current.segment = current.segment.replace(/\/$/, '');
        if (current.segment === '') {
          continue;
        }
        if (current.param) {
          current.param = current.param.replace(/^:/, '');
        }
        if (current.regex) {
          current.regex = current.regex.replace(/^\(/, '').replace(/\)$/, '');
        }
        parts.push(current);
        if (char == null) {
          break;
        }
        current = {
          segment: ''
        };
      }
      if (isRegex) {
        current.regex = current.regex || '';
        current.regex += char;
      }
      if (isParam && !isRegex) {
        current.param = current.param || '';
        current.param += char;
      }
    }
    if (isRegex) {
      throw new Error(`Could not find closing ')' in path: ${path}`);
    }
    const params = parts.map(part => part.param).filter(Boolean);
    for (const [index, param] of params.entries()) {
      if (params.indexOf(param) !== index) {
        throw new Error(`Duplicate param name '${param}' found in path: ${path}`);
      }
    }
    return parts;
  }
},305,[],"node_modules/@react-navigation/core/lib/module/getPatternParts.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.validatePathConfig = validatePathConfig;
  const formatToList = items => Object.entries(items).map(([key, value]) => `- ${key} (${value})`).join('\n');
  function validatePathConfig(config, root = true) {
    const validation = Object.assign({
      path: 'string',
      initialRouteName: 'string',
      screens: 'object'
    }, root ? null : {
      alias: 'array',
      exact: 'boolean',
      stringify: 'object',
      parse: 'object'
    });
    if (typeof config !== 'object' || config === null) {
      throw new Error(`Expected the configuration to be an object, but got ${JSON.stringify(config)}.`);
    }
    const validationErrors = Object.fromEntries(Object.keys(config).map(key => {
      if (key in validation) {
        const type = validation[key];
        // @ts-expect-error: we know the key exists
        const value = config[key];
        if (value !== undefined) {
          if (type === 'array') {
            if (!Array.isArray(value)) {
              return [key, `expected 'Array', got '${typeof value}'`];
            }
          } else if (typeof value !== type) {
            return [key, `expected '${type}', got '${typeof value}'`];
          }
        }
      } else {
        return [key, 'extraneous'];
      }
      return null;
    }).filter(Boolean));
    if (Object.keys(validationErrors).length) {
      throw new Error(`Found invalid properties in the configuration:\n${formatToList(validationErrors)}\n\nYou can only specify the following properties:\n${formatToList(validation)}\n\nIf you want to specify configuration for screens, you need to specify them under a 'screens' property.\n\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`);
    }
    if (root && 'path' in config && typeof config.path === 'string' && config.path.includes(':')) {
      throw new Error(`Found invalid path '${config.path}'. The 'path' in the top-level configuration cannot contain patterns for params.`);
    }
    if ('screens' in config && config.screens) {
      Object.entries(config.screens).forEach(([_, value]) => {
        if (typeof value !== 'string') {
          validatePathConfig(value, false);
        }
      });
    }
  }
},306,[],"node_modules/@react-navigation/core/lib/module/validatePathConfig.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.getStateFromPath = getStateFromPath;
  var _escapeStringRegexp = require(_dependencyMap[0], "escape-string-regexp");
  var escape = _interopDefault(_escapeStringRegexp);
  var _queryString = require(_dependencyMap[1], "query-string");
  var queryString = _interopNamespace(_queryString);
  var _arrayStartsWithJs = require(_dependencyMap[2], "./arrayStartsWith.js");
  var _findFocusedRouteJs = require(_dependencyMap[3], "./findFocusedRoute.js");
  var _getPatternPartsJs = require(_dependencyMap[4], "./getPatternParts.js");
  var _isArrayEqualJs = require(_dependencyMap[5], "./isArrayEqual.js");
  var _validatePathConfigJs = require(_dependencyMap[6], "./validatePathConfig.js");
  /**
   * Utility to parse a path string to initial state object accepted by the container.
   * This is useful for deep linking when we need to handle the incoming URL.
   *
   * @example
   * ```js
   * getStateFromPath(
   *   '/chat/jane/42',
   *   {
   *     screens: {
   *       Chat: {
   *         path: 'chat/:author/:id',
   *         parse: { id: Number }
   *       }
   *     }
   *   }
   * )
   * ```
   * @param path Path string to parse and convert, e.g. /foo/bar?count=42.
   * @param options Extra options to fine-tune how to parse the path.
   */
  function getStateFromPath(path, options) {
    const {
      initialRoutes,
      configs
    } = getConfigResources(options);
    const screens = options?.screens;
    let remaining = path.replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
    .replace(/^\//, '') // Remove extra leading slash
    .replace(/\?.*$/, ''); // Remove query params which we will handle later

    // Make sure there is a trailing slash
    remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;
    const prefix = options?.path?.replace(/^\//, ''); // Remove extra leading slash

    if (prefix) {
      // Make sure there is a trailing slash
      const normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;

      // If the path doesn't start with the prefix, it's not a match
      if (!remaining.startsWith(normalizedPrefix)) {
        return undefined;
      }

      // Remove the prefix from the path
      remaining = remaining.replace(normalizedPrefix, '');
    }
    if (screens === undefined) {
      // When no config is specified, use the path segments as route names
      const routes = remaining.split('/').filter(Boolean).map(segment => {
        const name = decodeURIComponent(segment);
        return {
          name
        };
      });
      if (routes.length) {
        return createNestedStateObject(path, routes, initialRoutes);
      }
      return undefined;
    }
    if (remaining === '/') {
      // We need to add special handling of empty path so navigation to empty path also works
      // When handling empty path, we should only look at the root level config
      const match = configs.find(config => config.segments.join('/') === '');
      if (match) {
        return createNestedStateObject(path, match.routeNames.map(name => ({
          name
        })), initialRoutes, configs);
      }
      return undefined;
    }
    let result;
    let current;

    // We match the whole path against the regex instead of segments
    // This makes sure matches such as wildcard will catch any unmatched routes, even if nested
    const {
      routes,
      remainingPath
    } = matchAgainstConfigs(remaining, configs);
    if (routes !== undefined) {
      // This will always be empty if full path matched
      current = createNestedStateObject(path, routes, initialRoutes, configs);
      remaining = remainingPath;
      result = current;
    }
    if (current == null || result == null) {
      return undefined;
    }
    return result;
  }

  /**
   * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.
   */
  const cachedConfigResources = new WeakMap();
  function getConfigResources(options) {
    if (!options) return prepareConfigResources();
    const cached = cachedConfigResources.get(options);
    if (cached) return cached;
    const resources = prepareConfigResources(options);
    cachedConfigResources.set(options, resources);
    return resources;
  }
  function prepareConfigResources(options) {
    if (options) {
      (0, _validatePathConfigJs.validatePathConfig)(options);
    }
    const initialRoutes = getInitialRoutes(options);
    const configs = getSortedNormalizedConfigs(initialRoutes, options?.screens);
    checkForDuplicatedConfigs(configs);
    const configWithRegexes = getConfigsWithRegexes(configs);
    return {
      initialRoutes,
      configs,
      configWithRegexes
    };
  }
  function getInitialRoutes(options) {
    const initialRoutes = [];
    if (options?.initialRouteName) {
      initialRoutes.push({
        initialRouteName: options.initialRouteName,
        parentScreens: []
      });
    }
    return initialRoutes;
  }
  function getSortedNormalizedConfigs(initialRoutes, screens = {}) {
    // Create a normalized configs array which will be easier to use
    return [].concat(...Object.keys(screens).map(key => createNormalizedConfigs(key, screens, initialRoutes, [], [], []))).sort((a, b) => {
      // Sort config from most specific to least specific:
      // - more segments
      // - static segments
      // - params with regex
      // - regular params
      // - wildcard

      // If 2 patterns are same, move the one with less route names up
      // This is an error state, so it's only useful for consistent error messages
      if ((0, _isArrayEqualJs.isArrayEqual)(a.segments, b.segments)) {
        return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));
      }

      // If one of the patterns starts with the other, it's more exhaustive
      // So move it up
      if ((0, _arrayStartsWithJs.arrayStartsWith)(a.segments, b.segments)) {
        return -1;
      }
      if ((0, _arrayStartsWithJs.arrayStartsWith)(b.segments, a.segments)) {
        return 1;
      }
      for (let i = 0; i < Math.max(a.segments.length, b.segments.length); i++) {
        // if b is longer, b gets higher priority
        if (a.segments[i] == null) {
          return 1;
        }

        // if a is longer, a gets higher priority
        if (b.segments[i] == null) {
          return -1;
        }
        const aWildCard = a.segments[i] === '*';
        const bWildCard = b.segments[i] === '*';
        const aParam = a.segments[i].startsWith(':');
        const bParam = b.segments[i].startsWith(':');
        const aRegex = aParam && a.segments[i].includes('(');
        const bRegex = bParam && b.segments[i].includes('(');

        // if both are wildcard or regex, we compare next component
        if (aWildCard && bWildCard || aRegex && bRegex) {
          continue;
        }

        // if only a is wildcard, b gets higher priority
        if (aWildCard && !bWildCard) {
          return 1;
        }

        // if only b is wildcard, a gets higher priority
        if (bWildCard && !aWildCard) {
          return -1;
        }

        // If only a has a param, b gets higher priority
        if (aParam && !bParam) {
          return 1;
        }

        // If only b has a param, a gets higher priority
        if (bParam && !aParam) {
          return -1;
        }

        // if only a has regex, a gets higher priority
        if (aRegex && !bRegex) {
          return -1;
        }

        // if only b has regex, b gets higher priority
        if (bRegex && !aRegex) {
          return 1;
        }
      }
      return a.segments.length - b.segments.length;
    });
  }
  function checkForDuplicatedConfigs(configs) {
    // Check for duplicate patterns in the config
    configs.reduce((acc, config) => {
      const pattern = config.segments.join('/');
      if (acc[pattern]) {
        const a = acc[pattern].routeNames;
        const b = config.routeNames;

        // It's not a problem if the path string omitted from a inner most screen
        // For example, it's ok if a path resolves to `A > B > C` or `A > B`
        const intersects = a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);
        if (!intersects) {
          throw new Error(`Found conflicting screens with the same pattern. The pattern '${pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);
        }
      }
      return Object.assign(acc, {
        [pattern]: config
      });
    }, {});
  }
  function getConfigsWithRegexes(configs) {
    return configs.map(c => Object.assign({}, c, {
      // Add `$` to the regex to make sure it matches till end of the path and not just beginning
      regex: c.regex ? new RegExp(c.regex.source + '$') : undefined
    }));
  }
  const matchAgainstConfigs = (remaining, configs) => {
    let routes;
    let remainingPath = remaining;

    // Go through all configs, and see if the next path segment matches our regex
    for (const config of configs) {
      if (!config.regex) {
        continue;
      }
      const match = remainingPath.match(config.regex);

      // If our regex matches, we need to extract params from the path
      if (match) {
        routes = config.routeNames.map(routeName => {
          const routeConfig = configs.find(c => {
            // Check matching name AND pattern in case same screen is used at different levels in config
            return c.screen === routeName && (0, _arrayStartsWithJs.arrayStartsWith)(config.segments, c.segments);
          });
          const params = routeConfig && match.groups ? Object.fromEntries(Object.entries(match.groups).map(([key, value]) => {
            const index = Number(key.replace('param_', ''));
            const param = routeConfig.params.find(it => it.index === index);
            if (param?.screen === routeName && param?.name) {
              return [param.name, value];
            }
            return null;
          }).filter(it => it != null).map(([key, value]) => {
            if (value == null) {
              return [key, undefined];
            }
            const decoded = decodeURIComponent(value);
            const parsed = routeConfig.parse?.[key] ? routeConfig.parse[key](decoded) : decoded;
            return [key, parsed];
          })) : undefined;
          if (params && Object.keys(params).length) {
            return {
              name: routeName,
              params
            };
          }
          return {
            name: routeName
          };
        });
        remainingPath = remainingPath.replace(match[0], '');
        break;
      }
    }
    return {
      routes,
      remainingPath
    };
  };
  const createNormalizedConfigs = (screen, routeConfig, initials, paths, parentScreens, routeNames) => {
    const configs = [];
    routeNames.push(screen);
    parentScreens.push(screen);
    const config = routeConfig[screen];
    if (typeof config === 'string') {
      paths.push({
        screen,
        path: config
      });
      configs.push(createConfigItem(screen, [...routeNames], [...paths]));
    } else if (typeof config === 'object') {
      // if an object is specified as the value (e.g. Foo: { ... }),
      // it can have `path` property and
      // it could have `screens` prop which has nested configs
      if (typeof config.path === 'string') {
        if (config.exact && config.path == null) {
          throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \`path: ''\`.`);
        }

        // We should add alias configs after the main config
        // So unless they are more specific, main config will be matched first
        const aliasConfigs = [];
        if (config.alias) {
          for (const alias of config.alias) {
            if (typeof alias === 'string') {
              aliasConfigs.push(createConfigItem(screen, [...routeNames], [...paths, {
                screen,
                path: alias
              }], config.parse));
            } else if (typeof alias === 'object') {
              aliasConfigs.push(createConfigItem(screen, [...routeNames], alias.exact ? [{
                screen,
                path: alias.path
              }] : [...paths, {
                screen,
                path: alias.path
              }], alias.parse));
            }
          }
        }
        if (config.exact) {
          // If it's an exact path, we don't need to keep track of the parent screens
          // So we can clear it
          paths.length = 0;
        }
        paths.push({
          screen,
          path: config.path
        });
        configs.push(createConfigItem(screen, [...routeNames], [...paths], config.parse));
        configs.push(...aliasConfigs);
      }
      if (typeof config !== 'string' && typeof config.path !== 'string' && config.alias?.length) {
        throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`);
      }
      if (config.screens) {
        // property `initialRouteName` without `screens` has no purpose
        if (config.initialRouteName) {
          initials.push({
            initialRouteName: config.initialRouteName,
            parentScreens
          });
        }
        Object.keys(config.screens).forEach(nestedConfig => {
          const result = createNormalizedConfigs(nestedConfig, config.screens, initials, [...paths], [...parentScreens], routeNames);
          configs.push(...result);
        });
      }
    }
    routeNames.pop();
    return configs;
  };
  const createConfigItem = (screen, routeNames, paths, parse) => {
    const parts = [];

    // Parse the path string into parts for easier matching
    for (const {
      screen,
      path
    } of paths) {
      parts.push(...(0, _getPatternPartsJs.getPatternParts)(path).map(part => Object.assign({}, part, {
        screen
      })));
    }
    const regex = parts.length ? new RegExp(`^(${parts.map((it, i) => {
      if (it.param) {
        const reg = it.regex || '[^/]+';
        return `(((?<param_${i}>${reg})\\/)${it.optional ? '?' : ''})`;
      }
      return `${it.segment === '*' ? '.*' : (0, escape.default)(it.segment)}\\/`;
    }).join('')})$`) : undefined;
    const segments = parts.map(it => it.segment);
    const params = parts.map((it, i) => it.param ? {
      index: i,
      screen: it.screen,
      name: it.param
    } : null).filter(it => it != null);
    return {
      screen,
      regex,
      segments,
      params,
      routeNames,
      parse
    };
  };
  const findParseConfigForRoute = (routeName, flatConfig) => {
    for (const config of flatConfig) {
      if (routeName === config.routeNames[config.routeNames.length - 1]) {
        return config.parse;
      }
    }
    return undefined;
  };

  // Try to find an initial route connected with the one passed
  const findInitialRoute = (routeName, parentScreens, initialRoutes) => {
    for (const config of initialRoutes) {
      if (parentScreens.length === config.parentScreens.length) {
        let sameParents = true;
        for (let i = 0; i < parentScreens.length; i++) {
          if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {
            sameParents = false;
            break;
          }
        }
        if (sameParents) {
          return routeName !== config.initialRouteName ? config.initialRouteName : undefined;
        }
      }
    }
    return undefined;
  };

  // returns state object with values depending on whether
  // it is the end of state and if there is initialRoute for this level
  const createStateObject = (initialRoute, route, isEmpty) => {
    if (isEmpty) {
      if (initialRoute) {
        return {
          index: 1,
          routes: [{
            name: initialRoute
          }, route]
        };
      } else {
        return {
          routes: [route]
        };
      }
    } else {
      if (initialRoute) {
        return {
          index: 1,
          routes: [{
            name: initialRoute
          }, Object.assign({}, route, {
            state: {
              routes: []
            }
          })]
        };
      } else {
        return {
          routes: [Object.assign({}, route, {
            state: {
              routes: []
            }
          })]
        };
      }
    }
  };
  const createNestedStateObject = (path, routes, initialRoutes, flatConfig) => {
    let route = routes.shift();
    const parentScreens = [];
    let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
    parentScreens.push(route.name);
    const state = createStateObject(initialRoute, route, routes.length === 0);
    if (routes.length > 0) {
      let nestedState = state;
      while (route = routes.shift()) {
        initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
        const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;
        nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);
        if (routes.length > 0) {
          nestedState = nestedState.routes[nestedStateIndex].state;
        }
        parentScreens.push(route.name);
      }
    }
    route = (0, _findFocusedRouteJs.findFocusedRoute)(state);
    route.path = path.replace(/\/$/, '');
    const params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);
    if (params) {
      route.params = Object.assign({}, route.params, params);
    }
    return state;
  };
  const parseQueryParams = (path, parseConfig) => {
    const query = path.split('?')[1];
    const params = queryString.parse(query);
    if (parseConfig) {
      Object.keys(params).forEach(name => {
        if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {
          params[name] = parseConfig[name](params[name]);
        }
      });
    }
    return Object.keys(params).length ? params : undefined;
  };
},307,[308,300,309,276,305,310,306],"node_modules/@react-navigation/core/lib/module/getStateFromPath.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = string => {
    if (typeof string !== 'string') {
      throw new TypeError('Expected a string');
    }

    // Escape characters with special meaning either inside or outside character sets.
    // Use a simple backslash escape when it’s always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
    return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
  };
},308,[],"node_modules/escape-string-regexp/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Compare two arrays to check if the first array starts with the second array.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.arrayStartsWith = arrayStartsWith;
  function arrayStartsWith(array, start) {
    if (start.length > array.length) {
      return false;
    }
    return start.every((it, index) => it === array[index]);
  }
},309,[],"node_modules/@react-navigation/core/lib/module/arrayStartsWith.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Compare two arrays with primitive values as the content.
   * We need to make sure that both values and order match.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.isArrayEqual = isArrayEqual;
  function isArrayEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (a.length !== b.length) {
      return false;
    }
    return a.every((it, index) => Object.is(it, b[index]));
  }
},310,[],"node_modules/@react-navigation/core/lib/module/isArrayEqual.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "NavigationContext", {
    enumerable: true,
    get: function () {
      return NavigationContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Context which holds the navigation prop for a screen.
   */
  const NavigationContext = /*#__PURE__*/React.createContext(undefined);
},311,[9],"node_modules/@react-navigation/core/lib/module/NavigationContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "NavigationHelpersContext", {
    enumerable: true,
    get: function () {
      return NavigationHelpersContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Context which holds the navigation helpers of the parent navigator.
   * Navigators should use this context in their view component.
   */
  const NavigationHelpersContext = /*#__PURE__*/React.createContext(undefined);
},312,[9],"node_modules/@react-navigation/core/lib/module/NavigationHelpersContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.NavigationIndependentTree = NavigationIndependentTree;
  require(_dependencyMap[0], "react");
  var _NavigationContextJs = require(_dependencyMap[1], "./NavigationContext.js");
  var _NavigationIndependentTreeContextJs = require(_dependencyMap[2], "./NavigationIndependentTreeContext.js");
  var _NavigationRouteContextJs = require(_dependencyMap[3], "./NavigationRouteContext.js");
  var _reactJsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  /**
   * Component to make the child navigation container independent of parent containers.
   */

  function NavigationIndependentTree({
    children
  }) {
    return (/*#__PURE__*/
      // We need to clear any existing contexts for nested independent container to work correctly
      (0, _reactJsxRuntime.jsx)(_NavigationRouteContextJs.NavigationRouteContext.Provider, {
        value: undefined,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationContextJs.NavigationContext.Provider, {
          value: undefined,
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationIndependentTreeContextJs.NavigationIndependentTreeContext.Provider, {
            value: true,
            children: children
          })
        })
      })
    );
  }
},313,[9,311,279,314,274],"node_modules/@react-navigation/core/lib/module/NavigationIndependentTree.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "NavigationRouteContext", {
    enumerable: true,
    get: function () {
      return NavigationRouteContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Context which holds the route prop for a screen.
   */
  const NavigationRouteContext = /*#__PURE__*/React.createContext(undefined);
},314,[9],"node_modules/@react-navigation/core/lib/module/NavigationRouteContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "NavigationMetaContext", {
    enumerable: true,
    get: function () {
      return NavigationMetaContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Context with additional metadata to pass to child navigator in a screen.
   * For example, child native stack to know it's inside native tabs.
   * So it doesn't implement features such as `popToTop` that are handled by native tabs.
   *
   * Consumers should not make any assumptions about the shape of the object.
   * It can be different depending on the navigator and may change without notice.
   * This is not intended to be used by application code.
   */
  const NavigationMetaContext = /*#__PURE__*/React.createContext(undefined);
},315,[9],"node_modules/@react-navigation/core/lib/module/NavigationMetaContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "PreventRemoveContext", {
    enumerable: true,
    get: function () {
      return PreventRemoveContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * A type of an object that have a route key as an object key
   * and a value whether to prevent that route.
   */

  const PreventRemoveContext = /*#__PURE__*/React.createContext(undefined);
},316,[9],"node_modules/@react-navigation/core/lib/module/PreventRemoveContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.PreventRemoveProvider = PreventRemoveProvider;
  var _nanoidNonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _useLatestCallback = require(_dependencyMap[2], "use-latest-callback");
  var useLatestCallback = _interopDefault(_useLatestCallback);
  var _NavigationHelpersContextJs = require(_dependencyMap[3], "./NavigationHelpersContext.js");
  var _NavigationRouteContextJs = require(_dependencyMap[4], "./NavigationRouteContext.js");
  var _PreventRemoveContextJs = require(_dependencyMap[5], "./PreventRemoveContext.js");
  var _reactJsxRuntime = require(_dependencyMap[6], "react/jsx-runtime");
  /**
   * Util function to transform map of prevented routes to a simpler object.
   */
  const transformPreventedRoutes = preventedRoutesMap => {
    const preventedRoutesToTransform = [...preventedRoutesMap.values()];
    const preventedRoutes = preventedRoutesToTransform.reduce((acc, {
      routeKey,
      preventRemove
    }) => {
      acc[routeKey] = {
        preventRemove: acc[routeKey]?.preventRemove || preventRemove
      };
      return acc;
    }, {});
    return preventedRoutes;
  };

  /**
   * Component used for managing which routes have to be prevented from removal in native-stack.
   */
  function PreventRemoveProvider({
    children
  }) {
    const [parentId] = React.useState(() => (0, _nanoidNonSecure.nanoid)());
    const [preventedRoutesMap, setPreventedRoutesMap] = React.useState(() => new Map());
    const navigation = React.useContext(_NavigationHelpersContextJs.NavigationHelpersContext);
    const route = React.useContext(_NavigationRouteContextJs.NavigationRouteContext);
    const preventRemoveContextValue = React.useContext(_PreventRemoveContextJs.PreventRemoveContext);
    // take `setPreventRemove` from parent context - if exist it means we're in a nested context
    const setParentPrevented = preventRemoveContextValue?.setPreventRemove;
    const setPreventRemove = (0, useLatestCallback.default)((id, routeKey, preventRemove) => {
      if (preventRemove && (navigation == null || navigation?.getState().routes.every(route => route.key !== routeKey))) {
        throw new Error(`Couldn't find a route with the key ${routeKey}. Is your component inside NavigationContent?`);
      }
      setPreventedRoutesMap(prevPrevented => {
        // values haven't changed - do nothing
        if (routeKey === prevPrevented.get(id)?.routeKey && preventRemove === prevPrevented.get(id)?.preventRemove) {
          return prevPrevented;
        }
        const nextPrevented = new Map(prevPrevented);
        if (preventRemove) {
          nextPrevented.set(id, {
            routeKey,
            preventRemove
          });
        } else {
          nextPrevented.delete(id);
        }
        return nextPrevented;
      });
    });
    const isPrevented = [...preventedRoutesMap.values()].some(({
      preventRemove
    }) => preventRemove);
    React.useEffect(() => {
      if (route?.key !== undefined && setParentPrevented !== undefined) {
        // when route is defined (and setParentPrevented) it means we're in a nested stack
        // route.key then will be the route key of parent
        setParentPrevented(parentId, route.key, isPrevented);
        return () => {
          setParentPrevented(parentId, route.key, false);
        };
      }
      return;
    }, [parentId, isPrevented, route?.key, setParentPrevented]);
    const value = React.useMemo(() => ({
      setPreventRemove,
      preventedRoutes: transformPreventedRoutes(preventedRoutesMap)
    }), [setPreventRemove, preventedRoutesMap]);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_PreventRemoveContextJs.PreventRemoveContext.Provider, {
      value: value,
      children: children
    });
  }
},317,[260,9,267,312,314,316,274],"node_modules/@react-navigation/core/lib/module/PreventRemoveProvider.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["screen", "if"],
    _excluded2 = ["screens", "groups"],
    _excluded3 = ["if"];
  /**
   * Flatten a type to remove all type alias names, unions etc.
   * This will show a plain object when hovering over the type.
   */
  /**
   * keyof T doesn't work for union types. We can use distributive conditional types instead.
   * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types
   */
  /**
   * We get a union type when using keyof, but we want an intersection instead.
   * https://stackoverflow.com/a/50375286/1665026
   */
  /**
   * Props for a screen component which is rendered by a static navigator.
   * Takes the route params as a generic argument.
   */
  /**
   * Infer the param list from the static navigation config.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.createComponentForStaticNavigation = createComponentForStaticNavigation;
  exports.createPathConfigForStaticNavigation = createPathConfigForStaticNavigation;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _reactIs = require(_dependencyMap[2], "react-is");
  var _useRouteJs = require(_dependencyMap[3], "./useRoute.js");
  var _reactJsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  const MemoizedScreen = /*#__PURE__*/React.memo(({
    component
  }) => {
    const route = (0, _useRouteJs.useRoute)();
    const children = /*#__PURE__*/React.createElement(component, {
      route
    });
    return children;
  });
  MemoizedScreen.displayName = 'Memo(Screen)';
  const getItemsFromScreens = (Screen, screens) => {
    return Object.entries(screens).map(([name, item]) => {
      let component;
      let props = {};
      let useIf;
      let isNavigator = false;
      if ('screen' in item) {
        const {
            screen,
            if: _if
          } = item,
          rest = (0, _objectWithoutPropertiesLoose.default)(item, _excluded);
        useIf = _if;
        props = rest;
        if ((0, _reactIs.isValidElementType)(screen)) {
          component = screen;
        } else if ('config' in screen) {
          isNavigator = true;
          component = createComponentForStaticNavigation(screen, `${name}Navigator`);
        }
      } else if ((0, _reactIs.isValidElementType)(item)) {
        component = item;
      } else if ('config' in item) {
        isNavigator = true;
        component = createComponentForStaticNavigation(item, `${name}Navigator`);
      }
      if (component == null) {
        throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);
      }
      const element = isNavigator ? (/*#__PURE__*/React.createElement(component, {})) : /*#__PURE__*/(0, _reactJsxRuntime.jsx)(MemoizedScreen, {
        component: component
      });
      return () => {
        const shouldRender = useIf == null || useIf();
        if (!shouldRender) {
          return null;
        }
        return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Screen, Object.assign({
          name: name
        }, props, {
          children: () => element
        }), name);
      };
    });
  };

  /**
   * Create a component that renders a navigator based on the static configuration.
   *
   * @param tree Static navigation config.
   * @param displayName Name of the component to be displayed in React DevTools.
   * @returns A component which renders the navigator.
   */
  function createComponentForStaticNavigation(tree, displayName) {
    const {
      Navigator,
      Group,
      Screen,
      config
    } = tree;
    const {
        screens,
        groups
      } = config,
      rest = (0, _objectWithoutPropertiesLoose.default)(config, _excluded2);
    if (screens == null && groups == null) {
      throw new Error("Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.");
    }
    const items = [];

    // Loop through the config to find screens and groups
    // So we add the screens and groups in the same order as they are defined
    for (const key in config) {
      if (key === 'screens' && screens) {
        items.push(...getItemsFromScreens(Screen, screens));
      }
      if (key === 'groups' && groups) {
        items.push(...Object.entries(groups).map(([key, _ref]) => {
          let {
              if: useIf
            } = _ref,
            group = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded3);
          const groupItems = getItemsFromScreens(Screen, group.screens);
          return () => {
            // Call unconditionally since screen configs may contain `useIf` hooks
            const children = groupItems.map(item => item());
            const shouldRender = useIf == null || useIf();
            if (!shouldRender) {
              return null;
            }
            return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Group, Object.assign({
              navigationKey: key
            }, group, {
              children: children
            }), key);
          };
        }));
      }
    }
    const NavigatorComponent = () => {
      const children = items.map(item => item());
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Navigator, Object.assign({}, rest, {
        children: children
      }));
    };
    NavigatorComponent.displayName = displayName;
    return NavigatorComponent;
  }
  /**
   * Create a path config object from a static navigation config for deep linking.
   *
   * @param tree Static navigation config.
   * @param options Additional options from `linking.config`.
   * @param auto Whether to automatically generate paths for leaf screens.
   * @returns Path config object to use in linking config.
   *
   * @example
   * ```js
   * const config = {
   *   screens: {
   *     Home: {
   *       screens: createPathConfigForStaticNavigation(HomeTabs),
   *     },
   *   },
   * };
   * ```
   */
  function createPathConfigForStaticNavigation(tree, options, auto) {
    let initialScreenHasPath = false;
    let initialScreenConfig;
    const createPathConfigForTree = (t, o, skipInitialDetection) => {
      const createPathConfigForScreens = (screens, initialRouteName) => {
        return Object.fromEntries(Object.entries(screens)
        // Re-order to move the initial route to the front
        // This way we can detect the initial route correctly
        .sort(([a], [b]) => {
          if (a === initialRouteName) {
            return -1;
          }
          if (b === initialRouteName) {
            return 1;
          }
          return 0;
        }).map(([key, item]) => {
          const screenConfig = {};
          if ('linking' in item) {
            if (typeof item.linking === 'string') {
              screenConfig.path = item.linking;
            } else {
              Object.assign(screenConfig, item.linking);
            }
            if (typeof screenConfig.path === 'string') {
              screenConfig.path = screenConfig.path.replace(/^\//, '') // Remove extra leading slash
              .replace(/\/$/, ''); // Remove extra trailing slash
            }
          }
          let screens;
          const skipInitialDetectionInChild = skipInitialDetection || screenConfig.path != null && screenConfig.path !== '';
          if ('config' in item) {
            screens = createPathConfigForTree(item, undefined, skipInitialDetectionInChild);
          } else if ('screen' in item && 'config' in item.screen && (item.screen.config.screens || item.screen.config.groups)) {
            screens = createPathConfigForTree(item.screen, undefined, skipInitialDetectionInChild);
          }
          if (screens) {
            screenConfig.screens = screens;
          }
          if (auto && !screenConfig.screens &&
          // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly
          !('linking' in item && item.linking == null)) {
            if (screenConfig.path != null) {
              if (!skipInitialDetection) {
                if (key === initialRouteName && screenConfig.path != null) {
                  initialScreenHasPath = true;
                } else if (screenConfig.path === '') {
                  // We encounter a leaf screen with empty path,
                  // Clear the initial screen config as it's not needed anymore
                  initialScreenConfig = undefined;
                }
              }
            } else {
              if (!skipInitialDetection && initialScreenConfig == null) {
                initialScreenConfig = screenConfig;
              }
              screenConfig.path = key.replace(/([A-Z]+)/g, '-$1').replace(/^-/, '').toLowerCase();
            }
          }
          return [key, screenConfig];
        }).filter(([, screen]) => Object.keys(screen).length > 0));
      };
      const screens = {};

      // Loop through the config to find screens and groups
      // So we add the screens and groups in the same order as they are defined
      for (const key in t.config) {
        if (key === 'screens' && t.config.screens) {
          Object.assign(screens, createPathConfigForScreens(t.config.screens, o?.initialRouteName ?? t.config.initialRouteName));
        }
        if (key === 'groups' && t.config.groups) {
          Object.entries(t.config.groups).forEach(([, group]) => {
            Object.assign(screens, createPathConfigForScreens(group.screens, o?.initialRouteName ?? t.config.initialRouteName));
          });
        }
      }
      if (Object.keys(screens).length === 0) {
        return undefined;
      }
      return screens;
    };
    const screens = createPathConfigForTree(tree, options, false);
    if (auto && initialScreenConfig && !initialScreenHasPath) {
      initialScreenConfig.path = '';
    }
    return screens;
  }
},318,[759,9,319,321,274],"node_modules/@react-navigation/core/lib/module/StaticNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react-is.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-is.development.js");
  }
},319,[10,320],"node_modules/react-is/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function typeOf(object) {
      if ("object" === typeof object && null !== object) {
        var $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            switch (object = object.type, object) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
              case REACT_VIEW_TRANSITION_TYPE:
                return object;
              default:
                switch (object = object && object.$$typeof, object) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                    return object;
                  case REACT_CONSUMER_TYPE:
                    return object;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
      REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
      REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
      REACT_MEMO_TYPE = Symbol.for("react.memo"),
      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
      REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    exports.ContextConsumer = REACT_CONSUMER_TYPE;
    exports.ContextProvider = REACT_CONTEXT_TYPE;
    exports.Element = REACT_ELEMENT_TYPE;
    exports.ForwardRef = REACT_FORWARD_REF_TYPE;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Lazy = REACT_LAZY_TYPE;
    exports.Memo = REACT_MEMO_TYPE;
    exports.Portal = REACT_PORTAL_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
    exports.isContextConsumer = function (object) {
      return typeOf(object) === REACT_CONSUMER_TYPE;
    };
    exports.isContextProvider = function (object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    };
    exports.isElement = function (object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    };
    exports.isForwardRef = function (object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    };
    exports.isFragment = function (object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    };
    exports.isLazy = function (object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    };
    exports.isMemo = function (object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    };
    exports.isPortal = function (object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    };
    exports.isProfiler = function (object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    };
    exports.isStrictMode = function (object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    };
    exports.isSuspense = function (object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    };
    exports.isSuspenseList = function (object) {
      return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
    };
    exports.isValidElementType = function (type) {
      return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? !0 : !1;
    };
    exports.typeOf = typeOf;
  }();
},320,[],"node_modules/react-is/cjs/react-is.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useRoute = useRoute;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _NavigationRouteContextJs = require(_dependencyMap[1], "./NavigationRouteContext.js");
  /**
   * Hook to access the route prop of the parent screen anywhere.
   *
   * @returns Route prop of the parent screen.
   */
  function useRoute() {
    const route = React.useContext(_NavigationRouteContextJs.NavigationRouteContext);
    if (route === undefined) {
      throw new Error("Couldn't find a route object. Is your component inside a screen in a navigator?");
    }
    return route;
  }
},321,[9,314],"node_modules/@react-navigation/core/lib/module/useRoute.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useTheme = useTheme;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _ThemeContextJs = require(_dependencyMap[1], "./ThemeContext.js");
  function useTheme() {
    const theme = React.useContext(_ThemeContextJs.ThemeContext);
    if (theme == null) {
      throw new Error("Couldn't find a theme. Is your component inside NavigationContainer or does it have a theme?");
    }
    return theme;
  }
},322,[9,282],"node_modules/@react-navigation/core/lib/module/theming/useTheme.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "PrivateValueStore", {
    enumerable: true,
    get: function () {
      return PrivateValueStore;
    }
  });
  class PrivateValueStore {}
},323,[],"node_modules/@react-navigation/core/lib/module/types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useFocusEffect = useFocusEffect;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _useNavigationJs = require(_dependencyMap[1], "./useNavigation.js");
  /**
   * Hook to run an effect in a focused screen, similar to `React.useEffect`.
   * This can be used to perform side-effects such as fetching data or subscribing to events.
   * The passed callback should be wrapped in `React.useCallback` to avoid running the effect too often.
   *
   * @param callback Memoized callback containing the effect, should optionally return a cleanup function.
   */
  function useFocusEffect(effect) {
    const navigation = (0, _useNavigationJs.useNavigation)();

    // eslint-disable-next-line prefer-rest-params
    if (arguments[1] !== undefined) {
      const message = "You passed a second argument to 'useFocusEffect', but it only accepts one argument. " + "If you want to pass a dependency array, you can use 'React.useCallback':\n\n" + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    // Your code here\n' + '  }, [depA, depB])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
      console.error(message);
    }
    React.useEffect(() => {
      let isFocused = false;
      let cleanup;
      const callback = () => {
        const destroy = effect();
        if (destroy === undefined || typeof destroy === 'function') {
          return destroy;
        }
        if (process.env.NODE_ENV !== 'production') {
          let message = 'An effect function must not return anything besides a function, which is used for clean-up.';
          if (destroy === null) {
            message += " You returned 'null'. If your effect does not require clean-up, return 'undefined' (or nothing).";
          } else if (typeof destroy.then === 'function') {
            message += "\n\nIt looks like you wrote 'useFocusEffect(async () => ...)' or returned a Promise. " + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    async function fetchData() {\n' + '      // You can await here\n' + '      const response = await MyAPI.getData(someId);\n' + '      // ...\n' + '    }\n\n' + '    fetchData();\n' + '  }, [someId])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
          } else {
            message += ` You returned '${JSON.stringify(destroy)}'.`;
          }
          console.error(message);
        }
      };

      // We need to run the effect on initial render/dep changes if the screen is focused
      if (navigation.isFocused()) {
        cleanup = callback();
        isFocused = true;
      }
      const unsubscribeFocus = navigation.addListener('focus', () => {
        // If callback was already called for focus, avoid calling it again
        // The focus event may also fire on initial render, so we guard against running the effect twice
        if (isFocused) {
          return;
        }
        if (cleanup !== undefined) {
          cleanup();
        }
        cleanup = callback();
        isFocused = true;
      });
      const unsubscribeBlur = navigation.addListener('blur', () => {
        if (cleanup !== undefined) {
          cleanup();
        }
        cleanup = undefined;
        isFocused = false;
      });
      return () => {
        if (cleanup !== undefined) {
          cleanup();
        }
        unsubscribeFocus();
        unsubscribeBlur();
      };
    }, [effect, navigation]);
  }
},324,[9,325],"node_modules/@react-navigation/core/lib/module/useFocusEffect.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useNavigation = useNavigation;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _NavigationContainerRefContextJs = require(_dependencyMap[1], "./NavigationContainerRefContext.js");
  var _NavigationContextJs = require(_dependencyMap[2], "./NavigationContext.js");
  /**
   * Hook to access the navigation prop of the parent screen anywhere.
   *
   * @returns Navigation prop of the parent screen.
   */
  function useNavigation() {
    const root = React.useContext(_NavigationContainerRefContextJs.NavigationContainerRefContext);
    const navigation = React.useContext(_NavigationContextJs.NavigationContext);
    if (navigation === undefined && root === undefined) {
      throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }

    // FIXME: Figure out a better way to do this
    return navigation ?? root;
  }
},325,[9,278,311],"node_modules/@react-navigation/core/lib/module/useNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useIsFocused = useIsFocused;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _useNavigationJs = require(_dependencyMap[1], "./useNavigation.js");
  /**
   * Hook to get the current focus state of the screen. Returns a `true` if screen is focused, otherwise `false`.
   * This can be used if a component needs to render something based on the focus state.
   */
  function useIsFocused() {
    const navigation = (0, _useNavigationJs.useNavigation)();
    const subscribe = React.useCallback(callback => {
      const unsubscribeFocus = navigation.addListener('focus', callback);
      const unsubscribeBlur = navigation.addListener('blur', callback);
      return () => {
        unsubscribeFocus();
        unsubscribeBlur();
      };
    }, [navigation]);
    const value = React.useSyncExternalStore(subscribe, navigation.isFocused, navigation.isFocused);
    return value;
  }
},326,[9,325],"node_modules/@react-navigation/core/lib/module/useIsFocused.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["children", "layout", "screenOptions", "screenLayout", "screenListeners", "UNSTABLE_router"]; // This is to make TypeScript compiler happy
  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useNavigationBuilder = useNavigationBuilder;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationRouters = require(_dependencyMap[1], "@react-navigation/routers");
  var _fastDeepEqual = require(_dependencyMap[2], "fast-deep-equal");
  var deepEqual = _interopDefault(_fastDeepEqual);
  var _react = require(_dependencyMap[3], "react");
  var React = _interopNamespace(_react);
  var _reactIs = require(_dependencyMap[4], "react-is");
  var _useLatestCallback = require(_dependencyMap[5], "use-latest-callback");
  var useLatestCallback = _interopDefault(_useLatestCallback);
  var _deepFreezeJs = require(_dependencyMap[6], "./deepFreeze.js");
  var _GroupJs = require(_dependencyMap[7], "./Group.js");
  var _isArrayEqualJs = require(_dependencyMap[8], "./isArrayEqual.js");
  var _isRecordEqualJs = require(_dependencyMap[9], "./isRecordEqual.js");
  var _NavigationHelpersContextJs = require(_dependencyMap[10], "./NavigationHelpersContext.js");
  var _NavigationMetaContextJs = require(_dependencyMap[11], "./NavigationMetaContext.js");
  var _NavigationRouteContextJs = require(_dependencyMap[12], "./NavigationRouteContext.js");
  var _NavigationStateContextJs = require(_dependencyMap[13], "./NavigationStateContext.js");
  var _PreventRemoveProviderJs = require(_dependencyMap[14], "./PreventRemoveProvider.js");
  var _ScreenJs = require(_dependencyMap[15], "./Screen.js");
  var _typesJs = require(_dependencyMap[16], "./types.js");
  var _UnhandledActionContextJs = require(_dependencyMap[17], "./UnhandledActionContext.js");
  var _useChildListenersJs = require(_dependencyMap[18], "./useChildListeners.js");
  var _useClientLayoutEffectJs = require(_dependencyMap[19], "./useClientLayoutEffect.js");
  var _useComponentJs = require(_dependencyMap[20], "./useComponent.js");
  var _useCurrentRenderJs = require(_dependencyMap[21], "./useCurrentRender.js");
  var _useDescriptorsJs = require(_dependencyMap[22], "./useDescriptors.js");
  var _useEventEmitterJs = require(_dependencyMap[23], "./useEventEmitter.js");
  var _useFocusedListenersChildrenAdapterJs = require(_dependencyMap[24], "./useFocusedListenersChildrenAdapter.js");
  var _useFocusEventsJs = require(_dependencyMap[25], "./useFocusEvents.js");
  var _useKeyedChildListenersJs = require(_dependencyMap[26], "./useKeyedChildListeners.js");
  var _useLazyValueJs = require(_dependencyMap[27], "./useLazyValue.js");
  var _useNavigationHelpersJs = require(_dependencyMap[28], "./useNavigationHelpers.js");
  var _useNavigationStateJs = require(_dependencyMap[29], "./useNavigationState.js");
  var _useOnActionJs = require(_dependencyMap[30], "./useOnAction.js");
  var _useOnGetStateJs = require(_dependencyMap[31], "./useOnGetState.js");
  var _useOnRouteFocusJs = require(_dependencyMap[32], "./useOnRouteFocus.js");
  var _useRegisterNavigatorJs = require(_dependencyMap[33], "./useRegisterNavigator.js");
  var _useScheduleUpdateJs = require(_dependencyMap[34], "./useScheduleUpdate.js");
  var _reactJsxRuntime = require(_dependencyMap[35], "react/jsx-runtime");
  _typesJs.PrivateValueStore;
  const isScreen = child => {
    return child.type === _ScreenJs.Screen;
  };
  const isGroup = child => {
    return child.type === React.Fragment || child.type === _GroupJs.Group;
  };
  const isValidKey = key => key === undefined || typeof key === 'string' && key !== '';

  /**
   * Extract route config object from React children elements.
   *
   * @param children React Elements to extract the config from.
   */
  const getRouteConfigsFromChildren = (children, groupKey, groupOptions, groupLayout) => {
    const configs = React.Children.toArray(children).reduce((acc, child) => {
      if (/*#__PURE__*/React.isValidElement(child)) {
        if (isScreen(child)) {
          // We can only extract the config from `Screen` elements
          // If something else was rendered, it's probably a bug

          if (typeof child.props !== 'object' || child.props === null) {
            throw new Error(`Got an invalid element for screen.`);
          }
          if (typeof child.props.name !== 'string' || child.props.name === '') {
            throw new Error(`Got an invalid name (${JSON.stringify(child.props.name)}) for the screen. It must be a non-empty string.`);
          }
          if (child.props.navigationKey !== undefined && (typeof child.props.navigationKey !== 'string' || child.props.navigationKey === '')) {
            throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the screen '${child.props.name}'. It must be a non-empty string or 'undefined'.`);
          }
          acc.push({
            keys: [groupKey, child.props.navigationKey],
            options: groupOptions,
            layout: groupLayout,
            props: child.props
          });
          return acc;
        }
        if (isGroup(child)) {
          if (!isValidKey(child.props.navigationKey)) {
            throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the group. It must be a non-empty string or 'undefined'.`);
          }

          // When we encounter a fragment or group, we need to dive into its children to extract the configs
          // This is handy to conditionally define a group of screens
          acc.push(...getRouteConfigsFromChildren(child.props.children, child.props.navigationKey,
          // FIXME
          // @ts-expect-error: add validation
          child.type !== _GroupJs.Group ? groupOptions : groupOptions != null ? [...groupOptions, child.props.screenOptions] : [child.props.screenOptions], typeof child.props.screenLayout === 'function' ? child.props.screenLayout : groupLayout));
          return acc;
        }
      }
      throw new Error(`A navigator can only contain 'Screen', 'Group' or 'React.Fragment' as its direct children (found ${ /*#__PURE__*/ /*#__PURE__*/React.isValidElement(child) ? `'${typeof child.type === 'string' ? child.type : child.type?.name}'${child.props != null && typeof child.props === 'object' && 'name' in child.props && child.props?.name ? ` for the screen '${child.props.name}'` : ''}` : typeof child === 'object' ? JSON.stringify(child) : `'${String(child)}'`}). To render this component in the navigator, pass it in the 'component' prop to 'Screen'.`);
    }, []);
    if (process.env.NODE_ENV !== 'production') {
      configs.forEach(config => {
        const {
          name,
          children,
          component,
          getComponent
        } = config.props;
        if (children != null || component !== undefined || getComponent !== undefined) {
          if (children != null && component !== undefined) {
            throw new Error(`Got both 'component' and 'children' props for the screen '${name}'. You must pass only one of them.`);
          }
          if (children != null && getComponent !== undefined) {
            throw new Error(`Got both 'getComponent' and 'children' props for the screen '${name}'. You must pass only one of them.`);
          }
          if (component !== undefined && getComponent !== undefined) {
            throw new Error(`Got both 'component' and 'getComponent' props for the screen '${name}'. You must pass only one of them.`);
          }
          if (children != null && typeof children !== 'function') {
            throw new Error(`Got an invalid value for 'children' prop for the screen '${name}'. It must be a function returning a React Element.`);
          }
          if (component !== undefined && !(0, _reactIs.isValidElementType)(component)) {
            throw new Error(`Got an invalid value for 'component' prop for the screen '${name}'. It must be a valid React Component.`);
          }
          if (getComponent !== undefined && typeof getComponent !== 'function') {
            throw new Error(`Got an invalid value for 'getComponent' prop for the screen '${name}'. It must be a function returning a React Component.`);
          }
          if (typeof component === 'function') {
            if (component.name === 'component') {
              // Inline anonymous functions passed in the `component` prop will have the name of the prop
              // It's relatively safe to assume that it's not a component since it should also have PascalCase name
              // We won't catch all scenarios here, but this should catch a good chunk of incorrect use.
              console.warn(`Looks like you're passing an inline function for 'component' prop for the screen '${name}' (e.g. component={() => <SomeComponent />}). Passing an inline function will cause the component state to be lost on re-render and cause perf issues since it's re-created every render. You can pass the function as children to 'Screen' instead to achieve the desired behaviour.`);
            } else if (/^[a-z]/.test(component.name)) {
              console.warn(`Got a component with the name '${component.name}' for the screen '${name}'. React Components must start with an uppercase letter. If you're passing a regular function and not a component, pass it as children to 'Screen' instead. Otherwise capitalize your component's name.`);
            }
          }
        } else {
          throw new Error(`Couldn't find a 'component', 'getComponent' or 'children' prop for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);
        }
      });
    }
    return configs;
  };
  const getStateFromParams = params => {
    if (params?.state != null) {
      return params.state;
    } else if (typeof params?.screen === 'string' && params?.initial !== false) {
      return {
        routes: [{
          name: params.screen,
          params: params.params,
          path: params.path
        }]
      };
    }
    return undefined;
  };

  /**
   * Hook for building navigators.
   *
   * @param createRouter Factory method which returns router object.
   * @param options Options object containing `children` and additional options for the router.
   * @returns An object containing `state`, `navigation`, `descriptors` objects.
   */
  function useNavigationBuilder(createRouter, options) {
    const navigatorKey = (0, _useRegisterNavigatorJs.useRegisterNavigator)();
    const route = React.useContext(_NavigationRouteContextJs.NavigationRouteContext);
    const {
        children,
        layout,
        screenOptions,
        screenLayout,
        screenListeners,
        UNSTABLE_router
      } = options,
      rest = (0, _objectWithoutPropertiesLoose.default)(options, _excluded);
    const routeConfigs = getRouteConfigsFromChildren(children);
    const router = (0, _useLazyValueJs.useLazyValue)(() => {
      if (rest.initialRouteName != null && routeConfigs.every(config => config.props.name !== rest.initialRouteName)) {
        throw new Error(`Couldn't find a screen named '${rest.initialRouteName}' to use as 'initialRouteName'.`);
      }
      const original = createRouter(rest);
      if (UNSTABLE_router != null) {
        const overrides = UNSTABLE_router(original);
        return Object.assign({}, original, overrides);
      }
      return original;
    });
    const screens = routeConfigs.reduce((acc, config) => {
      if (config.props.name in acc) {
        throw new Error(`A navigator cannot contain multiple 'Screen' components with the same name (found duplicate screen named '${config.props.name}')`);
      }
      acc[config.props.name] = config;
      return acc;
    }, {});
    const routeNames = routeConfigs.map(config => config.props.name);
    const routeKeyList = routeNames.reduce((acc, curr) => {
      acc[curr] = screens[curr].keys.map(key => key ?? '').join(':');
      return acc;
    }, {});
    const routeParamList = routeNames.reduce((acc, curr) => {
      const {
        initialParams
      } = screens[curr].props;
      acc[curr] = initialParams;
      return acc;
    }, {});
    const routeGetIdList = routeNames.reduce((acc, curr) => Object.assign(acc, {
      [curr]: screens[curr].props.getId
    }), {});
    if (!routeNames.length) {
      throw new Error("Couldn't find any screens for the navigator. Have you defined any screens as its children?");
    }
    const isStateValid = React.useCallback(state => state.type === undefined || state.type === router.type, [router.type]);
    const isStateInitialized = React.useCallback(state => state !== undefined && state.stale === false && isStateValid(state), [isStateValid]);
    const doesStateHaveOnlyInvalidRoutes = React.useCallback(state => state.routes.every(r => !routeNames.includes(r.name)), [routeNames]);
    const {
      state: currentState,
      getState: getCurrentState,
      setState: setCurrentState,
      setKey,
      getKey,
      getIsInitial
    } = React.useContext(_NavigationStateContextJs.NavigationStateContext);
    const stateCleanedUp = React.useRef(false);
    const setState = (0, useLatestCallback.default)(state => {
      if (stateCleanedUp.current) {
        // State might have been already cleaned up due to unmount
        // We do not want to expose API allowing to override this
        // This would lead to old data preservation on main navigator unmount
        return;
      }
      setCurrentState(state);
    });
    const [stateBeforeInitialization, initializedState, isFirstStateInitialization] = React.useMemo(() => {
      const initialRouteParamList = routeNames.reduce((acc, curr) => {
        const {
          initialParams
        } = screens[curr].props;
        const initialParamsFromParams = route?.params?.state == null && route?.params?.initial !== false && route?.params?.screen === curr ? route.params.params : undefined;
        acc[curr] = initialParams !== undefined || initialParamsFromParams !== undefined ? Object.assign({}, initialParams, initialParamsFromParams) : undefined;
        return acc;
      }, {});

      // If the current state isn't initialized on first render, we initialize it
      // We also need to re-initialize it if the state passed from parent was changed (maybe due to reset)
      // Otherwise assume that the state was provided as initial state
      // So we need to rehydrate it to make it usable
      if ((currentState === undefined || !isStateValid(currentState)) && route?.params?.state == null && !(typeof route?.params?.screen === 'string' && route?.params?.initial !== false)) {
        return [undefined, router.getInitialState({
          routeNames,
          routeParamList: initialRouteParamList,
          routeGetIdList
        }), true];
      } else {
        const stateFromParams = getStateFromParams(route?.params);
        const stateBeforeInitialization = stateFromParams ?? currentState;
        const hydratedState = router.getRehydratedState(stateBeforeInitialization, {
          routeNames,
          routeParamList: initialRouteParamList,
          routeGetIdList
        });
        if (options.UNSTABLE_routeNamesChangeBehavior === 'lastUnhandled' && doesStateHaveOnlyInvalidRoutes(stateBeforeInitialization)) {
          return [stateBeforeInitialization, hydratedState, true];
        }
        return [undefined, hydratedState, false];
      }
      // We explicitly don't include routeNames, route.params etc. in the dep list
      // below. We want to avoid forcing a new state to be calculated in those cases
      // Instead, we handle changes to these in the nextState code below. Note
      // that some changes to routeConfigs are explicitly ignored, such as changes
      // to initialParams
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [currentState, router, isStateValid]);
    const previousRouteKeyListRef = React.useRef(routeKeyList);
    React.useEffect(() => {
      previousRouteKeyListRef.current = routeKeyList;
    });
    const previousRouteKeyList = previousRouteKeyListRef.current;
    const [unhandledState, setUnhandledState] = React.useState(stateBeforeInitialization);

    // An unhandled state is state that didn't have any valid routes
    // So it was unhandled, i.e. not used for initializing the state
    // It's possible that they were absent due to conditional render
    // Store this state so we can reuse it if the routes change later
    if (options.UNSTABLE_routeNamesChangeBehavior === 'lastUnhandled' && stateBeforeInitialization && unhandledState !== stateBeforeInitialization) {
      setUnhandledState(stateBeforeInitialization);
    }
    let state =
    // If the state isn't initialized, or stale, use the state we initialized instead
    // The state won't update until there's a change needed in the state we have initialized locally
    // So it'll be `undefined` or stale until the first navigation event happens
    isStateInitialized(currentState) ? currentState : initializedState;
    let nextState = state;
    let shouldClearUnhandledState = false;

    // Previously unhandled state is now valid again
    // And current state no longer has any valid routes
    // We should reuse the unhandled state instead of re-calculating the state
    if (unhandledState?.routes.every(r => routeNames.includes(r.name)) && state?.routes.every(r => !routeNames.includes(r.name))) {
      shouldClearUnhandledState = true;
      nextState = router.getRehydratedState(unhandledState, {
        routeNames,
        routeParamList,
        routeGetIdList
      });
    } else if (!(0, _isArrayEqualJs.isArrayEqual)(state.routeNames, routeNames) || !(0, _isRecordEqualJs.isRecordEqual)(routeKeyList, previousRouteKeyList)) {
      // When the list of route names change, the router should handle it to remove invalid routes
      nextState = router.getStateForRouteNamesChange(state, {
        routeNames,
        routeParamList,
        routeGetIdList,
        routeKeyChanges: Object.keys(routeKeyList).filter(name => name in previousRouteKeyList && routeKeyList[name] !== previousRouteKeyList[name])
      });
    }
    const previousNestedParamsRef = React.useRef(route?.params);
    React.useEffect(() => {
      previousNestedParamsRef.current = route?.params;
    }, [route?.params]);
    if (route?.params) {
      const previousParams = previousNestedParamsRef.current;
      let action;
      if (typeof route.params.state === 'object' && route.params.state != null && route.params !== previousParams) {
        if (options.UNSTABLE_routeNamesChangeBehavior === 'lastUnhandled' && doesStateHaveOnlyInvalidRoutes(route.params.state)) {
          if (route.params.state !== unhandledState) {
            setUnhandledState(route.params.state);
          }
        } else {
          // If the route was updated with new state, we should reset to it
          action = _reactNavigationRouters.CommonActions.reset(route.params.state);
        }
      } else if (typeof route.params.screen === 'string' && (route.params.initial === false && isFirstStateInitialization || route.params !== previousParams)) {
        if (options.UNSTABLE_routeNamesChangeBehavior === 'lastUnhandled' && !routeNames.includes(route.params.screen)) {
          const state = getStateFromParams(route.params);
          if (state != null && !(0, deepEqual.default)(state, unhandledState)) {
            setUnhandledState(state);
          }
        } else {
          // If the route was updated with new screen name and/or params, we should navigate there
          action = _reactNavigationRouters.CommonActions.navigate({
            name: route.params.screen,
            params: route.params.params,
            path: route.params.path,
            merge: route.params.merge,
            pop: route.params.pop
          });
        }
      }

      // The update should be limited to current navigator only, so we call the router manually
      const updatedState = action ? router.getStateForAction(nextState, action, {
        routeNames,
        routeParamList,
        routeGetIdList
      }) : null;
      nextState = updatedState !== null ? router.getRehydratedState(updatedState, {
        routeNames,
        routeParamList,
        routeGetIdList
      }) : nextState;
    }
    const shouldUpdate = state !== nextState || typeof route?.params?.state === 'object' || typeof route?.params?.screen === 'string';
    (0, _useScheduleUpdateJs.useScheduleUpdate)(() => {
      if (shouldUpdate) {
        // If the state needs to be updated, we'll schedule an update
        setState(nextState);
        if (shouldClearUnhandledState) {
          setUnhandledState(undefined);
        }
      }
    });

    // The up-to-date state will come in next render, but we don't need to wait for it
    // We can't use the outdated state since the screens have changed, which will cause error due to mismatched config
    // So we override the state object we return to use the latest state as soon as possible
    state = nextState;
    React.useEffect(() => {
      // In strict mode, React will double-invoke effects.
      // So we need to reset the flag if component was not unmounted
      stateCleanedUp.current = false;
      setKey(navigatorKey);
      if (!getIsInitial()) {
        // If it's not initial render, we need to update the state
        // This will make sure that our container gets notifier of state changes due to new mounts
        // This is necessary for proper screen tracking, URL updates etc.
        setState(nextState);
      }
      return () => {
        // We need to clean up state for this navigator on unmount
        if (getCurrentState() !== undefined && getKey() === navigatorKey) {
          setCurrentState(undefined);
          stateCleanedUp.current = true;
        }
      };
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    // In some cases (e.g. route names change), internal state might have changed
    // But it hasn't been committed yet, so hasn't propagated to the sync external store
    // During this time, we need to return the internal state in `getState`
    // Otherwise it can result in inconsistent state during render in children
    // To avoid this, we use a ref for render phase, and immediately clear it on commit
    const stateRef = React.useRef(state);
    stateRef.current = state;
    (0, _useClientLayoutEffectJs.useClientLayoutEffect)(() => {
      stateRef.current = null;
    });
    const getState = (0, useLatestCallback.default)(() => {
      const currentState = getCurrentState();
      return (0, _deepFreezeJs.deepFreeze)(isStateInitialized(currentState) ? currentState : initializedState);
    });
    const emitter = (0, _useEventEmitterJs.useEventEmitter)(e => {
      const routeNames = [];
      let route;
      if (e.target) {
        route = state.routes.find(route => route.key === e.target);
        if (route?.name) {
          routeNames.push(route.name);
        }
      } else {
        route = state.routes[state.index];
        routeNames.push(...Object.keys(screens).filter(name => route?.name === name));
      }
      if (route == null) {
        return;
      }
      const navigation = descriptors[route.key].navigation;
      const listeners = [].concat(
      // Get an array of listeners for all screens + common listeners on navigator
      ...[screenListeners, ...routeNames.map(name => {
        const {
          listeners
        } = screens[name].props;
        return listeners;
      })].map(listeners => {
        const map = typeof listeners === 'function' ? listeners({
          route: route,
          navigation
        }) : listeners;
        return map ? Object.keys(map).filter(type => type === e.type).map(type => map?.[type]) : undefined;
      }))
      // We don't want same listener to be called multiple times for same event
      // So we remove any duplicate functions from the array
      .filter((cb, i, self) => cb && self.lastIndexOf(cb) === i);
      listeners.forEach(listener => listener?.(e));
    });
    (0, _useFocusEventsJs.useFocusEvents)({
      state,
      emitter
    });
    React.useEffect(() => {
      emitter.emit({
        type: 'state',
        data: {
          state
        }
      });
    }, [emitter, state]);
    const {
      listeners: childListeners,
      addListener
    } = (0, _useChildListenersJs.useChildListeners)();
    const {
      keyedListeners,
      addKeyedListener
    } = (0, _useKeyedChildListenersJs.useKeyedChildListeners)();
    const onAction = (0, _useOnActionJs.useOnAction)({
      router,
      getState,
      setState,
      key: route?.key,
      actionListeners: childListeners.action,
      beforeRemoveListeners: keyedListeners.beforeRemove,
      routerConfigOptions: {
        routeNames,
        routeParamList,
        routeGetIdList
      },
      emitter
    });
    const onRouteFocus = (0, _useOnRouteFocusJs.useOnRouteFocus)({
      router,
      key: route?.key,
      getState,
      setState
    });
    const onUnhandledActionParent = React.useContext(_UnhandledActionContextJs.UnhandledActionContext);
    const onUnhandledAction = (0, useLatestCallback.default)(action => {
      if (options.UNSTABLE_routeNamesChangeBehavior === 'lastUnhandled' && action.type === 'NAVIGATE' && action.payload != null && 'name' in action.payload && typeof action.payload.name === 'string' && !routeNames.includes(action.payload.name)) {
        const state = {
          routes: [{
            name: action.payload.name,
            params: 'params' in action.payload && typeof action.payload.params === 'object' && action.payload.params !== null ? action.payload.params : undefined,
            path: 'path' in action.payload && typeof action.payload.path === 'string' ? action.payload.path : undefined
          }]
        };
        setUnhandledState(state);
      }
      onUnhandledActionParent?.(action);
    });
    const navigation = (0, _useNavigationHelpersJs.useNavigationHelpers)({
      id: options.id,
      onAction,
      onUnhandledAction,
      getState,
      emitter,
      router,
      stateRef
    });
    (0, _useFocusedListenersChildrenAdapterJs.useFocusedListenersChildrenAdapter)({
      navigation,
      focusedListeners: childListeners.focus
    });
    (0, _useOnGetStateJs.useOnGetState)({
      getState,
      getStateListeners: keyedListeners.getState
    });
    const {
      describe,
      descriptors
    } = (0, _useDescriptorsJs.useDescriptors)({
      state,
      screens,
      navigation,
      screenOptions,
      screenLayout,
      onAction,
      getState,
      setState,
      onRouteFocus,
      addListener,
      addKeyedListener,
      router,
      // @ts-expect-error: this should have both core and custom events, but too much work right now
      emitter
    });
    (0, _useCurrentRenderJs.useCurrentRender)({
      state,
      navigation,
      descriptors
    });
    const NavigationContent = (0, _useComponentJs.useComponent)(children => {
      const element = layout != null ? layout({
        state,
        descriptors,
        navigation,
        children
      }) : children;
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationMetaContextJs.NavigationMetaContext.Provider, {
        value: undefined,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationHelpersContextJs.NavigationHelpersContext.Provider, {
          value: navigation,
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_useNavigationStateJs.NavigationStateListenerProvider, {
            state: state,
            children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_PreventRemoveProviderJs.PreventRemoveProvider, {
              children: element
            })
          })
        })
      });
    });
    return {
      state,
      navigation,
      describe,
      descriptors,
      NavigationContent
    };
  }
},327,[759,257,328,9,319,267,290,292,310,298,312,315,314,280,317,293,323,283,284,329,330,331,332,285,337,338,286,339,340,341,345,347,348,349,350,274],"node_modules/@react-navigation/core/lib/module/useNavigationBuilder.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  // do not edit .js files directly - edit src/index.jst
  module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      for (i = length; i-- !== 0;) {
        var key = keys[i];
        if (!equal(a[key], b[key])) return false;
      }
      return true;
    }

    // true if both NaN, false otherwise
    return a !== a && b !== b;
  };
},328,[],"node_modules/fast-deep-equal/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "useClientLayoutEffect", {
    enumerable: true,
    get: function () {
      return useClientLayoutEffect;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Use `useEffect` during SSR and `useLayoutEffect` in the Browser & React Native to avoid warnings.
   */
  const useClientLayoutEffect = typeof document !== 'undefined' || typeof navigator !== 'undefined' && navigator.product === 'ReactNative' ? React.useLayoutEffect : React.useEffect;
},329,[9],"node_modules/@react-navigation/core/lib/module/useClientLayoutEffect.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useComponent = useComponent;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _reactJsxRuntime = require(_dependencyMap[1], "react/jsx-runtime");
  const NavigationContent = ({
    render,
    children
  }) => {
    return render(children);
  };
  function useComponent(render) {
    const renderRef = React.useRef(render);

    // Normally refs shouldn't be mutated in render
    // But we return a component which will be rendered
    // So it's just for immediate consumption
    renderRef.current = render;
    React.useEffect(() => {
      renderRef.current = null;
    });
    return React.useRef(({
      children
    }) => {
      const render = renderRef.current;
      if (render === null) {
        throw new Error('The returned component must be rendered in the same render phase as the hook.');
      }
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(NavigationContent, {
        render: render,
        children: children
      });
    }).current;
  }
},330,[9,274],"node_modules/@react-navigation/core/lib/module/useComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useCurrentRender = useCurrentRender;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _CurrentRenderContextJs = require(_dependencyMap[1], "./CurrentRenderContext.js");
  /**
   * Write the current options, so that server renderer can get current values
   * Mutating values like this is not safe in async mode, but it doesn't apply to SSR
   */
  function useCurrentRender({
    state,
    navigation,
    descriptors
  }) {
    const current = React.useContext(_CurrentRenderContextJs.CurrentRenderContext);
    if (current && navigation.isFocused()) {
      current.options = descriptors[state.routes[state.index].key].options;
    }
  }
},331,[9,294],"node_modules/@react-navigation/core/lib/module/useCurrentRender.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useDescriptors = useDescriptors;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _NavigationBuilderContextJs = require(_dependencyMap[2], "./NavigationBuilderContext.js");
  var _NavigationContextJs = require(_dependencyMap[3], "./NavigationContext.js");
  var _NavigationRouteContextJs = require(_dependencyMap[4], "./NavigationRouteContext.js");
  var _SceneViewJs = require(_dependencyMap[5], "./SceneView.js");
  var _themingThemeContextJs = require(_dependencyMap[6], "./theming/ThemeContext.js");
  var _useNavigationCacheJs = require(_dependencyMap[7], "./useNavigationCache.js");
  var _useRouteCacheJs = require(_dependencyMap[8], "./useRouteCache.js");
  var _reactJsxRuntime = require(_dependencyMap[9], "react/jsx-runtime");
  function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
  function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  /**
   * Hook to create descriptor objects for the child routes.
   *
   * A descriptor object provides 3 things:
   * - Helper method to render a screen
   * - Options specified by the screen for the navigator
   * - Navigation object intended for the route
   */
  function useDescriptors({
    state,
    screens,
    navigation,
    screenOptions,
    screenLayout,
    onAction,
    getState,
    setState,
    addListener,
    addKeyedListener,
    onRouteFocus,
    router,
    emitter
  }) {
    const theme = React.useContext(_themingThemeContextJs.ThemeContext);
    const [options, setOptions] = React.useState({});
    const {
      onDispatchAction,
      onOptionsChange,
      scheduleUpdate,
      flushUpdates,
      stackRef
    } = React.useContext(_NavigationBuilderContextJs.NavigationBuilderContext);
    const context = React.useMemo(() => ({
      navigation,
      onAction,
      addListener,
      addKeyedListener,
      onRouteFocus,
      onDispatchAction,
      onOptionsChange,
      scheduleUpdate,
      flushUpdates,
      stackRef
    }), [navigation, onAction, addListener, addKeyedListener, onRouteFocus, onDispatchAction, onOptionsChange, scheduleUpdate, flushUpdates, stackRef]);
    const {
      base,
      navigations
    } = (0, _useNavigationCacheJs.useNavigationCache)({
      state,
      getState,
      navigation,
      setOptions,
      router,
      emitter
    });
    const routes = (0, _useRouteCacheJs.useRouteCache)(state.routes);
    const getOptions = (route, navigation, overrides) => {
      const config = screens[route.name];
      const screen = config.props;
      const optionsList = [
      // The default `screenOptions` passed to the navigator
      screenOptions,
      // The `screenOptions` props passed to `Group` elements
      ...(config.options ? config.options.filter(Boolean) : []),
      // The `options` prop passed to `Screen` elements,
      screen.options,
      // The options set via `navigation.setOptions`
      overrides];
      return optionsList.reduce((acc, curr) => Object.assign(acc,
      // @ts-expect-error: we check for function but TS still complains
      typeof curr !== 'function' ? curr : curr({
        route,
        navigation,
        theme
      })), {});
    };
    const render = (route, navigation, customOptions, routeState) => {
      const config = screens[route.name];
      const screen = config.props;
      const clearOptions = () => setOptions(o => {
        if (route.key in o) {
          var _route$key;
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          const rest = (0, _objectWithoutPropertiesLoose.default)(o, [_route$key].map(_toPropertyKey));
          return rest;
        }
        return o;
      });
      const layout =
      // The `layout` prop passed to `Screen` elements,
      screen.layout ??
      // The `screenLayout` props passed to `Group` elements
      config.layout ??
      // The default `screenLayout` passed to the navigator
      screenLayout;
      let element = /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_SceneViewJs.SceneView, {
        navigation: navigation,
        route: route,
        screen: screen,
        routeState: routeState,
        getState: getState,
        setState: setState,
        options: customOptions,
        clearOptions: clearOptions
      });
      if (layout != null) {
        element = layout({
          route,
          navigation,
          options: customOptions,
          // @ts-expect-error: in practice `theme` will be defined
          theme,
          children: element
        });
      }
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationBuilderContextJs.NavigationBuilderContext.Provider, {
        value: context,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationContextJs.NavigationContext.Provider, {
          value: navigation,
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationRouteContextJs.NavigationRouteContext.Provider, {
            value: route,
            children: element
          })
        })
      }, route.key);
    };
    const descriptors = routes.reduce((acc, route, i) => {
      const navigation = navigations[route.key];
      const customOptions = getOptions(route, navigation, options[route.key]);
      const element = render(route, navigation, customOptions, state.routes[i].state);
      acc[route.key] = {
        route,
        // @ts-expect-error: it's missing action helpers, fix later
        navigation,
        render() {
          return element;
        },
        options: customOptions
      };
      return acc;
    }, {});

    /**
     * Create a descriptor object for a route.
     *
     * @param route Route object for which the descriptor should be created
     * @param placeholder Whether the descriptor should be a placeholder, e.g. for a route not yet in the state
     * @returns Descriptor object
     */
    const describe = (route, placeholder) => {
      if (!placeholder) {
        if (!(route.key in descriptors)) {
          throw new Error(`Couldn't find a route with the key ${route.key}.`);
        }
        return descriptors[route.key];
      }
      const navigation = base;
      const customOptions = getOptions(route, navigation, {});
      const element = render(route, navigation, customOptions, undefined);
      return {
        route,
        navigation,
        render() {
          return element;
        },
        options: customOptions
      };
    };
    return {
      describe,
      descriptors
    };
  }
},332,[759,9,277,311,314,333,282,336,297,274],"node_modules/@react-navigation/core/lib/module/useDescriptors.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["state", "screen", "params", "initial"],
    _excluded2 = ["params"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.SceneView = SceneView;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _EnsureSingleNavigatorJs = require(_dependencyMap[2], "./EnsureSingleNavigator.js");
  var _isArrayEqualJs = require(_dependencyMap[3], "./isArrayEqual.js");
  var _NavigationFocusedRouteStateContextJs = require(_dependencyMap[4], "./NavigationFocusedRouteStateContext.js");
  var _NavigationStateContextJs = require(_dependencyMap[5], "./NavigationStateContext.js");
  var _StaticContainerJs = require(_dependencyMap[6], "./StaticContainer.js");
  var _useOptionsGettersJs = require(_dependencyMap[7], "./useOptionsGetters.js");
  var _reactJsxRuntime = require(_dependencyMap[8], "react/jsx-runtime");
  /**
   * Component which takes care of rendering the screen for a route.
   * It provides all required contexts and applies optimizations when applicable.
   */
  function SceneView({
    screen,
    route,
    navigation,
    routeState,
    getState,
    setState,
    options,
    clearOptions
  }) {
    const navigatorKeyRef = React.useRef(undefined);
    const getKey = React.useCallback(() => navigatorKeyRef.current, []);
    const {
      addOptionsGetter
    } = (0, _useOptionsGettersJs.useOptionsGetters)({
      key: route.key,
      options,
      navigation
    });
    const setKey = React.useCallback(key => {
      navigatorKeyRef.current = key;
    }, []);
    const getCurrentState = React.useCallback(() => {
      const state = getState();
      const currentRoute = state.routes.find(r => r.key === route.key);
      return currentRoute ? currentRoute.state : undefined;
    }, [getState, route.key]);
    const setCurrentState = React.useCallback(child => {
      const state = getState();
      const routes = state.routes.map(r => {
        if (r.key !== route.key) {
          return r;
        }
        const nextRoute = r.state !== child ? Object.assign({}, r, {
          state: child
        }) : r;

        // Before updating the state, cleanup any nested screen and state
        // This will avoid the navigator trying to handle them again
        if (nextRoute.params && ('state' in nextRoute.params && typeof nextRoute.params.state === 'object' && nextRoute.params.state !== null || 'screen' in nextRoute.params && typeof nextRoute.params.screen === 'string')) {
          // @ts-expect-error: we don't have correct type for params
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          const _nextRoute$params = nextRoute.params,
            rest = (0, _objectWithoutPropertiesLoose.default)(_nextRoute$params, _excluded);
          if (Object.keys(rest).length) {
            return Object.assign({}, nextRoute, {
              params: rest
            });
          } else {
            const restRoute = (0, _objectWithoutPropertiesLoose.default)(nextRoute, _excluded2);
            return restRoute;
          }
        }
        return nextRoute;
      });

      // Make sure not to update state if routes haven't changed
      // Otherwise this will result in params cleanup as well
      // We only want to cleanup params when state changes - after they are used
      if (!(0, _isArrayEqualJs.isArrayEqual)(state.routes, routes)) {
        setState(Object.assign({}, state, {
          routes
        }));
      }
    }, [getState, route.key, setState]);
    const isInitialRef = React.useRef(true);
    React.useEffect(() => {
      isInitialRef.current = false;
    });

    // Clear options set by this screen when it is unmounted
    React.useEffect(() => {
      return clearOptions;
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const getIsInitial = React.useCallback(() => isInitialRef.current, []);
    const parentFocusedRouteState = React.useContext(_NavigationFocusedRouteStateContextJs.NavigationFocusedRouteStateContext);
    const focusedRouteState = React.useMemo(() => {
      const state = {
        routes: [{
          key: route.key,
          name: route.name,
          params: route.params,
          path: route.path
        }]
      };

      // Add our state to the innermost route of the parent state
      const addState = parent => {
        const parentRoute = parent?.routes[0];
        if (parentRoute) {
          return {
            routes: [Object.assign({}, parentRoute, {
              state: addState(parentRoute.state)
            })]
          };
        }
        return state;
      };
      return addState(parentFocusedRouteState);
    }, [parentFocusedRouteState, route.key, route.name, route.params, route.path]);
    const context = React.useMemo(() => ({
      state: routeState,
      getState: getCurrentState,
      setState: setCurrentState,
      getKey,
      setKey,
      getIsInitial,
      addOptionsGetter
    }), [routeState, getCurrentState, setCurrentState, getKey, setKey, getIsInitial, addOptionsGetter]);
    const ScreenComponent = screen.getComponent ? screen.getComponent() : screen.component;
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationStateContextJs.NavigationStateContext.Provider, {
      value: context,
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_NavigationFocusedRouteStateContextJs.NavigationFocusedRouteStateContext.Provider, {
        value: focusedRouteState,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_EnsureSingleNavigatorJs.EnsureSingleNavigator, {
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_StaticContainerJs.StaticContainer, {
            name: screen.name,
            render: ScreenComponent || screen.children,
            navigation: navigation,
            route: route,
            children: ScreenComponent !== undefined ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(ScreenComponent, {
              navigation: navigation,
              route: route
            }) : screen.children !== undefined ? screen.children({
              navigation,
              route
            }) : null
          })
        })
      })
    });
  }
},333,[759,9,273,310,334,280,335,288,274],"node_modules/@react-navigation/core/lib/module/SceneView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "NavigationFocusedRouteStateContext", {
    enumerable: true,
    get: function () {
      return NavigationFocusedRouteStateContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Context for the parent route of a navigator.
   */
  const NavigationFocusedRouteStateContext = /*#__PURE__*/React.createContext(undefined);
},334,[9],"node_modules/@react-navigation/core/lib/module/NavigationFocusedRouteStateContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "StaticContainer", {
    enumerable: true,
    get: function () {
      return StaticContainer;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Component which prevents updates for children if no props changed
   */
  const StaticContainer = /*#__PURE__*/React.memo(function StaticContainer(props) {
    return props.children;
  }, (prevProps, nextProps) => {
    const prevPropKeys = Object.keys(prevProps);
    const nextPropKeys = Object.keys(nextProps);
    if (prevPropKeys.length !== nextPropKeys.length) {
      return false;
    }
    for (const key of prevPropKeys) {
      if (key === 'children') {
        continue;
      }
      if (prevProps[key] !== nextProps[key]) {
        return false;
      }
    }
    return true;
  });
},335,[9],"node_modules/@react-navigation/core/lib/module/StaticContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["emit"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useNavigationCache = useNavigationCache;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationRouters = require(_dependencyMap[1], "@react-navigation/routers");
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _NavigationBuilderContextJs = require(_dependencyMap[3], "./NavigationBuilderContext.js");
  /**
   * Hook to cache navigation objects for each screen in the navigator.
   * It's important to cache them to make sure navigation objects don't change between renders.
   * This lets us apply optimizations like `React.memo` to minimize re-rendering screens.
   */
  function useNavigationCache({
    state,
    getState,
    navigation,
    setOptions,
    router,
    emitter
  }) {
    const {
      stackRef
    } = React.useContext(_NavigationBuilderContextJs.NavigationBuilderContext);
    const base = React.useMemo(() => {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const rest = (0, _objectWithoutPropertiesLoose.default)(navigation, _excluded);
      const actions = Object.assign({}, router.actionCreators, _reactNavigationRouters.CommonActions);
      const dispatch = () => {
        throw new Error('Actions cannot be dispatched from a placeholder screen.');
      };
      const helpers = Object.keys(actions).reduce((acc, name) => {
        acc[name] = dispatch;
        return acc;
      }, {});
      return Object.assign({}, rest, helpers, {
        addListener: () => {
          // Event listeners are not supported for placeholder screens

          return () => {
            // Empty function
          };
        },
        removeListener: () => {
          // Event listeners are not supported for placeholder screens
        },
        dispatch,
        getParent: id => {
          if (id !== undefined && id === rest.getId()) {
            return base;
          }
          return rest.getParent(id);
        },
        setOptions: () => {
          throw new Error('Options cannot be set from a placeholder screen.');
        },
        isFocused: () => false
      });
    }, [navigation, router.actionCreators]);

    // Cache object which holds navigation objects for each screen
    // We use `React.useMemo` instead of `React.useRef` coz we want to invalidate it when deps change
    // In reality, these deps will rarely change, if ever
    const cache = React.useMemo(() => ({
      current: {}
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [base, getState, navigation, setOptions, emitter]);
    cache.current = state.routes.reduce((acc, route) => {
      const previous = cache.current[route.key];
      if (previous) {
        // If a cached navigation object already exists, reuse it
        acc[route.key] = previous;
      } else {
        const dispatch = thunk => {
          const action = typeof thunk === 'function' ? thunk(getState()) : thunk;
          if (action != null) {
            navigation.dispatch(Object.assign({
              source: route.key
            }, action));
          }
        };
        const withStack = callback => {
          let isStackSet = false;
          try {
            if (process.env.NODE_ENV !== 'production' && stackRef && !stackRef.current) {
              // Capture the stack trace for devtools
              stackRef.current = new Error().stack;
              isStackSet = true;
            }
            callback();
          } finally {
            if (isStackSet && stackRef) {
              stackRef.current = undefined;
            }
          }
        };
        const actions = Object.assign({}, router.actionCreators, _reactNavigationRouters.CommonActions);
        const helpers = Object.keys(actions).reduce((acc, name) => {
          acc[name] = (...args) => withStack(() =>
          // @ts-expect-error: name is a valid key, but TypeScript is dumb
          dispatch(actions[name](...args)));
          return acc;
        }, {});
        acc[route.key] = Object.assign({}, base, helpers, emitter.create(route.key), {
          dispatch: thunk => withStack(() => dispatch(thunk)),
          getParent: id => {
            if (id !== undefined && id === base.getId()) {
              // If the passed id is the same as the current navigation id,
              // we return the cached navigation object for the relevant route
              return acc[route.key];
            }
            return base.getParent(id);
          },
          setOptions: options => {
            setOptions(o => Object.assign({}, o, {
              [route.key]: Object.assign({}, o[route.key], options)
            }));
          },
          isFocused: () => {
            const state = base.getState();
            if (state.routes[state.index].key !== route.key) {
              return false;
            }

            // If the current screen is focused, we also need to check if parent navigator is focused
            // This makes sure that we return the focus state in the whole tree, not just this navigator
            return navigation ? navigation.isFocused() : true;
          }
        });
      }
      return acc;
    }, {});
    return {
      base,
      navigations: cache.current
    };
  }
},336,[759,257,9,277],"node_modules/@react-navigation/core/lib/module/useNavigationCache.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useFocusedListenersChildrenAdapter = useFocusedListenersChildrenAdapter;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _NavigationBuilderContextJs = require(_dependencyMap[1], "./NavigationBuilderContext.js");
  /**
   * Hook for passing focus callback to children
   */
  function useFocusedListenersChildrenAdapter({
    navigation,
    focusedListeners
  }) {
    const {
      addListener
    } = React.useContext(_NavigationBuilderContextJs.NavigationBuilderContext);
    const listener = React.useCallback(callback => {
      if (navigation.isFocused()) {
        for (const listener of focusedListeners) {
          const {
            handled,
            result
          } = listener(callback);
          if (handled) {
            return {
              handled,
              result
            };
          }
        }
        return {
          handled: true,
          result: callback(navigation)
        };
      } else {
        return {
          handled: false,
          result: null
        };
      }
    }, [focusedListeners, navigation]);
    React.useEffect(() => addListener?.('focus', listener), [addListener, listener]);
  }
},337,[9,277],"node_modules/@react-navigation/core/lib/module/useFocusedListenersChildrenAdapter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useFocusEvents = useFocusEvents;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _NavigationContextJs = require(_dependencyMap[1], "./NavigationContext.js");
  /**
   * Hook to take care of emitting `focus` and `blur` events.
   */
  function useFocusEvents({
    state,
    emitter
  }) {
    const navigation = React.useContext(_NavigationContextJs.NavigationContext);
    const lastFocusedKeyRef = React.useRef(undefined);
    const currentFocusedKey = state.routes[state.index].key;

    // When the parent screen changes its focus state, we also need to change child's focus
    // Coz the child screen can't be focused if the parent screen is out of focus
    React.useEffect(() => navigation?.addListener('focus', () => {
      lastFocusedKeyRef.current = currentFocusedKey;
      emitter.emit({
        type: 'focus',
        target: currentFocusedKey
      });
    }), [currentFocusedKey, emitter, navigation]);
    React.useEffect(() => navigation?.addListener('blur', () => {
      lastFocusedKeyRef.current = undefined;
      emitter.emit({
        type: 'blur',
        target: currentFocusedKey
      });
    }), [currentFocusedKey, emitter, navigation]);
    React.useEffect(() => {
      const lastFocusedKey = lastFocusedKeyRef.current;
      lastFocusedKeyRef.current = currentFocusedKey;

      // We wouldn't have `lastFocusedKey` on initial mount
      // Fire focus event for the current route on mount if there's no parent navigator
      if (lastFocusedKey === undefined && !navigation) {
        emitter.emit({
          type: 'focus',
          target: currentFocusedKey
        });
      }

      // We should only emit events when the focused key changed and navigator is focused
      // When navigator is not focused, screens inside shouldn't receive focused status either
      if (lastFocusedKey === currentFocusedKey || !(navigation ? navigation.isFocused() : true)) {
        return;
      }
      if (lastFocusedKey === undefined) {
        // Only fire events after initial mount
        return;
      }
      emitter.emit({
        type: 'blur',
        target: lastFocusedKey
      });
      emitter.emit({
        type: 'focus',
        target: currentFocusedKey
      });
    }, [currentFocusedKey, emitter, navigation]);
  }
},338,[9,311],"node_modules/@react-navigation/core/lib/module/useFocusEvents.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useLazyValue = useLazyValue;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  function useLazyValue(create) {
    const lazyRef = React.useRef(undefined);
    if (lazyRef.current === undefined) {
      lazyRef.current = create();
    }
    return lazyRef.current;
  }
},339,[9],"node_modules/@react-navigation/core/lib/module/useLazyValue.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useNavigationHelpers = useNavigationHelpers;
  var _reactNavigationRouters = require(_dependencyMap[0], "@react-navigation/routers");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _NavigationContextJs = require(_dependencyMap[2], "./NavigationContext.js");
  var _typesJs = require(_dependencyMap[3], "./types.js");
  // This is to make TypeScript compiler happy
  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
  _typesJs.PrivateValueStore;
  /**
   * Navigation object with helper methods to be used by a navigator.
   * This object includes methods for common actions as well as methods the parent screen's navigation object.
   */
  function useNavigationHelpers({
    id: navigatorId,
    onAction,
    onUnhandledAction,
    getState,
    emitter,
    router,
    stateRef
  }) {
    const parentNavigationHelpers = React.useContext(_NavigationContextJs.NavigationContext);
    return React.useMemo(() => {
      const dispatch = op => {
        const action = typeof op === 'function' ? op(getState()) : op;
        const handled = onAction(action);
        if (!handled) {
          onUnhandledAction?.(action);
        }
      };
      const actions = Object.assign({}, router.actionCreators, _reactNavigationRouters.CommonActions);
      const helpers = Object.keys(actions).reduce((acc, name) => {
        // @ts-expect-error: name is a valid key, but TypeScript is dumb
        acc[name] = (...args) => dispatch(actions[name](...args));
        return acc;
      }, {});
      const navigationHelpers = Object.assign({}, parentNavigationHelpers, helpers, {
        dispatch,
        emit: emitter.emit,
        isFocused: parentNavigationHelpers ? parentNavigationHelpers.isFocused : () => true,
        canGoBack: () => {
          const state = getState();
          return router.getStateForAction(state, _reactNavigationRouters.CommonActions.goBack(), {
            routeNames: state.routeNames,
            routeParamList: {},
            routeGetIdList: {}
          }) !== null || parentNavigationHelpers?.canGoBack() || false;
        },
        getId: () => navigatorId,
        getParent: id => {
          if (id !== undefined) {
            let current = navigationHelpers;
            while (current && id !== current.getId()) {
              current = current.getParent();
            }
            return current;
          }
          return parentNavigationHelpers;
        },
        getState: () => {
          // FIXME: Workaround for when the state is read during render
          // By this time, we haven't committed the new state yet
          // Without this `useSyncExternalStore` will keep reading the old state
          // This may result in `useNavigationState` or `useIsFocused` returning wrong values
          // Apart from `useSyncExternalStore`, `getState` should never be called during render
          if (stateRef.current != null) {
            return stateRef.current;
          }
          return getState();
        }
      });
      return navigationHelpers;
    }, [router, parentNavigationHelpers, emitter.emit, getState, onAction, onUnhandledAction, navigatorId, stateRef]);
  }
},340,[257,9,311,323],"node_modules/@react-navigation/core/lib/module/useNavigationHelpers.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.useNavigationState = useNavigationState;
  exports.NavigationStateListenerProvider = NavigationStateListenerProvider;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _useLatestCallback = require(_dependencyMap[1], "use-latest-callback");
  var useLatestCallback = _interopDefault(_useLatestCallback);
  var _useSyncExternalStoreWithSelector = require(_dependencyMap[2], "use-sync-external-store/with-selector");
  var _reactJsxRuntime = require(_dependencyMap[3], "react/jsx-runtime");
  /**
   * Hook to get a value from the current navigation state using a selector.
   *
   * @param selector Selector function to get a value from the state.
   */
  function useNavigationState(selector) {
    const stateListener = React.useContext(NavigationStateListenerContext);
    if (stateListener == null) {
      throw new Error("Couldn't get the navigation state. Is your component inside a navigator?");
    }
    const value = (0, _useSyncExternalStoreWithSelector.useSyncExternalStoreWithSelector)(stateListener.subscribe,
    // @ts-expect-error: this is unsafe, but needed to make the generic work
    stateListener.getState, stateListener.getState, selector);
    return value;
  }
  function NavigationStateListenerProvider({
    state,
    children
  }) {
    const listeners = React.useRef([]);
    const getState = (0, useLatestCallback.default)(() => state);
    const subscribe = (0, useLatestCallback.default)(callback => {
      listeners.current.push(callback);
      return () => {
        listeners.current = listeners.current.filter(cb => cb !== callback);
      };
    });
    React.useEffect(() => {
      listeners.current.forEach(callback => callback());
    }, [state]);
    const context = React.useMemo(() => ({
      getState,
      subscribe
    }), [getState, subscribe]);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(NavigationStateListenerContext.Provider, {
      value: context,
      children: children
    });
  }
  const NavigationStateListenerContext = /*#__PURE__*/React.createContext(undefined);
},341,[9,267,342,274],"node_modules/@react-navigation/core/lib/module/useNavigationState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/use-sync-external-store-with-selector.production.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/use-sync-external-store-with-selector.development.js");
  }
},342,[343,344],"node_modules/use-sync-external-store/with-selector.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * use-sync-external-store-with-selector.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  var React = require(_dependencyMap[0], "react");
  function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is,
    useSyncExternalStore = React.useSyncExternalStore,
    useRef = React.useRef,
    useEffect = React.useEffect,
    useMemo = React.useMemo,
    useDebugValue = React.useDebugValue;
  exports.useSyncExternalStoreWithSelector = function (subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = {
        hasValue: !1,
        value: null
      };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(function () {
      function memoizedSelector(nextSnapshot) {
        if (!hasMemo) {
          hasMemo = !0;
          memoizedSnapshot = nextSnapshot;
          nextSnapshot = selector(nextSnapshot);
          if (void 0 !== isEqual && inst.hasValue) {
            var currentSelection = inst.value;
            if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
          }
          return memoizedSelection = nextSnapshot;
        }
        currentSelection = memoizedSelection;
        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
        var nextSelection = selector(nextSnapshot);
        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
        memoizedSnapshot = nextSnapshot;
        return memoizedSelection = nextSelection;
      }
      var hasMemo = !1,
        memoizedSnapshot,
        memoizedSelection,
        maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
      return [function () {
        return memoizedSelector(getSnapshot());
      }, null === maybeGetServerSnapshot ? void 0 : function () {
        return memoizedSelector(maybeGetServerSnapshot());
      }];
    }, [getSnapshot, getServerSnapshot, selector, isEqual]);
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(function () {
      inst.hasValue = !0;
      inst.value = value;
    }, [value]);
    useDebugValue(value);
    return value;
  };
},343,[9],"node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.production.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  "production" !== process.env.NODE_ENV && function () {
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = require(_dependencyMap[0], "react"),
      objectIs = "function" === typeof Object.is ? Object.is : is,
      useSyncExternalStore = React.useSyncExternalStore,
      useRef = React.useRef,
      useEffect = React.useEffect,
      useMemo = React.useMemo,
      useDebugValue = React.useDebugValue;
    exports.useSyncExternalStoreWithSelector = function (subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
      var instRef = useRef(null);
      if (null === instRef.current) {
        var inst = {
          hasValue: !1,
          value: null
        };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo(function () {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = !0;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = !1,
          memoizedSnapshot,
          memoizedSelection,
          maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [function () {
          return memoizedSelector(getSnapshot());
        }, null === maybeGetServerSnapshot ? void 0 : function () {
          return memoizedSelector(maybeGetServerSnapshot());
        }];
      }, [getSnapshot, getServerSnapshot, selector, isEqual]);
      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
      useEffect(function () {
        inst.hasValue = !0;
        inst.value = value;
      }, [value]);
      useDebugValue(value);
      return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
},344,[9],"node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useOnAction = useOnAction;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _DeprecatedNavigationInChildContextJs = require(_dependencyMap[1], "./DeprecatedNavigationInChildContext.js");
  var _NavigationBuilderContextJs = require(_dependencyMap[2], "./NavigationBuilderContext.js");
  var _useOnPreventRemoveJs = require(_dependencyMap[3], "./useOnPreventRemove.js");
  /**
   * Hook to handle actions for a navigator, including state updates and bubbling.
   *
   * Bubbling an action is achieved in 2 ways:
   * 1. To bubble action to parent, we expose the action handler in context and then access the parent context
   * 2. To bubble action to child, child adds event listeners subscribing to actions from parent
   *
   * When the action handler handles as action, it returns `true`, otherwise `false`.
   */
  function useOnAction({
    router,
    getState,
    setState,
    key,
    actionListeners,
    beforeRemoveListeners,
    routerConfigOptions,
    emitter
  }) {
    const {
      onAction: onActionParent,
      onRouteFocus: onRouteFocusParent,
      addListener: addListenerParent,
      onDispatchAction
    } = React.useContext(_NavigationBuilderContextJs.NavigationBuilderContext);
    const navigationInChildEnabled = React.useContext(_DeprecatedNavigationInChildContextJs.DeprecatedNavigationInChildContext);
    const routerConfigOptionsRef = React.useRef(routerConfigOptions);
    React.useEffect(() => {
      routerConfigOptionsRef.current = routerConfigOptions;
    });
    const onAction = React.useCallback((action, visitedNavigators = new Set()) => {
      const state = getState();

      // Since actions can bubble both up and down, they could come to the same navigator again
      // We keep track of navigators which have already tried to handle the action and return if it's already visited
      if (visitedNavigators.has(state.key)) {
        return false;
      }
      visitedNavigators.add(state.key);
      if (typeof action.target !== 'string' || action.target === state.key) {
        let result = router.getStateForAction(state, action, routerConfigOptionsRef.current);

        // If a target is specified and set to current navigator, the action shouldn't bubble
        // So instead of `null`, we use the state object for such cases to signal that action was handled
        result = result === null && action.target === state.key ? state : result;
        if (result !== null) {
          onDispatchAction(action, state === result);
          if (state !== result) {
            const isPrevented = (0, _useOnPreventRemoveJs.shouldPreventRemove)(emitter, beforeRemoveListeners, state.routes, result.routes, action);
            if (isPrevented) {
              return true;
            }
            setState(result);
          }
          if (onRouteFocusParent !== undefined) {
            // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree
            // This means we need to focus all of the parent navigators of this navigator as well
            const shouldFocus = router.shouldActionChangeFocus(action);
            if (shouldFocus && key !== undefined) {
              onRouteFocusParent(key);
            }
          }
          return true;
        }
      }
      if (onActionParent !== undefined) {
        // Bubble action to the parent if the current navigator didn't handle it
        if (onActionParent(action, visitedNavigators)) {
          return true;
        }
      }
      if (typeof action.target === 'string' ||
      // For backward compatibility
      action.type === 'NAVIGATE_DEPRECATED' || navigationInChildEnabled) {
        // If the action wasn't handled by current navigator or a parent navigator, let children handle it
        // Handling this when target isn't specified is deprecated and will be removed in the future
        for (let i = actionListeners.length - 1; i >= 0; i--) {
          const listener = actionListeners[i];
          if (listener(action, visitedNavigators)) {
            return true;
          }
        }
      }
      return false;
    }, [actionListeners, beforeRemoveListeners, emitter, getState, navigationInChildEnabled, key, onActionParent, onDispatchAction, onRouteFocusParent, router, setState]);
    (0, _useOnPreventRemoveJs.useOnPreventRemove)({
      getState,
      emitter,
      beforeRemoveListeners
    });
    React.useEffect(() => addListenerParent?.('action', onAction), [addListenerParent, onAction]);
    return onAction;
  }
},345,[9,272,277,346],"node_modules/@react-navigation/core/lib/module/useOnAction.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "shouldPreventRemove", {
    enumerable: true,
    get: function () {
      return shouldPreventRemove;
    }
  });
  exports.useOnPreventRemove = useOnPreventRemove;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _NavigationBuilderContextJs = require(_dependencyMap[1], "./NavigationBuilderContext.js");
  var _NavigationRouteContextJs = require(_dependencyMap[2], "./NavigationRouteContext.js");
  const VISITED_ROUTE_KEYS = Symbol('VISITED_ROUTE_KEYS');
  const shouldPreventRemove = (emitter, beforeRemoveListeners, currentRoutes, nextRoutes, action) => {
    const nextRouteKeys = nextRoutes.map(route => route.key);

    // Call these in reverse order so last screens handle the event first
    const removedRoutes = currentRoutes.filter(route => !nextRouteKeys.includes(route.key)).reverse();
    const visitedRouteKeys =
    // @ts-expect-error: add this property to mark that we've already emitted this action
    action[VISITED_ROUTE_KEYS] ?? new Set();
    const beforeRemoveAction = Object.assign({}, action, {
      [VISITED_ROUTE_KEYS]: visitedRouteKeys
    });
    for (const route of removedRoutes) {
      if (visitedRouteKeys.has(route.key)) {
        // Skip if we've already emitted this action for this screen
        continue;
      }

      // First, we need to check if any child screens want to prevent it
      const isPrevented = beforeRemoveListeners[route.key]?.(beforeRemoveAction);
      if (isPrevented) {
        return true;
      }
      visitedRouteKeys.add(route.key);
      const event = emitter.emit({
        type: 'beforeRemove',
        target: route.key,
        data: {
          action: beforeRemoveAction
        },
        canPreventDefault: true
      });
      if (event.defaultPrevented) {
        return true;
      }
    }
    return false;
  };
  function useOnPreventRemove({
    getState,
    emitter,
    beforeRemoveListeners
  }) {
    const {
      addKeyedListener
    } = React.useContext(_NavigationBuilderContextJs.NavigationBuilderContext);
    const route = React.useContext(_NavigationRouteContextJs.NavigationRouteContext);
    const routeKey = route?.key;
    React.useEffect(() => {
      if (routeKey) {
        return addKeyedListener?.('beforeRemove', routeKey, action => {
          const state = getState();
          return shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, [], action);
        });
      }
    }, [addKeyedListener, beforeRemoveListeners, emitter, getState, routeKey]);
  }
},346,[9,277,314],"node_modules/@react-navigation/core/lib/module/useOnPreventRemove.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useOnGetState = useOnGetState;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _isArrayEqualJs = require(_dependencyMap[1], "./isArrayEqual.js");
  var _NavigationBuilderContextJs = require(_dependencyMap[2], "./NavigationBuilderContext.js");
  var _NavigationRouteContextJs = require(_dependencyMap[3], "./NavigationRouteContext.js");
  function useOnGetState({
    getState,
    getStateListeners
  }) {
    const {
      addKeyedListener
    } = React.useContext(_NavigationBuilderContextJs.NavigationBuilderContext);
    const route = React.useContext(_NavigationRouteContextJs.NavigationRouteContext);
    const key = route ? route.key : 'root';
    const getRehydratedState = React.useCallback(() => {
      const state = getState();

      // Avoid returning new route objects if we don't need to
      const routes = state.routes.map(route => {
        const childState = getStateListeners[route.key]?.();
        if (route.state === childState) {
          return route;
        }
        return Object.assign({}, route, {
          state: childState
        });
      });
      if ((0, _isArrayEqualJs.isArrayEqual)(state.routes, routes)) {
        return state;
      }
      return Object.assign({}, state, {
        routes
      });
    }, [getState, getStateListeners]);
    React.useEffect(() => {
      return addKeyedListener?.('getState', key, getRehydratedState);
    }, [addKeyedListener, getRehydratedState, key]);
  }
},347,[9,310,277,314],"node_modules/@react-navigation/core/lib/module/useOnGetState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useOnRouteFocus = useOnRouteFocus;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _NavigationBuilderContextJs = require(_dependencyMap[1], "./NavigationBuilderContext.js");
  /**
   * Hook to handle focus actions for a route.
   * Focus action needs to be treated specially, coz when a nested route is focused,
   * the parent navigators also needs to be focused.
   */
  function useOnRouteFocus({
    router,
    getState,
    key: sourceRouteKey,
    setState
  }) {
    const {
      onRouteFocus: onRouteFocusParent
    } = React.useContext(_NavigationBuilderContextJs.NavigationBuilderContext);
    return React.useCallback(key => {
      const state = getState();
      const result = router.getStateForRouteFocus(state, key);
      if (result !== state) {
        setState(result);
      }
      if (onRouteFocusParent !== undefined && sourceRouteKey !== undefined) {
        onRouteFocusParent(sourceRouteKey);
      }
    }, [getState, onRouteFocusParent, router, setState, sourceRouteKey]);
  }
},348,[9,277],"node_modules/@react-navigation/core/lib/module/useOnRouteFocus.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useRegisterNavigator = useRegisterNavigator;
  var _nanoidNonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _EnsureSingleNavigatorJs = require(_dependencyMap[2], "./EnsureSingleNavigator.js");
  /**
   * Register a navigator in the parent context (either a navigation container or a screen).
   * This is used to prevent multiple navigators under a single container or screen.
   */
  function useRegisterNavigator() {
    const [key] = React.useState(() => (0, _nanoidNonSecure.nanoid)());
    const container = React.useContext(_EnsureSingleNavigatorJs.SingleNavigatorContext);
    if (container === undefined) {
      throw new Error("Couldn't register the navigator. Have you wrapped your app with 'NavigationContainer'?\n\nThis can also happen if there are multiple copies of '@react-navigation' packages installed.");
    }
    React.useEffect(() => {
      const {
        register,
        unregister
      } = container;
      register(key);
      return () => unregister(key);
    }, [container, key]);
    return key;
  }
},349,[260,9,273],"node_modules/@react-navigation/core/lib/module/useRegisterNavigator.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useScheduleUpdate = useScheduleUpdate;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _NavigationBuilderContextJs = require(_dependencyMap[1], "./NavigationBuilderContext.js");
  var _useClientLayoutEffectJs = require(_dependencyMap[2], "./useClientLayoutEffect.js");
  /**
   * When screen config changes, we want to update the navigator in the same update phase.
   * However, navigation state is in the root component and React won't let us update it from a child.
   * This is a workaround for that, the scheduled update is stored in the ref without actually calling setState.
   * It lets all subsequent updates access the latest state so it stays correct.
   * Then we call setState during after the component updates.
   */
  function useScheduleUpdate(callback) {
    const {
      scheduleUpdate,
      flushUpdates
    } = React.useContext(_NavigationBuilderContextJs.NavigationBuilderContext);

    // FIXME: This is potentially unsafe
    // However, since we are using sync store, it might be fine
    scheduleUpdate(callback);
    (0, _useClientLayoutEffectJs.useClientLayoutEffect)(flushUpdates);
  }
},350,[9,277,329],"node_modules/@react-navigation/core/lib/module/useScheduleUpdate.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useNavigationContainerRef = useNavigationContainerRef;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _createNavigationContainerRefJs = require(_dependencyMap[1], "./createNavigationContainerRef.js");
  function useNavigationContainerRef() {
    const navigation = React.useRef(null);
    if (navigation.current == null) {
      navigation.current = (0, _createNavigationContainerRefJs.createNavigationContainerRef)();
    }
    return navigation.current;
  }
},351,[9,271],"node_modules/@react-navigation/core/lib/module/useNavigationContainerRef.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.usePreventRemove = usePreventRemove;
  var _nanoidNonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _useLatestCallback = require(_dependencyMap[2], "use-latest-callback");
  var useLatestCallback = _interopDefault(_useLatestCallback);
  var _useNavigationJs = require(_dependencyMap[3], "./useNavigation.js");
  var _usePreventRemoveContextJs = require(_dependencyMap[4], "./usePreventRemoveContext.js");
  var _useRouteJs = require(_dependencyMap[5], "./useRoute.js");
  /**
   * Hook to prevent screen from being removed. Can be used to prevent users from leaving the screen.
   *
   * @param preventRemove Boolean indicating whether to prevent screen from being removed.
   * @param callback Function which is executed when screen was prevented from being removed.
   */
  function usePreventRemove(preventRemove, callback) {
    const [id] = React.useState(() => (0, _nanoidNonSecure.nanoid)());
    const navigation = (0, _useNavigationJs.useNavigation)();
    const {
      key: routeKey
    } = (0, _useRouteJs.useRoute)();
    const {
      setPreventRemove
    } = (0, _usePreventRemoveContextJs.usePreventRemoveContext)();
    React.useEffect(() => {
      setPreventRemove(id, routeKey, preventRemove);
      return () => {
        setPreventRemove(id, routeKey, false);
      };
    }, [setPreventRemove, id, routeKey, preventRemove]);
    const beforeRemoveListener = (0, useLatestCallback.default)(e => {
      if (!preventRemove) {
        return;
      }
      e.preventDefault();
      callback({
        data: e.data
      });
    });
    React.useEffect(() => navigation?.addListener('beforeRemove', beforeRemoveListener), [navigation, beforeRemoveListener]);
  }
},352,[260,9,267,325,353,321],"node_modules/@react-navigation/core/lib/module/usePreventRemove.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.usePreventRemoveContext = usePreventRemoveContext;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _PreventRemoveContextJs = require(_dependencyMap[1], "./PreventRemoveContext.js");
  function usePreventRemoveContext() {
    const value = React.useContext(_PreventRemoveContextJs.PreventRemoveContext);
    if (value == null) {
      throw new Error("Couldn't find the prevent remove context. Is your component inside NavigationContent?");
    }
    return value;
  }
},353,[9,316],"node_modules/@react-navigation/core/lib/module/usePreventRemoveContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useStateForPath = useStateForPath;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _NavigationFocusedRouteStateContextJs = require(_dependencyMap[1], "./NavigationFocusedRouteStateContext.js");
  /**
   * Hook to get a minimal state representation for the current route.
   * The returned state can be used with `getPathFromState` to build a path.
   *
   * @returns Minimal state to build a path for the current route.
   */
  function useStateForPath() {
    const state = React.useContext(_NavigationFocusedRouteStateContextJs.NavigationFocusedRouteStateContext);
    return state;
  }
},354,[9,334],"node_modules/@react-navigation/core/lib/module/useStateForPath.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["direction", "theme", "linking", "fallback", "documentTitle", "onReady", "onStateChange"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "NavigationContainer", {
    enumerable: true,
    get: function () {
      return NavigationContainer;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationCore = require(_dependencyMap[1], "@react-navigation/core");
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsI18nManager = require(_dependencyMap[3], "react-native-web/dist/exports/I18nManager");
  var I18nManager = _interopDefault(_reactNativeWebDistExportsI18nManager);
  var _useLatestCallback = require(_dependencyMap[4], "use-latest-callback");
  var useLatestCallback = _interopDefault(_useLatestCallback);
  var _LinkingContextJs = require(_dependencyMap[5], "./LinkingContext.js");
  var _LocaleDirContextJs = require(_dependencyMap[6], "./LocaleDirContext.js");
  var _themingDefaultThemeJs = require(_dependencyMap[7], "./theming/DefaultTheme.js");
  var _UnhandledLinkingContextJs = require(_dependencyMap[8], "./UnhandledLinkingContext.js");
  var _useBackButton = require(_dependencyMap[9], "./useBackButton");
  var _useDocumentTitle = require(_dependencyMap[10], "./useDocumentTitle");
  var _useLinking = require(_dependencyMap[11], "./useLinking");
  var _useThenableJs = require(_dependencyMap[12], "./useThenable.js");
  var _reactJsxRuntime = require(_dependencyMap[13], "react/jsx-runtime");
  globalThis.REACT_NAVIGATION_DEVTOOLS = new WeakMap();
  function NavigationContainerInner(_ref, ref) {
    let {
        direction = I18nManager.default.getConstants().isRTL ? 'rtl' : 'ltr',
        theme = _themingDefaultThemeJs.DefaultTheme,
        linking,
        fallback = null,
        documentTitle,
        onReady,
        onStateChange
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const isLinkingEnabled = linking ? linking.enabled !== false : false;
    if (linking?.config) {
      (0, _reactNavigationCore.validatePathConfig)(linking.config);
    }
    const refContainer = React.useRef(null);
    (0, _useBackButton.useBackButton)(refContainer);
    (0, _useDocumentTitle.useDocumentTitle)(refContainer, documentTitle);
    const [lastUnhandledLink, setLastUnhandledLink] = React.useState();
    const {
      getInitialState
    } = (0, _useLinking.useLinking)(refContainer, Object.assign({
      enabled: isLinkingEnabled,
      prefixes: []
    }, linking), setLastUnhandledLink);
    const linkingContext = React.useMemo(() => ({
      options: linking
    }), [linking]);
    const unhandledLinkingContext = React.useMemo(() => ({
      lastUnhandledLink,
      setLastUnhandledLink
    }), [lastUnhandledLink, setLastUnhandledLink]);
    const onReadyForLinkingHandling = (0, useLatestCallback.default)(() => {
      // If the screen path matches lastUnhandledLink, we do not track it
      const path = refContainer.current?.getCurrentRoute()?.path;
      setLastUnhandledLink(previousLastUnhandledLink => {
        if (previousLastUnhandledLink === path) {
          return undefined;
        }
        return previousLastUnhandledLink;
      });
      onReady?.();
    });
    const onStateChangeForLinkingHandling = (0, useLatestCallback.default)(state => {
      // If the screen path matches lastUnhandledLink, we do not track it
      const path = refContainer.current?.getCurrentRoute()?.path;
      setLastUnhandledLink(previousLastUnhandledLink => {
        if (previousLastUnhandledLink === path) {
          return undefined;
        }
        return previousLastUnhandledLink;
      });
      onStateChange?.(state);
    });
    // Add additional linking related info to the ref
    // This will be used by the devtools
    React.useEffect(() => {
      if (refContainer.current) {
        REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {
          get linking() {
            return Object.assign({}, linking, {
              enabled: isLinkingEnabled,
              prefixes: linking?.prefixes ?? [],
              getStateFromPath: linking?.getStateFromPath ?? _reactNavigationCore.getStateFromPath,
              getPathFromState: linking?.getPathFromState ?? _reactNavigationCore.getPathFromState,
              getActionFromState: linking?.getActionFromState ?? _reactNavigationCore.getActionFromState
            });
          }
        });
      }
    });
    const [isResolved, initialState] = (0, _useThenableJs.useThenable)(getInitialState);

    // FIXME
    // @ts-expect-error not sure why this is not working
    React.useImperativeHandle(ref, () => refContainer.current);
    const isLinkingReady = rest.initialState != null || !isLinkingEnabled || isResolved;
    if (!isLinkingReady) {
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_LocaleDirContextJs.LocaleDirContext.Provider, {
        value: direction,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationCore.ThemeProvider, {
          value: theme,
          children: fallback
        })
      });
    }
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_LocaleDirContextJs.LocaleDirContext.Provider, {
      value: direction,
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_UnhandledLinkingContextJs.UnhandledLinkingContext.Provider, {
        value: unhandledLinkingContext,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_LinkingContextJs.LinkingContext.Provider, {
          value: linkingContext,
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationCore.BaseNavigationContainer, Object.assign({}, rest, {
            theme: theme,
            onReady: onReadyForLinkingHandling,
            onStateChange: onStateChangeForLinkingHandling,
            initialState: rest.initialState == null ? initialState : rest.initialState,
            ref: refContainer
          }))
        })
      })
    });
  }

  /**
   * Container component that manages the navigation state.
   * This should be rendered at the root wrapping the whole app.
   */
  const NavigationContainer = /*#__PURE__*/React.forwardRef(NavigationContainerInner);
},355,[759,255,9,356,267,357,358,359,361,362,363,364,367,274],"node_modules/@react-navigation/native/lib/module/NavigationContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var I18nManager = {
    allowRTL() {
      return;
    },
    forceRTL() {
      return;
    },
    getConstants() {
      return {
        isRTL: false
      };
    }
  };
  var _default = I18nManager;
},356,[],"node_modules/react-native-web/dist/exports/I18nManager/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "LinkingContext", {
    enumerable: true,
    get: function () {
      return LinkingContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  const MISSING_CONTEXT_ERROR = "Couldn't find a LinkingContext context.";
  const LinkingContext = /*#__PURE__*/React.createContext({
    get options() {
      throw new Error(MISSING_CONTEXT_ERROR);
    }
  });
  LinkingContext.displayName = 'LinkingContext';
},357,[9],"node_modules/@react-navigation/native/lib/module/LinkingContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "LocaleDirContext", {
    enumerable: true,
    get: function () {
      return LocaleDirContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  const LocaleDirContext = /*#__PURE__*/React.createContext('ltr');
  LocaleDirContext.displayName = 'LocaleDirContext';
},358,[9],"node_modules/@react-navigation/native/lib/module/LocaleDirContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "DefaultTheme", {
    enumerable: true,
    get: function () {
      return DefaultTheme;
    }
  });
  var _fontsJs = require(_dependencyMap[0], "./fonts.js");
  const DefaultTheme = {
    dark: false,
    colors: {
      primary: 'rgb(0, 122, 255)',
      background: 'rgb(242, 242, 242)',
      card: 'rgb(255, 255, 255)',
      text: 'rgb(28, 28, 30)',
      border: 'rgb(216, 216, 216)',
      notification: 'rgb(255, 59, 48)'
    },
    fonts: _fontsJs.fonts
  };
},359,[360],"node_modules/@react-navigation/native/lib/module/theming/DefaultTheme.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "fonts", {
    enumerable: true,
    get: function () {
      return fonts;
    }
  });
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[0], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  const WEB_FONT_STACK = 'system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"';
  const fonts = Platform.default.select({
    web: {
      regular: {
        fontFamily: WEB_FONT_STACK,
        fontWeight: '400'
      },
      medium: {
        fontFamily: WEB_FONT_STACK,
        fontWeight: '500'
      },
      bold: {
        fontFamily: WEB_FONT_STACK,
        fontWeight: '600'
      },
      heavy: {
        fontFamily: WEB_FONT_STACK,
        fontWeight: '700'
      }
    },
    ios: {
      regular: {
        fontFamily: 'System',
        fontWeight: '400'
      },
      medium: {
        fontFamily: 'System',
        fontWeight: '500'
      },
      bold: {
        fontFamily: 'System',
        fontWeight: '600'
      },
      heavy: {
        fontFamily: 'System',
        fontWeight: '700'
      }
    },
    default: {
      regular: {
        fontFamily: 'sans-serif',
        fontWeight: 'normal'
      },
      medium: {
        fontFamily: 'sans-serif-medium',
        fontWeight: 'normal'
      },
      bold: {
        fontFamily: 'sans-serif',
        fontWeight: '600'
      },
      heavy: {
        fontFamily: 'sans-serif',
        fontWeight: '700'
      }
    }
  });
},360,[14],"node_modules/@react-navigation/native/lib/module/theming/fonts.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "UnhandledLinkingContext", {
    enumerable: true,
    get: function () {
      return UnhandledLinkingContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  const MISSING_CONTEXT_ERROR = "Couldn't find an UnhandledLinkingContext context.";
  const UnhandledLinkingContext = /*#__PURE__*/React.createContext({
    get lastUnhandledLink() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setLastUnhandledLink() {
      throw new Error(MISSING_CONTEXT_ERROR);
    }
  });
  UnhandledLinkingContext.displayName = 'UnhandledLinkingContext';
},361,[9],"node_modules/@react-navigation/native/lib/module/UnhandledLinkingContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.useBackButton = useBackButton;
  function useBackButton(_) {
    // No-op
    // BackHandler is not available on web
  }
},362,[],"node_modules/@react-navigation/native/lib/module/useBackButton.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useDocumentTitle = useDocumentTitle;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Set the document title for the active screen
   */
  function useDocumentTitle(ref, {
    enabled = true,
    formatter = (options, route) => options?.title ?? route?.name
  } = {}) {
    React.useEffect(() => {
      if (!enabled) {
        return;
      }
      const navigation = ref.current;
      if (navigation) {
        const title = formatter(navigation.getCurrentOptions(), navigation.getCurrentRoute());
        document.title = title;
      }
      return navigation?.addListener('options', e => {
        const title = formatter(e.data.options, navigation?.getCurrentRoute());
        document.title = title;
      });
    });
  }
},363,[9],"node_modules/@react-navigation/native/lib/module/useDocumentTitle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "series", {
    enumerable: true,
    get: function () {
      return series;
    }
  });
  exports.useLinking = useLinking;
  var _reactNavigationCore = require(_dependencyMap[0], "@react-navigation/core");
  var _fastDeepEqual = require(_dependencyMap[1], "fast-deep-equal");
  var isEqual = _interopDefault(_fastDeepEqual);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _createMemoryHistoryJs = require(_dependencyMap[3], "./createMemoryHistory.js");
  var _ServerContextJs = require(_dependencyMap[4], "./ServerContext.js");
  /**
   * Find the matching navigation state that changed between 2 navigation states
   * e.g.: a -> b -> c -> d and a -> b -> c -> e -> f, if history in b changed, b is the matching state
   */
  const findMatchingState = (a, b) => {
    if (a === undefined || b === undefined || a.key !== b.key) {
      return [undefined, undefined];
    }

    // Tab and drawer will have `history` property, but stack will have history in `routes`
    const aHistoryLength = a.history ? a.history.length : a.routes.length;
    const bHistoryLength = b.history ? b.history.length : b.routes.length;
    const aRoute = a.routes[a.index];
    const bRoute = b.routes[b.index];
    const aChildState = aRoute.state;
    const bChildState = bRoute.state;

    // Stop here if this is the state object that changed:
    // - history length is different
    // - focused routes are different
    // - one of them doesn't have child state
    // - child state keys are different
    if (aHistoryLength !== bHistoryLength || aRoute.key !== bRoute.key || aChildState === undefined || bChildState === undefined || aChildState.key !== bChildState.key) {
      return [a, b];
    }
    return findMatchingState(aChildState, bChildState);
  };

  /**
   * Run async function in series as it's called.
   */
  const series = cb => {
    let queue = Promise.resolve();
    const callback = () => {
      // eslint-disable-next-line promise/no-callback-in-promise
      queue = queue.then(cb);
    };
    return callback;
  };
  const linkingHandlers = [];
  function useLinking(ref, {
    enabled = true,
    config,
    getStateFromPath = _reactNavigationCore.getStateFromPath,
    getPathFromState = _reactNavigationCore.getPathFromState,
    getActionFromState = _reactNavigationCore.getActionFromState
  }, onUnhandledLinking) {
    const independent = (0, _reactNavigationCore.useNavigationIndependentTree)();
    React.useEffect(() => {
      if (process.env.NODE_ENV === 'production') {
        return undefined;
      }
      if (independent) {
        return undefined;
      }
      if (enabled !== false && linkingHandlers.length) {
        console.error(['Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:', "- You don't have multiple NavigationContainers in the app each with 'linking' enabled", '- Only a single instance of the root component is rendered'].join('\n').trim());
      }
      const handler = Symbol();
      if (enabled !== false) {
        linkingHandlers.push(handler);
      }
      return () => {
        const index = linkingHandlers.indexOf(handler);
        if (index > -1) {
          linkingHandlers.splice(index, 1);
        }
      };
    }, [enabled, independent]);
    const [history] = React.useState(_createMemoryHistoryJs.createMemoryHistory);

    // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners
    // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`
    // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect
    const enabledRef = React.useRef(enabled);
    const configRef = React.useRef(config);
    const getStateFromPathRef = React.useRef(getStateFromPath);
    const getPathFromStateRef = React.useRef(getPathFromState);
    const getActionFromStateRef = React.useRef(getActionFromState);
    React.useEffect(() => {
      enabledRef.current = enabled;
      configRef.current = config;
      getStateFromPathRef.current = getStateFromPath;
      getPathFromStateRef.current = getPathFromState;
      getActionFromStateRef.current = getActionFromState;
    });
    const validateRoutesNotExistInRootState = React.useCallback(state => {
      const navigation = ref.current;
      const rootState = navigation?.getRootState();
      // Make sure that the routes in the state exist in the root navigator
      // Otherwise there's an error in the linking configuration
      return state?.routes.some(r => !rootState?.routeNames.includes(r.name));
    }, [ref]);
    const server = React.useContext(_ServerContextJs.ServerContext);
    const getInitialState = React.useCallback(() => {
      let value;
      if (enabledRef.current) {
        const location = server?.location ?? (typeof window !== 'undefined' ? window.location : undefined);
        const path = location ? location.pathname + location.search : undefined;
        if (path) {
          value = getStateFromPathRef.current(path, configRef.current);
        }

        // If the link were handled, it gets cleared in NavigationContainer
        onUnhandledLinking(path);
      }
      const thenable = {
        then(onfulfilled) {
          return Promise.resolve(onfulfilled ? onfulfilled(value) : value);
        },
        catch() {
          return thenable;
        }
      };
      return thenable;
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const previousIndexRef = React.useRef(undefined);
    const previousStateRef = React.useRef(undefined);
    const pendingPopStatePathRef = React.useRef(undefined);
    React.useEffect(() => {
      previousIndexRef.current = history.index;
      return history.listen(() => {
        const navigation = ref.current;
        if (!navigation || !enabled) {
          return;
        }
        const {
          location
        } = window;
        const path = location.pathname + location.search;
        const index = history.index;
        const previousIndex = previousIndexRef.current ?? 0;
        previousIndexRef.current = index;
        pendingPopStatePathRef.current = path;

        // When browser back/forward is clicked, we first need to check if state object for this index exists
        // If it does we'll reset to that state object
        // Otherwise, we'll handle it like a regular deep link
        const record = history.get(index);
        if (record?.path === path && record?.state) {
          navigation.resetRoot(record.state);
          return;
        }
        const state = getStateFromPathRef.current(path, configRef.current);

        // We should only dispatch an action when going forward
        // Otherwise the action will likely add items to history, which would mess things up
        if (state) {
          // If the link were handled, it gets cleared in NavigationContainer
          onUnhandledLinking(path);
          // Make sure that the routes in the state exist in the root navigator
          // Otherwise there's an error in the linking configuration
          if (validateRoutesNotExistInRootState(state)) {
            return;
          }
          if (index > previousIndex) {
            const action = getActionFromStateRef.current(state, configRef.current);
            if (action !== undefined) {
              try {
                navigation.dispatch(action);
              } catch (e) {
                // Ignore any errors from deep linking.
                // This could happen in case of malformed links, navigation object not being initialized etc.
                console.warn(`An error occurred when trying to handle the link '${path}': ${typeof e === 'object' && e != null && 'message' in e ? e.message : e}`);
              }
            } else {
              navigation.resetRoot(state);
            }
          } else {
            navigation.resetRoot(state);
          }
        } else {
          // if current path didn't return any state, we should revert to initial state
          navigation.resetRoot(state);
        }
      });
    }, [enabled, history, onUnhandledLinking, ref, validateRoutesNotExistInRootState]);
    React.useEffect(() => {
      if (!enabled) {
        return;
      }
      const getPathForRoute = (route, state) => {
        let path;

        // If the `route` object contains a `path`, use that path as long as `route.name` and `params` still match
        // This makes sure that we preserve the original URL for wildcard routes
        if (route?.path) {
          const stateForPath = getStateFromPathRef.current(route.path, configRef.current);
          if (stateForPath) {
            const focusedRoute = (0, _reactNavigationCore.findFocusedRoute)(stateForPath);
            if (focusedRoute && focusedRoute.name === route.name && (0, isEqual.default)(focusedRoute.params, route.params)) {
              path = route.path;
            }
          }
        }
        if (path == null) {
          path = getPathFromStateRef.current(state, configRef.current);
        }
        const previousRoute = previousStateRef.current ? (0, _reactNavigationCore.findFocusedRoute)(previousStateRef.current) : undefined;

        // Preserve the hash if the route didn't change
        if (previousRoute && route && 'key' in previousRoute && 'key' in route && previousRoute.key === route.key) {
          path = path + location.hash;
        }
        return path;
      };
      if (ref.current) {
        // We need to record the current metadata on the first render if they aren't set
        // This will allow the initial state to be in the history entry
        const state = ref.current.getRootState();
        if (state) {
          const route = (0, _reactNavigationCore.findFocusedRoute)(state);
          const path = getPathForRoute(route, state);
          if (previousStateRef.current === undefined) {
            previousStateRef.current = state;
          }
          history.replace({
            path,
            state
          });
        }
      }
      const onStateChange = async () => {
        const navigation = ref.current;
        if (!navigation || !enabled) {
          return;
        }
        const previousState = previousStateRef.current;
        const state = navigation.getRootState();

        // root state may not available, for example when root navigators switch inside the container
        if (!state) {
          return;
        }
        const pendingPath = pendingPopStatePathRef.current;
        const route = (0, _reactNavigationCore.findFocusedRoute)(state);
        const path = getPathForRoute(route, state);
        previousStateRef.current = state;
        pendingPopStatePathRef.current = undefined;

        // To detect the kind of state change, we need to:
        // - Find the common focused navigation state in previous and current state
        // - If only the route keys changed, compare history/routes.length to check if we go back/forward/replace
        // - If no common focused navigation state found, it's a replace
        const [previousFocusedState, focusedState] = findMatchingState(previousState, state);
        if (previousFocusedState && focusedState &&
        // We should only handle push/pop if path changed from what was in last `popstate`
        // Otherwise it's likely a change triggered by `popstate`
        path !== pendingPath) {
          const historyDelta = (focusedState.history ? focusedState.history.length : focusedState.routes.length) - (previousFocusedState.history ? previousFocusedState.history.length : previousFocusedState.routes.length);
          if (historyDelta > 0) {
            // If history length is increased, we should pushState
            // Note that path might not actually change here, for example, drawer open should pushState
            history.push({
              path,
              state
            });
          } else if (historyDelta < 0) {
            // If history length is decreased, i.e. entries were removed, we want to go back

            const nextIndex = history.backIndex({
              path
            });
            const currentIndex = history.index;
            try {
              if (nextIndex !== -1 && nextIndex < currentIndex &&
              // We should only go back if the entry exists and it's less than current index
              history.get(nextIndex)) {
                // An existing entry for this path exists and it's less than current index, go back to that
                await history.go(nextIndex - currentIndex);
              } else {
                // We couldn't find an existing entry to go back to, so we'll go back by the delta
                // This won't be correct if multiple routes were pushed in one go before
                // Usually this shouldn't happen and this is a fallback for that
                await history.go(historyDelta);
              }

              // Store the updated state as well as fix the path if incorrect
              history.replace({
                path,
                state
              });
            } catch (e) {
              // The navigation was interrupted
            }
          } else {
            // If history length is unchanged, we want to replaceState
            history.replace({
              path,
              state
            });
          }
        } else {
          // If no common navigation state was found, assume it's a replace
          // This would happen if the user did a reset/conditionally changed navigators
          history.replace({
            path,
            state
          });
        }
      };

      // We debounce onStateChange coz we don't want multiple state changes to be handled at one time
      // This could happen since `history.go(n)` is asynchronous
      // If `pushState` or `replaceState` were called before `history.go(n)` completes, it'll mess stuff up
      return ref.current?.addListener('state', series(onStateChange));
    }, [enabled, history, ref]);
    return {
      getInitialState
    };
  }
},364,[255,328,9,365,366],"node_modules/@react-navigation/native/lib/module/useLinking.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.createMemoryHistory = createMemoryHistory;
  var _nanoidNonSecure = require(_dependencyMap[0], "nanoid/non-secure");
  function createMemoryHistory() {
    let index = 0;
    let items = [];

    // Pending callbacks for `history.go(n)`
    // We might modify the callback stored if it was interrupted, so we have a ref to identify it
    const pending = [];
    const interrupt = () => {
      // If another history operation was performed we need to interrupt existing ones
      // This makes sure that calls such as `history.replace` after `history.go` don't happen
      // Since otherwise it won't be correct if something else has changed
      pending.forEach(it => {
        const cb = it.cb;
        it.cb = () => cb(true);
      });
    };
    const history = {
      get index() {
        // We store an id in the state instead of an index
        // Index could get out of sync with in-memory values if page reloads
        const id = window.history.state?.id;
        if (id) {
          const index = items.findIndex(item => item.id === id);
          return index > -1 ? index : 0;
        }
        return 0;
      },
      get(index) {
        return items[index];
      },
      backIndex({
        path
      }) {
        // We need to find the index from the element before current to get closest path to go back to
        for (let i = index - 1; i >= 0; i--) {
          const item = items[i];
          if (item.path === path) {
            return i;
          }
        }
        return -1;
      },
      push({
        path,
        state
      }) {
        interrupt();
        const id = (0, _nanoidNonSecure.nanoid)();

        // When a new entry is pushed, all the existing entries after index will be inaccessible
        // So we remove any existing entries after the current index to clean them up
        items = items.slice(0, index + 1);
        items.push({
          path,
          state,
          id
        });
        index = items.length - 1;

        // We pass empty string for title because it's ignored in all browsers except safari
        // We don't store state object in history.state because:
        // - browsers have limits on how big it can be, and we don't control the size
        // - while not recommended, there could be non-serializable data in state
        window.history.pushState({
          id
        }, '', path);
      },
      replace({
        path,
        state
      }) {
        interrupt();
        const id = window.history.state?.id ?? (0, _nanoidNonSecure.nanoid)();

        // Need to keep the hash part of the path if there was no previous history entry
        // or the previous history entry had the same path
        let pathWithHash = path;
        const hash = pathWithHash.includes('#') ? '' : location.hash;
        if (!items.length || items.findIndex(item => item.id === id) < 0) {
          // There are two scenarios for creating an array with only one history record:
          // - When loaded id not found in the items array, this function by default will replace
          //   the first item. We need to keep only the new updated object, otherwise it will break
          //   the page when navigating forward in history.
          // - This is the first time any state modifications are done
          //   So we need to push the entry as there's nothing to replace

          pathWithHash = pathWithHash + hash;
          items = [{
            path: pathWithHash,
            state,
            id
          }];
          index = 0;
        } else {
          if (items[index].path === path) {
            pathWithHash = pathWithHash + hash;
          }
          items[index] = {
            path,
            state,
            id
          };
        }
        window.history.replaceState({
          id
        }, '', pathWithHash);
      },
      // `history.go(n)` is asynchronous, there are couple of things to keep in mind:
      // - it won't do anything if we can't go `n` steps, the `popstate` event won't fire.
      // - each `history.go(n)` call will trigger a separate `popstate` event with correct location.
      // - the `popstate` event fires before the next frame after calling `history.go(n)`.
      // This method differs from `history.go(n)` in the sense that it'll go back as many steps it can.
      go(n) {
        interrupt();

        // To guard against unexpected navigation out of the app we will assume that browser history is only as deep as the length of our memory
        // history. If we don't have an item to navigate to then update our index and navigate as far as we can without taking the user out of the app.
        const nextIndex = index + n;
        const lastItemIndex = items.length - 1;
        if (n < 0 && !items[nextIndex]) {
          // Attempted to navigate beyond the first index. Negating the current index will align the browser history with the first item.
          n = -index;
          index = 0;
        } else if (n > 0 && nextIndex > lastItemIndex) {
          // Attempted to navigate past the last index. Calculate how many indices away from the last index and go there.
          n = lastItemIndex - index;
          index = lastItemIndex;
        } else {
          index = nextIndex;
        }
        if (n === 0) {
          return;
        }

        // When we call `history.go`, `popstate` will fire when there's history to go back to
        // So we need to somehow handle following cases:
        // - There's history to go back, `history.go` is called, and `popstate` fires
        // - `history.go` is called multiple times, we need to resolve on respective `popstate`
        // - No history to go back, but `history.go` was called, browser has no API to detect it
        return new Promise((resolve, reject) => {
          const done = interrupted => {
            clearTimeout(timer);
            if (interrupted) {
              reject(new Error('History was changed during navigation.'));
              return;
            }

            // There seems to be a bug in Chrome regarding updating the title
            // If we set a title just before calling `history.go`, the title gets lost
            // However the value of `document.title` is still what we set it to
            // It's just not displayed in the tab bar
            // To update the tab bar, we need to reset the title to something else first (e.g. '')
            // And set the title to what it was before so it gets applied
            // It won't work without setting it to empty string coz otherwise title isn't changing
            // Which means that the browser won't do anything after setting the title
            const {
              title
            } = window.document;
            window.document.title = '';
            window.document.title = title;
            resolve();
          };
          pending.push({
            ref: done,
            cb: done
          });

          // If navigation didn't happen within 100ms, assume that it won't happen
          // This may not be accurate, but hopefully it won't take so much time
          // In Chrome, navigation seems to happen instantly in next microtask
          // But on Firefox, it seems to take much longer, around 50ms from our testing
          // We're using a hacky timeout since there doesn't seem to be way to know for sure
          const timer = setTimeout(() => {
            const foundIndex = pending.findIndex(it => it.ref === done);
            if (foundIndex > -1) {
              pending[foundIndex].cb();
              pending.splice(foundIndex, 1);
            }
            index = this.index;
          }, 100);
          const onPopState = () => {
            // Fix createMemoryHistory.index variable's value
            // as it may go out of sync when navigating in the browser.
            index = this.index;
            const last = pending.pop();
            window.removeEventListener('popstate', onPopState);
            last?.cb();
          };
          window.addEventListener('popstate', onPopState);
          window.history.go(n);
        });
      },
      // The `popstate` event is triggered when history changes, except `pushState` and `replaceState`
      // If we call `history.go(n)` ourselves, we don't want it to trigger the listener
      // Here we normalize it so that only external changes (e.g. user pressing back/forward) trigger the listener
      listen(listener) {
        const onPopState = () => {
          // Fix createMemoryHistory.index variable's value
          // as it may go out of sync when navigating in the browser.
          index = this.index;
          if (pending.length) {
            // This was triggered by `history.go(n)`, we shouldn't call the listener
            return;
          }
          listener();
        };
        window.addEventListener('popstate', onPopState);
        return () => window.removeEventListener('popstate', onPopState);
      }
    };
    return history;
  }
},365,[260],"node_modules/@react-navigation/native/lib/module/createMemoryHistory.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "ServerContext", {
    enumerable: true,
    get: function () {
      return ServerContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  const ServerContext = /*#__PURE__*/React.createContext(undefined);
},366,[9],"node_modules/@react-navigation/native/lib/module/ServerContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useThenable = useThenable;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  function useThenable(create) {
    const [promise] = React.useState(create);
    let initialState = [false, undefined];

    // Check if our thenable is synchronous
    // eslint-disable-next-line promise/catch-or-return, promise/always-return
    promise.then(result => {
      initialState = [true, result];
    });
    const [state, setState] = React.useState(initialState);
    const [resolved] = state;
    React.useEffect(() => {
      let cancelled = false;
      const resolve = async () => {
        let result;
        try {
          result = await promise;
        } finally {
          if (!cancelled) {
            setState([true, result]);
          }
        }
      };
      if (!resolved) {
        resolve();
      }
      return () => {
        cancelled = true;
      };
    }, [promise, resolved]);
    return state;
  }
},367,[9],"node_modules/@react-navigation/native/lib/module/useThenable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["screen", "params", "action", "href", "style"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.Link = Link;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationCore = require(_dependencyMap[1], "@react-navigation/core");
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[3], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsText = require(_dependencyMap[4], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _useLinkPropsJs = require(_dependencyMap[5], "./useLinkProps.js");
  /**
   * Component to render link to another screen using a path.
   * Uses an anchor tag on the web.
   *
   * @param props.screen Name of the screen to navigate to (e.g. `'Feeds'`).
   * @param props.params Params to pass to the screen to navigate to (e.g. `{ sort: 'hot' }`).
   * @param props.href Optional absolute path to use for the href (e.g. `/feeds/hot`).
   * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.
   * @param props.children Child elements to render the content.
   */
  function Link(_ref) {
    let {
        screen,
        params,
        action,
        href,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const {
      colors,
      fonts
    } = (0, _reactNavigationCore.useTheme)();
    // @ts-expect-error: This is already type-checked by the prop types
    const props = (0, _useLinkPropsJs.useLinkProps)({
      screen,
      params,
      action,
      href
    });
    const onPress = e => {
      if ('onPress' in rest) {
        rest.onPress?.(e);
      }

      // Let user prevent default behavior
      if (!e.defaultPrevented) {
        props.onPress(e);
      }
    };
    return /*#__PURE__*/React.createElement(Text.default, Object.assign({}, props, rest, Platform.default.select({
      web: {
        onClick: onPress
      },
      default: {
        onPress
      }
    }), {
      style: [{
        color: colors.primary
      }, fonts.regular, style]
    }));
  }
},368,[759,255,9,14,138,369],"node_modules/@react-navigation/native/lib/module/Link.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.useLinkProps = useLinkProps;
  var _reactNavigationCore = require(_dependencyMap[0], "@react-navigation/core");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[2], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _LinkingContextJs = require(_dependencyMap[3], "./LinkingContext.js");
  const getStateFromParams = params => {
    if (params?.state) {
      return params.state;
    }
    if (params?.screen) {
      return {
        routes: [{
          name: params.screen,
          params: params.params,
          // @ts-expect-error this is fine 🔥
          state: params.screen ? getStateFromParams(params.params) : undefined
        }]
      };
    }
    return undefined;
  };

  /**
   * Hook to get props for an anchor tag so it can work with in page navigation.
   *
   * @param props.screen Name of the screen to navigate to (e.g. `'Feeds'`).
   * @param props.params Params to pass to the screen to navigate to (e.g. `{ sort: 'hot' }`).
   * @param props.href Optional absolute path to use for the href (e.g. `/feeds/hot`).
   * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.
   */
  function useLinkProps({
    screen,
    params,
    href,
    action
  }) {
    const root = React.useContext(_reactNavigationCore.NavigationContainerRefContext);
    const navigation = React.useContext(_reactNavigationCore.NavigationHelpersContext);
    const {
      options
    } = React.useContext(_LinkingContextJs.LinkingContext);
    const onPress = e => {
      let shouldHandle = false;
      if (Platform.default.OS !== 'web' || !e) {
        e?.preventDefault?.();
        shouldHandle = true;
      } else {
        // ignore clicks with modifier keys
        const hasModifierKey = 'metaKey' in e && e.metaKey || 'altKey' in e && e.altKey || 'ctrlKey' in e && e.ctrlKey || 'shiftKey' in e && e.shiftKey;

        // only handle left clicks
        const isLeftClick = 'button' in e ? e.button == null || e.button === 0 : true;

        // let browser handle "target=_blank" etc.
        const isSelfTarget = e.currentTarget && 'target' in e.currentTarget ? [undefined, null, '', 'self'].includes(e.currentTarget.target) : true;
        if (!hasModifierKey && isLeftClick && isSelfTarget) {
          e.preventDefault?.();
          shouldHandle = true;
        }
      }
      if (shouldHandle) {
        if (action) {
          if (navigation) {
            navigation.dispatch(action);
          } else if (root) {
            root.dispatch(action);
          } else {
            throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
          }
        } else {
          // @ts-expect-error This is already type-checked by the prop types
          navigation?.navigate(screen, params);
        }
      }
    };
    const getPathFromStateHelper = options?.getPathFromState ?? _reactNavigationCore.getPathFromState;
    return {
      href: href ?? (Platform.default.OS === 'web' && screen != null ? getPathFromStateHelper({
        routes: [{
          // @ts-expect-error this is fine 🔥
          name: screen,
          // @ts-expect-error this is fine 🔥
          params: params,
          // @ts-expect-error this is fine 🔥
          state: getStateFromParams(params)
        }]
      }, options?.config) : undefined),
      role: 'link',
      onPress
    };
  }
},369,[255,9,14,357],"node_modules/@react-navigation/native/lib/module/useLinkProps.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "ServerContainer", {
    enumerable: true,
    get: function () {
      return ServerContainer;
    }
  });
  var _reactNavigationCore = require(_dependencyMap[0], "@react-navigation/core");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _ServerContextJs = require(_dependencyMap[2], "./ServerContext.js");
  var _reactJsxRuntime = require(_dependencyMap[3], "react/jsx-runtime");
  /**
   * Container component for server rendering.
   *
   * @param props.location Location object to base the initial URL for SSR.
   * @param props.children Child elements to render the content.
   * @param props.ref Ref object which contains helper methods.
   */
  const ServerContainer = /*#__PURE__*/React.forwardRef(function ServerContainer({
    children,
    location
  }, ref) {
    React.useEffect(() => {
      console.error("'ServerContainer' should only be used on the server with 'react-dom/server' for SSR.");
    }, []);

    // eslint-disable-next-line @eslint-react/no-unstable-context-value
    const current = {};
    if (ref) {
      const value = {
        getCurrentOptions() {
          return current.options;
        }
      };

      // We write to the `ref` during render instead of `React.useImperativeHandle`
      // This is because `useImperativeHandle` will update the ref after 'commit',
      // and there's no 'commit' phase during SSR.
      // Mutating ref during render is unsafe in concurrent mode, but we don't care about it for SSR.
      if (typeof ref === 'function') {
        ref(value);
      } else {
        ref.current = value;
      }
    }
    return (/*#__PURE__*/
      // eslint-disable-next-line @eslint-react/no-unstable-context-value
      (0, _reactJsxRuntime.jsx)(_ServerContextJs.ServerContext.Provider, {
        value: {
          location
        },
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationCore.CurrentRenderContext.Provider, {
          value: current,
          children: children
        })
      })
    );
  });
},370,[255,9,366,274],"node_modules/@react-navigation/native/lib/module/ServerContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "DarkTheme", {
    enumerable: true,
    get: function () {
      return DarkTheme;
    }
  });
  var _fontsJs = require(_dependencyMap[0], "./fonts.js");
  const DarkTheme = {
    dark: true,
    colors: {
      primary: 'rgb(10, 132, 255)',
      background: 'rgb(1, 1, 1)',
      card: 'rgb(18, 18, 18)',
      text: 'rgb(229, 229, 231)',
      border: 'rgb(39, 39, 41)',
      notification: 'rgb(255, 69, 58)'
    },
    fonts: _fontsJs.fonts
  };
},371,[360],"node_modules/@react-navigation/native/lib/module/theming/DarkTheme.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},372,[],"node_modules/@react-navigation/native/lib/module/types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useBuildHref = useBuildHref;
  Object.defineProperty(exports, "useBuildAction", {
    enumerable: true,
    get: function () {
      return useBuildAction;
    }
  });
  exports.useLinkBuilder = useLinkBuilder;
  var _reactNavigationCore = require(_dependencyMap[0], "@react-navigation/core");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _LinkingContextJs = require(_dependencyMap[2], "./LinkingContext.js");
  /**
   * Helper to build a href for a screen based on the linking options.
   */
  function useBuildHref() {
    const navigation = React.useContext(_reactNavigationCore.NavigationHelpersContext);
    const route = React.useContext(_reactNavigationCore.NavigationRouteContext);
    const {
      options
    } = React.useContext(_LinkingContextJs.LinkingContext);
    const focusedRouteState = (0, _reactNavigationCore.useStateForPath)();
    const getPathFromStateHelper = options?.getPathFromState ?? _reactNavigationCore.getPathFromState;
    const buildHref = React.useCallback((name, params) => {
      if (options?.enabled === false) {
        return undefined;
      }

      // Check that we're inside:
      // - navigator's context
      // - route context of the navigator (could be a screen, tab, etc.)
      // - route matches the state for path (from the screen's context)
      // This ensures that we're inside a screen
      const isScreen = navigation && route?.key && focusedRouteState ? route.key === (0, _reactNavigationCore.findFocusedRoute)(focusedRouteState)?.key && navigation.getState().routes.some(r => r.key === route.key) : false;
      const stateForRoute = {
        routes: [{
          name,
          params
        }]
      };
      const constructState = state => {
        if (state) {
          const route = state.routes[0];

          // If we're inside a screen and at the innermost route
          // We need to replace the state with the provided one
          // This assumes that we're navigating to a sibling route
          if (isScreen && !route.state) {
            return stateForRoute;
          }

          // Otherwise, dive into the nested state of the route
          return {
            routes: [Object.assign({}, route, {
              state: constructState(route.state)
            })]
          };
        }

        // Once there is no more nested state, we're at the innermost route
        // We can add a state based on provided parameters
        // This assumes that we're navigating to a child of this route
        // In this case, the helper is used in a navigator for its routes
        return stateForRoute;
      };
      const state = constructState(focusedRouteState);
      const path = getPathFromStateHelper(state, options?.config);
      return path;
    }, [options?.enabled, options?.config, route?.key, navigation, focusedRouteState, getPathFromStateHelper]);
    return buildHref;
  }

  /**
   * Helper to build a navigation action from a href based on the linking options.
   */
  const useBuildAction = () => {
    const {
      options
    } = React.useContext(_LinkingContextJs.LinkingContext);
    const getStateFromPathHelper = options?.getStateFromPath ?? _reactNavigationCore.getStateFromPath;
    const getActionFromStateHelper = options?.getActionFromState ?? _reactNavigationCore.getActionFromState;
    const buildAction = React.useCallback(href => {
      if (!href.startsWith('/')) {
        throw new Error(`The href must start with '/' (${href}).`);
      }
      const state = getStateFromPathHelper(href, options?.config);
      if (state) {
        const action = getActionFromStateHelper(state, options?.config);
        return action ?? _reactNavigationCore.CommonActions.reset(state);
      } else {
        throw new Error('Failed to parse the href to a navigation state.');
      }
    }, [options?.config, getStateFromPathHelper, getActionFromStateHelper]);
    return buildAction;
  };

  /**
   * Helpers to build href or action based on the linking options.
   *
   * @returns `buildHref` to build an `href` for screen and `buildAction` to build an action from an `href`.
   */
  function useLinkBuilder() {
    const buildHref = useBuildHref();
    const buildAction = useBuildAction();
    return {
      buildHref,
      buildAction
    };
  }
},373,[255,9,357],"node_modules/@react-navigation/native/lib/module/useLinkBuilder.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useLinkTo = useLinkTo;
  var _reactNavigationCore = require(_dependencyMap[0], "@react-navigation/core");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _useLinkBuilderJs = require(_dependencyMap[2], "./useLinkBuilder.js");
  /**
   * Helper to navigate to a screen using a href based on the linking options.
   *
   * @returns function that receives the href to navigate to.
   */
  function useLinkTo() {
    const navigation = React.useContext(_reactNavigationCore.NavigationContainerRefContext);
    const buildAction = (0, _useLinkBuilderJs.useBuildAction)();
    const linkTo = React.useCallback(href => {
      if (navigation === undefined) {
        throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
      }
      const action = buildAction(href);
      navigation.dispatch(action);
    }, [buildAction, navigation]);
    return linkTo;
  }
},374,[255,9,373],"node_modules/@react-navigation/native/lib/module/useLinkTo.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useLocale = useLocale;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _LocaleDirContextJs = require(_dependencyMap[1], "./LocaleDirContext.js");
  /**
   * Hook to access the text direction specified in the `NavigationContainer`.
   */
  function useLocale() {
    const direction = React.useContext(_LocaleDirContextJs.LocaleDirContext);
    if (direction === undefined) {
      throw new Error("Couldn't determine the text direction. Is your component inside NavigationContainer?");
    }
    return {
      direction
    };
  }
},375,[9,358],"node_modules/@react-navigation/native/lib/module/useLocale.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useRoutePath = useRoutePath;
  var _reactNavigationCore = require(_dependencyMap[0], "@react-navigation/core");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _LinkingContextJs = require(_dependencyMap[2], "./LinkingContext.js");
  /**
   * Hook to get the path for the current route based on linking options.
   *
   * @returns Path for the current route.
   */
  function useRoutePath() {
    const {
      options
    } = React.useContext(_LinkingContextJs.LinkingContext);
    const state = (0, _reactNavigationCore.useStateForPath)();
    if (state === undefined) {
      throw new Error("Couldn't find a state for the route object. Is your component inside a screen in a navigator?");
    }
    const getPathFromStateHelper = options?.getPathFromState ?? _reactNavigationCore.getPathFromState;
    const path = React.useMemo(() => {
      if (options?.enabled === false) {
        return undefined;
      }
      const path = getPathFromStateHelper(state, options?.config);
      return path;
    }, [options?.enabled, options?.config, state, getPathFromStateHelper]);
    return path;
  }
},376,[255,9,357],"node_modules/@react-navigation/native/lib/module/useRoutePath.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useScrollToTop = useScrollToTop;
  var _reactNavigationCore = require(_dependencyMap[0], "@react-navigation/core");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  function getScrollableNode(ref) {
    if (ref.current == null) {
      return null;
    }
    if ('scrollToTop' in ref.current || 'scrollTo' in ref.current || 'scrollToOffset' in ref.current || 'scrollResponderScrollTo' in ref.current) {
      // This is already a scrollable node.
      return ref.current;
    } else if ('getScrollResponder' in ref.current) {
      // If the view is a wrapper like FlatList, SectionList etc.
      // We need to use `getScrollResponder` to get access to the scroll responder
      return ref.current.getScrollResponder();
    } else if ('getNode' in ref.current) {
      // When a `ScrollView` is wrapped in `Animated.createAnimatedComponent`
      // we need to use `getNode` to get the ref to the actual scrollview.
      // Note that `getNode` is deprecated in newer versions of react-native
      // this is why we check if we already have a scrollable node above.
      return ref.current.getNode();
    } else {
      return ref.current;
    }
  }
  function useScrollToTop(ref) {
    const navigation = React.useContext(_reactNavigationCore.NavigationContext);
    const route = (0, _reactNavigationCore.useRoute)();
    if (navigation === undefined) {
      throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }
    React.useEffect(() => {
      const tabNavigations = [];
      let currentNavigation = navigation;
      // If the screen is nested inside multiple tab navigators, we should scroll to top for any of them
      // So we need to find all the parent tab navigators and add the listeners there
      while (currentNavigation) {
        if (currentNavigation.getState().type === 'tab') {
          tabNavigations.push(currentNavigation);
        }
        currentNavigation = currentNavigation.getParent();
      }
      if (tabNavigations.length === 0) {
        return;
      }
      const unsubscribers = tabNavigations.map(tab => {
        return tab.addListener(
        // We don't wanna import tab types here to avoid extra deps
        // in addition, there are multiple tab implementations
        // @ts-expect-error the `tabPress` event is only available when navigation type is tab
        'tabPress', e => {
          // We should scroll to top only when the screen is focused
          const isFocused = navigation.isFocused();

          // In a nested stack navigator, tab press resets the stack to first screen
          // So we should scroll to top only when we are on first screen
          const isFirst = tabNavigations.includes(navigation) || navigation.getState().routes[0].key === route.key;

          // Run the operation in the next frame so we're sure all listeners have been run
          // This is necessary to know if preventDefault() has been called
          requestAnimationFrame(() => {
            const scrollable = getScrollableNode(ref);
            if (isFocused && isFirst && scrollable && !e.defaultPrevented) {
              if ('scrollToTop' in scrollable) {
                scrollable.scrollToTop();
              } else if ('scrollTo' in scrollable) {
                scrollable.scrollTo({
                  y: 0,
                  animated: true
                });
              } else if ('scrollToOffset' in scrollable) {
                scrollable.scrollToOffset({
                  offset: 0,
                  animated: true
                });
              } else if ('scrollResponderScrollTo' in scrollable) {
                scrollable.scrollResponderScrollTo({
                  y: 0,
                  animated: true
                });
              }
            }
          });
        });
      });
      return () => {
        unsubscribers.forEach(unsubscribe => unsubscribe());
      };
    }, [navigation, ref, route.key]);
  }
},377,[255,9],"node_modules/@react-navigation/native/lib/module/useScrollToTop.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["children"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\layouts\\withLayoutContext.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useFilterScreenChildren = useFilterScreenChildren;
  exports.withLayoutContext = withLayoutContext;
  const react_1 = __importStar(require(_dependencyMap[2], "react"));
  const Route_1 = require(_dependencyMap[3], "../Route");
  const NativeTabTrigger_1 = require(_dependencyMap[4], "../native-tabs/NativeBottomTabs/NativeTabTrigger");
  const useScreens_1 = require(_dependencyMap[5], "../useScreens");
  const Protected_1 = require(_dependencyMap[6], "../views/Protected");
  const Screen_1 = require(_dependencyMap[7], "../views/Screen");
  function useFilterScreenChildren(children, {
    isCustomNavigator,
    contextKey
  } = {}) {
    return (0, react_1.useMemo)(() => {
      const customChildren = [];
      const screens = [];
      const protectedScreens = new Set();
      function flattenChild(child, exclude = false) {
        if ((0, Screen_1.isScreen)(child, contextKey)) {
          if (exclude) {
            protectedScreens.add(child.props.name);
          } else {
            screens.push(child.props);
          }
          return;
        }
        if ((0, NativeTabTrigger_1.isNativeTabTrigger)(child, contextKey)) {
          if (exclude) {
            protectedScreens.add(child.props.name);
          } else {
            const options = (0, NativeTabTrigger_1.convertTabPropsToOptions)(child.props);
            if (options.hidden === false) {
              screens.push(Object.assign({}, child.props, {
                options: (0, NativeTabTrigger_1.convertTabPropsToOptions)(child.props)
              }));
            } else {
              // - hidden = undefined -> then the route was not specified in navigator
              // - hidden = true -> then the route is hidden
              // In this cases we should treat the tab as protected
              protectedScreens.add(child.props.name);
            }
          }
          return;
        }
        if ((0, Protected_1.isProtectedReactElement)(child)) {
          const excludeChildren = exclude || !child.props.guard;
          react_1.Children.forEach(child.props.children, protectedChild => {
            flattenChild(protectedChild, excludeChildren);
          });
          return;
        }
        if (isCustomNavigator) {
          customChildren.push(child);
          return null;
        }
        console.warn(`Layout children must be of type Screen, all other children are ignored. To use custom children, create a custom <Layout />. Update Layout Route at: "app${contextKey}/_layout"`);
        return null;
      }
      react_1.Children.forEach(children, child => flattenChild(child));
      // Add an assertion for development
      if (process.env.NODE_ENV !== 'production') {
        // Assert if names are not unique
        const names = screens?.map(screen => screen && typeof screen === 'object' && 'name' in screen && screen.name);
        if (names && new Set(names).size !== names.length) {
          throw new Error('Screen names must be unique: ' + names);
        }
      }
      return {
        screens,
        children: customChildren,
        protectedScreens
      };
    }, [children]);
  }
  /**
   * Returns a navigator that automatically injects matched routes and renders nothing when there are no children.
   * Return type with `children` prop optional.
   *
   * Enables use of other built-in React Navigation navigators and other navigators built with the React Navigation custom navigator API.
   *
   * @param Nav - The navigator component to wrap.
   * @param processor - A function that processes the screens before passing them to the navigator.
   * @param useOnlyUserDefinedScreens - If true, all screens not specified as navigator's children will be ignored.
   *
   *  @example
   * ```tsx app/_layout.tsx
   * import { ParamListBase, TabNavigationState } from "@react-navigation/native";
   * import {
   *   createMaterialTopTabNavigator,
   *   MaterialTopTabNavigationOptions,
   *   MaterialTopTabNavigationEventMap,
   * } from "@react-navigation/material-top-tabs";
   * import { withLayoutContext } from "expo-router";
   *
   * const MaterialTopTabs = createMaterialTopTabNavigator();
   *
   * const ExpoRouterMaterialTopTabs = withLayoutContext<
   *   MaterialTopTabNavigationOptions,
   *   typeof MaterialTopTabs.Navigator,
   *   TabNavigationState<ParamListBase>,
   *   MaterialTopTabNavigationEventMap
   * >(MaterialTopTabs.Navigator);
  
   * export default function TabLayout() {
   *   return <ExpoRouterMaterialTopTabs />;
   * }
   * ```
   */
  function withLayoutContext(Nav, processor, useOnlyUserDefinedScreens = false) {
    return Object.assign((0, react_1.forwardRef)((_ref, ref) => {
      let {
          children: userDefinedChildren
        } = _ref,
        props = _objectWithoutPropertiesLoose(_ref, _excluded);
      const contextKey = (0, Route_1.useContextKey)();
      const {
        screens,
        protectedScreens
      } = useFilterScreenChildren(userDefinedChildren, {
        contextKey
      });
      const processed = processor ? processor(screens ?? []) : screens;
      const sorted = (0, useScreens_1.useSortedScreens)(processed ?? [], protectedScreens, useOnlyUserDefinedScreens);
      // Prevent throwing an error when there are no screens.
      if (!sorted.length) {
        return null;
      }
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Nav, Object.assign({}, props, {
        id: contextKey,
        ref: ref,
        children: sorted
      }), void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 156,
        columnNumber: 16
      }, this);
    }), {
      Screen: Screen_1.Screen,
      Protected: Protected_1.Protected
    });
  }
},378,[33,759,9,379,382,388,632,633],"node_modules/expo-router/build/layouts/withLayoutContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\Route.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.sortRoutes = exports.sortRoutesWithInitial = exports.LocalRouteParamsContext = void 0;
  exports.useRouteNode = useRouteNode;
  exports.useContextKey = useContextKey;
  exports.Route = Route;
  const react_1 = require(_dependencyMap[1], "react");
  const matchers_1 = require(_dependencyMap[2], "./matchers");
  const sortRoutes_1 = require(_dependencyMap[3], "./sortRoutes");
  Object.defineProperty(exports, "sortRoutesWithInitial", {
    enumerable: true,
    get: function () {
      return sortRoutes_1.sortRoutesWithInitial;
    }
  });
  Object.defineProperty(exports, "sortRoutes", {
    enumerable: true,
    get: function () {
      return sortRoutes_1.sortRoutes;
    }
  });
  const CurrentRouteContext = (0, react_1.createContext)(null);
  exports.LocalRouteParamsContext = (0, react_1.createContext)({});
  if (process.env.NODE_ENV !== 'production') {
    CurrentRouteContext.displayName = 'RouteNode';
  }
  /** Return the RouteNode at the current contextual boundary. */
  function useRouteNode() {
    return (0, react_1.use)(CurrentRouteContext);
  }
  function useContextKey() {
    const node = useRouteNode();
    if (node == null) {
      throw new Error('No filename found. This is likely a bug in expo-router.');
    }
    return (0, matchers_1.getContextKey)(node.contextKey);
  }
  /** Provides the matching routes and filename to the children. */
  function Route({
    children,
    node,
    route
  }) {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(exports.LocalRouteParamsContext.Provider, {
      value: route?.params,
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(CurrentRouteContext.Provider, {
        value: node,
        children: children
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 32,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 31,
      columnNumber: 13
    }, this);
  }
},379,[33,9,380,381],"node_modules/expo-router/build/Route.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.matchDynamicName = matchDynamicName;
  exports.testNotFound = testNotFound;
  exports.matchGroupName = matchGroupName;
  exports.matchLastGroupName = matchLastGroupName;
  exports.matchArrayGroupName = matchArrayGroupName;
  exports.getNameFromFilePath = getNameFromFilePath;
  exports.getContextKey = getContextKey;
  exports.removeSupportedExtensions = removeSupportedExtensions;
  exports.removeFileSystemExtensions = removeFileSystemExtensions;
  exports.removeFileSystemDots = removeFileSystemDots;
  exports.stripGroupSegmentsFromPath = stripGroupSegmentsFromPath;
  exports.stripInvisibleSegmentsFromPath = stripInvisibleSegmentsFromPath;
  exports.isTypedRoute = isTypedRoute;
  /** Match `[page]` -> `page` or `[...group]` -> `...group` */
  const dynamicNameRe = /^\[([^[\]]+?)\]$/;
  /** Match `[page]` -> `page` */
  function matchDynamicName(name) {
    const paramName = name.match(dynamicNameRe)?.[1];
    if (paramName == null) {
      return undefined;
    } else if (paramName.startsWith('...')) {
      return {
        name: paramName.slice(3),
        deep: true
      };
    } else {
      return {
        name: paramName,
        deep: false
      };
    }
  }
  /** Test `/` -> `page` */
  function testNotFound(name) {
    return /\+not-found$/.test(name);
  }
  /** Match `(page)` -> `page` */
  function matchGroupName(name) {
    return name.match(/^(?:[^\\()])*?\(([^\\/]+)\)/)?.[1];
  }
  /** Match `(app)/(page)` -> `page` */
  function matchLastGroupName(name) {
    return name.match(/.*(?:\/|^)\(([^\\/]+)\)[^\s]*$/)?.[1];
  }
  /** Match the first array group name `(a,b,c)/(d,c)` -> `'a,b,c'` */
  function matchArrayGroupName(name) {
    return name.match(/(?:[^\\()])*?\(([^\\/]+,[^\\/]+)\)/)?.[1];
  }
  function getNameFromFilePath(name) {
    return removeSupportedExtensions(removeFileSystemDots(name));
  }
  function getContextKey(name) {
    // The root path is `` (empty string) so always prepend `/` to ensure
    // there is some value.
    const normal = '/' + getNameFromFilePath(name);
    if (!normal.endsWith('_layout')) {
      return normal;
    }
    return normal.replace(/\/?_layout$/, '');
  }
  /** Remove `.js`, `.ts`, `.jsx`, `.tsx`, and the +api suffix */
  function removeSupportedExtensions(name) {
    return name.replace(/(\+api)?\.[jt]sx?$/g, '');
  }
  /** Remove `.js`, `.ts`, `.jsx`, `.tsx` */
  function removeFileSystemExtensions(name) {
    return name.replace(/\.[jt]sx?$/g, '');
  }
  // Remove any amount of `./` and `../` from the start of the string
  function removeFileSystemDots(filePath) {
    return filePath.replace(/^(?:\.\.?\/)+/g, '');
  }
  function stripGroupSegmentsFromPath(path) {
    return path.split('/').reduce((acc, v) => {
      if (matchGroupName(v) == null) {
        acc.push(v);
      }
      return acc;
    }, []).join('/');
  }
  function stripInvisibleSegmentsFromPath(path) {
    return stripGroupSegmentsFromPath(path).replace(/\/?index$/, '');
  }
  /**
   * Match:
   *  - _layout files, +html, +not-found, string+api, etc
   *  - Routes can still use `+`, but it cannot be in the last segment.
   */
  function isTypedRoute(name) {
    return !name.startsWith('+') && name.match(/(_layout|[^/]*?\+[^/]*?)\.[tj]sx?$/) === null;
  }
},380,[],"node_modules/expo-router/build/matchers.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.sortRoutes = sortRoutes;
  exports.sortRoutesWithInitial = sortRoutesWithInitial;
  const matchers_1 = require(_dependencyMap[0], "./matchers");
  function sortDynamicConvention(a, b) {
    if (a.deep && !b.deep) {
      return 1;
    }
    if (!a.deep && b.deep) {
      return -1;
    }
    return 0;
  }
  function sortRoutes(a, b) {
    if (a.dynamic && !b.dynamic) {
      return 1;
    }
    if (!a.dynamic && b.dynamic) {
      return -1;
    }
    if (a.dynamic && b.dynamic) {
      if (a.dynamic.length !== b.dynamic.length) {
        return b.dynamic.length - a.dynamic.length;
      }
      for (let i = 0; i < a.dynamic.length; i++) {
        const aDynamic = a.dynamic[i];
        const bDynamic = b.dynamic[i];
        if (aDynamic.notFound && bDynamic.notFound) {
          const s = sortDynamicConvention(aDynamic, bDynamic);
          if (s) {
            return s;
          }
        }
        if (aDynamic.notFound && !bDynamic.notFound) {
          return 1;
        }
        if (!aDynamic.notFound && bDynamic.notFound) {
          return -1;
        }
        const s = sortDynamicConvention(aDynamic, bDynamic);
        if (s) {
          return s;
        }
      }
      return 0;
    }
    const aIndex = a.route === 'index' || (0, matchers_1.matchGroupName)(a.route) != null;
    const bIndex = b.route === 'index' || (0, matchers_1.matchGroupName)(b.route) != null;
    if (aIndex && !bIndex) {
      return -1;
    }
    if (!aIndex && bIndex) {
      return 1;
    }
    return a.route.length - b.route.length;
  }
  function sortRoutesWithInitial(initialRouteName) {
    return (a, b) => {
      if (initialRouteName) {
        if (a.route === initialRouteName) {
          return -1;
        }
        if (b.route === initialRouteName) {
          return 1;
        }
      }
      return sortRoutes(a, b);
    };
  }
},381,[380],"node_modules/expo-router/build/sortRoutes.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NativeTabTrigger = void 0;
  exports.convertTabPropsToOptions = convertTabPropsToOptions;
  exports.appendIconOptions = appendIconOptions;
  exports.isNativeTabTrigger = isNativeTabTrigger;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const react_1 = require(_dependencyMap[1], "react");
  const NativeTabsTriggerTabBar_1 = require(_dependencyMap[2], "./NativeTabsTriggerTabBar");
  const utils_1 = require(_dependencyMap[3], "./utils");
  const PreviewRouteContext_1 = require(_dependencyMap[4], "../../link/preview/PreviewRouteContext");
  const useSafeLayoutEffect_1 = require(_dependencyMap[5], "../../views/useSafeLayoutEffect");
  const elements_1 = require(_dependencyMap[6], "../common/elements");
  /**
   * The component used to customize the native tab options both in the _layout file and from the tab screen.
   *
   * When used in the _layout file, you need to provide a `name` prop.
   * When used in the tab screen, the `name` prop takes no effect.
   *
   * @example
   * ```tsx
   * // In _layout file
   * import { NativeTabs } from 'expo-router/unstable-native-tabs';
   *
   * export default function Layout() {
   *   return (
   *     <NativeTabs>
   *       <NativeTabs.Trigger name="home" />
   *       <NativeTabs.Trigger name="settings" />
   *     </NativeTabs>
   *   );
   * }
   * ```
   *
   * @example
   * ```tsx
   * // In a tab screen
   * import { NativeTabs } from 'expo-router/unstable-native-tabs';
   *
   * export default function HomeScreen() {
   *   return (
   *     <View>
   *       <NativeTabs.Trigger>
   *         <Label>Home</Label>
   *       </NativeTabs.Trigger>
   *       <Text>This is home screen!</Text>
   *     </View>
   *   );
   * }
   * ```
   *
   * > **Note:** You can use the alias `NativeTabs.Trigger` for this component.
   */
  function NativeTabTriggerImpl(props) {
    const route = (0, native_1.useRoute)();
    const navigation = (0, native_1.useNavigation)();
    const isFocused = navigation.isFocused();
    const isInPreview = (0, PreviewRouteContext_1.useIsPreview)();
    (0, useSafeLayoutEffect_1.useSafeLayoutEffect)(() => {
      // This will cause the tab to update only when it is focused.
      // As long as all tabs are loaded at the start, we don't need this check.
      // It is here to ensure similar behavior to stack
      if (isFocused && !isInPreview) {
        if (navigation.getState()?.type !== 'tab') {
          throw new Error(`Trigger component can only be used in the tab screen. Current route: ${route.name}`);
        }
        const options = convertTabPropsToOptions(props, true);
        navigation.setOptions(options);
      }
    }, [isFocused, props, isInPreview]);
    return null;
  }
  exports.NativeTabTrigger = Object.assign(NativeTabTriggerImpl, {
    TabBar: NativeTabsTriggerTabBar_1.NativeTabsTriggerTabBar
  });
  function convertTabPropsToOptions({
    options,
    hidden,
    children,
    role,
    disablePopToTop,
    disableScrollToTop
  }, isDynamic = false) {
    const initialOptions = isDynamic ? Object.assign({}, options) : Object.assign({}, options, {
      hidden: !!hidden,
      specialEffects: {
        repeatedTabSelection: {
          popToRoot: !disablePopToTop,
          scrollToTop: !disableScrollToTop
        }
      },
      role: role ?? options?.role
    });
    const allowedChildren = (0, utils_1.filterAllowedChildrenElements)(children, [elements_1.Badge, elements_1.Label, elements_1.Icon, NativeTabsTriggerTabBar_1.NativeTabsTriggerTabBar]);
    return allowedChildren.reduce((acc, child) => {
      if ((0, utils_1.isChildOfType)(child, elements_1.Badge)) {
        appendBadgeOptions(acc, child.props);
      } else if ((0, utils_1.isChildOfType)(child, elements_1.Label)) {
        appendLabelOptions(acc, child.props);
      } else if ((0, utils_1.isChildOfType)(child, elements_1.Icon)) {
        appendIconOptions(acc, child.props);
      } else if ((0, utils_1.isChildOfType)(child, NativeTabsTriggerTabBar_1.NativeTabsTriggerTabBar)) {
        appendTabBarOptions(acc, child.props);
      }
      return acc;
    }, Object.assign({}, initialOptions));
  }
  function appendBadgeOptions(options, props) {
    if (props.children) {
      options.badgeValue = String(props.children);
      options.selectedBadgeBackgroundColor = props.selectedBackgroundColor;
    } else if (!props.hidden) {
      // If no value is provided, we set it to a space to show the badge
      // Otherwise, the `react-native-screens` will interpret it as a hidden badge
      // https://github.com/software-mansion/react-native-screens/blob/b4358fd95dd0736fc54df6bb97f210dc89edf24c/ios/bottom-tabs/RNSBottomTabsScreenComponentView.mm#L172
      options.badgeValue = ' ';
    }
  }
  function appendLabelOptions(options, props) {
    if (props.hidden) {
      options.title = '';
    } else {
      options.title = props.children;
      if (props.selectedStyle) {
        options.selectedLabelStyle = props.selectedStyle;
      }
    }
  }
  function appendIconOptions(options, props) {
    if ('src' in props && props.src) {
      const icon = convertIconSrcToIconOption(props);
      options.icon = icon?.icon;
      options.selectedIcon = icon?.selectedIcon;
    } else if ('sf' in props && false) {
      if (typeof props.sf === 'string') {
        options.icon = props.sf ? {
          sf: props.sf
        } : undefined;
        options.selectedIcon = undefined;
      } else if (props.sf) {
        options.icon = props.sf.default ? {
          sf: props.sf.default
        } : undefined;
        options.selectedIcon = props.sf.selected ? {
          sf: props.sf.selected
        } : undefined;
      }
    } else if ('androidSrc' in props && false) {
      const icon = convertIconSrcToIconOption({
        src: props.androidSrc
      });
      options.icon = icon?.icon;
      options.selectedIcon = icon?.selectedIcon;
    } else if ('drawable' in props && false) {
      options.icon = {
        drawable: props.drawable
      };
      options.selectedIcon = undefined;
    }
    if (props.selectedColor) {
      options.selectedIconColor = props.selectedColor;
    }
  }
  function convertIconSrcToIconOption(icon) {
    if (icon && icon.src) {
      const {
        defaultIcon,
        selected
      } = typeof icon.src === 'object' && 'selected' in icon.src ? {
        defaultIcon: icon.src.default,
        selected: icon.src.selected
      } : {
        defaultIcon: icon.src
      };
      const options = {};
      options.icon = convertSrcOrComponentToSrc(defaultIcon);
      options.selectedIcon = convertSrcOrComponentToSrc(selected);
      return options;
    }
    return undefined;
  }
  function convertSrcOrComponentToSrc(src) {
    if (src) {
      if ((0, react_1.isValidElement)(src)) {
        if (src.type === elements_1.VectorIcon) {
          const props = src.props;
          return {
            src: props.family.getImageSource(props.name, 24, 'white')
          };
        } else {
          console.warn('Only VectorIcon is supported as a React element in Icon.src');
        }
      } else {
        return {
          src
        };
      }
    }
    return undefined;
  }
  function appendTabBarOptions(options, props) {
    const {
      backgroundColor,
      blurEffect,
      iconColor,
      disableTransparentOnScrollEdge,
      badgeBackgroundColor,
      badgeTextColor,
      indicatorColor,
      labelStyle,
      shadowColor
    } = props;
    if (backgroundColor) {
      options.backgroundColor = backgroundColor;
    }
    // We need better native integration of this on Android
    // Simulating from JS side creates ugly transitions
    if (true) {
      if (blurEffect) {
        options.blurEffect = blurEffect;
      }
      if (shadowColor) {
        options.shadowColor = shadowColor;
      }
      if (iconColor) {
        options.iconColor = iconColor;
      }
      if (disableTransparentOnScrollEdge !== undefined) {
        options.disableTransparentOnScrollEdge = disableTransparentOnScrollEdge;
      }
      if (badgeBackgroundColor) {
        options.badgeBackgroundColor = badgeBackgroundColor;
      }
      if (badgeTextColor) {
        options.badgeTextColor = badgeTextColor;
      }
      if (indicatorColor) {
        options.indicatorColor = indicatorColor;
      }
      if (labelStyle) {
        options.labelStyle = labelStyle;
      }
    }
  }
  function isNativeTabTrigger(child, contextKey) {
    if ((0, react_1.isValidElement)(child) && child && child.type === exports.NativeTabTrigger) {
      if (typeof child.props === 'object' && child.props && 'name' in child.props && !child.props.name) {
        throw new Error(`<Trigger /> component in \`default export\` at \`app${contextKey}/_layout\` must have a \`name\` prop when used as a child of a Layout Route.`);
      }
      if (process.env.NODE_ENV !== 'production') {
        if (['component', 'getComponent'].some(key => child.props && typeof child.props === 'object' && key in child.props)) {
          throw new Error(`<Trigger /> component in \`default export\` at \`app${contextKey}/_layout\` must not have a \`component\` or \`getComponent\` prop when used as a child of a Layout Route`);
        }
      }
      return true;
    }
    return false;
  }
},382,[253,9,383,384,385,386,387],"node_modules/expo-router/build/native-tabs/NativeBottomTabs/NativeTabTrigger.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NativeTabsTriggerTabBar = NativeTabsTriggerTabBar;
  /**
   * The component used to customize the style of the tab bar, when given trigger is selected.
   *
   * Prefer this to global changes of tab bar styles, directly in the page.
   *
   * > **Note:** You can use the alias `NativeTabs.Trigger.TabBar` for this component.
   *
   * @example
   * ```tsx
   * <NativeTabs
   *  backgroundColor="black"
   * >
   *  <NativeTabs.Trigger name="page">
   *    <NativeTabs.Trigger.TabBar
   *      backgroundColor="white"
   *    />
   *    <Label>Page</Label>
   *  </NativeTabs.Trigger>
   * </NativeTabs>
   *
   */
  function NativeTabsTriggerTabBar(props) {
    return null;
  }
},383,[],"node_modules/expo-router/build/native-tabs/NativeBottomTabs/NativeTabsTriggerTabBar.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.filterAllowedChildrenElements = filterAllowedChildrenElements;
  exports.isChildOfType = isChildOfType;
  exports.shouldTabBeVisible = shouldTabBeVisible;
  exports.convertLabelStylePropToObject = convertLabelStylePropToObject;
  exports.convertIconColorPropToObject = convertIconColorPropToObject;
  const react_1 = __importDefault(require(_dependencyMap[0], "react"));
  function filterAllowedChildrenElements(children, components) {
    return react_1.default.Children.toArray(children).filter(child => react_1.default.isValidElement(child) && components.includes(child.type));
  }
  function isChildOfType(child, type) {
    return react_1.default.isValidElement(child) && child.type === type;
  }
  function shouldTabBeVisible(options) {
    // The <NativeTab.Trigger> always sets `hidden` to defined boolean value.
    // If it is not defined, then it was not specified, and we should hide the tab.
    return options.hidden === false;
  }
  function convertLabelStylePropToObject(labelStyle) {
    if (labelStyle) {
      if (typeof labelStyle === 'object' && ('default' in labelStyle || 'selected' in labelStyle)) {
        return labelStyle;
      }
      return {
        default: labelStyle
      };
    }
    return {};
  }
  function convertIconColorPropToObject(iconColor) {
    if (iconColor) {
      if (typeof iconColor === 'object' && ('default' in iconColor || 'selected' in iconColor)) {
        return iconColor;
      }
      return {
        default: iconColor
      };
    }
    return {};
  }
},384,[9],"node_modules/expo-router/build/native-tabs/NativeBottomTabs/utils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PreviewRouteContext = void 0;
  exports.usePreviewInfo = usePreviewInfo;
  exports.useIsPreview = useIsPreview;
  const react_1 = require(_dependencyMap[0], "react");
  exports.PreviewRouteContext = (0, react_1.createContext)(undefined);
  /**
   * Returns information about the current route if it is displayed in preview mode.
   */
  function usePreviewInfo() {
    const paramsContext = (0, react_1.use)(exports.PreviewRouteContext);
    return Object.assign({
      isPreview: !!paramsContext
    }, paramsContext);
  }
  /**
   * Hook to determine if the current route is rendered inside a preview.
   *
   *  @returns {boolean} - True if the current route is rendered inside a preview, false otherwise.
   */
  function useIsPreview() {
    const {
      isPreview
    } = usePreviewInfo();
    return isPreview;
  }
},385,[9],"node_modules/expo-router/build/link/preview/PreviewRouteContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useSafeLayoutEffect = void 0;
  const react_1 = require(_dependencyMap[0], "react");
  exports.useSafeLayoutEffect = typeof window !== 'undefined' ? react_1.useLayoutEffect : function () {};
},386,[9],"node_modules/expo-router/build/views/useSafeLayoutEffect.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Label = Label;
  exports.Icon = Icon;
  exports.VectorIcon = VectorIcon;
  exports.Badge = Badge;
  function Label(props) {
    return null;
  }
  /**
   * Renders an icon for the tab.
   *
   * @platform ios
   * @platform android
   */
  function Icon(props) {
    return null;
  }
  /**
   * Helper component which can be used to load vector icons for `NativeTabs`.
   *
   * @example
   * ```tsx
   * import { NativeTabs, VectorIcon } from 'expo-router';
   * import MaterialCommunityIcons from '@expo/vector-icons/MaterialCommunityIcons';
   *
   * export default Layout(){
   *   return (
   *     <NativeTabs>
   *       <NativeTabs.Trigger name="index">
   *         <Icon src={<VectorIcon family={MaterialCommunityIcons} name="home" />} />
   *       </NativeTabs.Trigger>
   *     </NativeTabs>
   *   );
   * }
   * ```
   */
  function VectorIcon(props) {
    return null;
  }
  function Badge(props) {
    return null;
  }
},387,[],"node_modules/expo-router/build/native-tabs/common/elements.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _react = require(_dependencyMap[0], "react");
  var _reactJsxDevRuntime = require(_dependencyMap[1], "react/jsx-dev-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["ErrorBoundary"],
    _excluded2 = ["route", "navigation"],
    _excluded3 = ["options", "getId"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\useScreens.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useSortedScreens = useSortedScreens;
  exports.getQualifiedRouteComponent = getQualifiedRouteComponent;
  exports.screenOptionsFactory = screenOptionsFactory;
  exports.routeToScreen = routeToScreen;
  exports.getSingularId = getSingularId;
  const native_1 = require(_dependencyMap[3], "@react-navigation/native");
  const react_1 = __importStar(require(_dependencyMap[0], "react"));
  const Route_1 = require(_dependencyMap[4], "./Route");
  const storeContext_1 = require(_dependencyMap[5], "./global-state/storeContext");
  const import_mode_1 = __importDefault(require(_dependencyMap[6], "./import-mode"));
  const primitives_1 = require(_dependencyMap[7], "./primitives");
  const EmptyRoute_1 = require(_dependencyMap[8], "./views/EmptyRoute");
  const SuspenseFallback_1 = require(_dependencyMap[9], "./views/SuspenseFallback");
  const Try_1 = require(_dependencyMap[10], "./views/Try");
  function getSortedChildren(children, order = [], initialRouteName) {
    if (!order?.length) {
      return children.sort((0, Route_1.sortRoutesWithInitial)(initialRouteName)).map(route => ({
        route,
        props: {}
      }));
    }
    const entries = [...children];
    const ordered = order.map(({
      name,
      redirect,
      initialParams,
      listeners,
      options,
      getId,
      dangerouslySingular: singular
    }) => {
      if (!entries.length) {
        console.warn(`[Layout children]: Too many screens defined. Route "${name}" is extraneous.`);
        return null;
      }
      const matchIndex = entries.findIndex(child => child.route === name);
      if (matchIndex === -1) {
        console.warn(`[Layout children]: No route named "${name}" exists in nested children:`, children.map(({
          route
        }) => route));
        return null;
      } else {
        // Get match and remove from entries
        const match = entries[matchIndex];
        entries.splice(matchIndex, 1);
        // Ensure to return null after removing from entries.
        if (redirect) {
          if (typeof redirect === 'string') {
            throw new Error(`Redirecting to a specific route is not supported yet.`);
          }
          return null;
        }
        if (getId) {
          console.warn(`Deprecated: prop 'getId' on screen ${name} is deprecated. Please rename the prop to 'dangerouslySingular'`);
          if (singular) {
            console.warn(`Screen ${name} cannot use both getId and dangerouslySingular together.`);
          }
        } else if (singular) {
          // If singular is set, use it as the getId function.
          if (typeof singular === 'string') {
            getId = () => singular;
          } else if (typeof singular === 'function' && name) {
            getId = options => singular(name, options.params || {});
          } else if (singular === true && name) {
            getId = options => getSingularId(name, options);
          }
        }
        return {
          route: match,
          props: {
            initialParams,
            listeners,
            options,
            getId
          }
        };
      }
    }).filter(Boolean);
    // Add any remaining children
    ordered.push(...entries.sort((0, Route_1.sortRoutesWithInitial)(initialRouteName)).map(route => ({
      route,
      props: {}
    })));
    return ordered;
  }
  /**
   * @returns React Navigation screens sorted by the `route` property.
   */
  function useSortedScreens(order, protectedScreens, useOnlyUserDefinedScreens = false) {
    const node = (0, Route_1.useRouteNode)();
    const nodeChildren = node?.children ?? [];
    const children = useOnlyUserDefinedScreens ? nodeChildren.filter(child => order.some(userDefinedScreen => userDefinedScreen.name === child.route)) : nodeChildren;
    const sorted = children.length ? getSortedChildren(children, order, node?.initialRouteName) : [];
    return react_1.default.useMemo(() => sorted.filter(item => !protectedScreens.has(item.route.route)).map(value => {
      return routeToScreen(value.route, value.props);
    }), [sorted, protectedScreens]);
  }
  function fromImport(value, _ref) {
    let {
        ErrorBoundary
      } = _ref,
      component = _objectWithoutPropertiesLoose(_ref, _excluded);
    // If possible, add a more helpful display name for the component stack to improve debugging of React errors such as `Text strings must be rendered within a <Text> component.`.
    if (component?.default && __DEV__) {
      component.default.displayName ??= `${component.default.name ?? 'Route'}(${value.contextKey})`;
    }
    if (ErrorBoundary) {
      const Wrapped = react_1.default.forwardRef((props, ref) => {
        const children = react_1.default.createElement(component.default || EmptyRoute_1.EmptyRoute, Object.assign({}, props, {
          ref
        }));
        return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Try_1.Try, {
          catch: ErrorBoundary,
          children: children
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 139,
          columnNumber: 20
        }, this);
      });
      if (__DEV__) {
        Wrapped.displayName = `ErrorBoundary(${value.contextKey})`;
      }
      return {
        default: Wrapped
      };
    }
    if (process.env.NODE_ENV !== 'production') {
      if (typeof component.default === 'object' && component.default && Object.keys(component.default).length === 0) {
        return {
          default: EmptyRoute_1.EmptyRoute
        };
      }
    }
    return {
      default: component.default
    };
  }
  function fromLoadedRoute(value, res) {
    if (!(res instanceof Promise)) {
      return fromImport(value, res);
    }
    return res.then(fromImport.bind(null, value));
  }
  // TODO: Maybe there's a more React-y way to do this?
  // Without this store, the process enters a recursive loop.
  const qualifiedStore = new WeakMap();
  /** Wrap the component with various enhancements and add access to child routes. */
  function getQualifiedRouteComponent(value) {
    if (qualifiedStore.has(value)) {
      return qualifiedStore.get(value);
    }
    let ScreenComponent;
    // TODO: This ensures sync doesn't use React.lazy, but it's not ideal.
    if (import_mode_1.default === 'lazy') {
      ScreenComponent = react_1.default.lazy(async () => {
        const res = value.loadRoute();
        return fromLoadedRoute(value, res);
      });
      if (__DEV__) {
        ScreenComponent.displayName = `AsyncRoute(${value.route})`;
      }
    } else {
      const res = value.loadRoute();
      ScreenComponent = fromImport(value, res).default;
    }
    function BaseRoute(_ref2) {
      let {
          // Remove these React Navigation props to
          // enforce usage of expo-router hooks (where the query params are correct).
          route,
          navigation
          // Pass all other props to the component
        } = _ref2,
        props = _objectWithoutPropertiesLoose(_ref2, _excluded2);
      const stateForPath = (0, native_1.useStateForPath)();
      const isFocused = navigation.isFocused();
      const store = (0, storeContext_1.useExpoRouterStore)();
      if (isFocused) {
        const state = navigation.getState();
        const isLeaf = !('state' in state.routes[state.index]);
        if (isLeaf && stateForPath) store.setFocusedState(stateForPath);
      }
      (0, react_1.useEffect)(() => navigation.addListener('focus', () => {
        const state = navigation.getState();
        const isLeaf = !('state' in state.routes[state.index]);
        // Because setFocusedState caches the route info, this call will only trigger rerenders
        // if the component itself didn’t rerender and the route info changed.
        // Otherwise, the update from the `if` above will handle it,
        // and this won’t cause a redundant second update.
        if (isLeaf && stateForPath) store.setFocusedState(stateForPath);
      }), [navigation]);
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Route_1.Route, {
        node: value,
        route: route,
        children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_1.default.Suspense, {
          fallback: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(SuspenseFallback_1.SuspenseFallback, {
            route: value
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 212,
            columnNumber: 45
          }, this),
          children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(ScreenComponent, Object.assign({}, props, {
            // Expose the template segment path, e.g. `(home)`, `[foo]`, `index`
            // the intention is to make it possible to deduce shared routes.
            segment: value.route
          }), void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 213,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 212,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 211,
        columnNumber: 17
      }, this);
    }
    if (__DEV__) {
      BaseRoute.displayName = `Route(${value.route})`;
    }
    qualifiedStore.set(value, BaseRoute);
    return BaseRoute;
  }
  function screenOptionsFactory(route, options) {
    return args => {
      // Only eager load generated components
      const staticOptions = route.generated ? route.loadRoute()?.getNavOptions : null;
      const staticResult = typeof staticOptions === 'function' ? staticOptions(args) : staticOptions;
      const dynamicResult = typeof options === 'function' ? options?.(args) : options;
      const output = Object.assign({}, staticResult, dynamicResult);
      // Prevent generated screens from showing up in the tab bar.
      if (route.internal) {
        output.tabBarItemStyle = {
          display: 'none'
        };
        output.tabBarButton = () => null;
        // TODO: React Navigation doesn't provide a way to prevent rendering the drawer item.
        output.drawerItemStyle = {
          height: 0,
          display: 'none'
        };
      }
      return output;
    };
  }
  function routeToScreen(route, _ref3 = {}) {
    let {
        options,
        getId
      } = _ref3,
      props = _objectWithoutPropertiesLoose(_ref3, _excluded3);
    return /*#__PURE__*/_react.createElement(primitives_1.Screen, Object.assign({}, props, {
      name: route.route,
      key: route.route,
      getId: getId,
      options: screenOptionsFactory(route, options),
      getComponent: () => getQualifiedRouteComponent(route),
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 247,
        columnNumber: 13
      }
    }));
  }
  function getSingularId(name, options = {}) {
    return name.split('/').map(segment => {
      if (segment.startsWith('[...')) {
        return options.params?.[segment.slice(4, -1)]?.join('/') || segment;
      } else if (segment.startsWith('[') && segment.endsWith(']')) {
        return options.params?.[segment.slice(1, -1)] || segment;
      } else {
        return segment;
      }
    }).join('/');
  }
},388,[9,33,759,253,379,389,390,391,392,546,547],"node_modules/expo-router/build/useScreens.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useExpoRouterStore = exports.StoreContext = void 0;
  const react_1 = require(_dependencyMap[0], "react");
  exports.StoreContext = (0, react_1.createContext)(null);
  const useExpoRouterStore = () => (0, react_1.use)(exports.StoreContext);
  exports.useExpoRouterStore = useExpoRouterStore;
},389,[9],"node_modules/expo-router/build/global-state/storeContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = "sync" || 'sync';
},390,[],"node_modules/expo-router/build/import-mode/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _a;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Group = exports.Screen = void 0;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  // `@react-navigation/native` does not expose the Screen or Group components directly, so we have to
  // do this hack.
  _a = (0, native_1.createNavigatorFactory)({})(), exports.Screen = _a.Screen, exports.Group = _a.Group;
},391,[253],"node_modules/expo-router/build/primitives.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\views\\EmptyRoute.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.EmptyRoute = EmptyRoute;
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  const Toast_1 = require(_dependencyMap[2], "./Toast");
  const Route_1 = require(_dependencyMap[3], "../Route");
  function EmptyRoute() {
    const route = (0, Route_1.useRouteNode)();
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Toast_1.ToastWrapper, {
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Toast_1.Toast, {
        warning: true,
        filename: route?.contextKey,
        children: "Missing default export"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 14,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 13
    }, this);
  }
},392,[33,9,393,379],"node_modules/expo-router/build/views/EmptyRoute.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\views\\Toast.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CODE_FONT = void 0;
  exports.ToastWrapper = ToastWrapper;
  exports.Toast = Toast;
  const bottom_tabs_1 = require(_dependencyMap[1], "@react-navigation/bottom-tabs");
  const react_1 = __importDefault(require(_dependencyMap[2], "react"));
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const react_native_safe_area_context_1 = require(_dependencyMap[4], "react-native-safe-area-context");
  exports.CODE_FONT = react_native_1.Platform.select({
    default: 'Courier',
    ios: 'Courier New',
    android: 'monospace'
  });
  function useFadeIn() {
    // Returns a React Native Animated value for fading in
    const [value] = react_1.default.useState(() => new react_native_1.Animated.Value(0));
    react_1.default.useEffect(() => {
      react_native_1.Animated.timing(value, {
        toValue: 1,
        duration: 200,
        useNativeDriver: true
      }).start();
    }, []);
    return value;
  }
  function ToastWrapper({
    children
  }) {
    const inTabBar = react_1.default.use(bottom_tabs_1.BottomTabBarHeightContext);
    const Wrapper = inTabBar ? react_native_1.View : react_native_safe_area_context_1.SafeAreaView;
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Wrapper, {
      collapsable: false,
      style: {
        flex: 1
      },
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 13
    }, this);
  }
  function Toast({
    children,
    filename,
    warning
  }) {
    const filenamePretty = react_1.default.useMemo(() => {
      if (!filename) return undefined;
      return 'app' + filename.replace(/^\./, '');
    }, [filename]);
    const value = useFadeIn();
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
      style: styles.container,
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Animated.View, {
        style: [styles.toast, {
          position: react_native_1.Platform.select({
            // NOTE(@kitten): This isn't typed to support Web properties
            web: 'fixed',
            default: 'absolute'
          }),
          opacity: value
        }],
        children: [!warning && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.ActivityIndicator, {
          color: "white"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 57,
          columnNumber: 22
        }, this), warning && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Image, {
          source: require(_dependencyMap[5], "expo-router/assets/error.png"),
          style: styles.icon
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 58,
          columnNumber: 21
        }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
          style: {
            marginLeft: 8
          },
          children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
            style: styles.text,
            children: children
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 60,
            columnNumber: 11
          }, this), filenamePretty && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
            style: styles.filename,
            children: filenamePretty
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 61,
            columnNumber: 30
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 59,
          columnNumber: 9
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 46,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 45,
      columnNumber: 13
    }, this);
  }
  const styles = react_native_1.StyleSheet.create({
    container: {
      backgroundColor: 'transparent',
      flex: 1
    },
    icon: {
      width: 20,
      height: 20,
      resizeMode: 'contain'
    },
    toast: {
      alignItems: 'center',
      borderWidth: 1,
      borderColor: 'rgba(255,255,255,0.2)',
      flexDirection: 'row',
      bottom: 8,
      left: 8,
      paddingVertical: 8,
      paddingHorizontal: 12,
      borderRadius: 4,
      backgroundColor: 'black'
    },
    text: {
      color: 'white',
      fontSize: 16
    },
    filename: {
      fontFamily: exports.CODE_FONT,
      opacity: 0.8,
      color: 'white',
      fontSize: 12
    },
    code: {
      fontFamily: exports.CODE_FONT
    }
  });
},393,[33,394,9,492,423,545],"node_modules/expo-router/build/views/Toast.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "createBottomTabNavigator", {
    enumerable: true,
    get: function () {
      return _navigatorsCreateBottomTabNavigatorJs.createBottomTabNavigator;
    }
  });
  Object.defineProperty(exports, "BottomTabBar", {
    enumerable: true,
    get: function () {
      return _viewsBottomTabBarJs.BottomTabBar;
    }
  });
  Object.defineProperty(exports, "BottomTabView", {
    enumerable: true,
    get: function () {
      return _viewsBottomTabViewJs.BottomTabView;
    }
  });
  Object.defineProperty(exports, "BottomTabBarHeightCallbackContext", {
    enumerable: true,
    get: function () {
      return _utilsBottomTabBarHeightCallbackContextJs.BottomTabBarHeightCallbackContext;
    }
  });
  Object.defineProperty(exports, "BottomTabBarHeightContext", {
    enumerable: true,
    get: function () {
      return _utilsBottomTabBarHeightContextJs.BottomTabBarHeightContext;
    }
  });
  Object.defineProperty(exports, "useBottomTabBarHeight", {
    enumerable: true,
    get: function () {
      return _utilsUseBottomTabBarHeightJs.useBottomTabBarHeight;
    }
  });
  Object.defineProperty(exports, "SceneStyleInterpolators", {
    enumerable: true,
    get: function () {
      return SceneStyleInterpolators;
    }
  });
  Object.defineProperty(exports, "TransitionPresets", {
    enumerable: true,
    get: function () {
      return TransitionPresets;
    }
  });
  Object.defineProperty(exports, "TransitionSpecs", {
    enumerable: true,
    get: function () {
      return TransitionSpecs;
    }
  });
  var _TransitionConfigsSceneStyleInterpolatorsJs = require(_dependencyMap[0], "./TransitionConfigs/SceneStyleInterpolators.js");
  var SceneStyleInterpolators = _interopNamespace(_TransitionConfigsSceneStyleInterpolatorsJs);
  var _TransitionConfigsTransitionPresetsJs = require(_dependencyMap[1], "./TransitionConfigs/TransitionPresets.js");
  var TransitionPresets = _interopNamespace(_TransitionConfigsTransitionPresetsJs);
  var _TransitionConfigsTransitionSpecsJs = require(_dependencyMap[2], "./TransitionConfigs/TransitionSpecs.js");
  var TransitionSpecs = _interopNamespace(_TransitionConfigsTransitionSpecsJs);
  var _navigatorsCreateBottomTabNavigatorJs = require(_dependencyMap[3], "./navigators/createBottomTabNavigator.js");
  var _viewsBottomTabBarJs = require(_dependencyMap[4], "./views/BottomTabBar.js");
  var _viewsBottomTabViewJs = require(_dependencyMap[5], "./views/BottomTabView.js");
  var _utilsBottomTabBarHeightCallbackContextJs = require(_dependencyMap[6], "./utils/BottomTabBarHeightCallbackContext.js");
  var _utilsBottomTabBarHeightContextJs = require(_dependencyMap[7], "./utils/BottomTabBarHeightContext.js");
  var _utilsUseBottomTabBarHeightJs = require(_dependencyMap[8], "./utils/useBottomTabBarHeight.js");
},394,[395,396,397,398,454,399,451,452,491],"node_modules/@react-navigation/bottom-tabs/lib/module/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Simple cross fade animation
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.forFade = forFade;
  exports.forShift = forShift;
  function forFade({
    current
  }) {
    return {
      sceneStyle: {
        opacity: current.progress.interpolate({
          inputRange: [-1, 0, 1],
          outputRange: [0, 1, 0]
        })
      }
    };
  }

  /**
   * Animation where the screens slightly shift to left/right
   */
  function forShift({
    current
  }) {
    return {
      sceneStyle: {
        opacity: current.progress.interpolate({
          inputRange: [-1, 0, 1],
          outputRange: [0, 1, 0]
        }),
        transform: [{
          translateX: current.progress.interpolate({
            inputRange: [-1, 0, 1],
            outputRange: [-50, 0, 50]
          })
        }]
      }
    };
  }
},395,[],"node_modules/@react-navigation/bottom-tabs/lib/module/TransitionConfigs/SceneStyleInterpolators.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "FadeTransition", {
    enumerable: true,
    get: function () {
      return FadeTransition;
    }
  });
  Object.defineProperty(exports, "ShiftTransition", {
    enumerable: true,
    get: function () {
      return ShiftTransition;
    }
  });
  var _SceneStyleInterpolatorsJs = require(_dependencyMap[0], "./SceneStyleInterpolators.js");
  var _TransitionSpecsJs = require(_dependencyMap[1], "./TransitionSpecs.js");
  const FadeTransition = {
    transitionSpec: _TransitionSpecsJs.FadeSpec,
    sceneStyleInterpolator: _SceneStyleInterpolatorsJs.forFade
  };
  const ShiftTransition = {
    transitionSpec: _TransitionSpecsJs.ShiftSpec,
    sceneStyleInterpolator: _SceneStyleInterpolatorsJs.forShift
  };
},396,[395,397],"node_modules/@react-navigation/bottom-tabs/lib/module/TransitionConfigs/TransitionPresets.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "FadeSpec", {
    enumerable: true,
    get: function () {
      return FadeSpec;
    }
  });
  Object.defineProperty(exports, "ShiftSpec", {
    enumerable: true,
    get: function () {
      return ShiftSpec;
    }
  });
  var _reactNativeWebDistExportsEasing = require(_dependencyMap[0], "react-native-web/dist/exports/Easing");
  var Easing = _interopDefault(_reactNativeWebDistExportsEasing);
  const FadeSpec = {
    animation: 'timing',
    config: {
      duration: 150,
      easing: Easing.default.in(Easing.default.linear)
    }
  };
  const ShiftSpec = {
    animation: 'timing',
    config: {
      duration: 150,
      easing: Easing.default.inOut(Easing.default.ease)
    }
  };
},397,[235],"node_modules/@react-navigation/bottom-tabs/lib/module/TransitionConfigs/TransitionSpecs.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["id", "initialRouteName", "backBehavior", "UNSTABLE_routeNamesChangeBehavior", "children", "layout", "screenListeners", "screenOptions", "screenLayout", "UNSTABLE_router"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.createBottomTabNavigator = createBottomTabNavigator;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _viewsBottomTabViewJs = require(_dependencyMap[2], "../views/BottomTabView.js");
  var _reactJsxRuntime = require(_dependencyMap[3], "react/jsx-runtime");
  function BottomTabNavigator(_ref) {
    let {
        id,
        initialRouteName,
        backBehavior,
        UNSTABLE_routeNamesChangeBehavior,
        children,
        layout,
        screenListeners,
        screenOptions,
        screenLayout,
        UNSTABLE_router
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const {
      state,
      descriptors,
      navigation,
      NavigationContent
    } = (0, _reactNavigationNative.useNavigationBuilder)(_reactNavigationNative.TabRouter, {
      id,
      initialRouteName,
      backBehavior,
      UNSTABLE_routeNamesChangeBehavior,
      children,
      layout,
      screenListeners,
      screenOptions,
      screenLayout,
      UNSTABLE_router
    });
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(NavigationContent, {
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_viewsBottomTabViewJs.BottomTabView, Object.assign({}, rest, {
        state: state,
        navigation: navigation,
        descriptors: descriptors
      }))
    });
  }
  function createBottomTabNavigator(config) {
    return (0, _reactNavigationNative.createNavigatorFactory)(BottomTabNavigator)(config);
  }
},398,[759,253,399,274],"node_modules/@react-navigation/bottom-tabs/lib/module/navigators/createBottomTabNavigator.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.BottomTabView = BottomTabView;
  var _reactNavigationElements = require(_dependencyMap[0], "@react-navigation/elements");
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[3], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[4], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeSafeAreaContext = require(_dependencyMap[6], "react-native-safe-area-context");
  var _TransitionConfigsTransitionPresetsJs = require(_dependencyMap[7], "../TransitionConfigs/TransitionPresets.js");
  var _utilsBottomTabBarHeightCallbackContextJs = require(_dependencyMap[8], "../utils/BottomTabBarHeightCallbackContext.js");
  var _utilsBottomTabBarHeightContextJs = require(_dependencyMap[9], "../utils/BottomTabBarHeightContext.js");
  var _utilsUseAnimatedHashMapJs = require(_dependencyMap[10], "../utils/useAnimatedHashMap.js");
  var _BottomTabBarJs = require(_dependencyMap[11], "./BottomTabBar.js");
  var _ScreenFallbackJs = require(_dependencyMap[12], "./ScreenFallback.js");
  var _reactJsxRuntime = require(_dependencyMap[13], "react/jsx-runtime");
  const EPSILON = 1e-5;
  const STATE_INACTIVE = 0;
  const STATE_TRANSITIONING_OR_BELOW_TOP = 1;
  const STATE_ON_TOP = 2;
  const NAMED_TRANSITIONS_PRESETS = {
    fade: _TransitionConfigsTransitionPresetsJs.FadeTransition,
    shift: _TransitionConfigsTransitionPresetsJs.ShiftTransition,
    none: {
      sceneStyleInterpolator: undefined,
      transitionSpec: {
        animation: 'timing',
        config: {
          duration: 0
        }
      }
    }
  };
  const useNativeDriver = Platform.default.OS !== 'web';
  const hasAnimation = options => {
    const {
      animation,
      transitionSpec
    } = options;
    if (animation) {
      return animation !== 'none';
    }
    return Boolean(transitionSpec);
  };
  const renderTabBarDefault = props => /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_BottomTabBarJs.BottomTabBar, Object.assign({}, props));
  function BottomTabView(props) {
    const {
      tabBar = renderTabBarDefault,
      state,
      navigation,
      descriptors,
      safeAreaInsets,
      detachInactiveScreens = Platform.default.OS === 'web' || Platform.default.OS === 'android' || Platform.default.OS === 'ios'
    } = props;
    const focusedRouteKey = state.routes[state.index].key;

    /**
     * List of loaded tabs, tabs will be loaded when navigated to.
     */
    const [loaded, setLoaded] = React.useState([focusedRouteKey]);
    if (!loaded.includes(focusedRouteKey)) {
      // Set the current tab to be loaded if it was not loaded before
      setLoaded([...loaded, focusedRouteKey]);
    }
    const previousRouteKeyRef = React.useRef(focusedRouteKey);
    const tabAnims = (0, _utilsUseAnimatedHashMapJs.useAnimatedHashMap)(state);
    React.useEffect(() => {
      const previousRouteKey = previousRouteKeyRef.current;
      let popToTopAction;
      if (previousRouteKey !== focusedRouteKey && descriptors[previousRouteKey]?.options.popToTopOnBlur) {
        const prevRoute = state.routes.find(route => route.key === previousRouteKey);
        if (prevRoute?.state?.type === 'stack' && prevRoute.state.key) {
          popToTopAction = Object.assign({}, _reactNavigationNative.StackActions.popToTop(), {
            target: prevRoute.state.key
          });
        }
      }
      const animateToIndex = () => {
        if (previousRouteKey !== focusedRouteKey) {
          navigation.emit({
            type: 'transitionStart',
            target: focusedRouteKey
          });
        }
        Animated.default.parallel(state.routes.map((route, index) => {
          const {
            options
          } = descriptors[route.key];
          const {
            animation = 'none',
            transitionSpec = NAMED_TRANSITIONS_PRESETS[animation].transitionSpec
          } = options;
          let spec = transitionSpec;
          if (route.key !== previousRouteKey && route.key !== focusedRouteKey) {
            // Don't animate if the screen is not previous one or new one
            // This will avoid flicker for screens not involved in the transition
            spec = NAMED_TRANSITIONS_PRESETS.none.transitionSpec;
          }
          spec = spec ?? NAMED_TRANSITIONS_PRESETS.none.transitionSpec;
          const toValue = index === state.index ? 0 : index >= state.index ? 1 : -1;
          return Animated.default[spec.animation](tabAnims[route.key], Object.assign({}, spec.config, {
            toValue,
            useNativeDriver
          }));
        }).filter(Boolean)).start(({
          finished
        }) => {
          if (finished && popToTopAction) {
            navigation.dispatch(popToTopAction);
          }
          if (previousRouteKey !== focusedRouteKey) {
            navigation.emit({
              type: 'transitionEnd',
              target: focusedRouteKey
            });
          }
        });
      };
      animateToIndex();
      previousRouteKeyRef.current = focusedRouteKey;
    }, [descriptors, focusedRouteKey, navigation, state.index, state.routes, tabAnims]);
    const dimensions = _reactNavigationElements.SafeAreaProviderCompat.initialMetrics.frame;
    const [tabBarHeight, setTabBarHeight] = React.useState(() => (0, _BottomTabBarJs.getTabBarHeight)({
      state,
      descriptors,
      dimensions,
      insets: Object.assign({}, _reactNavigationElements.SafeAreaProviderCompat.initialMetrics.insets, props.safeAreaInsets),
      style: descriptors[state.routes[state.index].key].options.tabBarStyle
    }));
    const renderTabBar = () => {
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNativeSafeAreaContext.SafeAreaInsetsContext.Consumer, {
        children: insets => tabBar({
          state: state,
          descriptors: descriptors,
          navigation: navigation,
          insets: {
            top: safeAreaInsets?.top ?? insets?.top ?? 0,
            right: safeAreaInsets?.right ?? insets?.right ?? 0,
            bottom: safeAreaInsets?.bottom ?? insets?.bottom ?? 0,
            left: safeAreaInsets?.left ?? insets?.left ?? 0
          }
        })
      });
    };
    const {
      routes
    } = state;

    // If there is no animation, we only have 2 states: visible and invisible
    const hasTwoStates = !routes.some(route => hasAnimation(descriptors[route.key].options));
    const {
      tabBarPosition = 'bottom'
    } = descriptors[focusedRouteKey].options;
    const tabBarElement = /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_utilsBottomTabBarHeightCallbackContextJs.BottomTabBarHeightCallbackContext.Provider, {
      value: setTabBarHeight,
      children: renderTabBar()
    }, "tabbar");
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(_reactNavigationElements.SafeAreaProviderCompat, {
      style: {
        flexDirection: tabBarPosition === 'left' || tabBarPosition === 'right' ? 'row' : 'column'
      },
      children: [tabBarPosition === 'top' || tabBarPosition === 'left' ? tabBarElement : null, /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_ScreenFallbackJs.MaybeScreenContainer, {
        enabled: detachInactiveScreens,
        hasTwoStates: hasTwoStates,
        style: styles.screens,
        children: routes.map((route, index) => {
          const descriptor = descriptors[route.key];
          const {
            lazy = true,
            animation = 'none',
            sceneStyleInterpolator = NAMED_TRANSITIONS_PRESETS[animation].sceneStyleInterpolator
          } = descriptor.options;
          const isFocused = state.index === index;
          const isPreloaded = state.preloadedRouteKeys.includes(route.key);
          if (lazy && !loaded.includes(route.key) && !isFocused && !isPreloaded) {
            // Don't render a lazy screen if we've never navigated to it or it wasn't preloaded
            return null;
          }
          const {
            freezeOnBlur,
            header = ({
              layout,
              options
            }) => /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationElements.Header, Object.assign({}, options, {
              layout: layout,
              title: (0, _reactNavigationElements.getHeaderTitle)(options, route.name)
            })),
            headerShown,
            headerStatusBarHeight,
            headerTransparent,
            sceneStyle: customSceneStyle
          } = descriptor.options;
          const {
            sceneStyle
          } = sceneStyleInterpolator?.({
            current: {
              progress: tabAnims[route.key]
            }
          }) ?? {};
          const animationEnabled = hasAnimation(descriptor.options);
          const activityState = isFocused ? STATE_ON_TOP // the screen is on top after the transition
          : animationEnabled // is animation is not enabled, immediately move to inactive state
          ? tabAnims[route.key].interpolate({
            inputRange: [0, 1 - EPSILON, 1],
            outputRange: [STATE_TRANSITIONING_OR_BELOW_TOP,
            // screen visible during transition
            STATE_TRANSITIONING_OR_BELOW_TOP, STATE_INACTIVE // the screen is detached after transition
            ],
            extrapolate: 'extend'
          }) : STATE_INACTIVE;
          return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_ScreenFallbackJs.MaybeScreen, {
            style: [StyleSheet.default.absoluteFill, {
              zIndex: isFocused ? 0 : -1
            }],
            active: activityState,
            enabled: detachInactiveScreens,
            freezeOnBlur: freezeOnBlur,
            shouldFreeze: activityState === STATE_INACTIVE && !isPreloaded,
            children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_utilsBottomTabBarHeightContextJs.BottomTabBarHeightContext.Provider, {
              value: tabBarPosition === 'bottom' ? tabBarHeight : 0,
              children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationElements.Screen, {
                focused: isFocused,
                route: descriptor.route,
                navigation: descriptor.navigation,
                headerShown: headerShown,
                headerStatusBarHeight: headerStatusBarHeight,
                headerTransparent: headerTransparent,
                header: header({
                  layout: dimensions,
                  route: descriptor.route,
                  navigation: descriptor.navigation,
                  options: descriptor.options
                }),
                style: [customSceneStyle, animationEnabled && sceneStyle],
                children: descriptor.render()
              })
            })
          }, route.key);
        })
      }, "screens"), tabBarPosition === 'bottom' || tabBarPosition === 'right' ? tabBarElement : null]
    });
  }
  const styles = StyleSheet.default.create({
    screens: {
      flex: 1,
      overflow: 'hidden'
    }
  });
},399,[400,253,9,166,14,55,423,396,451,452,453,454,459,274],"node_modules/@react-navigation/bottom-tabs/lib/module/views/BottomTabView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "Background", {
    enumerable: true,
    get: function () {
      return _BackgroundJs.Background;
    }
  });
  Object.defineProperty(exports, "Badge", {
    enumerable: true,
    get: function () {
      return _BadgeJs.Badge;
    }
  });
  Object.defineProperty(exports, "Button", {
    enumerable: true,
    get: function () {
      return _ButtonJs.Button;
    }
  });
  Object.defineProperty(exports, "getDefaultSidebarWidth", {
    enumerable: true,
    get: function () {
      return _getDefaultSidebarWidthJs.getDefaultSidebarWidth;
    }
  });
  Object.defineProperty(exports, "getDefaultHeaderHeight", {
    enumerable: true,
    get: function () {
      return _HeaderGetDefaultHeaderHeightJs.getDefaultHeaderHeight;
    }
  });
  Object.defineProperty(exports, "getHeaderTitle", {
    enumerable: true,
    get: function () {
      return _HeaderGetHeaderTitleJs.getHeaderTitle;
    }
  });
  Object.defineProperty(exports, "Header", {
    enumerable: true,
    get: function () {
      return _HeaderHeaderJs.Header;
    }
  });
  Object.defineProperty(exports, "HeaderBackButton", {
    enumerable: true,
    get: function () {
      return _HeaderHeaderBackButtonJs.HeaderBackButton;
    }
  });
  Object.defineProperty(exports, "HeaderBackContext", {
    enumerable: true,
    get: function () {
      return _HeaderHeaderBackContextJs.HeaderBackContext;
    }
  });
  Object.defineProperty(exports, "HeaderBackground", {
    enumerable: true,
    get: function () {
      return _HeaderHeaderBackgroundJs.HeaderBackground;
    }
  });
  Object.defineProperty(exports, "HeaderButton", {
    enumerable: true,
    get: function () {
      return _HeaderHeaderButtonJs.HeaderButton;
    }
  });
  Object.defineProperty(exports, "HeaderHeightContext", {
    enumerable: true,
    get: function () {
      return _HeaderHeaderHeightContextJs.HeaderHeightContext;
    }
  });
  Object.defineProperty(exports, "HeaderShownContext", {
    enumerable: true,
    get: function () {
      return _HeaderHeaderShownContextJs.HeaderShownContext;
    }
  });
  Object.defineProperty(exports, "HeaderTitle", {
    enumerable: true,
    get: function () {
      return _HeaderHeaderTitleJs.HeaderTitle;
    }
  });
  Object.defineProperty(exports, "useHeaderHeight", {
    enumerable: true,
    get: function () {
      return _HeaderUseHeaderHeightJs.useHeaderHeight;
    }
  });
  Object.defineProperty(exports, "getLabel", {
    enumerable: true,
    get: function () {
      return _LabelGetLabelJs.getLabel;
    }
  });
  Object.defineProperty(exports, "Label", {
    enumerable: true,
    get: function () {
      return _LabelLabelJs.Label;
    }
  });
  Object.defineProperty(exports, "Lazy", {
    enumerable: true,
    get: function () {
      return _LazyJs.Lazy;
    }
  });
  Object.defineProperty(exports, "MissingIcon", {
    enumerable: true,
    get: function () {
      return _MissingIconJs.MissingIcon;
    }
  });
  Object.defineProperty(exports, "PlatformPressable", {
    enumerable: true,
    get: function () {
      return _PlatformPressableJs.PlatformPressable;
    }
  });
  Object.defineProperty(exports, "ResourceSavingView", {
    enumerable: true,
    get: function () {
      return _ResourceSavingViewJs.ResourceSavingView;
    }
  });
  Object.defineProperty(exports, "SafeAreaProviderCompat", {
    enumerable: true,
    get: function () {
      return _SafeAreaProviderCompatJs.SafeAreaProviderCompat;
    }
  });
  Object.defineProperty(exports, "Screen", {
    enumerable: true,
    get: function () {
      return _ScreenJs.Screen;
    }
  });
  Object.defineProperty(exports, "Text", {
    enumerable: true,
    get: function () {
      return _TextJs.Text;
    }
  });
  Object.defineProperty(exports, "useFrameSize", {
    enumerable: true,
    get: function () {
      return _useFrameSizeJs.useFrameSize;
    }
  });
  Object.defineProperty(exports, "Assets", {
    enumerable: true,
    get: function () {
      return Assets;
    }
  });
  var _assetsBackIconPng = require(_dependencyMap[0], "./assets/back-icon.png");
  var backIcon = _interopDefault(_assetsBackIconPng);
  var _assetsBackIconMaskPng = require(_dependencyMap[1], "./assets/back-icon-mask.png");
  var backIconMask = _interopDefault(_assetsBackIconMaskPng);
  var _assetsClearIconPng = require(_dependencyMap[2], "./assets/clear-icon.png");
  var clearIcon = _interopDefault(_assetsClearIconPng);
  var _assetsCloseIconPng = require(_dependencyMap[3], "./assets/close-icon.png");
  var closeIcon = _interopDefault(_assetsCloseIconPng);
  var _assetsSearchIconPng = require(_dependencyMap[4], "./assets/search-icon.png");
  var searchIcon = _interopDefault(_assetsSearchIconPng);
  var _BackgroundJs = require(_dependencyMap[5], "./Background.js");
  var _BadgeJs = require(_dependencyMap[6], "./Badge.js");
  var _ButtonJs = require(_dependencyMap[7], "./Button.js");
  var _getDefaultSidebarWidthJs = require(_dependencyMap[8], "./getDefaultSidebarWidth.js");
  var _HeaderGetDefaultHeaderHeightJs = require(_dependencyMap[9], "./Header/getDefaultHeaderHeight.js");
  var _HeaderGetHeaderTitleJs = require(_dependencyMap[10], "./Header/getHeaderTitle.js");
  var _HeaderHeaderJs = require(_dependencyMap[11], "./Header/Header.js");
  var _HeaderHeaderBackButtonJs = require(_dependencyMap[12], "./Header/HeaderBackButton.js");
  var _HeaderHeaderBackContextJs = require(_dependencyMap[13], "./Header/HeaderBackContext.js");
  var _HeaderHeaderBackgroundJs = require(_dependencyMap[14], "./Header/HeaderBackground.js");
  var _HeaderHeaderButtonJs = require(_dependencyMap[15], "./Header/HeaderButton.js");
  var _HeaderHeaderHeightContextJs = require(_dependencyMap[16], "./Header/HeaderHeightContext.js");
  var _HeaderHeaderShownContextJs = require(_dependencyMap[17], "./Header/HeaderShownContext.js");
  var _HeaderHeaderTitleJs = require(_dependencyMap[18], "./Header/HeaderTitle.js");
  var _HeaderUseHeaderHeightJs = require(_dependencyMap[19], "./Header/useHeaderHeight.js");
  var _LabelGetLabelJs = require(_dependencyMap[20], "./Label/getLabel.js");
  var _LabelLabelJs = require(_dependencyMap[21], "./Label/Label.js");
  var _LazyJs = require(_dependencyMap[22], "./Lazy.js");
  var _MissingIconJs = require(_dependencyMap[23], "./MissingIcon.js");
  var _PlatformPressableJs = require(_dependencyMap[24], "./PlatformPressable.js");
  var _ResourceSavingViewJs = require(_dependencyMap[25], "./ResourceSavingView.js");
  var _SafeAreaProviderCompatJs = require(_dependencyMap[26], "./SafeAreaProviderCompat.js");
  var _ScreenJs = require(_dependencyMap[27], "./Screen.js");
  var _TextJs = require(_dependencyMap[28], "./Text.js");
  var _useFrameSizeJs = require(_dependencyMap[29], "./useFrameSize.js");
  var _typesJs = require(_dependencyMap[30], "./types.js");
  Object.keys(_typesJs).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _typesJs[k];
        }
      });
    }
  });
  const Assets = [backIcon.default, backIconMask.default, searchIcon.default, closeIcon.default, clearIcon.default];
},400,[401,402,403,404,405,406,407,416,419,420,421,422,430,440,434,432,441,437,439,442,443,444,445,446,417,447,448,449,418,429,450],"node_modules/@react-navigation/elements/lib/module/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40react-navigation%2Felements%2Flib%2Fmodule%2Fassets/back-icon.png",
    width: 96,
    height: 96
  };
},401,[],"node_modules/@react-navigation/elements/lib/module/assets/back-icon.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40react-navigation%2Felements%2Flib%2Fmodule%2Fassets/back-icon-mask.png",
    width: 50,
    height: 85
  };
},402,[],"node_modules/@react-navigation/elements/lib/module/assets/back-icon-mask.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40react-navigation%2Felements%2Flib%2Fmodule%2Fassets/clear-icon.png",
    width: 64,
    height: 64
  };
},403,[],"node_modules/@react-navigation/elements/lib/module/assets/clear-icon.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40react-navigation%2Felements%2Flib%2Fmodule%2Fassets/close-icon.png",
    width: 96,
    height: 96
  };
},404,[],"node_modules/@react-navigation/elements/lib/module/assets/close-icon.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40react-navigation%2Felements%2Flib%2Fmodule%2Fassets/search-icon.png",
    width: 96,
    height: 96
  };
},405,[],"node_modules/@react-navigation/elements/lib/module/assets/search-icon.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["style"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.Background = Background;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  require(_dependencyMap[2], "react");
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[3], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactJsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  function Background(_ref) {
    let {
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const {
      colors
    } = (0, _reactNavigationNative.useTheme)();
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Animated.default.View, Object.assign({}, rest, {
      style: [{
        flex: 1,
        backgroundColor: colors.background
      }, style]
    }));
  }
},406,[759,253,9,166,274],"node_modules/@react-navigation/elements/lib/module/Background.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["children", "style", "visible", "size"],
    _excluded2 = ["backgroundColor"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.Badge = Badge;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _color = require(_dependencyMap[2], "color");
  var Color = _interopDefault(_color);
  var _react = require(_dependencyMap[3], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[4], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[5], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[6], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactJsxRuntime = require(_dependencyMap[7], "react/jsx-runtime");
  const useNativeDriver = Platform.default.OS !== 'web';
  function Badge(_ref) {
    let {
        children,
        style,
        visible = true,
        size = 18
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const [opacity] = React.useState(() => new Animated.default.Value(visible ? 1 : 0));
    const [rendered, setRendered] = React.useState(visible);
    const {
      colors,
      fonts
    } = (0, _reactNavigationNative.useTheme)();
    React.useEffect(() => {
      if (!rendered) {
        return;
      }
      Animated.default.timing(opacity, {
        toValue: visible ? 1 : 0,
        duration: 150,
        useNativeDriver
      }).start(({
        finished
      }) => {
        if (finished && !visible) {
          setRendered(false);
        }
      });
      return () => opacity.stopAnimation();
    }, [opacity, rendered, visible]);
    if (!rendered) {
      if (visible) {
        setRendered(true);
      } else {
        return null;
      }
    }

    // @ts-expect-error: backgroundColor definitely exists
    const _ref2 = StyleSheet.default.flatten(style) || {},
      {
        backgroundColor = colors.notification
      } = _ref2,
      restStyle = (0, _objectWithoutPropertiesLoose.default)(_ref2, _excluded2);
    const textColor = (0, Color.default)(backgroundColor).isLight() ? 'black' : 'white';
    const borderRadius = size / 2;
    const fontSize = Math.floor(size * 3 / 4);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Animated.default.Text, Object.assign({
      numberOfLines: 1,
      style: [{
        transform: [{
          scale: opacity.interpolate({
            inputRange: [0, 1],
            outputRange: [0.5, 1]
          })
        }],
        color: textColor,
        lineHeight: size - 1,
        height: size,
        minWidth: size,
        opacity,
        backgroundColor,
        fontSize,
        borderRadius,
        borderCurve: 'continuous'
      }, fonts.regular, styles.container, restStyle]
    }, rest, {
      children: children
    }));
  }
  const styles = StyleSheet.default.create({
    container: {
      alignSelf: 'flex-end',
      textAlign: 'center',
      paddingHorizontal: 4,
      overflow: 'hidden'
    }
  });
},407,[759,253,408,9,166,14,55,274],"node_modules/@react-navigation/elements/lib/module/Badge.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const colorString = require(_dependencyMap[0], "color-string");
  const convert = require(_dependencyMap[1], "color-convert");
  const skippedModels = [
  // To be honest, I don't really feel like keyword belongs in color convert, but eh.
  'keyword',
  // Gray conflicts with some method names, and has its own method defined.
  'gray',
  // Shouldn't really be in color-convert either...
  'hex'];
  const hashedModelKeys = {};
  for (const model of Object.keys(convert)) {
    hashedModelKeys[[...convert[model].labels].sort().join('')] = model;
  }
  const limiters = {};
  function Color(object, model) {
    if (!(this instanceof Color)) {
      return new Color(object, model);
    }
    if (model && model in skippedModels) {
      model = null;
    }
    if (model && !(model in convert)) {
      throw new Error('Unknown model: ' + model);
    }
    let i;
    let channels;
    if (object == null) {
      // eslint-disable-line no-eq-null,eqeqeq
      this.model = 'rgb';
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (object instanceof Color) {
      this.model = object.model;
      this.color = [...object.color];
      this.valpha = object.valpha;
    } else if (typeof object === 'string') {
      const result = colorString.get(object);
      if (result === null) {
        throw new Error('Unable to parse color from string: ' + object);
      }
      this.model = result.model;
      channels = convert[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
    } else if (object.length > 0) {
      this.model = model || 'rgb';
      channels = convert[this.model].channels;
      const newArray = Array.prototype.slice.call(object, 0, channels);
      this.color = zeroArray(newArray, channels);
      this.valpha = typeof object[channels] === 'number' ? object[channels] : 1;
    } else if (typeof object === 'number') {
      // This is always RGB - can be converted later on.
      this.model = 'rgb';
      this.color = [object >> 16 & 0xFF, object >> 8 & 0xFF, object & 0xFF];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      const keys = Object.keys(object);
      if ('alpha' in object) {
        keys.splice(keys.indexOf('alpha'), 1);
        this.valpha = typeof object.alpha === 'number' ? object.alpha : 0;
      }
      const hashedKeys = keys.sort().join('');
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error('Unable to parse color from object: ' + JSON.stringify(object));
      }
      this.model = hashedModelKeys[hashedKeys];
      const {
        labels
      } = convert[this.model];
      const color = [];
      for (i = 0; i < labels.length; i++) {
        color.push(object[labels[i]]);
      }
      this.color = zeroArray(color);
    }

    // Perform limitations (clamping, etc.)
    if (limiters[this.model]) {
      channels = convert[this.model].channels;
      for (i = 0; i < channels; i++) {
        const limit = limiters[this.model][i];
        if (limit) {
          this.color[i] = limit(this.color[i]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  }
  Color.prototype = {
    toString() {
      return this.string();
    },
    toJSON() {
      return this[this.model]();
    },
    string(places) {
      let self = this.model in colorString.to ? this : this.rgb();
      self = self.round(typeof places === 'number' ? places : 1);
      const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
      return colorString.to[self.model](args);
    },
    percentString(places) {
      const self = this.rgb().round(typeof places === 'number' ? places : 1);
      const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
      return colorString.to.rgb.percent(args);
    },
    array() {
      return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
    },
    object() {
      const result = {};
      const {
        channels
      } = convert[this.model];
      const {
        labels
      } = convert[this.model];
      for (let i = 0; i < channels; i++) {
        result[labels[i]] = this.color[i];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray() {
      const rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject() {
      const rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round(places) {
      places = Math.max(places || 0, 0);
      return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
    },
    alpha(value) {
      if (value !== undefined) {
        return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
      }
      return this.valpha;
    },
    // Rgb
    red: getset('rgb', 0, maxfn(255)),
    green: getset('rgb', 1, maxfn(255)),
    blue: getset('rgb', 2, maxfn(255)),
    hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => (value % 360 + 360) % 360),
    saturationl: getset('hsl', 1, maxfn(100)),
    lightness: getset('hsl', 2, maxfn(100)),
    saturationv: getset('hsv', 1, maxfn(100)),
    value: getset('hsv', 2, maxfn(100)),
    chroma: getset('hcg', 1, maxfn(100)),
    gray: getset('hcg', 2, maxfn(100)),
    white: getset('hwb', 1, maxfn(100)),
    wblack: getset('hwb', 2, maxfn(100)),
    cyan: getset('cmyk', 0, maxfn(100)),
    magenta: getset('cmyk', 1, maxfn(100)),
    yellow: getset('cmyk', 2, maxfn(100)),
    black: getset('cmyk', 3, maxfn(100)),
    x: getset('xyz', 0, maxfn(95.047)),
    y: getset('xyz', 1, maxfn(100)),
    z: getset('xyz', 2, maxfn(108.833)),
    l: getset('lab', 0, maxfn(100)),
    a: getset('lab', 1),
    b: getset('lab', 2),
    keyword(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      return convert[this.model].keyword(this.color);
    },
    hex(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      return colorString.to.hex(this.rgb().round().color);
    },
    hexa(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      const rgbArray = this.rgb().round().color;
      let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
      if (alphaHex.length === 1) {
        alphaHex = '0' + alphaHex;
      }
      return colorString.to.hex(rgbArray) + alphaHex;
    },
    rgbNumber() {
      const rgb = this.rgb().color;
      return (rgb[0] & 0xFF) << 16 | (rgb[1] & 0xFF) << 8 | rgb[2] & 0xFF;
    },
    luminosity() {
      // http://www.w3.org/TR/WCAG20/#relativeluminancedef
      const rgb = this.rgb().color;
      const lum = [];
      for (const [i, element] of rgb.entries()) {
        const chan = element / 255;
        lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast(color2) {
      // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
      const lum1 = this.luminosity();
      const lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level(color2) {
      // https://www.w3.org/TR/WCAG/#contrast-enhanced
      const contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7) {
        return 'AAA';
      }
      return contrastRatio >= 4.5 ? 'AA' : '';
    },
    isDark() {
      // YIQ equation from http://24ways.org/2010/calculating-color-contrast
      const rgb = this.rgb().color;
      const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 10000;
      return yiq < 128;
    },
    isLight() {
      return !this.isDark();
    },
    negate() {
      const rgb = this.rgb();
      for (let i = 0; i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }
      return rgb;
    },
    lighten(ratio) {
      const hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken(ratio) {
      const hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten(ratio) {
      const hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken(ratio) {
      const hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale() {
      // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
      const rgb = this.rgb().color;
      const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(value, value, value);
    },
    fade(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate(degrees) {
      const hsl = this.hsl();
      let hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix(mixinColor, weight) {
      // Ported from sass implementation in C
      // https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      const color1 = mixinColor.rgb();
      const color2 = this.rgb();
      const p = weight === undefined ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = color1.alpha() - color2.alpha();
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      const w2 = 1 - w1;
      return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
    }
  };

  // Model conversion methods and static constructors
  for (const model of Object.keys(convert)) {
    if (skippedModels.includes(model)) {
      continue;
    }
    const {
      channels
    } = convert[model];

    // Conversion methods
    Color.prototype[model] = function (...args) {
      if (this.model === model) {
        return new Color(this);
      }
      if (args.length > 0) {
        return new Color(args, model);
      }
      return new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
    };

    // 'static' construction methods
    Color[model] = function (...args) {
      let color = args[0];
      if (typeof color === 'number') {
        color = zeroArray(args, channels);
      }
      return new Color(color, model);
    };
  }
  function roundTo(number, places) {
    return Number(number.toFixed(places));
  }
  function roundToPlace(places) {
    return function (number) {
      return roundTo(number, places);
    };
  }
  function getset(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    for (const m of model) {
      (limiters[m] || (limiters[m] = []))[channel] = modifier;
    }
    model = model[0];
    return function (value) {
      let result;
      if (value !== undefined) {
        if (modifier) {
          value = modifier(value);
        }
        result = this[model]();
        result.color[channel] = value;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  }
  function maxfn(max) {
    return function (v) {
      return Math.max(0, Math.min(max, v));
    };
  }
  function assertArray(value) {
    return Array.isArray(value) ? value : [value];
  }
  function zeroArray(array, length) {
    for (let i = 0; i < length; i++) {
      if (typeof array[i] !== 'number') {
        array[i] = 0;
      }
    }
    return array;
  }
  module.exports = Color;
},408,[409,413],"node_modules/color/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /* MIT license */
  var colorNames = require(_dependencyMap[0], "color-name");
  var swizzle = require(_dependencyMap[1], "simple-swizzle");
  var hasOwnProperty = Object.hasOwnProperty;
  var reverseNames = Object.create(null);

  // create a list of reverse color names
  for (var name in colorNames) {
    if (hasOwnProperty.call(colorNames, name)) {
      reverseNames[colorNames[name]] = name;
    }
  }
  var cs = module.exports = {
    to: {},
    get: {}
  };
  cs.get = function (string) {
    var prefix = string.substring(0, 3).toLowerCase();
    var val;
    var model;
    switch (prefix) {
      case 'hsl':
        val = cs.get.hsl(string);
        model = 'hsl';
        break;
      case 'hwb':
        val = cs.get.hwb(string);
        model = 'hwb';
        break;
      default:
        val = cs.get.rgb(string);
        model = 'rgb';
        break;
    }
    if (!val) {
      return null;
    }
    return {
      model: model,
      value: val
    };
  };
  cs.get.rgb = function (string) {
    if (!string) {
      return null;
    }
    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match;
    var i;
    var hexAlpha;
    if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];
      for (i = 0; i < 3; i++) {
        // https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
        var i2 = i * 2;
        rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match = string.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];
      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match = string.match(rgba)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match[i + 1], 0);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(per)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(keyword)) {
      if (match[1] === 'transparent') {
        return [0, 0, 0, 0];
      }
      if (!hasOwnProperty.call(colorNames, match[1])) {
        return null;
      }
      rgb = colorNames[match[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i = 0; i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function (string) {
    if (!string) {
      return null;
    }
    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hsl);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var s = clamp(parseFloat(match[2]), 0, 100);
      var l = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }
    return null;
  };
  cs.get.hwb = function (string) {
    if (!string) {
      return null;
    }
    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hwb);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var w = clamp(parseFloat(match[2]), 0, 100);
      var b = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }
    return null;
  };
  cs.to.hex = function () {
    var rgba = swizzle(arguments);
    return '#' + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : '');
  };
  cs.to.rgb = function () {
    var rgba = swizzle(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')' : 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
  };
  cs.to.rgb.percent = function () {
    var rgba = swizzle(arguments);
    var r = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)' : 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
  };
  cs.to.hsl = function () {
    var hsla = swizzle(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)' : 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
  };

  // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
  // (hwb have alpha optional & 1 is default value)
  cs.to.hwb = function () {
    var hwba = swizzle(arguments);
    var a = '';
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ', ' + hwba[3];
    }
    return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
  };
  cs.to.keyword = function (rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };

  // helpers
  function clamp(num, min, max) {
    return Math.min(Math.max(min, num), max);
  }
  function hexDouble(num) {
    var str = Math.round(num).toString(16).toUpperCase();
    return str.length < 2 ? '0' + str : str;
  }
},409,[410,411],"node_modules/color-string/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
},410,[],"node_modules/color-name/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var isArrayish = require(_dependencyMap[0], "is-arrayish");
  var concat = Array.prototype.concat;
  var slice = Array.prototype.slice;
  var swizzle = module.exports = function swizzle(args) {
    var results = [];
    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (isArrayish(arg)) {
        // http://jsperf.com/javascript-array-concat-vs-push/98
        results = concat.call(results, slice.call(arg));
      } else {
        results.push(arg);
      }
    }
    return results;
  };
  swizzle.wrap = function (fn) {
    return function () {
      return fn(swizzle(arguments));
    };
  };
},411,[412],"node_modules/simple-swizzle/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = function isArrayish(obj) {
    if (!obj || typeof obj === 'string') {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== 'String');
  };
},412,[],"node_modules/is-arrayish/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const conversions = require(_dependencyMap[0], "./conversions");
  const route = require(_dependencyMap[1], "./route");
  const convert = {};
  const models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function (...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };

    // Preserve .conversion property if there is one
    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function (...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);

      // We're assuming the result is an array here.
      // see notice in conversions.js; don't use box types
      // in conversion functions.
      if (typeof result === 'object') {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };

    // Preserve .conversion property if there is one
    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach(fromModel => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
      value: conversions[fromModel].channels
    });
    Object.defineProperty(convert[fromModel], 'labels', {
      value: conversions[fromModel].labels
    });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach(toModel => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
},413,[414,415],"node_modules/color-convert/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /* MIT license */
  /* eslint-disable no-mixed-operators */
  const cssKeywords = require(_dependencyMap[0], "color-name");

  // NOTE: conversions should only return primitive values (i.e. arrays, or
  //       values that give correct `typeof` results).
  //       do not use box values types (i.e. Number(), String(), etc.)

  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert = {
    rgb: {
      channels: 3,
      labels: 'rgb'
    },
    hsl: {
      channels: 3,
      labels: 'hsl'
    },
    hsv: {
      channels: 3,
      labels: 'hsv'
    },
    hwb: {
      channels: 3,
      labels: 'hwb'
    },
    cmyk: {
      channels: 4,
      labels: 'cmyk'
    },
    xyz: {
      channels: 3,
      labels: 'xyz'
    },
    lab: {
      channels: 3,
      labels: 'lab'
    },
    lch: {
      channels: 3,
      labels: 'lch'
    },
    hex: {
      channels: 1,
      labels: ['hex']
    },
    keyword: {
      channels: 1,
      labels: ['keyword']
    },
    ansi16: {
      channels: 1,
      labels: ['ansi16']
    },
    ansi256: {
      channels: 1,
      labels: ['ansi256']
    },
    hcg: {
      channels: 3,
      labels: ['h', 'c', 'g']
    },
    apple: {
      channels: 3,
      labels: ['r16', 'g16', 'b16']
    },
    gray: {
      channels: 1,
      labels: ['gray']
    }
  };
  module.exports = convert;

  // Hide .channels and .labels properties
  for (const model of Object.keys(convert)) {
    if (!('channels' in convert[model])) {
      throw new Error('missing channels property: ' + model);
    }
    if (!('labels' in convert[model])) {
      throw new Error('missing channel labels property: ' + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error('channel and label counts mismatch: ' + model);
    }
    const {
      channels,
      labels
    } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], 'channels', {
      value: channels
    });
    Object.defineProperty(convert[model], 'labels', {
      value: labels
    });
  }
  convert.rgb.hsl = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function (rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function (c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [h * 360, s * 100, v * 100];
  };
  convert.rgb.hwb = function (rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    /*
    	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
    */
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert.rgb.keyword = function (rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];

      // Compute comparative distance
      const distance = comparativeDistance(rgb, value);

      // Check if its less, if so set as closest
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function (keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function (rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;

    // Assume sRGB
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function (rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function (hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function (hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function (hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function (hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };

  // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
  convert.hwb.rgb = function (hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;

    // Wh + bl cant be > 1
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 0x01) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh); // Linear interpolation

    let r;
    let g;
    let b;
    /* eslint-disable max-statements-per-line,no-multi-spaces */
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    /* eslint-enable max-statements-per-line,no-multi-spaces */

    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function (cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function (xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570;

    // Assume sRGB
    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function (xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function (lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function (args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function (args) {
    // Optimization here; we already know the value and don't need to get
    // it converted for us.
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function (args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];

    // We use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function (args) {
    let color = args % 10;

    // Handle greyscale
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function (args) {
    // Handle greyscale
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function (args) {
    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };
  convert.hex.rgb = function (args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split('').map(char => {
        return char + char;
      }).join('');
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 0xFF;
    const g = integer >> 8 & 0xFF;
    const b = integer & 0xFF;
    return [r, g, b];
  };
  convert.rgb.hcg = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function (hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
    let f = 0;
    if (c < 1.0) {
      f = (l - 0.5 * c) / (1.0 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function (hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1.0) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function (hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0.0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;

    /* eslint-disable max-statements-per-line */
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    /* eslint-enable max-statements-per-line */

    mg = (1.0 - c) * g;
    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
  };
  convert.hcg.hsv = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    let f = 0;
    if (v > 0.0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1.0 - c) + 0.5 * c;
    let s = 0;
    if (l > 0.0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function (hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function (apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function (rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function (args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function (args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function (gray) {
    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };
  convert.rgb.gray = function (rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
},414,[410],"node_modules/color-convert/conversions.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const conversions = require(_dependencyMap[0], "./conversions");

  /*
  	This function routes a model to all other models.
  
  	all functions that are routed have a property `.conversion` attached
  	to the returned synthetic function. This property is an array
  	of strings, each with the steps in between the 'from' and 'to'
  	color models (inclusive).
  
  	conversions that are not possible simply are not included.
  */

  function buildGraph() {
    const graph = {};
    // https://jsperf.com/object-keys-vs-for-in-with-closure/3
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }
    return graph;
  }

  // https://en.wikipedia.org/wiki/Breadth-first_search
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel]; // Unshift -> queue -> pop

    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  module.exports = function (fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        // No possible conversion, or this node is the source model.
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
},415,[414],"node_modules/color-convert/route.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["screen", "params", "action", "href"],
    _excluded2 = ["variant", "color", "android_ripple", "style", "children"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.Button = Button;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _color = require(_dependencyMap[2], "color");
  var Color = _interopDefault(_color);
  require(_dependencyMap[3], "react");
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[4], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _PlatformPressableJs = require(_dependencyMap[6], "./PlatformPressable.js");
  var _TextJs = require(_dependencyMap[7], "./Text.js");
  var _reactJsxRuntime = require(_dependencyMap[8], "react/jsx-runtime");
  const BUTTON_RADIUS = 40;
  function Button(props) {
    if ('screen' in props || 'action' in props) {
      // @ts-expect-error: This is already type-checked by the prop types
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(ButtonLink, Object.assign({}, props));
    } else {
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(ButtonBase, Object.assign({}, props));
    }
  }
  function ButtonLink(_ref) {
    let {
        screen,
        params,
        action,
        href
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    // @ts-expect-error: This is already type-checked by the prop types
    const props = (0, _reactNavigationNative.useLinkProps)({
      screen,
      params,
      action,
      href
    });
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(ButtonBase, Object.assign({}, rest, props));
  }
  function ButtonBase(_ref2) {
    let {
        variant = 'tinted',
        color: customColor,
        android_ripple,
        style,
        children
      } = _ref2,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref2, _excluded2);
    const {
      colors,
      fonts
    } = (0, _reactNavigationNative.useTheme)();
    const color = customColor ?? colors.primary;
    let backgroundColor;
    let textColor;
    switch (variant) {
      case 'plain':
        backgroundColor = 'transparent';
        textColor = color;
        break;
      case 'tinted':
        backgroundColor = (0, Color.default)(color).fade(0.85).string();
        textColor = color;
        break;
      case 'filled':
        backgroundColor = color;
        textColor = (0, Color.default)(color).isDark() ? 'white' : (0, Color.default)(color).darken(0.71).string();
        break;
    }
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_PlatformPressableJs.PlatformPressable, Object.assign({}, rest, {
      android_ripple: Object.assign({
        radius: BUTTON_RADIUS,
        color: (0, Color.default)(textColor).fade(0.85).string()
      }, android_ripple),
      pressOpacity: Platform.default.OS === 'ios' ? undefined : 1,
      hoverEffect: {
        color: textColor
      },
      style: [{
        backgroundColor
      }, styles.button, style],
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_TextJs.Text, {
        style: [{
          color: textColor
        }, fonts.regular, styles.text],
        children: children
      })
    }));
  }
  const styles = StyleSheet.default.create({
    button: {
      paddingHorizontal: 24,
      paddingVertical: 10,
      borderRadius: BUTTON_RADIUS,
      borderCurve: 'continuous'
    },
    text: {
      fontSize: 14,
      lineHeight: 20,
      letterSpacing: 0.1,
      textAlign: 'center'
    }
  });
},416,[759,253,408,9,14,55,417,418,274],"node_modules/@react-navigation/elements/lib/module/Button.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["disabled", "onPress", "onPressIn", "onPressOut", "android_ripple", "pressColor", "pressOpacity", "hoverEffect", "style", "children"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "PlatformPressable", {
    enumerable: true,
    get: function () {
      return PlatformPressable;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[3], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsEasing = require(_dependencyMap[4], "react-native-web/dist/exports/Easing");
  var Easing = _interopDefault(_reactNativeWebDistExportsEasing);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[5], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsPressable = require(_dependencyMap[6], "react-native-web/dist/exports/Pressable");
  var Pressable = _interopDefault(_reactNativeWebDistExportsPressable);
  var _reactJsxRuntime = require(_dependencyMap[7], "react/jsx-runtime");
  const AnimatedPressable = Animated.default.createAnimatedComponent(Pressable.default);
  const ANDROID_VERSION_LOLLIPOP = 21;
  const ANDROID_SUPPORTS_RIPPLE = Platform.default.OS === 'android' && Platform.default.Version >= ANDROID_VERSION_LOLLIPOP;
  const useNativeDriver = Platform.default.OS !== 'web';

  /**
   * PlatformPressable provides an abstraction on top of Pressable to handle platform differences.
   */
  function PlatformPressableInternal(_ref, ref) {
    let {
        disabled,
        onPress,
        onPressIn,
        onPressOut,
        android_ripple,
        pressColor,
        pressOpacity = 0.3,
        hoverEffect,
        style,
        children
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const {
      dark
    } = (0, _reactNavigationNative.useTheme)();
    const [opacity] = React.useState(() => new Animated.default.Value(1));
    const animateTo = (toValue, duration) => {
      if (ANDROID_SUPPORTS_RIPPLE) {
        return;
      }
      Animated.default.timing(opacity, {
        toValue,
        duration,
        easing: Easing.default.inOut(Easing.default.quad),
        useNativeDriver
      }).start();
    };
    const handlePress = e => {
      if (Platform.default.OS === 'web' && rest.href !== null) {
        // ignore clicks with modifier keys
        const hasModifierKey = 'metaKey' in e && e.metaKey || 'altKey' in e && e.altKey || 'ctrlKey' in e && e.ctrlKey || 'shiftKey' in e && e.shiftKey;

        // only handle left clicks
        const isLeftClick = 'button' in e ? e.button == null || e.button === 0 : true;

        // let browser handle "target=_blank" etc.
        const isSelfTarget = e.currentTarget && 'target' in e.currentTarget ? [undefined, null, '', 'self'].includes(e.currentTarget.target) : true;
        if (!hasModifierKey && isLeftClick && isSelfTarget) {
          e.preventDefault();
          // call `onPress` only when browser default is prevented
          // this prevents app from handling the click when a link is being opened
          onPress?.(e);
        }
      } else {
        onPress?.(e);
      }
    };
    const handlePressIn = e => {
      animateTo(pressOpacity, 0);
      onPressIn?.(e);
    };
    const handlePressOut = e => {
      animateTo(1, 200);
      onPressOut?.(e);
    };
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(AnimatedPressable, Object.assign({
      ref: ref,
      accessible: true,
      role: Platform.default.OS === 'web' && rest.href != null ? 'link' : 'button',
      onPress: disabled ? undefined : handlePress,
      onPressIn: disabled ? undefined : handlePressIn,
      onPressOut: disabled ? undefined : handlePressOut,
      android_ripple: ANDROID_SUPPORTS_RIPPLE && !disabled ? Object.assign({
        color: pressColor !== undefined ? pressColor : dark ? 'rgba(255, 255, 255, .32)' : 'rgba(0, 0, 0, .32)'
      }, android_ripple) : undefined,
      style: [{
        cursor: (Platform.default.OS === 'web' || Platform.default.OS === 'ios') && !disabled ?
        // Pointer cursor on web
        // Hover effect on iPad and visionOS
        'pointer' : 'auto',
        opacity: !ANDROID_SUPPORTS_RIPPLE && !disabled ? opacity : 1
      }, style]
    }, rest, {
      children: [!disabled ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(HoverEffect, Object.assign({}, hoverEffect)) : null, children]
    }));
  }
  const PlatformPressable = /*#__PURE__*/React.forwardRef(PlatformPressableInternal);
  PlatformPressable.displayName = 'PlatformPressable';
  const css = String.raw;
  const CLASS_NAME = `__react-navigation_elements_Pressable_hover`;
  const CSS_TEXT = css`
  .${CLASS_NAME} {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: inherit;
    background-color: var(--overlay-color);
    opacity: 0;
    transition: opacity 0.15s;
    pointer-events: none;
  }

  a:hover > .${CLASS_NAME}, button:hover > .${CLASS_NAME} {
    opacity: var(--overlay-hover-opacity);
  }

  a:active > .${CLASS_NAME}, button:active > .${CLASS_NAME} {
    opacity: var(--overlay-active-opacity);
  }
`;
  const HoverEffect = ({
    color,
    hoverOpacity = 0.08,
    activeOpacity = 0.16
  }) => {
    if (Platform.default.OS !== 'web' || color == null) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(_reactJsxRuntime.Fragment, {
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("style", {
        href: CLASS_NAME,
        precedence: "elements",
        children: CSS_TEXT
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
        className: CLASS_NAME,
        style: {
          // @ts-expect-error: CSS variables are not typed
          '--overlay-color': color,
          '--overlay-hover-opacity': hoverOpacity,
          '--overlay-active-opacity': activeOpacity
        }
      })]
    });
  };
},417,[759,253,9,166,235,14,143,274],"node_modules/@react-navigation/elements/lib/module/PlatformPressable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["style"]; // eslint-disable-next-line no-restricted-imports
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.Text = Text;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _reactNativeWebDistExportsText = require(_dependencyMap[2], "react-native-web/dist/exports/Text");
  var NativeText = _interopDefault(_reactNativeWebDistExportsText);
  var _reactJsxRuntime = require(_dependencyMap[3], "react/jsx-runtime");
  function Text(_ref) {
    let {
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const {
      colors,
      fonts
    } = (0, _reactNavigationNative.useTheme)();
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(NativeText.default, Object.assign({}, rest, {
      style: [{
        color: colors.text
      }, fonts.regular, style]
    }));
  }
},418,[759,253,138,274],"node_modules/@react-navigation/elements/lib/module/Text.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "getDefaultSidebarWidth", {
    enumerable: true,
    get: function () {
      return getDefaultSidebarWidth;
    }
  });
  const APPROX_APP_BAR_HEIGHT = 56;
  const DEFAULT_DRAWER_WIDTH = 360;
  const getDefaultSidebarWidth = ({
    width
  }) => {
    /**
     * Default sidebar width is 360dp
     * On screens smaller than 320dp, ideally the drawer would collapse to a tab bar
     * https://m3.material.io/components/navigation-drawer/specs
     */
    if (width - APPROX_APP_BAR_HEIGHT <= 360) {
      return width - APPROX_APP_BAR_HEIGHT;
    }
    return DEFAULT_DRAWER_WIDTH;
  };
},419,[],"node_modules/@react-navigation/elements/lib/module/getDefaultSidebarWidth.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.getDefaultHeaderHeight = getDefaultHeaderHeight;
  var _reactNativeWebDistExportsPixelRatio = require(_dependencyMap[0], "react-native-web/dist/exports/PixelRatio");
  var PixelRatio = _interopDefault(_reactNativeWebDistExportsPixelRatio);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[1], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  function getDefaultHeaderHeight(layout, modalPresentation, topInset) {
    let headerHeight;

    // On models with Dynamic Island the status bar height is smaller than the safe area top inset.
    const hasDynamicIsland = Platform.default.OS === 'ios' && topInset > 50;
    const statusBarHeight = hasDynamicIsland ? topInset - (5 + 1 / PixelRatio.default.get()) : topInset;
    const isLandscape = layout.width > layout.height;
    if (Platform.default.OS === 'ios') {
      if (Platform.default.isPad || Platform.default.isTV) {
        if (modalPresentation) {
          headerHeight = 56;
        } else {
          headerHeight = 50;
        }
      } else {
        if (isLandscape) {
          headerHeight = 32;
        } else {
          if (modalPresentation) {
            headerHeight = 56;
          } else {
            headerHeight = 44;
          }
        }
      }
    } else {
      headerHeight = 64;
    }
    return headerHeight + statusBarHeight;
  }
},420,[158,14],"node_modules/@react-navigation/elements/lib/module/Header/getDefaultHeaderHeight.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.getHeaderTitle = getHeaderTitle;
  function getHeaderTitle(options, fallback) {
    return typeof options.headerTitle === 'string' ? options.headerTitle : options.title !== undefined ? options.title : fallback;
  }
},421,[],"node_modules/@react-navigation/elements/lib/module/Header/getHeaderTitle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["height", "maxHeight", "minHeight", "backfaceVisibility", "backgroundColor", "borderBlockColor", "borderBlockEndColor", "borderBlockStartColor", "borderBottomColor", "borderBottomEndRadius", "borderBottomLeftRadius", "borderBottomRightRadius", "borderBottomStartRadius", "borderBottomWidth", "borderColor", "borderCurve", "borderEndColor", "borderEndEndRadius", "borderEndStartRadius", "borderEndWidth", "borderLeftColor", "borderLeftWidth", "borderRadius", "borderRightColor", "borderRightWidth", "borderStartColor", "borderStartEndRadius", "borderStartStartRadius", "borderStartWidth", "borderStyle", "borderTopColor", "borderTopEndRadius", "borderTopLeftRadius", "borderTopRightRadius", "borderTopStartRadius", "borderTopWidth", "borderWidth", "boxShadow", "elevation", "filter", "mixBlendMode", "opacity", "shadowColor", "shadowOffset", "shadowOpacity", "shadowRadius", "transform", "transformOrigin"]; // Width of the screen in split layout on portrait mode on iPad Mini
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.Header = Header;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _color = require(_dependencyMap[2], "color");
  var Color = _interopDefault(_color);
  var _react = require(_dependencyMap[3], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[4], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[5], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[6], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsView = require(_dependencyMap[7], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactNativeSafeAreaContext = require(_dependencyMap[8], "react-native-safe-area-context");
  var _assetsSearchIconPng = require(_dependencyMap[9], "../assets/search-icon.png");
  var searchIcon = _interopDefault(_assetsSearchIconPng);
  var _useFrameSizeJs = require(_dependencyMap[10], "../useFrameSize.js");
  var _getDefaultHeaderHeightJs = require(_dependencyMap[11], "./getDefaultHeaderHeight.js");
  var _HeaderBackButtonJs = require(_dependencyMap[12], "./HeaderBackButton.js");
  var _HeaderBackgroundJs = require(_dependencyMap[13], "./HeaderBackground.js");
  var _HeaderButtonJs = require(_dependencyMap[14], "./HeaderButton.js");
  var _HeaderIconJs = require(_dependencyMap[15], "./HeaderIcon.js");
  var _HeaderSearchBarJs = require(_dependencyMap[16], "./HeaderSearchBar.js");
  var _HeaderShownContextJs = require(_dependencyMap[17], "./HeaderShownContext.js");
  var _HeaderTitleJs = require(_dependencyMap[18], "./HeaderTitle.js");
  var _reactJsxRuntime = require(_dependencyMap[19], "react/jsx-runtime");
  const IPAD_MINI_MEDIUM_WIDTH = 414;
  const warnIfHeaderStylesDefined = styles => {
    Object.keys(styles).forEach(styleProp => {
      const value = styles[styleProp];
      if (styleProp === 'position' && value === 'absolute') {
        console.warn("position: 'absolute' is not supported on headerStyle. If you would like to render content under the header, use the 'headerTransparent' option.");
      } else if (value !== undefined) {
        console.warn(`${styleProp} was given a value of ${value}, this has no effect on headerStyle.`);
      }
    });
  };
  function Header(props) {
    const insets = (0, _reactNativeSafeAreaContext.useSafeAreaInsets)();
    const frame = (0, _useFrameSizeJs.useFrameSize)(size => size, true);
    const {
      colors
    } = (0, _reactNavigationNative.useTheme)();
    const navigation = (0, _reactNavigationNative.useNavigation)();
    const isParentHeaderShown = React.useContext(_HeaderShownContextJs.HeaderShownContext);
    const [searchBarVisible, setSearchBarVisible] = React.useState(false);
    const [titleLayout, setTitleLayout] = React.useState(undefined);
    const onTitleLayout = e => {
      const {
        height,
        width
      } = e.nativeEvent.layout;
      setTitleLayout(titleLayout => {
        if (titleLayout && height === titleLayout.height && width === titleLayout.width) {
          return titleLayout;
        }
        return {
          height,
          width
        };
      });
    };
    const {
      layout = frame,
      modal = false,
      back,
      title,
      headerTitle: customTitle,
      headerTitleAlign = Platform.default.OS === 'ios' ? 'center' : 'left',
      headerLeft = back ? props => /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderBackButtonJs.HeaderBackButton, Object.assign({}, props)) : undefined,
      headerSearchBarOptions,
      headerTransparent,
      headerTintColor,
      headerBackground,
      headerRight,
      headerTitleAllowFontScaling: titleAllowFontScaling,
      headerTitleStyle: titleStyle,
      headerLeftContainerStyle: leftContainerStyle,
      headerRightContainerStyle: rightContainerStyle,
      headerTitleContainerStyle: titleContainerStyle,
      headerBackButtonDisplayMode = Platform.default.OS === 'ios' ? 'default' : 'minimal',
      headerBackTitleStyle,
      headerBackgroundContainerStyle: backgroundContainerStyle,
      headerStyle: customHeaderStyle,
      headerShadowVisible,
      headerPressColor,
      headerPressOpacity,
      headerStatusBarHeight = isParentHeaderShown ? 0 : insets.top
    } = props;
    const defaultHeight = (0, _getDefaultHeaderHeightJs.getDefaultHeaderHeight)(layout, modal, headerStatusBarHeight);
    const _StyleSheet$flatten = StyleSheet.default.flatten(customHeaderStyle || {}),
      {
        height = defaultHeight,
        maxHeight,
        minHeight,
        backfaceVisibility,
        backgroundColor,
        borderBlockColor,
        borderBlockEndColor,
        borderBlockStartColor,
        borderBottomColor,
        borderBottomEndRadius,
        borderBottomLeftRadius,
        borderBottomRightRadius,
        borderBottomStartRadius,
        borderBottomWidth,
        borderColor,
        borderCurve,
        borderEndColor,
        borderEndEndRadius,
        borderEndStartRadius,
        borderEndWidth,
        borderLeftColor,
        borderLeftWidth,
        borderRadius,
        borderRightColor,
        borderRightWidth,
        borderStartColor,
        borderStartEndRadius,
        borderStartStartRadius,
        borderStartWidth,
        borderStyle,
        borderTopColor,
        borderTopEndRadius,
        borderTopLeftRadius,
        borderTopRightRadius,
        borderTopStartRadius,
        borderTopWidth,
        borderWidth,
        boxShadow,
        elevation,
        filter,
        mixBlendMode,
        opacity,
        shadowColor,
        shadowOffset,
        shadowOpacity,
        shadowRadius,
        transform,
        transformOrigin
      } = _StyleSheet$flatten,
      unsafeStyles = (0, _objectWithoutPropertiesLoose.default)(_StyleSheet$flatten, _excluded);
    if (process.env.NODE_ENV !== 'production') {
      warnIfHeaderStylesDefined(unsafeStyles);
    }
    const safeStyles = {
      backfaceVisibility,
      backgroundColor,
      borderBlockColor,
      borderBlockEndColor,
      borderBlockStartColor,
      borderBottomColor,
      borderBottomEndRadius,
      borderBottomLeftRadius,
      borderBottomRightRadius,
      borderBottomStartRadius,
      borderBottomWidth,
      borderColor,
      borderCurve,
      borderEndColor,
      borderEndEndRadius,
      borderEndStartRadius,
      borderEndWidth,
      borderLeftColor,
      borderLeftWidth,
      borderRadius,
      borderRightColor,
      borderRightWidth,
      borderStartColor,
      borderStartEndRadius,
      borderStartStartRadius,
      borderStartWidth,
      borderStyle,
      borderTopColor,
      borderTopEndRadius,
      borderTopLeftRadius,
      borderTopRightRadius,
      borderTopStartRadius,
      borderTopWidth,
      borderWidth,
      boxShadow,
      elevation,
      filter,
      mixBlendMode,
      opacity,
      shadowColor,
      shadowOffset,
      shadowOpacity,
      shadowRadius,
      transform,
      transformOrigin
    };

    // Setting a property to undefined triggers default style
    // So we need to filter them out
    // Users can use `null` instead
    for (const styleProp in safeStyles) {
      // @ts-expect-error: typescript wrongly complains that styleProp cannot be used to index safeStyles
      if (safeStyles[styleProp] === undefined) {
        // @ts-expect-error don't need to care about index signature for deletion
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete safeStyles[styleProp];
      }
    }
    const backgroundStyle = Object.assign({}, headerTransparent && {
      backgroundColor: 'transparent'
    }, (headerTransparent || headerShadowVisible === false) && Object.assign({
      borderBottomWidth: 0
    }, Platform.default.select({
      android: {
        elevation: 0
      },
      web: {
        boxShadow: 'none'
      },
      default: {
        shadowOpacity: 0
      }
    })), safeStyles);
    const iconTintColor = headerTintColor ?? Platform.default.select({
      ios: colors.primary,
      default: colors.text
    });
    const leftButton = headerLeft ? headerLeft({
      tintColor: iconTintColor,
      pressColor: headerPressColor,
      pressOpacity: headerPressOpacity,
      displayMode: headerBackButtonDisplayMode,
      titleLayout,
      screenLayout: layout,
      canGoBack: Boolean(back),
      onPress: back ? navigation.goBack : undefined,
      label: back?.title,
      labelStyle: headerBackTitleStyle,
      href: back?.href
    }) : null;
    const rightButton = headerRight ? headerRight({
      tintColor: iconTintColor,
      pressColor: headerPressColor,
      pressOpacity: headerPressOpacity,
      canGoBack: Boolean(back)
    }) : null;
    const headerTitle = typeof customTitle !== 'function' ? props => /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderTitleJs.HeaderTitle, Object.assign({}, props)) : customTitle;
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(Animated.default.View, {
      pointerEvents: "box-none",
      style: [{
        height,
        minHeight,
        maxHeight,
        opacity,
        transform
      }],
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(Animated.default.View, {
        pointerEvents: "box-none",
        style: [StyleSheet.default.absoluteFill, backgroundContainerStyle],
        children: headerBackground ? headerBackground({
          style: backgroundStyle
        }) : /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderBackgroundJs.HeaderBackground, {
          pointerEvents:
          // Allow touch through the header when background color is transparent
          headerTransparent && (backgroundStyle.backgroundColor === 'transparent' || (0, Color.default)(backgroundStyle.backgroundColor).alpha() === 0) ? 'none' : 'auto',
          style: backgroundStyle
        })
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
        pointerEvents: "none",
        style: {
          height: headerStatusBarHeight
        }
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(View.default, {
        pointerEvents: "box-none",
        style: [styles.content, Platform.default.OS === 'ios' && frame.width >= IPAD_MINI_MEDIUM_WIDTH ? styles.large : null],
        children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(Animated.default.View, {
          pointerEvents: "box-none",
          style: [styles.start, !searchBarVisible && headerTitleAlign === 'center' && styles.expand, {
            marginStart: insets.left
          }, leftContainerStyle],
          children: leftButton
        }), Platform.default.OS === 'ios' || !searchBarVisible ? /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(_reactJsxRuntime.Fragment, {
          children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(Animated.default.View, {
            pointerEvents: "box-none",
            style: [styles.title, {
              // Avoid the title from going offscreen or overlapping buttons
              maxWidth: headerTitleAlign === 'center' ? layout.width - ((leftButton ? headerBackButtonDisplayMode !== 'minimal' ? 80 : 32 : 16) + (rightButton || headerSearchBarOptions ? 16 : 0) + Math.max(insets.left, insets.right)) * 2 : layout.width - ((leftButton ? 52 : 16) + (rightButton || headerSearchBarOptions ? 52 : 16) + insets.left - insets.right)
            }, headerTitleAlign === 'left' && leftButton ? {
              marginStart: 4
            } : {
              marginHorizontal: 16
            }, titleContainerStyle],
            children: headerTitle({
              children: title,
              allowFontScaling: titleAllowFontScaling,
              tintColor: headerTintColor,
              onLayout: onTitleLayout,
              style: titleStyle
            })
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(Animated.default.View, {
            pointerEvents: "box-none",
            style: [styles.end, styles.expand, {
              marginEnd: insets.right
            }, rightContainerStyle],
            children: [rightButton, headerSearchBarOptions ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderButtonJs.HeaderButton, {
              tintColor: iconTintColor,
              pressColor: headerPressColor,
              pressOpacity: headerPressOpacity,
              onPress: () => {
                setSearchBarVisible(true);
                headerSearchBarOptions?.onOpen?.();
              },
              children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderIconJs.HeaderIcon, {
                source: searchIcon.default,
                tintColor: iconTintColor
              })
            }) : null]
          })]
        }) : null, Platform.default.OS === 'ios' || searchBarVisible ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderSearchBarJs.HeaderSearchBar, Object.assign({}, headerSearchBarOptions, {
          visible: searchBarVisible,
          onClose: () => {
            setSearchBarVisible(false);
            headerSearchBarOptions?.onClose?.();
          },
          tintColor: headerTintColor,
          style: [Platform.default.OS === 'ios' ? [StyleSheet.default.absoluteFill, {
            paddingTop: headerStatusBarHeight ? 0 : 4
          }, {
            backgroundColor: backgroundColor ?? colors.card
          }] : !leftButton && {
            marginStart: 8
          }]
        })) : null]
      })]
    });
  }
  const styles = StyleSheet.default.create({
    content: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'stretch'
    },
    large: {
      marginHorizontal: 5
    },
    title: {
      justifyContent: 'center'
    },
    start: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-start'
    },
    end: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-end'
    },
    expand: {
      flexGrow: 1,
      flexBasis: 0
    }
  });
},422,[759,253,408,9,166,14,55,110,423,405,429,420,430,434,432,433,435,437,439,274],"node_modules/@react-navigation/elements/lib/module/Header/Header.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  var _SafeAreaContext = require(_dependencyMap[0], "./SafeAreaContext");
  Object.keys(_SafeAreaContext).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _SafeAreaContext[k];
        }
      });
    }
  });
  var _SafeAreaView = require(_dependencyMap[1], "./SafeAreaView");
  Object.keys(_SafeAreaView).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _SafeAreaView[k];
        }
      });
    }
  });
  var _InitialWindow = require(_dependencyMap[2], "./InitialWindow");
  Object.keys(_InitialWindow).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _InitialWindow[k];
        }
      });
    }
  });
  var _SafeAreaTypes = require(_dependencyMap[3], "./SafeArea.types");
  Object.keys(_SafeAreaTypes).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _SafeAreaTypes[k];
        }
      });
    }
  });
},423,[424,426,427,428],"node_modules/react-native-safe-area-context/lib/module/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["children", "initialMetrics", "initialSafeAreaInsets", "style"],
    _excluded2 = ["onChange", "style", "children"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "SafeAreaInsetsContext", {
    enumerable: true,
    get: function () {
      return SafeAreaInsetsContext;
    }
  });
  Object.defineProperty(exports, "SafeAreaFrameContext", {
    enumerable: true,
    get: function () {
      return SafeAreaFrameContext;
    }
  });
  exports.SafeAreaProvider = SafeAreaProvider;
  exports.SafeAreaListener = SafeAreaListener;
  exports.useSafeAreaInsets = useSafeAreaInsets;
  exports.useSafeAreaFrame = useSafeAreaFrame;
  exports.withSafeAreaInsets = withSafeAreaInsets;
  exports.useSafeArea = useSafeArea;
  Object.defineProperty(exports, "SafeAreaConsumer", {
    enumerable: true,
    get: function () {
      return SafeAreaConsumer;
    }
  });
  Object.defineProperty(exports, "SafeAreaContext", {
    enumerable: true,
    get: function () {
      return SafeAreaContext;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsDimensions = require(_dependencyMap[2], "react-native-web/dist/exports/Dimensions");
  var Dimensions = _interopDefault(_reactNativeWebDistExportsDimensions);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _NativeSafeAreaProvider = require(_dependencyMap[4], "./NativeSafeAreaProvider");
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  const isDev = process.env.NODE_ENV !== 'production';
  const SafeAreaInsetsContext = /*#__PURE__*/React.createContext(null);
  if (isDev) {
    SafeAreaInsetsContext.displayName = 'SafeAreaInsetsContext';
  }
  const SafeAreaFrameContext = /*#__PURE__*/React.createContext(null);
  if (isDev) {
    SafeAreaFrameContext.displayName = 'SafeAreaFrameContext';
  }
  function SafeAreaProvider(_ref) {
    let {
        children,
        initialMetrics,
        initialSafeAreaInsets,
        style
      } = _ref,
      others = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const parentInsets = useParentSafeAreaInsets();
    const parentFrame = useParentSafeAreaFrame();
    const [insets, setInsets] = React.useState(initialMetrics?.insets ?? initialSafeAreaInsets ?? parentInsets ?? null);
    const [frame, setFrame] = React.useState(initialMetrics?.frame ?? parentFrame ?? {
      // Backwards compat so we render anyway if we don't have frame.
      x: 0,
      y: 0,
      width: Dimensions.default.get('window').width,
      height: Dimensions.default.get('window').height
    });
    const onInsetsChange = React.useCallback(event => {
      const {
        nativeEvent: {
          frame: nextFrame,
          insets: nextInsets
        }
      } = event;
      setFrame(curFrame => {
        if (
        // Backwards compat with old native code that won't send frame.
        nextFrame && (nextFrame.height !== curFrame.height || nextFrame.width !== curFrame.width || nextFrame.x !== curFrame.x || nextFrame.y !== curFrame.y)) {
          return nextFrame;
        } else {
          return curFrame;
        }
      });
      setInsets(curInsets => {
        if (!curInsets || nextInsets.bottom !== curInsets.bottom || nextInsets.left !== curInsets.left || nextInsets.right !== curInsets.right || nextInsets.top !== curInsets.top) {
          return nextInsets;
        } else {
          return curInsets;
        }
      });
    }, []);
    return /*#__PURE__*/React.createElement(_NativeSafeAreaProvider.NativeSafeAreaProvider, _extends({
      style: [styles.fill, style],
      onInsetsChange: onInsetsChange
    }, others), insets != null ? /*#__PURE__*/React.createElement(SafeAreaFrameContext.Provider, {
      value: frame
    }, /*#__PURE__*/React.createElement(SafeAreaInsetsContext.Provider, {
      value: insets
    }, children)) : null);
  }
  function SafeAreaListener(_ref2) {
    let {
        onChange,
        style,
        children
      } = _ref2,
      others = (0, _objectWithoutPropertiesLoose.default)(_ref2, _excluded2);
    return /*#__PURE__*/React.createElement(_NativeSafeAreaProvider.NativeSafeAreaProvider, _extends({}, others, {
      style: [styles.fill, style],
      onInsetsChange: e => {
        onChange({
          insets: e.nativeEvent.insets,
          frame: e.nativeEvent.frame
        });
      }
    }), children);
  }
  const styles = StyleSheet.default.create({
    fill: {
      flex: 1
    }
  });
  function useParentSafeAreaInsets() {
    return React.useContext(SafeAreaInsetsContext);
  }
  function useParentSafeAreaFrame() {
    return React.useContext(SafeAreaFrameContext);
  }
  const NO_INSETS_ERROR = 'No safe area value available. Make sure you are rendering `<SafeAreaProvider>` at the top of your app.';
  function useSafeAreaInsets() {
    const insets = React.useContext(SafeAreaInsetsContext);
    if (insets == null) {
      throw new Error(NO_INSETS_ERROR);
    }
    return insets;
  }
  function useSafeAreaFrame() {
    const frame = React.useContext(SafeAreaFrameContext);
    if (frame == null) {
      throw new Error(NO_INSETS_ERROR);
    }
    return frame;
  }
  function withSafeAreaInsets(WrappedComponent) {
    return /*#__PURE__*/React.forwardRef((props, ref) => {
      const insets = useSafeAreaInsets();
      return /*#__PURE__*/React.createElement(WrappedComponent, _extends({}, props, {
        insets: insets,
        ref: ref
      }));
    });
  }

  /**
   * @deprecated
   */
  function useSafeArea() {
    return useSafeAreaInsets();
  }

  /**
   * @deprecated
   */
  const SafeAreaConsumer = SafeAreaInsetsContext.Consumer;

  /**
   * @deprecated
   */
  const SafeAreaContext = SafeAreaInsetsContext;
},424,[759,9,44,55,425],"node_modules/react-native-safe-area-context/lib/module/SafeAreaContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.NativeSafeAreaProvider = NativeSafeAreaProvider;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsView = require(_dependencyMap[1], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  /* eslint-env browser */

  /**
   * TODO:
   * Currently insets and frame are based on the window and are not
   * relative to the provider view. This is inconsistent with iOS and Android.
   * However in most cases if the provider view covers the screen this is not
   * an issue.
   */

  const CSSTransitions = {
    WebkitTransition: 'webkitTransitionEnd',
    Transition: 'transitionEnd',
    MozTransition: 'transitionend',
    MSTransition: 'msTransitionEnd',
    OTransition: 'oTransitionEnd'
  };
  function NativeSafeAreaProvider({
    children,
    style,
    onInsetsChange
  }) {
    React.useEffect(() => {
      // Skip for SSR.
      if (typeof document === 'undefined') {
        return;
      }
      const element = createContextElement();
      document.body.appendChild(element);
      const onEnd = () => {
        const {
          paddingTop,
          paddingBottom,
          paddingLeft,
          paddingRight
        } = window.getComputedStyle(element);
        const insets = {
          top: paddingTop ? parseInt(paddingTop, 10) : 0,
          bottom: paddingBottom ? parseInt(paddingBottom, 10) : 0,
          left: paddingLeft ? parseInt(paddingLeft, 10) : 0,
          right: paddingRight ? parseInt(paddingRight, 10) : 0
        };
        const frame = {
          x: 0,
          y: 0,
          width: document.documentElement.offsetWidth,
          height: document.documentElement.offsetHeight
        };
        // @ts-ignore: missing properties
        onInsetsChange({
          nativeEvent: {
            insets,
            frame
          }
        });
      };
      element.addEventListener(getSupportedTransitionEvent(), onEnd);
      onEnd();
      return () => {
        document.body.removeChild(element);
        element.removeEventListener(getSupportedTransitionEvent(), onEnd);
      };
    }, [onInsetsChange]);
    return /*#__PURE__*/React.createElement(View.default, {
      style: style
    }, children);
  }
  let _supportedTransitionEvent = null;
  function getSupportedTransitionEvent() {
    if (_supportedTransitionEvent != null) {
      return _supportedTransitionEvent;
    }
    const element = document.createElement('invalidtype');
    _supportedTransitionEvent = CSSTransitions.Transition;
    for (const key in CSSTransitions) {
      if (element.style[key] !== undefined) {
        _supportedTransitionEvent = CSSTransitions[key];
        break;
      }
    }
    return _supportedTransitionEvent;
  }
  let _supportedEnv = null;
  function getSupportedEnv() {
    if (_supportedEnv !== null) {
      return _supportedEnv;
    }
    const {
      CSS
    } = window;
    if (CSS && CSS.supports && CSS.supports('top: constant(safe-area-inset-top)')) {
      _supportedEnv = 'constant';
    } else {
      _supportedEnv = 'env';
    }
    return _supportedEnv;
  }
  function getInset(side) {
    return `${getSupportedEnv()}(safe-area-inset-${side})`;
  }
  function createContextElement() {
    const element = document.createElement('div');
    const {
      style
    } = element;
    style.position = 'fixed';
    style.left = '0';
    style.top = '0';
    style.width = '0';
    style.height = '0';
    style.zIndex = '-1';
    style.overflow = 'hidden';
    style.visibility = 'hidden';
    // Bacon: Anything faster than this and the callback will be invoked too early with the wrong insets
    style.transitionDuration = '0.05s';
    style.transitionProperty = 'padding';
    style.transitionDelay = '0s';
    style.paddingTop = getInset('top');
    style.paddingBottom = getInset('bottom');
    style.paddingLeft = getInset('left');
    style.paddingRight = getInset('right');
    return element;
  }
},425,[9,110],"node_modules/react-native-safe-area-context/lib/module/NativeSafeAreaProvider.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["style", "mode", "edges"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "SafeAreaView", {
    enumerable: true,
    get: function () {
      return SafeAreaView;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsView = require(_dependencyMap[3], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _SafeAreaContext = require(_dependencyMap[4], "./SafeAreaContext");
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  const defaultEdges = {
    top: 'additive',
    left: 'additive',
    bottom: 'additive',
    right: 'additive'
  };
  function getEdgeValue(inset, current, mode) {
    switch (mode) {
      case 'off':
        return current;
      case 'maximum':
        return Math.max(current, inset);
      case 'additive':
      default:
        return current + inset;
    }
  }
  const SafeAreaView = /*#__PURE__*/React.forwardRef((_ref, ref) => {
    let {
        style = {},
        mode,
        edges
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const insets = (0, _SafeAreaContext.useSafeAreaInsets)();
    const edgesRecord = React.useMemo(() => {
      if (edges == null) {
        return defaultEdges;
      }
      return Array.isArray(edges) ? edges.reduce((acc, edge) => {
        acc[edge] = 'additive';
        return acc;
      }, {}) :
      // ts has trouble with refining readonly arrays.
      edges;
    }, [edges]);
    const appliedStyle = React.useMemo(() => {
      const flatStyle = StyleSheet.default.flatten(style);
      if (mode === 'margin') {
        const {
          margin = 0,
          marginVertical = margin,
          marginHorizontal = margin,
          marginTop = marginVertical,
          marginRight = marginHorizontal,
          marginBottom = marginVertical,
          marginLeft = marginHorizontal
        } = flatStyle;
        const marginStyle = {
          marginTop: getEdgeValue(insets.top, marginTop, edgesRecord.top),
          marginRight: getEdgeValue(insets.right, marginRight, edgesRecord.right),
          marginBottom: getEdgeValue(insets.bottom, marginBottom, edgesRecord.bottom),
          marginLeft: getEdgeValue(insets.left, marginLeft, edgesRecord.left)
        };
        return [style, marginStyle];
      } else {
        const {
          padding = 0,
          paddingVertical = padding,
          paddingHorizontal = padding,
          paddingTop = paddingVertical,
          paddingRight = paddingHorizontal,
          paddingBottom = paddingVertical,
          paddingLeft = paddingHorizontal
        } = flatStyle;
        const paddingStyle = {
          paddingTop: getEdgeValue(insets.top, paddingTop, edgesRecord.top),
          paddingRight: getEdgeValue(insets.right, paddingRight, edgesRecord.right),
          paddingBottom: getEdgeValue(insets.bottom, paddingBottom, edgesRecord.bottom),
          paddingLeft: getEdgeValue(insets.left, paddingLeft, edgesRecord.left)
        };
        return [style, paddingStyle];
      }
    }, [edgesRecord.bottom, edgesRecord.left, edgesRecord.right, edgesRecord.top, insets.bottom, insets.left, insets.right, insets.top, mode, style]);
    return /*#__PURE__*/React.createElement(View.default, _extends({
      style: appliedStyle
    }, rest, {
      ref: ref
    }));
  });
},426,[759,9,55,110,424],"node_modules/react-native-safe-area-context/lib/module/SafeAreaView.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "initialWindowMetrics", {
    enumerable: true,
    get: function () {
      return initialWindowMetrics;
    }
  });
  Object.defineProperty(exports, "initialWindowSafeAreaInsets", {
    enumerable: true,
    get: function () {
      return initialWindowSafeAreaInsets;
    }
  });
  const initialWindowMetrics = null;

  /**
   * @deprecated
   */
  const initialWindowSafeAreaInsets = null;
},427,[],"node_modules/react-native-safe-area-context/lib/module/InitialWindow.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},428,[],"node_modules/react-native-safe-area-context/lib/module/SafeArea.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.useFrameSize = useFrameSize;
  exports.FrameSizeProvider = FrameSizeProvider;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[1], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _useLatestCallback = require(_dependencyMap[2], "use-latest-callback");
  var useLatestCallback = _interopDefault(_useLatestCallback);
  var _useSyncExternalStoreWithSelector = require(_dependencyMap[3], "use-sync-external-store/with-selector");
  var _reactJsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  const FrameContext = /*#__PURE__*/React.createContext(undefined);
  function useFrameSize(selector, throttle) {
    const context = React.useContext(FrameContext);
    if (context == null) {
      throw new Error('useFrameSize must be used within a FrameSizeProvider');
    }
    const value = (0, _useSyncExternalStoreWithSelector.useSyncExternalStoreWithSelector)(throttle ? context.subscribeThrottled : context.subscribe, context.getCurrent, context.getCurrent, selector);
    return value;
  }
  function FrameSizeProvider({
    initialFrame,
    render
  }) {
    const frameRef = React.useRef({
      width: initialFrame.width,
      height: initialFrame.height
    });
    const listeners = React.useRef(new Set());
    const getCurrent = (0, useLatestCallback.default)(() => frameRef.current);
    const subscribe = (0, useLatestCallback.default)(listener => {
      listeners.current.add(listener);
      return () => {
        listeners.current.delete(listener);
      };
    });
    const subscribeThrottled = (0, useLatestCallback.default)(listener => {
      const delay = 100; // Throttle delay in milliseconds

      let timer;
      let updated = false;
      let waiting = false;
      const throttledListener = () => {
        clearTimeout(timer);
        updated = true;
        if (waiting) {
          // Schedule a timer to call the listener at the end
          timer = setTimeout(() => {
            if (updated) {
              updated = false;
              listener();
            }
          }, delay);
        } else {
          waiting = true;
          setTimeout(function () {
            waiting = false;
          }, delay);

          // Call the listener immediately at start
          updated = false;
          listener();
        }
      };
      const unsubscribe = subscribe(throttledListener);
      return () => {
        unsubscribe();
        clearTimeout(timer);
      };
    });
    const context = React.useMemo(() => ({
      getCurrent,
      subscribe,
      subscribeThrottled
    }), [subscribe, subscribeThrottled, getCurrent]);
    const onChange = (0, useLatestCallback.default)(frame => {
      if (frameRef.current.height === frame.height && frameRef.current.width === frame.width) {
        return;
      }
      frameRef.current = {
        width: frame.width,
        height: frame.height
      };
      listeners.current.forEach(listener => listener());
    });
    const viewRef = React.useRef(null);
    React.useEffect(() => {
      if (Platform.default.OS === 'web') {
        // We use ResizeObserver on web
        return;
      }
      viewRef.current?.measure((_x, _y, width, height) => {
        onChange({
          width,
          height
        });
      });
    }, [onChange]);
    const onLayout = event => {
      const {
        width,
        height
      } = event.nativeEvent.layout;
      onChange({
        width,
        height
      });
    };
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(FrameContext.Provider, {
      value: context,
      children: [Platform.default.OS === 'web' ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(FrameSizeListenerWeb, {
        onChange: onChange
      }) : null, render({
        ref: viewRef,
        onLayout
      })]
    });
  }

  // FIXME: On the Web, `onLayout` doesn't fire on resize
  // So we workaround this by using ResizeObserver
  function FrameSizeListenerWeb({
    onChange
  }) {
    const elementRef = React.useRef(null);
    React.useEffect(() => {
      if (elementRef.current == null) {
        return;
      }
      const rect = elementRef.current.getBoundingClientRect();
      onChange({
        width: rect.width,
        height: rect.height
      });
      const observer = new ResizeObserver(entries => {
        const entry = entries[0];
        if (entry) {
          const {
            width,
            height
          } = entry.contentRect;
          onChange({
            width,
            height
          });
        }
      });
      observer.observe(elementRef.current);
      return () => {
        observer.disconnect();
      };
    }, [onChange]);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
      ref: elementRef,
      style: {
        position: 'absolute',
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        pointerEvents: 'none',
        visibility: 'hidden'
      }
    });
  }
},429,[9,14,267,342,274],"node_modules/@react-navigation/elements/lib/module/useFrameSize.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.HeaderBackButton = HeaderBackButton;
  var _reactNavigationNative = require(_dependencyMap[0], "@react-navigation/native");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[2], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsImage = require(_dependencyMap[3], "react-native-web/dist/exports/Image");
  var Image = _interopDefault(_reactNativeWebDistExportsImage);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[4], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsView = require(_dependencyMap[6], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _assetsBackIconPng = require(_dependencyMap[7], "../assets/back-icon.png");
  var backIcon = _interopDefault(_assetsBackIconPng);
  var _assetsBackIconMaskPng = require(_dependencyMap[8], "../assets/back-icon-mask.png");
  var backIconMask = _interopDefault(_assetsBackIconMaskPng);
  var _MaskedView = require(_dependencyMap[9], "../MaskedView");
  var _HeaderButtonJs = require(_dependencyMap[10], "./HeaderButton.js");
  var _HeaderIconJs = require(_dependencyMap[11], "./HeaderIcon.js");
  var _reactJsxRuntime = require(_dependencyMap[12], "react/jsx-runtime");
  function HeaderBackButton({
    disabled,
    allowFontScaling,
    backImage,
    label,
    labelStyle,
    displayMode = Platform.default.OS === 'ios' ? 'default' : 'minimal',
    onLabelLayout,
    onPress,
    pressColor,
    pressOpacity,
    screenLayout,
    tintColor,
    titleLayout,
    truncatedLabel = 'Back',
    accessibilityLabel = label && label !== 'Back' ? `${label}, back` : 'Go back',
    testID,
    style,
    href
  }) {
    const {
      colors,
      fonts
    } = (0, _reactNavigationNative.useTheme)();
    const {
      direction
    } = (0, _reactNavigationNative.useLocale)();
    const [labelWidth, setLabelWidth] = React.useState(null);
    const [truncatedLabelWidth, setTruncatedLabelWidth] = React.useState(null);
    const renderBackImage = () => {
      if (backImage) {
        return backImage({
          tintColor: tintColor ?? colors.text
        });
      } else {
        return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderIconJs.HeaderIcon, {
          source: backIcon.default,
          tintColor: tintColor,
          style: [styles.icon, displayMode !== 'minimal' && styles.iconWithLabel]
        });
      }
    };
    const renderLabel = () => {
      if (displayMode === 'minimal') {
        return null;
      }
      const availableSpace = titleLayout && screenLayout ? (screenLayout.width - titleLayout.width) / 2 - (ICON_WIDTH + _HeaderIconJs.ICON_MARGIN) : null;
      const potentialLabelText = displayMode === 'default' ? label : truncatedLabel;
      const finalLabelText = availableSpace && labelWidth && truncatedLabelWidth ? availableSpace > labelWidth ? potentialLabelText : availableSpace > truncatedLabelWidth ? truncatedLabel : null : potentialLabelText;
      const commonStyle = [fonts.regular, styles.label, labelStyle];
      const hiddenStyle = [commonStyle, {
        position: 'absolute',
        top: 0,
        left: 0,
        opacity: 0
      }];
      const labelElement = /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(View.default, {
        style: styles.labelWrapper,
        children: [label && displayMode === 'default' ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Animated.default.Text, {
          style: hiddenStyle,
          numberOfLines: 1,
          onLayout: e => setLabelWidth(e.nativeEvent.layout.width),
          children: label
        }) : null, truncatedLabel ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Animated.default.Text, {
          style: hiddenStyle,
          numberOfLines: 1,
          onLayout: e => setTruncatedLabelWidth(e.nativeEvent.layout.width),
          children: truncatedLabel
        }) : null, finalLabelText ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Animated.default.Text, {
          accessible: false,
          onLayout: onLabelLayout,
          style: [tintColor ? {
            color: tintColor
          } : null, commonStyle],
          numberOfLines: 1,
          allowFontScaling: !!allowFontScaling,
          children: finalLabelText
        }) : null]
      });
      if (backImage || Platform.default.OS !== 'ios') {
        // When a custom backimage is specified, we can't mask the label
        // Otherwise there might be weird effect due to our mask not being the same as the image
        return labelElement;
      }
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_MaskedView.MaskedView, {
        maskElement: /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(View.default, {
          style: [styles.iconMaskContainer,
          // Extend the mask to the center of the screen so that label isn't clipped during animation
          screenLayout ? {
            minWidth: screenLayout.width / 2 - 27
          } : null],
          children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(Image.default, {
            source: backIconMask.default,
            resizeMode: "contain",
            style: [styles.iconMask, direction === 'rtl' && styles.flip]
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
            style: styles.iconMaskFillerRect
          })]
        }),
        children: labelElement
      });
    };
    const handlePress = () => {
      if (onPress) {
        requestAnimationFrame(() => onPress());
      }
    };
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderButtonJs.HeaderButton, {
      disabled: disabled,
      href: href,
      accessibilityLabel: accessibilityLabel,
      testID: testID,
      onPress: handlePress,
      pressColor: pressColor,
      pressOpacity: pressOpacity,
      style: [styles.container, style],
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(React.Fragment, {
        children: [renderBackImage(), renderLabel()]
      })
    });
  }
  const ICON_WIDTH = Platform.default.OS === 'ios' ? 13 : 24;
  const ICON_MARGIN_END = Platform.default.OS === 'ios' ? 22 : 3;
  const styles = StyleSheet.default.create({
    container: Object.assign({
      paddingHorizontal: 0,
      minWidth: StyleSheet.default.hairlineWidth
    }, Platform.default.select({
      ios: null,
      default: {
        marginVertical: 3,
        marginHorizontal: 11
      }
    })),
    label: {
      fontSize: 17,
      // Title and back label are a bit different width due to title being bold
      // Adjusting the letterSpacing makes them coincide better
      letterSpacing: 0.35
    },
    labelWrapper: {
      // These styles will make sure that the label doesn't fill the available space
      // Otherwise it messes with the measurement of the label
      flexDirection: 'row',
      alignItems: 'flex-start',
      marginEnd: _HeaderIconJs.ICON_MARGIN
    },
    icon: {
      width: ICON_WIDTH,
      marginEnd: ICON_MARGIN_END
    },
    iconWithLabel: Platform.default.OS === 'ios' ? {
      marginEnd: 6
    } : {},
    iconMaskContainer: {
      flex: 1,
      flexDirection: 'row',
      justifyContent: 'center'
    },
    iconMaskFillerRect: {
      flex: 1,
      backgroundColor: '#000'
    },
    iconMask: {
      height: 21,
      width: 13,
      marginStart: -14.5,
      marginVertical: 12,
      alignSelf: 'center'
    },
    flip: {
      transform: 'scaleX(-1)'
    }
  });
},430,[253,9,166,155,14,55,110,401,402,431,432,433,274],"node_modules/@react-navigation/elements/lib/module/Header/HeaderBackButton.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Use a stub for MaskedView on all Platforms that don't support it.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.MaskedView = MaskedView;
  function MaskedView({
    children
  }) {
    return children;
  }
},431,[],"node_modules/@react-navigation/elements/lib/module/MaskedView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "HeaderButton", {
    enumerable: true,
    get: function () {
      return HeaderButton;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[1], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _PlatformPressableJs = require(_dependencyMap[3], "../PlatformPressable.js");
  var _reactJsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  function HeaderButtonInternal({
    disabled,
    onPress,
    pressColor,
    pressOpacity,
    accessibilityLabel,
    testID,
    style,
    href,
    children
  }, ref) {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_PlatformPressableJs.PlatformPressable, {
      ref: ref,
      disabled: disabled,
      href: href,
      "aria-label": accessibilityLabel,
      testID: testID,
      onPress: onPress,
      pressColor: pressColor,
      pressOpacity: pressOpacity,
      android_ripple: androidRipple,
      style: [styles.container, disabled && styles.disabled, style],
      hitSlop: Platform.default.select({
        ios: undefined,
        default: {
          top: 16,
          right: 16,
          bottom: 16,
          left: 16
        }
      }),
      children: children
    });
  }
  const HeaderButton = /*#__PURE__*/React.forwardRef(HeaderButtonInternal);
  HeaderButton.displayName = 'HeaderButton';
  const androidRipple = {
    borderless: true,
    foreground: Platform.default.OS === 'android' && Platform.default.Version >= 23,
    radius: 20
  };
  const styles = StyleSheet.default.create({
    container: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: 8,
      // Roundness for iPad hover effect
      borderRadius: 10,
      borderCurve: 'continuous'
    },
    disabled: {
      opacity: 0.5
    }
  });
},432,[9,14,55,417,274],"node_modules/@react-navigation/elements/lib/module/Header/HeaderButton.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["source", "style"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.HeaderIcon = HeaderIcon;
  Object.defineProperty(exports, "ICON_SIZE", {
    enumerable: true,
    get: function () {
      return ICON_SIZE;
    }
  });
  Object.defineProperty(exports, "ICON_MARGIN", {
    enumerable: true,
    get: function () {
      return ICON_MARGIN;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _reactNativeWebDistExportsImage = require(_dependencyMap[2], "react-native-web/dist/exports/Image");
  var Image = _interopDefault(_reactNativeWebDistExportsImage);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[3], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactJsxRuntime = require(_dependencyMap[5], "react/jsx-runtime");
  function HeaderIcon(_ref) {
    let {
        source,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const {
      colors
    } = (0, _reactNavigationNative.useTheme)();
    const {
      direction
    } = (0, _reactNavigationNative.useLocale)();
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Image.default, Object.assign({
      source: source,
      resizeMode: "contain",
      fadeDuration: 0,
      tintColor: colors.text,
      style: [styles.icon, direction === 'rtl' && styles.flip, style]
    }, rest));
  }
  const ICON_SIZE = Platform.default.OS === 'ios' ? 21 : 24;
  const ICON_MARGIN = Platform.default.OS === 'ios' ? 8 : 3;
  const styles = StyleSheet.default.create({
    icon: {
      width: ICON_SIZE,
      height: ICON_SIZE,
      margin: ICON_MARGIN
    },
    flip: {
      transform: 'scaleX(-1)'
    }
  });
},433,[759,253,155,14,55,274],"node_modules/@react-navigation/elements/lib/module/Header/HeaderIcon.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["style"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.HeaderBackground = HeaderBackground;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  require(_dependencyMap[2], "react");
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[3], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[4], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactJsxRuntime = require(_dependencyMap[6], "react/jsx-runtime");
  function HeaderBackground(_ref) {
    let {
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const {
      colors,
      dark
    } = (0, _reactNavigationNative.useTheme)();
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Animated.default.View, Object.assign({
      style: [styles.container, Object.assign({
        backgroundColor: colors.card,
        borderBottomColor: colors.border
      }, Platform.default.OS === 'ios' && {
        shadowColor: dark ? 'rgba(255, 255, 255, 0.45)' : 'rgba(0, 0, 0, 1)'
      }), style]
    }, rest));
  }
  const styles = StyleSheet.default.create({
    container: Object.assign({
      flex: 1
    }, Platform.default.select({
      android: {
        elevation: 4
      },
      ios: {
        shadowOpacity: 0.3,
        shadowRadius: 0,
        shadowOffset: {
          width: 0,
          height: StyleSheet.default.hairlineWidth
        }
      },
      default: {
        borderBottomWidth: StyleSheet.default.hairlineWidth
      }
    }))
  });
},434,[759,253,9,166,14,55,274],"node_modules/@react-navigation/elements/lib/module/Header/HeaderBackground.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["visible", "inputType", "autoFocus", "autoCapitalize", "placeholder", "cancelButtonText", "enterKeyHint", "onChangeText", "onClose", "tintColor", "style"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "HeaderSearchBar", {
    enumerable: true,
    get: function () {
      return HeaderSearchBar;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _color = require(_dependencyMap[2], "color");
  var Color = _interopDefault(_color);
  var _react = require(_dependencyMap[3], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[4], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsImage = require(_dependencyMap[5], "react-native-web/dist/exports/Image");
  var Image = _interopDefault(_reactNativeWebDistExportsImage);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[6], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[7], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsTextInput = require(_dependencyMap[8], "react-native-web/dist/exports/TextInput");
  var TextInput = _interopDefault(_reactNativeWebDistExportsTextInput);
  var _reactNativeWebDistExportsView = require(_dependencyMap[9], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _assetsClearIconPng = require(_dependencyMap[10], "../assets/clear-icon.png");
  var clearIcon = _interopDefault(_assetsClearIconPng);
  var _assetsCloseIconPng = require(_dependencyMap[11], "../assets/close-icon.png");
  var closeIcon = _interopDefault(_assetsCloseIconPng);
  var _assetsSearchIconPng = require(_dependencyMap[12], "../assets/search-icon.png");
  var searchIcon = _interopDefault(_assetsSearchIconPng);
  var _PlatformPressableJs = require(_dependencyMap[13], "../PlatformPressable.js");
  var _TextJs = require(_dependencyMap[14], "../Text.js");
  var _HeaderButtonJs = require(_dependencyMap[15], "./HeaderButton.js");
  var _HeaderIconJs = require(_dependencyMap[16], "./HeaderIcon.js");
  var _reactJsxRuntime = require(_dependencyMap[17], "react/jsx-runtime");
  const INPUT_TYPE_TO_MODE = {
    text: 'text',
    number: 'numeric',
    phone: 'tel',
    email: 'email'
  };
  const useNativeDriver = Platform.default.OS !== 'web';
  function HeaderSearchBarInternal(_ref, ref) {
    let {
        visible,
        inputType,
        autoFocus = true,
        autoCapitalize,
        placeholder = 'Search',
        cancelButtonText = 'Cancel',
        enterKeyHint = 'search',
        onChangeText,
        onClose,
        tintColor,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const navigation = (0, _reactNavigationNative.useNavigation)();
    const {
      dark,
      colors,
      fonts
    } = (0, _reactNavigationNative.useTheme)();
    const [value, setValue] = React.useState('');
    const [rendered, setRendered] = React.useState(visible);
    const [visibleAnim] = React.useState(() => new Animated.default.Value(visible ? 1 : 0));
    const [clearVisibleAnim] = React.useState(() => new Animated.default.Value(0));
    const visibleValueRef = React.useRef(visible);
    const clearVisibleValueRef = React.useRef(false);
    const inputRef = React.useRef(null);
    React.useEffect(() => {
      // Avoid act warning in tests just by rendering header
      if (visible === visibleValueRef.current) {
        return;
      }
      Animated.default.timing(visibleAnim, {
        toValue: visible ? 1 : 0,
        duration: 100,
        useNativeDriver
      }).start(({
        finished
      }) => {
        if (finished) {
          setRendered(visible);
          visibleValueRef.current = visible;
        }
      });
      return () => {
        visibleAnim.stopAnimation();
      };
    }, [visible, visibleAnim]);
    const hasText = value !== '';
    React.useEffect(() => {
      if (clearVisibleValueRef.current === hasText) {
        return;
      }
      Animated.default.timing(clearVisibleAnim, {
        toValue: hasText ? 1 : 0,
        duration: 100,
        useNativeDriver
      }).start(({
        finished
      }) => {
        if (finished) {
          clearVisibleValueRef.current = hasText;
        }
      });
    }, [clearVisibleAnim, hasText]);
    const clearText = React.useCallback(() => {
      inputRef.current?.clear();
      inputRef.current?.focus();
      setValue('');
    }, []);
    const onClear = React.useCallback(() => {
      clearText();
      // FIXME: figure out how to create a SyntheticEvent
      // @ts-expect-error: we don't have the native event here
      onChangeText?.({
        nativeEvent: {
          text: ''
        }
      });
    }, [clearText, onChangeText]);
    const cancelSearch = React.useCallback(() => {
      onClear();
      onClose();
    }, [onClear, onClose]);
    React.useEffect(() => navigation?.addListener('blur', cancelSearch), [cancelSearch, navigation]);
    React.useImperativeHandle(ref, () => ({
      focus: () => {
        inputRef.current?.focus();
      },
      blur: () => {
        inputRef.current?.blur();
      },
      setText: text => {
        inputRef.current?.setNativeProps({
          text
        });
        setValue(text);
      },
      clearText,
      cancelSearch
    }), [cancelSearch, clearText]);
    if (!visible && !rendered) {
      return null;
    }
    const textColor = tintColor ?? colors.text;
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(Animated.default.View, {
      pointerEvents: visible ? 'auto' : 'none',
      "aria-live": "polite",
      "aria-hidden": !visible,
      style: [styles.container, {
        opacity: visibleAnim
      }, style],
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsxs)(View.default, {
        style: styles.searchbarContainer,
        children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderIconJs.HeaderIcon, {
          source: searchIcon.default,
          tintColor: textColor,
          style: styles.inputSearchIcon
        }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(TextInput.default, Object.assign({}, rest, {
          ref: inputRef,
          onChange: onChangeText,
          onChangeText: setValue,
          autoFocus: autoFocus,
          autoCapitalize: autoCapitalize === 'systemDefault' ? undefined : autoCapitalize,
          inputMode: INPUT_TYPE_TO_MODE[inputType ?? 'text'],
          enterKeyHint: enterKeyHint,
          placeholder: placeholder,
          placeholderTextColor: (0, Color.default)(textColor).alpha(0.5).string(),
          cursorColor: colors.primary,
          selectionHandleColor: colors.primary,
          selectionColor: (0, Color.default)(colors.primary).alpha(0.3).string(),
          style: [fonts.regular, styles.searchbar, {
            backgroundColor: Platform.default.select({
              ios: dark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
              default: 'transparent'
            }),
            color: textColor,
            borderBottomColor: (0, Color.default)(textColor).alpha(0.2).string()
          }]
        })), Platform.default.OS === 'ios' ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_PlatformPressableJs.PlatformPressable, {
          onPress: onClear,
          style: [{
            opacity: clearVisibleAnim,
            transform: [{
              scale: clearVisibleAnim
            }]
          }, styles.clearButton],
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Image.default, {
            source: clearIcon.default,
            resizeMode: "contain",
            tintColor: textColor,
            style: styles.clearIcon
          })
        }) : null]
      }), Platform.default.OS !== 'ios' ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderButtonJs.HeaderButton, {
        onPress: () => {
          if (value) {
            onClear();
          } else {
            onClose();
          }
        },
        style: styles.closeButton,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderIconJs.HeaderIcon, {
          source: closeIcon.default,
          tintColor: textColor
        })
      }) : null, Platform.default.OS === 'ios' ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_PlatformPressableJs.PlatformPressable, {
        onPress: cancelSearch,
        style: styles.cancelButton,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_TextJs.Text, {
          style: [fonts.regular, {
            color: tintColor ?? colors.primary
          }, styles.cancelText],
          children: cancelButtonText
        })
      }) : null]
    });
  }
  const styles = StyleSheet.default.create({
    container: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'stretch'
    },
    inputSearchIcon: Object.assign({
      position: 'absolute',
      opacity: 0.5,
      left: Platform.default.select({
        ios: 16,
        default: 4
      }),
      top: Platform.default.select({
        ios: -1,
        default: 17
      })
    }, Platform.default.select({
      ios: {
        height: 18,
        width: 18
      },
      default: {}
    })),
    closeButton: {
      position: 'absolute',
      opacity: 0.5,
      right: Platform.default.select({
        ios: 0,
        default: 8
      }),
      top: Platform.default.select({
        ios: -2,
        default: 17
      })
    },
    clearButton: {
      position: 'absolute',
      right: 0,
      top: -7,
      bottom: 0,
      justifyContent: 'center',
      padding: 8
    },
    clearIcon: {
      height: 16,
      width: 16,
      opacity: 0.5
    },
    cancelButton: {
      alignSelf: 'center',
      top: -4
    },
    cancelText: {
      fontSize: 17,
      marginHorizontal: 12
    },
    searchbarContainer: {
      flex: 1
    },
    searchbar: Platform.default.select({
      ios: {
        flex: 1,
        fontSize: 17,
        paddingHorizontal: 32,
        marginLeft: 16,
        marginTop: -1,
        marginBottom: 4,
        borderRadius: 8,
        borderCurve: 'continuous'
      },
      default: {
        flex: 1,
        fontSize: 18,
        paddingHorizontal: 36,
        marginRight: 8,
        marginTop: 8,
        marginBottom: 8,
        borderBottomWidth: 1
      }
    })
  });
  const HeaderSearchBar = /*#__PURE__*/React.forwardRef(HeaderSearchBarInternal);
},435,[759,253,408,9,166,155,14,55,436,110,403,404,405,417,418,432,433,274],"node_modules/@react-navigation/elements/lib/module/Header/HeaderSearchBar.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[1], "../createElement");
  var createElement = _interopDefault(_createElement);
  var _modulesForwardedProps = require(_dependencyMap[2], "../../modules/forwardedProps");
  var forwardedProps = _interopNamespace(_modulesForwardedProps);
  var _modulesPick = require(_dependencyMap[3], "../../modules/pick");
  var pick = _interopDefault(_modulesPick);
  var _modulesUseElementLayout = require(_dependencyMap[4], "../../modules/useElementLayout");
  var useElementLayout = _interopDefault(_modulesUseElementLayout);
  var _modulesUseLayoutEffect = require(_dependencyMap[5], "../../modules/useLayoutEffect");
  var useLayoutEffect = _interopDefault(_modulesUseLayoutEffect);
  var _modulesUseMergeRefs = require(_dependencyMap[6], "../../modules/useMergeRefs");
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePlatformMethods = require(_dependencyMap[7], "../../modules/usePlatformMethods");
  var usePlatformMethods = _interopDefault(_modulesUsePlatformMethods);
  var _modulesUseResponderEvents = require(_dependencyMap[8], "../../modules/useResponderEvents");
  var useResponderEvents = _interopDefault(_modulesUseResponderEvents);
  var _modulesUseLocale = require(_dependencyMap[9], "../../modules/useLocale");
  var _StyleSheet = require(_dependencyMap[10], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _modulesTextInputState = require(_dependencyMap[11], "../../modules/TextInputState");
  var TextInputState = _interopDefault(_modulesTextInputState);
  //import { warnOnce } from '../../modules/warnOnce';

  /**
   * Determines whether a 'selection' prop differs from a node's existing
   * selection state.
   */
  var isSelectionStale = (node, selection) => {
    var selectionEnd = node.selectionEnd,
      selectionStart = node.selectionStart;
    var start = selection.start,
      end = selection.end;
    return start !== selectionStart || end !== selectionEnd;
  };

  /**
   * Certain input types do no support 'selectSelectionRange' and will throw an
   * error.
   */
  var setSelection = (node, selection) => {
    if (isSelectionStale(node, selection)) {
      var start = selection.start,
        end = selection.end;
      try {
        node.setSelectionRange(start, end || start);
      } catch (e) {}
    }
  };
  var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
    autoCapitalize: true,
    autoComplete: true,
    autoCorrect: true,
    autoFocus: true,
    defaultValue: true,
    disabled: true,
    lang: true,
    maxLength: true,
    onChange: true,
    onScroll: true,
    placeholder: true,
    pointerEvents: true,
    readOnly: true,
    rows: true,
    spellCheck: true,
    value: true,
    type: true
  });
  var pickProps = props => (0, pick.default)(props, forwardPropsList);

  // If an Input Method Editor is processing key input, the 'keyCode' is 229.
  // https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
  function isEventComposing(nativeEvent) {
    return nativeEvent.isComposing || nativeEvent.keyCode === 229;
  }
  var focusTimeout = null;
  var TextInput = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var _props$autoCapitalize = props.autoCapitalize,
      autoCapitalize = _props$autoCapitalize === void 0 ? 'sentences' : _props$autoCapitalize,
      autoComplete = props.autoComplete,
      autoCompleteType = props.autoCompleteType,
      _props$autoCorrect = props.autoCorrect,
      autoCorrect = _props$autoCorrect === void 0 ? true : _props$autoCorrect,
      blurOnSubmit = props.blurOnSubmit,
      caretHidden = props.caretHidden,
      clearTextOnFocus = props.clearTextOnFocus,
      dir = props.dir,
      editable = props.editable,
      enterKeyHint = props.enterKeyHint,
      inputMode = props.inputMode,
      keyboardType = props.keyboardType,
      _props$multiline = props.multiline,
      multiline = _props$multiline === void 0 ? false : _props$multiline,
      numberOfLines = props.numberOfLines,
      onBlur = props.onBlur,
      onChange = props.onChange,
      onChangeText = props.onChangeText,
      onContentSizeChange = props.onContentSizeChange,
      onFocus = props.onFocus,
      onKeyPress = props.onKeyPress,
      onLayout = props.onLayout,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChange = props.onSelectionChange,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      onSubmitEditing = props.onSubmitEditing,
      placeholderTextColor = props.placeholderTextColor,
      _props$readOnly = props.readOnly,
      readOnly = _props$readOnly === void 0 ? false : _props$readOnly,
      returnKeyType = props.returnKeyType,
      rows = props.rows,
      _props$secureTextEntr = props.secureTextEntry,
      secureTextEntry = _props$secureTextEntr === void 0 ? false : _props$secureTextEntr,
      selection = props.selection,
      selectTextOnFocus = props.selectTextOnFocus,
      showSoftInputOnFocus = props.showSoftInputOnFocus,
      spellCheck = props.spellCheck;
    var type;
    var _inputMode;
    if (inputMode != null) {
      _inputMode = inputMode;
      if (inputMode === 'email') {
        type = 'email';
      } else if (inputMode === 'tel') {
        type = 'tel';
      } else if (inputMode === 'search') {
        type = 'search';
      } else if (inputMode === 'url') {
        type = 'url';
      } else {
        type = 'text';
      }
    } else if (keyboardType != null) {
      // warnOnce('keyboardType', 'keyboardType is deprecated. Use inputMode.');
      switch (keyboardType) {
        case 'email-address':
          type = 'email';
          break;
        case 'number-pad':
        case 'numeric':
          _inputMode = 'numeric';
          break;
        case 'decimal-pad':
          _inputMode = 'decimal';
          break;
        case 'phone-pad':
          type = 'tel';
          break;
        case 'search':
        case 'web-search':
          type = 'search';
          break;
        case 'url':
          type = 'url';
          break;
        default:
          type = 'text';
      }
    }
    if (secureTextEntry) {
      type = 'password';
    }
    var dimensions = React.useRef({
      height: null,
      width: null
    });
    var hostRef = React.useRef(null);
    var prevSelection = React.useRef(null);
    var prevSecureTextEntry = React.useRef(false);
    React.useEffect(() => {
      if (hostRef.current && prevSelection.current) {
        setSelection(hostRef.current, prevSelection.current);
      }
      prevSecureTextEntry.current = secureTextEntry;
    }, [secureTextEntry]);
    var handleContentSizeChange = React.useCallback(hostNode => {
      if (multiline && onContentSizeChange && hostNode != null) {
        var newHeight = hostNode.scrollHeight;
        var newWidth = hostNode.scrollWidth;
        if (newHeight !== dimensions.current.height || newWidth !== dimensions.current.width) {
          dimensions.current.height = newHeight;
          dimensions.current.width = newWidth;
          onContentSizeChange({
            nativeEvent: {
              contentSize: {
                height: dimensions.current.height,
                width: dimensions.current.width
              }
            }
          });
        }
      }
    }, [multiline, onContentSizeChange]);
    var imperativeRef = React.useMemo(() => hostNode => {
      // TextInput needs to add more methods to the hostNode in addition to those
      // added by `usePlatformMethods`. This is temporarily until an API like
      // `TextInput.clear(hostRef)` is added to React Native.
      if (hostNode != null) {
        hostNode.clear = function () {
          if (hostNode != null) {
            hostNode.value = '';
          }
        };
        hostNode.isFocused = function () {
          return hostNode != null && TextInputState.default.currentlyFocusedField() === hostNode;
        };
        handleContentSizeChange(hostNode);
      }
    }, [handleContentSizeChange]);
    function handleBlur(e) {
      TextInputState.default._currentlyFocusedNode = null;
      if (onBlur) {
        e.nativeEvent.text = e.target.value;
        onBlur(e);
      }
    }
    function handleChange(e) {
      var hostNode = e.target;
      var text = hostNode.value;
      e.nativeEvent.text = text;
      handleContentSizeChange(hostNode);
      if (onChange) {
        onChange(e);
      }
      if (onChangeText) {
        onChangeText(text);
      }
    }
    function handleFocus(e) {
      var hostNode = e.target;
      if (onFocus) {
        e.nativeEvent.text = hostNode.value;
        onFocus(e);
      }
      if (hostNode != null) {
        TextInputState.default._currentlyFocusedNode = hostNode;
        if (clearTextOnFocus) {
          hostNode.value = '';
        }
        if (selectTextOnFocus) {
          // Safari requires selection to occur in a setTimeout
          if (focusTimeout != null) {
            clearTimeout(focusTimeout);
          }
          focusTimeout = setTimeout(() => {
            // Check if the input is still focused after the timeout
            // (see #2704)
            if (hostNode != null && document.activeElement === hostNode) {
              hostNode.select();
            }
          }, 0);
        }
      }
    }
    function handleKeyDown(e) {
      var hostNode = e.target;
      // Prevent key events bubbling (see #612)
      e.stopPropagation();
      var blurOnSubmitDefault = !multiline;
      var shouldBlurOnSubmit = blurOnSubmit == null ? blurOnSubmitDefault : blurOnSubmit;
      var nativeEvent = e.nativeEvent;
      var isComposing = isEventComposing(nativeEvent);
      if (onKeyPress) {
        onKeyPress(e);
      }
      if (e.key === 'Enter' && !e.shiftKey &&
      // Do not call submit if composition is occuring.
      !isComposing && !e.isDefaultPrevented()) {
        if ((blurOnSubmit || !multiline) && onSubmitEditing) {
          // prevent "Enter" from inserting a newline or submitting a form
          e.preventDefault();
          nativeEvent.text = e.target.value;
          onSubmitEditing(e);
        }
        if (shouldBlurOnSubmit && hostNode != null) {
          setTimeout(() => hostNode.blur(), 0);
        }
      }
    }
    function handleSelectionChange(e) {
      try {
        var _e$target = e.target,
          selectionStart = _e$target.selectionStart,
          selectionEnd = _e$target.selectionEnd;
        var _selection = {
          start: selectionStart,
          end: selectionEnd
        };
        if (onSelectionChange) {
          e.nativeEvent.selection = _selection;
          e.nativeEvent.text = e.target.value;
          onSelectionChange(e);
        }
        if (prevSecureTextEntry.current === secureTextEntry) {
          prevSelection.current = _selection;
        }
      } catch (e) {}
    }
    (0, useLayoutEffect.default)(() => {
      var node = hostRef.current;
      if (node != null && selection != null) {
        setSelection(node, selection);
      }
      if (document.activeElement === node) {
        TextInputState.default._currentlyFocusedNode = node;
      }
    }, [hostRef, selection]);
    var component = multiline ? 'textarea' : 'input';
    (0, useElementLayout.default)(hostRef, onLayout);
    (0, useResponderEvents.default)(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    var _useLocaleContext = (0, _modulesUseLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;
    var supportedProps = pickProps(props);
    supportedProps.autoCapitalize = autoCapitalize;
    supportedProps.autoComplete = autoComplete || autoCompleteType || 'on';
    supportedProps.autoCorrect = autoCorrect ? 'on' : 'off';
    // 'auto' by default allows browsers to infer writing direction
    supportedProps.dir = dir !== undefined ? dir : 'auto';
    /*
    if (returnKeyType != null) {
      warnOnce('returnKeyType', 'returnKeyType is deprecated. Use enterKeyHint.');
    }
    */
    supportedProps.enterKeyHint = enterKeyHint || returnKeyType;
    supportedProps.inputMode = _inputMode;
    supportedProps.onBlur = handleBlur;
    supportedProps.onChange = handleChange;
    supportedProps.onFocus = handleFocus;
    supportedProps.onKeyDown = handleKeyDown;
    supportedProps.onSelect = handleSelectionChange;
    /*
    if (editable != null) {
      warnOnce('editable', 'editable is deprecated. Use readOnly.');
    }
    */
    supportedProps.readOnly = readOnly === true || editable === false;
    /*
    if (numberOfLines != null) {
      warnOnce(
        'numberOfLines',
        'TextInput numberOfLines is deprecated. Use rows.'
      );
    }
    */
    supportedProps.rows = multiline ? rows != null ? rows : numberOfLines : 1;
    supportedProps.spellCheck = spellCheck != null ? spellCheck : autoCorrect;
    supportedProps.style = [{
      '--placeholderTextColor': placeholderTextColor
    }, styles.textinput$raw, styles.placeholder, props.style, caretHidden && styles.caretHidden];
    supportedProps.type = multiline ? undefined : type;
    supportedProps.virtualkeyboardpolicy = showSoftInputOnFocus === false ? 'manual' : 'auto';
    var platformMethodsRef = (0, usePlatformMethods.default)(supportedProps);
    var setRef = (0, useMergeRefs.default)(hostRef, platformMethodsRef, imperativeRef, forwardedRef);
    supportedProps.ref = setRef;
    var langDirection = props.lang != null ? (0, _modulesUseLocale.getLocaleDirection)(props.lang) : null;
    var componentDirection = props.dir || langDirection;
    var writingDirection = componentDirection || contextDirection;
    var element = (0, createElement.default)(component, supportedProps, {
      writingDirection
    });
    return element;
  });
  TextInput.displayName = 'TextInput';
  // $FlowFixMe
  TextInput.State = TextInputState.default;
  var styles = StyleSheet.default.create({
    textinput$raw: {
      MozAppearance: 'textfield',
      WebkitAppearance: 'none',
      backgroundColor: 'transparent',
      border: '0 solid black',
      borderRadius: 0,
      boxSizing: 'border-box',
      font: '14px System',
      margin: 0,
      padding: 0,
      resize: 'none'
    },
    placeholder: {
      placeholderTextColor: 'var(--placeholderTextColor)'
    },
    caretHidden: {
      caretColor: 'transparent'
    }
  });
  var _default = TextInput;
},436,[9,111,119,120,121,122,123,124,126,117,55,47],"node_modules/react-native-web/dist/exports/TextInput/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "HeaderShownContext", {
    enumerable: true,
    get: function () {
      return HeaderShownContext;
    }
  });
  var _getNamedContextJs = require(_dependencyMap[0], "../getNamedContext.js");
  const HeaderShownContext = (0, _getNamedContextJs.getNamedContext)('HeaderShownContext', false);
},437,[438],"node_modules/@react-navigation/elements/lib/module/Header/HeaderShownContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.getNamedContext = getNamedContext;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  const contexts = '__react_navigation__elements_contexts';
  // We use a global variable to keep our contexts so that we can reuse same contexts across packages
  globalThis[contexts] = globalThis[contexts] ?? new Map();
  function getNamedContext(name, initialValue) {
    let context = globalThis[contexts].get(name);
    if (context) {
      return context;
    }
    context = /*#__PURE__*/React.createContext(initialValue);
    context.displayName = name;
    globalThis[contexts].set(name, context);
    return context;
  }
},438,[9],"node_modules/@react-navigation/elements/lib/module/getNamedContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["tintColor", "style"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.HeaderTitle = HeaderTitle;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[2], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[3], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactJsxRuntime = require(_dependencyMap[5], "react/jsx-runtime");
  function HeaderTitle(_ref) {
    let {
        tintColor,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const {
      colors,
      fonts
    } = (0, _reactNavigationNative.useTheme)();
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Animated.default.Text, Object.assign({
      role: "heading",
      "aria-level": "1",
      numberOfLines: 1
    }, rest, {
      style: [{
        color: tintColor === undefined ? colors.text : tintColor
      }, Platform.default.select({
        ios: fonts.bold,
        default: fonts.medium
      }), styles.title, style]
    }));
  }
  const styles = StyleSheet.default.create({
    title: Platform.default.select({
      ios: {
        fontSize: 17
      },
      android: {
        fontSize: 20
      },
      default: {
        fontSize: 18
      }
    })
  });
},439,[759,253,166,14,55,274],"node_modules/@react-navigation/elements/lib/module/Header/HeaderTitle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "HeaderBackContext", {
    enumerable: true,
    get: function () {
      return HeaderBackContext;
    }
  });
  var _getNamedContextJs = require(_dependencyMap[0], "../getNamedContext.js");
  const HeaderBackContext = (0, _getNamedContextJs.getNamedContext)('HeaderBackContext', undefined);
},440,[438],"node_modules/@react-navigation/elements/lib/module/Header/HeaderBackContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "HeaderHeightContext", {
    enumerable: true,
    get: function () {
      return HeaderHeightContext;
    }
  });
  var _getNamedContextJs = require(_dependencyMap[0], "../getNamedContext.js");
  const HeaderHeightContext = (0, _getNamedContextJs.getNamedContext)('HeaderHeightContext', undefined);
},441,[438],"node_modules/@react-navigation/elements/lib/module/Header/HeaderHeightContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useHeaderHeight = useHeaderHeight;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _HeaderHeightContextJs = require(_dependencyMap[1], "./HeaderHeightContext.js");
  function useHeaderHeight() {
    const height = React.useContext(_HeaderHeightContextJs.HeaderHeightContext);
    if (height === undefined) {
      throw new Error("Couldn't find the header height. Are you inside a screen in a navigator with a header?");
    }
    return height;
  }
},442,[9,441],"node_modules/@react-navigation/elements/lib/module/Header/useHeaderHeight.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.getLabel = getLabel;
  function getLabel(options, fallback) {
    return options.label !== undefined ? options.label : options.title !== undefined ? options.title : fallback;
  }
},443,[],"node_modules/@react-navigation/elements/lib/module/Label/getLabel.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["tintColor", "style"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.Label = Label;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[1], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _TextJs = require(_dependencyMap[2], "../Text.js");
  var _reactJsxRuntime = require(_dependencyMap[3], "react/jsx-runtime");
  function Label(_ref) {
    let {
        tintColor,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_TextJs.Text, Object.assign({
      numberOfLines: 1
    }, rest, {
      style: [styles.label, tintColor != null && {
        color: tintColor
      }, style]
    }));
  }
  const styles = StyleSheet.default.create({
    label: {
      textAlign: 'center',
      backgroundColor: 'transparent'
    }
  });
},444,[759,55,418,274],"node_modules/@react-navigation/elements/lib/module/Label/Label.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.Lazy = Lazy;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  /**
   * Render content lazily based on visibility.
   *
   * When enabled:
   * - If content is visible, it will render immediately
   * - If content is not visible, it won't render until it becomes visible
   *
   * Otherwise:
   * - If content is visible, it will render immediately
   * - If content is not visible, it will defer rendering until idle
   *
   * Once rendered, the content remains rendered.
   */
  function Lazy({
    enabled,
    visible,
    children
  }) {
    const [rendered, setRendered] = React.useState(enabled ? visible : false);
    const shouldRenderInIdle = !(enabled || visible || rendered);
    React.useEffect(() => {
      if (shouldRenderInIdle === false) {
        return;
      }
      const id = requestIdleCallback(() => {
        setRendered(true);
      });
      return () => cancelIdleCallback(id);
    }, [shouldRenderInIdle]);
    if (visible && rendered === false) {
      setRendered(true);
      return children;
    }
    if (rendered) {
      return children;
    }
    return null;
  }
},445,[9],"node_modules/@react-navigation/elements/lib/module/Lazy.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.MissingIcon = MissingIcon;
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[0], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _TextJs = require(_dependencyMap[1], "./Text.js");
  var _reactJsxRuntime = require(_dependencyMap[2], "react/jsx-runtime");
  function MissingIcon({
    color,
    size,
    style
  }) {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_TextJs.Text, {
      style: [styles.icon, {
        color,
        fontSize: size
      }, style],
      children: "\u23F7"
    });
  }
  const styles = StyleSheet.default.create({
    icon: {
      backgroundColor: 'transparent'
    }
  });
},446,[55,418,274],"node_modules/@react-navigation/elements/lib/module/MissingIcon.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["visible", "children", "style"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.ResourceSavingView = ResourceSavingView;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  require(_dependencyMap[1], "react");
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[2], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsView = require(_dependencyMap[4], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactJsxRuntime = require(_dependencyMap[5], "react/jsx-runtime");
  const FAR_FAR_AWAY = 30000; // this should be big enough to move the whole view out of its container

  function ResourceSavingView(_ref) {
    let {
        visible,
        children,
        style
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    if (Platform.default.OS === 'web') {
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default // @ts-expect-error: hidden exists on web, but not in React Native
      , Object.assign({
        hidden: !visible,
        style: [{
          display: visible ? 'flex' : 'none'
        }, styles.container, style],
        pointerEvents: visible ? 'auto' : 'none'
      }, rest, {
        children: children
      }));
    }
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
      style: [styles.container, style]
      // box-none doesn't seem to work properly on Android
      ,

      pointerEvents: visible ? 'auto' : 'none',
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
        collapsable: false,
        removeClippedSubviews:
        // On iOS & macOS, set removeClippedSubviews to true only when not focused
        // This is an workaround for a bug where the clipped view never re-appears
        Platform.default.OS === 'ios' || Platform.default.OS === 'macos' ? !visible : true,
        pointerEvents: visible ? 'auto' : 'none',
        style: visible ? styles.attached : styles.detached,
        children: children
      })
    });
  }
  const styles = StyleSheet.default.create({
    container: {
      flex: 1,
      overflow: 'hidden'
    },
    attached: {
      flex: 1
    },
    detached: {
      flex: 1,
      top: FAR_FAR_AWAY
    }
  });
},447,[759,9,14,55,110,274],"node_modules/@react-navigation/elements/lib/module/ResourceSavingView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.SafeAreaProviderCompat = SafeAreaProviderCompat;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsDimensions = require(_dependencyMap[1], "react-native-web/dist/exports/Dimensions");
  var Dimensions = _interopDefault(_reactNativeWebDistExportsDimensions);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[2], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsView = require(_dependencyMap[4], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactNativeSafeAreaContext = require(_dependencyMap[5], "react-native-safe-area-context");
  var _useFrameSizeJs = require(_dependencyMap[6], "./useFrameSize.js");
  var _reactJsxRuntime = require(_dependencyMap[7], "react/jsx-runtime");
  const {
    width = 0,
    height = 0
  } = Dimensions.default.get('window');

  // To support SSR on web, we need to have empty insets for initial values
  // Otherwise there can be mismatch between SSR and client output
  // We also need to specify empty values to support tests environments
  const initialMetrics = Platform.default.OS === 'web' || _reactNativeSafeAreaContext.initialWindowMetrics == null ? {
    frame: {
      x: 0,
      y: 0,
      width,
      height
    },
    insets: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }
  } : _reactNativeSafeAreaContext.initialWindowMetrics;
  function SafeAreaProviderCompat({
    children,
    style
  }) {
    const insets = React.useContext(_reactNativeSafeAreaContext.SafeAreaInsetsContext);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_useFrameSizeJs.FrameSizeProvider, {
      initialFrame: initialMetrics.frame,
      render: ({
        ref,
        onLayout
      }) => {
        if (insets) {
          // If we already have insets, don't wrap the stack in another safe area provider
          // This avoids an issue with updates at the cost of potentially incorrect values
          // https://github.com/react-navigation/react-navigation/issues/174
          return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
            ref: ref,
            onLayout: onLayout,
            style: [styles.container, style],
            children: children
          });
        }

        // SafeAreaProvider doesn't forward ref
        // So we only pass onLayout to it
        return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNativeSafeAreaContext.SafeAreaProvider, {
          initialMetrics: initialMetrics,
          style: style,
          onLayout: onLayout,
          children: children
        });
      }
    });
  }
  SafeAreaProviderCompat.initialMetrics = initialMetrics;
  const styles = StyleSheet.default.create({
    container: {
      flex: 1
    }
  });
},448,[9,44,14,55,110,423,429,274],"node_modules/@react-navigation/elements/lib/module/SafeAreaProviderCompat.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.Screen = Screen;
  var _reactNavigationNative = require(_dependencyMap[0], "@react-navigation/native");
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsView = require(_dependencyMap[3], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactNativeSafeAreaContext = require(_dependencyMap[4], "react-native-safe-area-context");
  var _BackgroundJs = require(_dependencyMap[5], "./Background.js");
  var _HeaderGetDefaultHeaderHeightJs = require(_dependencyMap[6], "./Header/getDefaultHeaderHeight.js");
  var _HeaderHeaderHeightContextJs = require(_dependencyMap[7], "./Header/HeaderHeightContext.js");
  var _HeaderHeaderShownContextJs = require(_dependencyMap[8], "./Header/HeaderShownContext.js");
  var _useFrameSizeJs = require(_dependencyMap[9], "./useFrameSize.js");
  var _reactJsxRuntime = require(_dependencyMap[10], "react/jsx-runtime");
  function Screen(props) {
    const insets = (0, _reactNativeSafeAreaContext.useSafeAreaInsets)();
    const isParentHeaderShown = React.useContext(_HeaderHeaderShownContextJs.HeaderShownContext);
    const parentHeaderHeight = React.useContext(_HeaderHeaderHeightContextJs.HeaderHeightContext);
    const {
      focused,
      modal = false,
      header,
      headerShown = true,
      headerTransparent,
      headerStatusBarHeight = isParentHeaderShown ? 0 : insets.top,
      navigation,
      route,
      children,
      style
    } = props;
    const defaultHeaderHeight = (0, _useFrameSizeJs.useFrameSize)(size => (0, _HeaderGetDefaultHeaderHeightJs.getDefaultHeaderHeight)(size, modal, headerStatusBarHeight));
    const headerRef = React.useRef(null);
    const [headerHeight, setHeaderHeight] = React.useState(defaultHeaderHeight);
    React.useLayoutEffect(() => {
      headerRef.current?.measure((_x, _y, _width, height) => {
        setHeaderHeight(height);
      });
    }, [route.name]);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(_BackgroundJs.Background, {
      "aria-hidden": !focused,
      style: [styles.container, style]
      // On Fabric we need to disable collapsing for the background to ensure
      // that we won't render unnecessary views due to the view flattening.
      ,

      collapsable: false,
      children: [headerShown ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationNative.NavigationContext.Provider, {
        value: navigation,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationNative.NavigationRouteContext.Provider, {
          value: route,
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
            ref: headerRef,
            pointerEvents: "box-none",
            onLayout: e => {
              const {
                height
              } = e.nativeEvent.layout;
              setHeaderHeight(height);
            },
            style: [styles.header, headerTransparent ? styles.absolute : null],
            children: header
          })
        })
      }) : null, /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
        style: styles.content,
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderHeaderShownContextJs.HeaderShownContext.Provider, {
          value: isParentHeaderShown || headerShown !== false,
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_HeaderHeaderHeightContextJs.HeaderHeightContext.Provider, {
            value: headerShown ? headerHeight : parentHeaderHeight ?? 0,
            children: children
          })
        })
      })]
    });
  }
  const styles = StyleSheet.default.create({
    container: {
      flex: 1
    },
    content: {
      flex: 1
    },
    header: {
      zIndex: 1
    },
    absolute: {
      position: 'absolute',
      top: 0,
      start: 0,
      end: 0
    }
  });
},449,[253,9,55,110,423,406,420,441,437,429,274],"node_modules/@react-navigation/elements/lib/module/Screen.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},450,[],"node_modules/@react-navigation/elements/lib/module/types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "BottomTabBarHeightCallbackContext", {
    enumerable: true,
    get: function () {
      return BottomTabBarHeightCallbackContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  const BottomTabBarHeightCallbackContext = /*#__PURE__*/React.createContext(undefined);
},451,[9],"node_modules/@react-navigation/bottom-tabs/lib/module/utils/BottomTabBarHeightCallbackContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "BottomTabBarHeightContext", {
    enumerable: true,
    get: function () {
      return BottomTabBarHeightContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  const BottomTabBarHeightContext = /*#__PURE__*/React.createContext(undefined);
},452,[9],"node_modules/@react-navigation/bottom-tabs/lib/module/utils/BottomTabBarHeightContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.useAnimatedHashMap = useAnimatedHashMap;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[1], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  function useAnimatedHashMap({
    routes,
    index
  }) {
    const refs = React.useRef({});
    const previous = refs.current;
    const routeKeys = Object.keys(previous);
    if (routes.length === routeKeys.length && routes.every(route => routeKeys.includes(route.key))) {
      return previous;
    }
    refs.current = {};
    routes.forEach(({
      key
    }, i) => {
      refs.current[key] = previous[key] ?? new Animated.default.Value(i === index ? 0 : i >= index ? 1 : -1);
    });
    return refs.current;
  }
},453,[9,166],"node_modules/@react-navigation/bottom-tabs/lib/module/utils/useAnimatedHashMap.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "getTabBarHeight", {
    enumerable: true,
    get: function () {
      return getTabBarHeight;
    }
  });
  exports.BottomTabBar = BottomTabBar;
  var _reactNavigationElements = require(_dependencyMap[0], "@react-navigation/elements");
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _react = require(_dependencyMap[2], "react");
  var React = _interopDefault(_react);
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[3], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[4], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsView = require(_dependencyMap[6], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _utilsBottomTabBarHeightCallbackContextJs = require(_dependencyMap[7], "../utils/BottomTabBarHeightCallbackContext.js");
  var _utilsUseIsKeyboardShownJs = require(_dependencyMap[8], "../utils/useIsKeyboardShown.js");
  var _BottomTabItemJs = require(_dependencyMap[9], "./BottomTabItem.js");
  var _reactJsxRuntime = require(_dependencyMap[10], "react/jsx-runtime");
  const TABBAR_HEIGHT_UIKIT = 49;
  const TABBAR_HEIGHT_UIKIT_COMPACT = 32;
  const SPACING_UIKIT = 15;
  const SPACING_MATERIAL = 12;
  const DEFAULT_MAX_TAB_ITEM_WIDTH = 125;
  const useNativeDriver = Platform.default.OS !== 'web';
  const shouldUseHorizontalLabels = ({
    state,
    descriptors,
    dimensions
  }) => {
    const {
      tabBarLabelPosition
    } = descriptors[state.routes[state.index].key].options;
    if (tabBarLabelPosition) {
      switch (tabBarLabelPosition) {
        case 'beside-icon':
          return true;
        case 'below-icon':
          return false;
      }
    }
    if (dimensions.width >= 768) {
      // Screen size matches a tablet
      const maxTabWidth = state.routes.reduce((acc, route) => {
        const {
          tabBarItemStyle
        } = descriptors[route.key].options;
        const flattenedStyle = StyleSheet.default.flatten(tabBarItemStyle);
        if (flattenedStyle) {
          if (typeof flattenedStyle.width === 'number') {
            return acc + flattenedStyle.width;
          } else if (typeof flattenedStyle.maxWidth === 'number') {
            return acc + flattenedStyle.maxWidth;
          }
        }
        return acc + DEFAULT_MAX_TAB_ITEM_WIDTH;
      }, 0);
      return maxTabWidth <= dimensions.width;
    } else {
      return dimensions.width > dimensions.height;
    }
  };
  const isCompact = ({
    state,
    descriptors,
    dimensions
  }) => {
    const {
      tabBarPosition,
      tabBarVariant
    } = descriptors[state.routes[state.index].key].options;
    if (tabBarPosition === 'left' || tabBarPosition === 'right' || tabBarVariant === 'material') {
      return false;
    }
    const isLandscape = dimensions.width > dimensions.height;
    const horizontalLabels = shouldUseHorizontalLabels({
      state,
      descriptors,
      dimensions
    });
    if (Platform.default.OS === 'ios' && !Platform.default.isPad && isLandscape && horizontalLabels) {
      return true;
    }
    return false;
  };
  const getTabBarHeight = ({
    state,
    descriptors,
    dimensions,
    insets,
    style
  }) => {
    const {
      tabBarPosition
    } = descriptors[state.routes[state.index].key].options;
    const flattenedStyle = StyleSheet.default.flatten(style);
    const customHeight = flattenedStyle && 'height' in flattenedStyle ? flattenedStyle.height : undefined;
    if (typeof customHeight === 'number') {
      return customHeight;
    }
    const inset = insets[tabBarPosition === 'top' ? 'top' : 'bottom'];
    if (isCompact({
      state,
      descriptors,
      dimensions
    })) {
      return TABBAR_HEIGHT_UIKIT_COMPACT + inset;
    }
    return TABBAR_HEIGHT_UIKIT + inset;
  };
  function BottomTabBar({
    state,
    navigation,
    descriptors,
    insets,
    style
  }) {
    const {
      colors
    } = (0, _reactNavigationNative.useTheme)();
    const {
      direction
    } = (0, _reactNavigationNative.useLocale)();
    const {
      buildHref
    } = (0, _reactNavigationNative.useLinkBuilder)();
    const focusedRoute = state.routes[state.index];
    const focusedDescriptor = descriptors[focusedRoute.key];
    const focusedOptions = focusedDescriptor.options;
    const {
      tabBarPosition = 'bottom',
      tabBarShowLabel,
      tabBarLabelPosition,
      tabBarHideOnKeyboard = false,
      tabBarVisibilityAnimationConfig,
      tabBarVariant = 'uikit',
      tabBarStyle,
      tabBarBackground,
      tabBarActiveTintColor,
      tabBarInactiveTintColor,
      tabBarActiveBackgroundColor,
      tabBarInactiveBackgroundColor
    } = focusedOptions;
    if (tabBarVariant === 'material' && tabBarPosition !== 'left' && tabBarPosition !== 'right') {
      throw new Error("The 'material' variant for tab bar is only supported when 'tabBarPosition' is set to 'left' or 'right'.");
    }
    if (tabBarLabelPosition === 'below-icon' && tabBarVariant === 'uikit' && (tabBarPosition === 'left' || tabBarPosition === 'right')) {
      throw new Error("The 'below-icon' label position for tab bar is only supported when 'tabBarPosition' is set to 'top' or 'bottom' when using the 'uikit' variant.");
    }
    const isKeyboardShown = (0, _utilsUseIsKeyboardShownJs.useIsKeyboardShown)();
    const onHeightChange = React.default.useContext(_utilsBottomTabBarHeightCallbackContextJs.BottomTabBarHeightCallbackContext);
    const shouldShowTabBar = !(tabBarHideOnKeyboard && isKeyboardShown);
    const visibilityAnimationConfigRef = React.default.useRef(tabBarVisibilityAnimationConfig);
    React.default.useEffect(() => {
      visibilityAnimationConfigRef.current = tabBarVisibilityAnimationConfig;
    });
    const [isTabBarHidden, setIsTabBarHidden] = React.default.useState(!shouldShowTabBar);
    const [visible] = React.default.useState(() => new Animated.default.Value(shouldShowTabBar ? 1 : 0));
    React.default.useEffect(() => {
      const visibilityAnimationConfig = visibilityAnimationConfigRef.current;
      if (shouldShowTabBar) {
        const animation = visibilityAnimationConfig?.show?.animation === 'spring' ? Animated.default.spring : Animated.default.timing;
        animation(visible, Object.assign({
          toValue: 1,
          useNativeDriver,
          duration: 250
        }, visibilityAnimationConfig?.show?.config)).start(({
          finished
        }) => {
          if (finished) {
            setIsTabBarHidden(false);
          }
        });
      } else {
        // eslint-disable-next-line @eslint-react/hooks-extra/no-direct-set-state-in-use-effect
        setIsTabBarHidden(true);
        const animation = visibilityAnimationConfig?.hide?.animation === 'spring' ? Animated.default.spring : Animated.default.timing;
        animation(visible, Object.assign({
          toValue: 0,
          useNativeDriver,
          duration: 200
        }, visibilityAnimationConfig?.hide?.config)).start();
      }
      return () => visible.stopAnimation();
    }, [visible, shouldShowTabBar]);
    const [layout, setLayout] = React.default.useState({
      height: 0
    });
    const handleLayout = e => {
      const {
        height
      } = e.nativeEvent.layout;
      onHeightChange?.(height);
      setLayout(layout => {
        if (height === layout.height) {
          return layout;
        } else {
          return {
            height
          };
        }
      });
    };
    const {
      routes
    } = state;
    const tabBarHeight = (0, _reactNavigationElements.useFrameSize)(dimensions => getTabBarHeight({
      state,
      descriptors,
      insets,
      dimensions,
      style: [tabBarStyle, style]
    }));
    const hasHorizontalLabels = (0, _reactNavigationElements.useFrameSize)(dimensions => shouldUseHorizontalLabels({
      state,
      descriptors,
      dimensions
    }));
    const compact = (0, _reactNavigationElements.useFrameSize)(dimensions => isCompact({
      state,
      descriptors,
      dimensions
    }));
    const sidebar = tabBarPosition === 'left' || tabBarPosition === 'right';
    const spacing = tabBarVariant === 'material' ? SPACING_MATERIAL : SPACING_UIKIT;
    const minSidebarWidth = (0, _reactNavigationElements.useFrameSize)(size => sidebar && hasHorizontalLabels ? (0, _reactNavigationElements.getDefaultSidebarWidth)(size) : 0);
    const tabBarBackgroundElement = tabBarBackground?.();
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(Animated.default.View, {
      style: [tabBarPosition === 'left' ? styles.start : tabBarPosition === 'right' ? styles.end : styles.bottom, (Platform.default.OS === 'web' ? tabBarPosition === 'right' : direction === 'rtl' && tabBarPosition === 'left' || direction !== 'rtl' && tabBarPosition === 'right') ? {
        borderLeftWidth: StyleSheet.default.hairlineWidth
      } : (Platform.default.OS === 'web' ? tabBarPosition === 'left' : direction === 'rtl' && tabBarPosition === 'right' || direction !== 'rtl' && tabBarPosition === 'left') ? {
        borderRightWidth: StyleSheet.default.hairlineWidth
      } : tabBarPosition === 'top' ? {
        borderBottomWidth: StyleSheet.default.hairlineWidth
      } : {
        borderTopWidth: StyleSheet.default.hairlineWidth
      }, {
        backgroundColor: tabBarBackgroundElement != null ? 'transparent' : colors.card,
        borderColor: colors.border
      }, sidebar ? {
        paddingTop: (hasHorizontalLabels ? spacing : spacing / 2) + insets.top,
        paddingBottom: (hasHorizontalLabels ? spacing : spacing / 2) + insets.bottom,
        paddingStart: spacing + (tabBarPosition === 'left' ? insets.left : 0),
        paddingEnd: spacing + (tabBarPosition === 'right' ? insets.right : 0),
        minWidth: minSidebarWidth
      } : [{
        transform: [{
          translateY: visible.interpolate({
            inputRange: [0, 1],
            outputRange: [layout.height + insets[tabBarPosition === 'top' ? 'top' : 'bottom'] + StyleSheet.default.hairlineWidth, 0]
          })
        }],
        // Absolutely position the tab bar so that the content is below it
        // This is needed to avoid gap at bottom when the tab bar is hidden
        position: isTabBarHidden ? 'absolute' : undefined
      }, {
        height: tabBarHeight,
        paddingBottom: tabBarPosition === 'bottom' ? insets.bottom : 0,
        paddingTop: tabBarPosition === 'top' ? insets.top : 0,
        paddingHorizontal: Math.max(insets.left, insets.right)
      }], tabBarStyle],
      pointerEvents: isTabBarHidden ? 'none' : 'auto',
      onLayout: sidebar ? undefined : handleLayout,
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
        pointerEvents: "none",
        style: StyleSheet.default.absoluteFill,
        children: tabBarBackgroundElement
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
        role: "tablist",
        style: sidebar ? styles.sideContent : styles.bottomContent,
        children: routes.map((route, index) => {
          const focused = index === state.index;
          const {
            options
          } = descriptors[route.key];
          const onPress = () => {
            const event = navigation.emit({
              type: 'tabPress',
              target: route.key,
              canPreventDefault: true
            });
            if (!focused && !event.defaultPrevented) {
              navigation.dispatch(Object.assign({}, _reactNavigationNative.CommonActions.navigate(route), {
                target: state.key
              }));
            }
          };
          const onLongPress = () => {
            navigation.emit({
              type: 'tabLongPress',
              target: route.key
            });
          };
          const label = typeof options.tabBarLabel === 'function' ? options.tabBarLabel : (0, _reactNavigationElements.getLabel)({
            label: options.tabBarLabel,
            title: options.title
          }, route.name);
          const accessibilityLabel = options.tabBarAccessibilityLabel !== undefined ? options.tabBarAccessibilityLabel : typeof label === 'string' && Platform.default.OS === 'ios' ? `${label}, tab, ${index + 1} of ${routes.length}` : undefined;
          return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationNative.NavigationContext.Provider, {
            value: descriptors[route.key].navigation,
            children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationNative.NavigationRouteContext.Provider, {
              value: route,
              children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_BottomTabItemJs.BottomTabItem, {
                href: buildHref(route.name, route.params),
                route: route,
                descriptor: descriptors[route.key],
                focused: focused,
                horizontal: hasHorizontalLabels,
                compact: compact,
                sidebar: sidebar,
                variant: tabBarVariant,
                onPress: onPress,
                onLongPress: onLongPress,
                accessibilityLabel: accessibilityLabel,
                testID: options.tabBarButtonTestID,
                allowFontScaling: options.tabBarAllowFontScaling,
                activeTintColor: tabBarActiveTintColor,
                inactiveTintColor: tabBarInactiveTintColor,
                activeBackgroundColor: tabBarActiveBackgroundColor,
                inactiveBackgroundColor: tabBarInactiveBackgroundColor,
                button: options.tabBarButton,
                icon: options.tabBarIcon ?? (({
                  color,
                  size
                }) => /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationElements.MissingIcon, {
                  color: color,
                  size: size
                })),
                badge: options.tabBarBadge,
                badgeStyle: options.tabBarBadgeStyle,
                label: label,
                showLabel: tabBarShowLabel,
                labelStyle: options.tabBarLabelStyle,
                iconStyle: options.tabBarIconStyle,
                style: [sidebar ? {
                  marginVertical: hasHorizontalLabels ? tabBarVariant === 'material' ? 0 : 1 : spacing / 2
                } : styles.bottomItem, options.tabBarItemStyle]
              })
            })
          }, route.key);
        })
      })]
    });
  }
  const styles = StyleSheet.default.create({
    start: {
      top: 0,
      bottom: 0,
      start: 0
    },
    end: {
      top: 0,
      bottom: 0,
      end: 0
    },
    bottom: {
      start: 0,
      end: 0,
      bottom: 0,
      elevation: 8
    },
    bottomContent: {
      flex: 1,
      flexDirection: 'row'
    },
    sideContent: {
      flex: 1,
      flexDirection: 'column'
    },
    bottomItem: {
      flex: 1
    }
  });
},454,[400,253,9,166,14,55,110,451,455,457,274],"node_modules/@react-navigation/bottom-tabs/lib/module/views/BottomTabBar.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.useIsKeyboardShown = useIsKeyboardShown;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsKeyboard = require(_dependencyMap[1], "react-native-web/dist/exports/Keyboard");
  var Keyboard = _interopDefault(_reactNativeWebDistExportsKeyboard);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[2], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  function useIsKeyboardShown() {
    const [isKeyboardShown, setIsKeyboardShown] = React.useState(false);
    React.useEffect(() => {
      const handleKeyboardShow = () => setIsKeyboardShown(true);
      const handleKeyboardHide = () => setIsKeyboardShown(false);
      let subscriptions;
      if (Platform.default.OS === 'ios') {
        subscriptions = [Keyboard.default.addListener('keyboardWillShow', handleKeyboardShow), Keyboard.default.addListener('keyboardWillHide', handleKeyboardHide)];
      } else {
        subscriptions = [Keyboard.default.addListener('keyboardDidShow', handleKeyboardShow), Keyboard.default.addListener('keyboardDidHide', handleKeyboardHide)];
      }
      return () => {
        subscriptions.forEach(s => s.remove());
      };
    }, []);
    return isKeyboardShown;
  }
},455,[9,456,14],"node_modules/@react-navigation/bottom-tabs/lib/module/utils/useIsKeyboardShown.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesDismissKeyboard = require(_dependencyMap[0], "../../modules/dismissKeyboard");
  var dismissKeyboard = _interopDefault(_modulesDismissKeyboard);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  // in the future we can use https://github.com/w3c/virtual-keyboard
  var Keyboard = {
    isVisible() {
      return false;
    },
    addListener() {
      return {
        remove: () => {}
      };
    },
    dismiss() {
      (0, dismissKeyboard.default)();
    },
    removeAllListeners() {},
    removeListener() {}
  };
  var _default = Keyboard;
},456,[46],"node_modules/react-native-web/dist/exports/Keyboard/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.BottomTabItem = BottomTabItem;
  var _reactNavigationElements = require(_dependencyMap[0], "@react-navigation/elements");
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _color = require(_dependencyMap[2], "color");
  var Color = _interopDefault(_color);
  var _react = require(_dependencyMap[3], "react");
  var React = _interopDefault(_react);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[4], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[5], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsView = require(_dependencyMap[6], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _TabBarIconJs = require(_dependencyMap[7], "./TabBarIcon.js");
  var _reactJsxRuntime = require(_dependencyMap[8], "react/jsx-runtime");
  const renderButtonDefault = props => /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationElements.PlatformPressable, Object.assign({}, props));
  const SUPPORTS_LARGE_CONTENT_VIEWER = Platform.default.OS === 'ios' && parseInt(Platform.default.Version, 10) >= 13;
  function BottomTabItem({
    route,
    href,
    focused,
    descriptor,
    label,
    icon,
    badge,
    badgeStyle,
    button = renderButtonDefault,
    accessibilityLabel,
    testID,
    onPress,
    onLongPress,
    horizontal,
    compact,
    sidebar,
    variant,
    activeTintColor: customActiveTintColor,
    inactiveTintColor: customInactiveTintColor,
    activeBackgroundColor: customActiveBackgroundColor,
    inactiveBackgroundColor = 'transparent',
    showLabel = true,
    // On iOS 13+, we use `largeContentTitle` for accessibility
    // So we don't need the font to scale up
    // https://developer.apple.com/documentation/uikit/uiview/3183939-largecontenttitle
    allowFontScaling = SUPPORTS_LARGE_CONTENT_VIEWER ? false : undefined,
    labelStyle,
    iconStyle,
    style
  }) {
    const {
      colors,
      fonts
    } = (0, _reactNavigationNative.useTheme)();
    const activeTintColor = customActiveTintColor ?? (variant === 'uikit' && sidebar && horizontal ? (0, Color.default)(colors.primary).isDark() ? 'white' : (0, Color.default)(colors.primary).darken(0.71).string() : colors.primary);
    const inactiveTintColor = customInactiveTintColor === undefined ? variant === 'material' ? (0, Color.default)(colors.text).alpha(0.68).rgb().string() : (0, Color.default)(colors.text).mix((0, Color.default)(colors.card), 0.5).hex() : customInactiveTintColor;
    const activeBackgroundColor = customActiveBackgroundColor ?? (variant === 'material' ? (0, Color.default)(activeTintColor).alpha(0.12).rgb().string() : sidebar && horizontal ? colors.primary : 'transparent');
    const {
      options
    } = descriptor;
    const labelString = (0, _reactNavigationElements.getLabel)({
      label: typeof options.tabBarLabel === 'string' ? options.tabBarLabel : undefined,
      title: options.title
    }, route.name);
    let labelInactiveTintColor = inactiveTintColor;
    let iconInactiveTintColor = inactiveTintColor;
    if (variant === 'uikit' && sidebar && horizontal && customInactiveTintColor === undefined) {
      iconInactiveTintColor = colors.primary;
      labelInactiveTintColor = colors.text;
    }
    const renderLabel = ({
      focused
    }) => {
      if (showLabel === false) {
        return null;
      }
      const color = focused ? activeTintColor : labelInactiveTintColor;
      if (typeof label !== 'string') {
        return label({
          focused,
          color,
          position: horizontal ? 'beside-icon' : 'below-icon',
          children: labelString
        });
      }
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationElements.Label, {
        style: [horizontal ? [styles.labelBeside, variant === 'material' ? styles.labelSidebarMaterial : sidebar ? styles.labelSidebarUiKit : compact ? styles.labelBesideUikitCompact : styles.labelBesideUikit, icon == null && {
          marginStart: 0
        }] : styles.labelBeneath, compact || variant === 'uikit' && sidebar && horizontal ? fonts.regular : fonts.medium, labelStyle],
        allowFontScaling: allowFontScaling,
        tintColor: color,
        children: label
      });
    };
    const renderIcon = ({
      focused
    }) => {
      if (icon === undefined) {
        return null;
      }
      const activeOpacity = focused ? 1 : 0;
      const inactiveOpacity = focused ? 0 : 1;
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_TabBarIconJs.TabBarIcon, {
        route: route,
        variant: variant,
        size: compact ? 'compact' : 'regular',
        badge: badge,
        badgeStyle: badgeStyle,
        activeOpacity: activeOpacity,
        allowFontScaling: allowFontScaling,
        inactiveOpacity: inactiveOpacity,
        activeTintColor: activeTintColor,
        inactiveTintColor: iconInactiveTintColor,
        renderIcon: icon,
        style: iconStyle
      });
    };
    const scene = {
      route,
      focused
    };
    const backgroundColor = focused ? activeBackgroundColor : inactiveBackgroundColor;
    const {
      flex
    } = StyleSheet.default.flatten(style || {});
    const borderRadius = variant === 'material' ? horizontal ? 56 : 16 : sidebar && horizontal ? 10 : 0;
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
      style: [
      // Clip ripple effect on Android
      {
        borderRadius,
        overflow: variant === 'material' ? 'hidden' : 'visible'
      }, style],
      children: button({
        href,
        onPress,
        onLongPress,
        testID,
        'aria-label': accessibilityLabel,
        'accessibilityLargeContentTitle': labelString,
        'accessibilityShowsLargeContentViewer': true,
        // FIXME: role: 'tab' doesn't seem to work as expected on iOS
        'role': Platform.default.select({
          ios: 'button',
          default: 'tab'
        }),
        'aria-selected': focused,
        'android_ripple': {
          borderless: true
        },
        'hoverEffect': variant === 'material' || sidebar && horizontal ? {
          color: colors.text
        } : undefined,
        'pressOpacity': 1,
        'style': [styles.tab, {
          flex,
          backgroundColor,
          borderRadius
        }, sidebar ? variant === 'material' ? horizontal ? styles.tabBarSidebarMaterial : styles.tabVerticalMaterial : horizontal ? styles.tabBarSidebarUiKit : styles.tabVerticalUiKit : variant === 'material' ? styles.tabVerticalMaterial : horizontal ? styles.tabHorizontalUiKit : styles.tabVerticalUiKit],
        'children': /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(React.default.Fragment, {
          children: [renderIcon(scene), renderLabel(scene)]
        })
      })
    });
  }
  const styles = StyleSheet.default.create({
    tab: {
      alignItems: 'center',
      // Roundness for iPad hover effect
      borderRadius: 10,
      borderCurve: 'continuous'
    },
    tabVerticalUiKit: {
      justifyContent: 'flex-start',
      flexDirection: 'column',
      padding: 5
    },
    tabVerticalMaterial: {
      padding: 10
    },
    tabHorizontalUiKit: {
      justifyContent: 'center',
      alignItems: 'center',
      flexDirection: 'row',
      padding: 5
    },
    tabBarSidebarUiKit: {
      justifyContent: 'flex-start',
      alignItems: 'center',
      flexDirection: 'row',
      paddingVertical: 7,
      paddingHorizontal: 5
    },
    tabBarSidebarMaterial: {
      justifyContent: 'flex-start',
      alignItems: 'center',
      flexDirection: 'row',
      paddingVertical: 15,
      paddingStart: 16,
      paddingEnd: 24
    },
    labelSidebarMaterial: {
      marginStart: 12
    },
    labelSidebarUiKit: {
      fontSize: 17,
      marginStart: 10
    },
    labelBeneath: {
      fontSize: 10
    },
    labelBeside: {
      marginEnd: 12,
      lineHeight: 24
    },
    labelBesideUikit: {
      fontSize: 13,
      marginStart: 5
    },
    labelBesideUikitCompact: {
      fontSize: 12,
      marginStart: 5
    }
  });
},457,[400,253,408,9,14,55,110,458,274],"node_modules/@react-navigation/bottom-tabs/lib/module/views/BottomTabItem.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.TabBarIcon = TabBarIcon;
  var _reactNavigationElements = require(_dependencyMap[0], "@react-navigation/elements");
  require(_dependencyMap[1], "react");
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[2], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsView = require(_dependencyMap[3], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactJsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  /**
   * Icon sizes taken from Apple HIG
   * https://developer.apple.com/design/human-interface-guidelines/tab-bars
   */
  const ICON_SIZE_WIDE = 31;
  const ICON_SIZE_WIDE_COMPACT = 23;
  const ICON_SIZE_TALL = 28;
  const ICON_SIZE_TALL_COMPACT = 20;
  const ICON_SIZE_ROUND = 25;
  const ICON_SIZE_ROUND_COMPACT = 18;
  const ICON_SIZE_MATERIAL = 24;
  function TabBarIcon({
    route: _,
    variant,
    size,
    badge,
    badgeStyle,
    activeOpacity,
    inactiveOpacity,
    activeTintColor,
    inactiveTintColor,
    renderIcon,
    allowFontScaling,
    style
  }) {
    const iconSize = variant === 'material' ? ICON_SIZE_MATERIAL : size === 'compact' ? ICON_SIZE_ROUND_COMPACT : ICON_SIZE_ROUND;

    // We render the icon twice at the same position on top of each other:
    // active and inactive one, so we can fade between them.
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(View.default, {
      style: [variant === 'material' ? styles.wrapperMaterial : size === 'compact' ? styles.wrapperUikitCompact : styles.wrapperUikit, style],
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
        style: [styles.icon, {
          opacity: activeOpacity,
          // Workaround for react-native >= 0.54 layout bug
          minWidth: iconSize
        }],
        children: renderIcon({
          focused: true,
          size: iconSize,
          color: activeTintColor
        })
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
        style: [styles.icon, {
          opacity: inactiveOpacity
        }],
        children: renderIcon({
          focused: false,
          size: iconSize,
          color: inactiveTintColor
        })
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationElements.Badge, {
        visible: badge != null,
        size: iconSize * 0.75,
        allowFontScaling: allowFontScaling,
        style: [styles.badge, badgeStyle],
        children: badge
      })]
    });
  }
  const styles = StyleSheet.default.create({
    icon: {
      // We render the icon twice at the same position on top of each other:
      // active and inactive one, so we can fade between them:
      // Cover the whole iconContainer:
      position: 'absolute',
      alignSelf: 'center',
      alignItems: 'center',
      justifyContent: 'center',
      height: '100%',
      width: '100%'
    },
    wrapperUikit: {
      width: ICON_SIZE_WIDE,
      height: ICON_SIZE_TALL
    },
    wrapperUikitCompact: {
      width: ICON_SIZE_WIDE_COMPACT,
      height: ICON_SIZE_TALL_COMPACT
    },
    wrapperMaterial: {
      width: ICON_SIZE_MATERIAL,
      height: ICON_SIZE_MATERIAL
    },
    badge: {
      position: 'absolute',
      end: -3,
      top: -3
    }
  });
},458,[400,9,55,110,274],"node_modules/@react-navigation/bottom-tabs/lib/module/views/TabBarIcon.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["enabled"],
    _excluded2 = ["enabled", "active"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "MaybeScreenContainer", {
    enumerable: true,
    get: function () {
      return MaybeScreenContainer;
    }
  });
  exports.MaybeScreen = MaybeScreen;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  require(_dependencyMap[1], "react");
  var _reactNativeWebDistExportsView = require(_dependencyMap[2], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactJsxRuntime = require(_dependencyMap[3], "react/jsx-runtime");
  let Screens;
  try {
    Screens = require(_dependencyMap[4], "react-native-screens");
  } catch (e) {
    // Ignore
  }
  const MaybeScreenContainer = _ref => {
    let {
        enabled
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    if (Screens?.screensEnabled?.()) {
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Screens.ScreenContainer, Object.assign({
        enabled: enabled
      }, rest));
    }
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, Object.assign({}, rest));
  };
  function MaybeScreen(_ref2) {
    let {
        enabled,
        active
      } = _ref2,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref2, _excluded2);
    if (Screens?.screensEnabled?.()) {
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Screens.Screen, Object.assign({
        enabled: enabled,
        activityState: active
      }, rest));
    }
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, Object.assign({}, rest));
  }
},459,[759,9,110,274,460],"node_modules/@react-navigation/bottom-tabs/lib/module/views/ScreenFallback.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "enableScreens", {
    enumerable: true,
    get: function () {
      return _core.enableScreens;
    }
  });
  Object.defineProperty(exports, "enableFreeze", {
    enumerable: true,
    get: function () {
      return _core.enableFreeze;
    }
  });
  Object.defineProperty(exports, "screensEnabled", {
    enumerable: true,
    get: function () {
      return _core.screensEnabled;
    }
  });
  Object.defineProperty(exports, "freezeEnabled", {
    enumerable: true,
    get: function () {
      return _core.freezeEnabled;
    }
  });
  Object.defineProperty(exports, "Screen", {
    enumerable: true,
    get: function () {
      return _componentsScreen2.default;
    }
  });
  Object.defineProperty(exports, "InnerScreen", {
    enumerable: true,
    get: function () {
      return _componentsScreen.InnerScreen;
    }
  });
  Object.defineProperty(exports, "ScreenContext", {
    enumerable: true,
    get: function () {
      return _componentsScreen.ScreenContext;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderConfig", {
    enumerable: true,
    get: function () {
      return _componentsScreenStackHeaderConfig.ScreenStackHeaderConfig;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderSubview", {
    enumerable: true,
    get: function () {
      return _componentsScreenStackHeaderConfig.ScreenStackHeaderSubview;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderLeftView", {
    enumerable: true,
    get: function () {
      return _componentsScreenStackHeaderConfig.ScreenStackHeaderLeftView;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderCenterView", {
    enumerable: true,
    get: function () {
      return _componentsScreenStackHeaderConfig.ScreenStackHeaderCenterView;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderRightView", {
    enumerable: true,
    get: function () {
      return _componentsScreenStackHeaderConfig.ScreenStackHeaderRightView;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderBackButtonImage", {
    enumerable: true,
    get: function () {
      return _componentsScreenStackHeaderConfig.ScreenStackHeaderBackButtonImage;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderSearchBarView", {
    enumerable: true,
    get: function () {
      return _componentsScreenStackHeaderConfig.ScreenStackHeaderSearchBarView;
    }
  });
  Object.defineProperty(exports, "SearchBar", {
    enumerable: true,
    get: function () {
      return _componentsSearchBar2.default;
    }
  });
  Object.defineProperty(exports, "ScreenContainer", {
    enumerable: true,
    get: function () {
      return _componentsScreenContainer2.default;
    }
  });
  Object.defineProperty(exports, "ScreenStack", {
    enumerable: true,
    get: function () {
      return _componentsScreenStack2.default;
    }
  });
  Object.defineProperty(exports, "ScreenStackItem", {
    enumerable: true,
    get: function () {
      return _componentsScreenStackItem2.default;
    }
  });
  Object.defineProperty(exports, "FullWindowOverlay", {
    enumerable: true,
    get: function () {
      return _componentsFullWindowOverlay2.default;
    }
  });
  Object.defineProperty(exports, "ScreenFooter", {
    enumerable: true,
    get: function () {
      return _componentsScreenFooter2.default;
    }
  });
  Object.defineProperty(exports, "ScreenContentWrapper", {
    enumerable: true,
    get: function () {
      return _componentsScreenContentWrapper2.default;
    }
  });
  Object.defineProperty(exports, "isSearchBarAvailableForCurrentPlatform", {
    enumerable: true,
    get: function () {
      return _utils.isSearchBarAvailableForCurrentPlatform;
    }
  });
  Object.defineProperty(exports, "executeNativeBackPress", {
    enumerable: true,
    get: function () {
      return _utils.executeNativeBackPress;
    }
  });
  Object.defineProperty(exports, "compatibilityFlags", {
    enumerable: true,
    get: function () {
      return _flags.compatibilityFlags;
    }
  });
  Object.defineProperty(exports, "featureFlags", {
    enumerable: true,
    get: function () {
      return _flags.featureFlags;
    }
  });
  Object.defineProperty(exports, "useTransitionProgress", {
    enumerable: true,
    get: function () {
      return _useTransitionProgress2.default;
    }
  });
  Object.defineProperty(exports, "BottomTabs", {
    enumerable: true,
    get: function () {
      return _componentsBottomTabsBottomTabs2.default;
    }
  });
  Object.defineProperty(exports, "BottomTabsScreen", {
    enumerable: true,
    get: function () {
      return _componentsBottomTabsBottomTabsScreen2.default;
    }
  });
  Object.defineProperty(exports, "ScreenStackHost", {
    enumerable: true,
    get: function () {
      return _componentsGammaScreenStackHost2.default;
    }
  });
  Object.defineProperty(exports, "StackScreen", {
    enumerable: true,
    get: function () {
      return _componentsGammaStackScreen2.default;
    }
  });
  Object.defineProperty(exports, "StackScreenLifecycleState", {
    enumerable: true,
    get: function () {
      return _componentsGammaStackScreen.StackScreenLifecycleState;
    }
  });
  Object.defineProperty(exports, "SplitViewHost", {
    enumerable: true,
    get: function () {
      return _componentsGammaSplitViewHost2.default;
    }
  });
  Object.defineProperty(exports, "SplitViewScreen", {
    enumerable: true,
    get: function () {
      return _componentsGammaSplitViewScreen2.default;
    }
  });
  require(_dependencyMap[0], "./fabric/NativeScreensModule");
  var _types = require(_dependencyMap[1], "./types");
  Object.keys(_types).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _types[k];
        }
      });
    }
  });
  var _core = require(_dependencyMap[2], "./core");
  var _componentsScreen = require(_dependencyMap[3], "./components/Screen");
  var _componentsScreen2 = _interopDefault(_componentsScreen);
  var _componentsScreenStackHeaderConfig = require(_dependencyMap[4], "./components/ScreenStackHeaderConfig");
  var _componentsSearchBar = require(_dependencyMap[5], "./components/SearchBar");
  var _componentsSearchBar2 = _interopDefault(_componentsSearchBar);
  var _componentsScreenContainer = require(_dependencyMap[6], "./components/ScreenContainer");
  var _componentsScreenContainer2 = _interopDefault(_componentsScreenContainer);
  var _componentsScreenStack = require(_dependencyMap[7], "./components/ScreenStack");
  var _componentsScreenStack2 = _interopDefault(_componentsScreenStack);
  var _componentsScreenStackItem = require(_dependencyMap[8], "./components/ScreenStackItem");
  var _componentsScreenStackItem2 = _interopDefault(_componentsScreenStackItem);
  var _componentsFullWindowOverlay = require(_dependencyMap[9], "./components/FullWindowOverlay");
  var _componentsFullWindowOverlay2 = _interopDefault(_componentsFullWindowOverlay);
  var _componentsScreenFooter = require(_dependencyMap[10], "./components/ScreenFooter");
  var _componentsScreenFooter2 = _interopDefault(_componentsScreenFooter);
  var _componentsScreenContentWrapper = require(_dependencyMap[11], "./components/ScreenContentWrapper");
  var _componentsScreenContentWrapper2 = _interopDefault(_componentsScreenContentWrapper);
  var _utils = require(_dependencyMap[12], "./utils");
  var _flags = require(_dependencyMap[13], "./flags");
  var _useTransitionProgress = require(_dependencyMap[14], "./useTransitionProgress");
  var _useTransitionProgress2 = _interopDefault(_useTransitionProgress);
  var _componentsBottomTabsBottomTabs = require(_dependencyMap[15], "./components/bottom-tabs/BottomTabs");
  var _componentsBottomTabsBottomTabs2 = _interopDefault(_componentsBottomTabsBottomTabs);
  var _componentsBottomTabsBottomTabsScreen = require(_dependencyMap[16], "./components/bottom-tabs/BottomTabsScreen");
  var _componentsBottomTabsBottomTabsScreen2 = _interopDefault(_componentsBottomTabsBottomTabsScreen);
  var _componentsGammaScreenStackHost = require(_dependencyMap[17], "./components/gamma/ScreenStackHost");
  var _componentsGammaScreenStackHost2 = _interopDefault(_componentsGammaScreenStackHost);
  var _componentsGammaStackScreen = require(_dependencyMap[18], "./components/gamma/StackScreen");
  var _componentsGammaStackScreen2 = _interopDefault(_componentsGammaStackScreen);
  var _componentsGammaSplitViewHost = require(_dependencyMap[19], "./components/gamma/SplitViewHost");
  var _componentsGammaSplitViewHost2 = _interopDefault(_componentsGammaSplitViewHost);
  var _componentsGammaSplitViewScreen = require(_dependencyMap[20], "./components/gamma/SplitViewScreen");
  var _componentsGammaSplitViewScreen2 = _interopDefault(_componentsGammaSplitViewScreen);
},460,[461,462,467,468,469,470,471,472,473,479,478,476,480,482,483,485,486,487,488,489,490],"node_modules/react-native-screens/lib/module/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _default = {};
},461,[],"node_modules/react-native-screens/lib/module/fabric/NativeScreensModule.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  var _componentsBottomTabsBottomTabsTypes = require(_dependencyMap[0], "./components/bottom-tabs/BottomTabs.types");
  Object.keys(_componentsBottomTabsBottomTabsTypes).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _componentsBottomTabsBottomTabsTypes[k];
        }
      });
    }
  });
  var _componentsBottomTabsBottomTabsScreenTypes = require(_dependencyMap[1], "./components/bottom-tabs/BottomTabsScreen.types");
  Object.keys(_componentsBottomTabsBottomTabsScreenTypes).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _componentsBottomTabsBottomTabsScreenTypes[k];
        }
      });
    }
  });
  var _componentsGammaSplitViewHostTypes = require(_dependencyMap[2], "./components/gamma/SplitViewHost.types");
  Object.keys(_componentsGammaSplitViewHostTypes).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _componentsGammaSplitViewHostTypes[k];
        }
      });
    }
  });
  var _componentsGammaSplitViewScreenTypes = require(_dependencyMap[3], "./components/gamma/SplitViewScreen.types");
  Object.keys(_componentsGammaSplitViewScreenTypes).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _componentsGammaSplitViewScreenTypes[k];
        }
      });
    }
  });
},462,[463,464,465,466],"node_modules/react-native-screens/lib/module/types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},463,[],"node_modules/react-native-screens/lib/module/components/bottom-tabs/BottomTabs.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},464,[],"node_modules/react-native-screens/lib/module/components/bottom-tabs/BottomTabsScreen.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},465,[],"node_modules/react-native-screens/lib/module/components/gamma/SplitViewHost.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},466,[],"node_modules/react-native-screens/lib/module/components/gamma/SplitViewScreen.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "isNativePlatformSupported", {
    enumerable: true,
    get: function () {
      return isNativePlatformSupported;
    }
  });
  exports.enableScreens = enableScreens;
  exports.enableFreeze = enableFreeze;
  exports.screensEnabled = screensEnabled;
  exports.freezeEnabled = freezeEnabled;
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[0], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsUIManager = require(_dependencyMap[1], "react-native-web/dist/exports/UIManager");
  var UIManager = _interopDefault(_reactNativeWebDistExportsUIManager);
  const isNativePlatformSupported = Platform.default.OS === 'ios' || Platform.default.OS === 'android' || Platform.default.OS === 'windows';
  let ENABLE_SCREENS = isNativePlatformSupported;
  function enableScreens(shouldEnableScreens = true) {
    ENABLE_SCREENS = shouldEnableScreens;
    if (!isNativePlatformSupported) {
      return;
    }
    if (ENABLE_SCREENS && !UIManager.default.getViewManagerConfig('RNSScreen')) {
      console.error(`Screen native module hasn't been linked. Please check the react-native-screens README for more details`);
    }
  }
  let ENABLE_FREEZE = false;
  function enableFreeze(shouldEnableReactFreeze = true) {
    if (!isNativePlatformSupported) {
      return;
    }
    ENABLE_FREEZE = shouldEnableReactFreeze;
  }
  function screensEnabled() {
    return ENABLE_SCREENS;
  }
  function freezeEnabled() {
    return ENABLE_FREEZE;
  }
},467,[14,48],"node_modules/react-native-screens/lib/module/core.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  const _excluded = ["active", "activityState", "style", "enabled"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "InnerScreen", {
    enumerable: true,
    get: function () {
      return InnerScreen;
    }
  });
  Object.defineProperty(exports, "NativeScreen", {
    enumerable: true,
    get: function () {
      return NativeScreen;
    }
  });
  Object.defineProperty(exports, "ScreenContext", {
    enumerable: true,
    get: function () {
      return ScreenContext;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[1], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsView = require(_dependencyMap[2], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _react = require(_dependencyMap[3], "react");
  var React = _interopDefault(_react);
  var _core = require(_dependencyMap[4], "../core");
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  const InnerScreen = View.default;

  // We're using class component here because of the error from reanimated:
  // createAnimatedComponent` does not support stateless functional components; use a class component instead.
  // NOTE: React Server Components do not support class components.
  class NativeScreen extends React.default.Component {
    render() {
      let _this$props = this.props,
        {
          active,
          activityState,
          style,
          enabled = (0, _core.screensEnabled)()
        } = _this$props,
        rest = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      if (enabled) {
        if (active !== undefined && activityState === undefined) {
          activityState = active !== 0 ? 2 : 0; // change taken from index.native.tsx
        }
        return /*#__PURE__*/React.default.createElement(View.default // @ts-expect-error: hidden exists on web, but not in React Native
        , _extends({
          hidden: activityState === 0,
          style: [style, {
            display: activityState !== 0 ? 'flex' : 'none'
          }]
        }, rest));
      }
      return /*#__PURE__*/React.default.createElement(View.default, rest);
    }
  }
  const Screen = Animated.default.createAnimatedComponent(NativeScreen);
  const ScreenContext = /*#__PURE__*/React.default.createContext(Screen);
  var _default = Screen;
},468,[759,166,110,9,467],"node_modules/react-native-screens/lib/module/components/Screen.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "ScreenStackHeaderBackButtonImage", {
    enumerable: true,
    get: function () {
      return ScreenStackHeaderBackButtonImage;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderRightView", {
    enumerable: true,
    get: function () {
      return ScreenStackHeaderRightView;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderLeftView", {
    enumerable: true,
    get: function () {
      return ScreenStackHeaderLeftView;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderCenterView", {
    enumerable: true,
    get: function () {
      return ScreenStackHeaderCenterView;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderSearchBarView", {
    enumerable: true,
    get: function () {
      return ScreenStackHeaderSearchBarView;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderConfig", {
    enumerable: true,
    get: function () {
      return ScreenStackHeaderConfig;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderSubview", {
    enumerable: true,
    get: function () {
      return ScreenStackHeaderSubview;
    }
  });
  var _reactNativeWebDistExportsImage = require(_dependencyMap[0], "react-native-web/dist/exports/Image");
  var Image = _interopDefault(_reactNativeWebDistExportsImage);
  var _reactNativeWebDistExportsView = require(_dependencyMap[1], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopDefault(_react);
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  const ScreenStackHeaderBackButtonImage = props => /*#__PURE__*/React.default.createElement(View.default, null, /*#__PURE__*/React.default.createElement(Image.default, _extends({
    resizeMode: "center",
    fadeDuration: 0
  }, props)));
  const ScreenStackHeaderRightView = props => /*#__PURE__*/React.default.createElement(View.default, props);
  const ScreenStackHeaderLeftView = props => /*#__PURE__*/React.default.createElement(View.default, props);
  const ScreenStackHeaderCenterView = props => /*#__PURE__*/React.default.createElement(View.default, props);
  const ScreenStackHeaderSearchBarView = props => /*#__PURE__*/React.default.createElement(View.default, props);
  const ScreenStackHeaderConfig = props => /*#__PURE__*/React.default.createElement(View.default, props);
  const ScreenStackHeaderSubview = View.default;
},469,[155,110,9],"node_modules/react-native-screens/lib/module/components/ScreenStackHeaderConfig.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  const SearchBar = View.default;
  var _default = SearchBar;
},470,[110],"node_modules/react-native-screens/lib/module/components/SearchBar.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  const ScreenContainer = View.default;
  var _default = ScreenContainer;
},471,[110],"node_modules/react-native-screens/lib/module/components/ScreenContainer.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  const ScreenStack = View.default;
  var _default = ScreenStack;
},472,[110],"node_modules/react-native-screens/lib/module/components/ScreenStack.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["children", "headerConfig", "activityState", "shouldFreeze", "stackPresentation", "sheetAllowedDetents", "contentStyle", "style", "screenId", "unstable_sheetFooter"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[2], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _warnOnce = require(_dependencyMap[4], "warn-once");
  var warnOnce = _interopDefault(_warnOnce);
  var _DebugContainer = require(_dependencyMap[5], "./DebugContainer");
  var DebugContainer = _interopDefault(_DebugContainer);
  var _ScreenStackHeaderConfig = require(_dependencyMap[6], "./ScreenStackHeaderConfig");
  var _Screen = require(_dependencyMap[7], "./Screen");
  var Screen = _interopDefault(_Screen);
  var _ScreenStack = require(_dependencyMap[8], "./ScreenStack");
  var ScreenStack = _interopDefault(_ScreenStack);
  var _contexts = require(_dependencyMap[9], "../contexts");
  var _ScreenFooter = require(_dependencyMap[10], "./ScreenFooter");
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  function ScreenStackItem(_ref, ref) {
    let {
        children,
        headerConfig,
        activityState,
        shouldFreeze,
        stackPresentation,
        sheetAllowedDetents,
        contentStyle,
        style,
        screenId,
        // eslint-disable-next-line camelcase
        unstable_sheetFooter
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const currentScreenRef = React.useRef(null);
    const screenRefs = React.useContext(_contexts.RNSScreensRefContext);
    React.useImperativeHandle(ref, () => currentScreenRef.current);
    const isHeaderInModal = Platform.default.OS === 'android' ? false : stackPresentation !== 'push' && headerConfig?.hidden === false;
    const headerHiddenPreviousRef = React.useRef(headerConfig?.hidden);
    React.useEffect(() => {
      (0, warnOnce.default)(Platform.default.OS !== 'android' && stackPresentation !== 'push' && headerHiddenPreviousRef.current !== headerConfig?.hidden, `Dynamically changing header's visibility in modals will result in remounting the screen and losing all local state.`);
      headerHiddenPreviousRef.current = headerConfig?.hidden;
    }, [headerConfig?.hidden, stackPresentation]);
    const content = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(DebugContainer.default, {
      style: [stackPresentation === 'formSheet' ? Platform.default.OS === 'ios' ? styles.absolute : sheetAllowedDetents === 'fitToContents' ? null : styles.container : styles.container, contentStyle],
      stackPresentation: stackPresentation ?? 'push'
    }, children), /*#__PURE__*/React.createElement(_ScreenStackHeaderConfig.ScreenStackHeaderConfig, headerConfig), stackPresentation === 'formSheet' && unstable_sheetFooter && /*#__PURE__*/React.createElement(_ScreenFooter.FooterComponent, null, unstable_sheetFooter()));

    // We take backgroundColor from contentStyle and apply it on Screen.
    // This allows to workaround one issue with truncated
    // content with formSheet presentation.
    let internalScreenStyle;
    if (stackPresentation === 'formSheet' && contentStyle) {
      const flattenContentStyles = StyleSheet.default.flatten(contentStyle);
      internalScreenStyle = {
        backgroundColor: flattenContentStyles?.backgroundColor
      };
    }
    return /*#__PURE__*/React.createElement(Screen.default, _extends({
      ref: node => {
        currentScreenRef.current = node;
        if (screenRefs === null) {
          console.warn('Looks like RNSScreensRefContext is missing. Make sure the ScreenStack component is wrapped in it');
          return;
        }
        const currentRefs = screenRefs.current;
        if (node === null) {
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete currentRefs[screenId];
        } else {
          currentRefs[screenId] = {
            current: node
          };
        }
      },
      enabled: true,
      isNativeStack: true,
      activityState: activityState,
      shouldFreeze: shouldFreeze,
      screenId: screenId,
      stackPresentation: stackPresentation,
      hasLargeHeader: headerConfig?.largeTitle ?? false,
      sheetAllowedDetents: sheetAllowedDetents,
      style: [style, internalScreenStyle]
    }, rest), isHeaderInModal ? /*#__PURE__*/React.createElement(ScreenStack.default, {
      style: styles.container
    }, /*#__PURE__*/React.createElement(Screen.default, {
      enabled: true,
      isNativeStack: true,
      activityState: activityState,
      shouldFreeze: shouldFreeze,
      hasLargeHeader: headerConfig?.largeTitle ?? false,
      style: StyleSheet.default.absoluteFill
    }, content)) : content);
  }
  var _default = /*#__PURE__*/React.forwardRef(ScreenStackItem);
  const styles = StyleSheet.default.create({
    container: {
      flex: 1
    },
    absolute: {
      position: 'absolute',
      top: 0,
      start: 0,
      end: 0
    }
  });
},473,[759,9,14,55,474,475,469,468,472,477,478],"node_modules/react-native-screens/lib/module/components/ScreenStackItem.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const DEV = process.env.NODE_ENV !== "production";
  const warnings = new Set();
  function warnOnce(condition, ...rest) {
    if (DEV && condition) {
      const key = rest.join(" ");
      if (warnings.has(key)) {
        return;
      }
      warnings.add(key);
      console.warn(...rest);
    }
  }
  module.exports = warnOnce;
},474,[],"node_modules/warn-once/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return DebugContainer;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _ScreenContentWrapper = require(_dependencyMap[1], "./ScreenContentWrapper");
  var ScreenContentWrapper = _interopDefault(_ScreenContentWrapper);
  function DebugContainer(props) {
    return /*#__PURE__*/React.createElement(ScreenContentWrapper.default, props);
  }
},475,[9,476],"node_modules/react-native-screens/lib/module/components/DebugContainer.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  const ScreenContentWrapper = View.default;
  var _default = ScreenContentWrapper;
},476,[110],"node_modules/react-native-screens/lib/module/components/ScreenContentWrapper.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "GHContext", {
    enumerable: true,
    get: function () {
      return GHContext;
    }
  });
  Object.defineProperty(exports, "RNSScreensRefContext", {
    enumerable: true,
    get: function () {
      return RNSScreensRefContext;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopDefault(_react);
  const GHContext = /*#__PURE__*/React.default.createContext(props => /*#__PURE__*/React.default.createElement(React.default.Fragment, null, props.children));
  const RNSScreensRefContext = /*#__PURE__*/React.default.createContext(null);
},477,[9],"node_modules/react-native-screens/lib/module/contexts.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "FooterComponent", {
    enumerable: true,
    get: function () {
      return FooterComponent;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  const ScreenFooter = View.default;
  const FooterComponent = View.default;
  var _default = ScreenFooter;
},478,[110],"node_modules/react-native-screens/lib/module/components/ScreenFooter.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _default = View.default;
},479,[110],"node_modules/react-native-screens/lib/module/components/FullWindowOverlay.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "isSearchBarAvailableForCurrentPlatform", {
    enumerable: true,
    get: function () {
      return isSearchBarAvailableForCurrentPlatform;
    }
  });
  exports.executeNativeBackPress = executeNativeBackPress;
  var _reactNativeWebDistExportsBackHandler = require(_dependencyMap[0], "react-native-web/dist/exports/BackHandler");
  var BackHandler = _interopDefault(_reactNativeWebDistExportsBackHandler);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[1], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  const isSearchBarAvailableForCurrentPlatform = ['ios', 'android'].includes(Platform.default.OS);
  function executeNativeBackPress() {
    // This function invokes the native back press event
    BackHandler.default.exitApp();
    return true;
  }
},480,[481,14],"node_modules/react-native-screens/lib/module/utils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  function emptyFunction() {}
  var BackHandler = {
    exitApp: emptyFunction,
    addEventListener: () => ({
      remove: emptyFunction
    }),
    removeEventListener: emptyFunction
  };
  var _default = BackHandler;
},481,[],"\u0000shim:react-native-web/dist/exports/BackHandler/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "compatibilityFlags", {
    enumerable: true,
    get: function () {
      return compatibilityFlags;
    }
  });
  Object.defineProperty(exports, "featureFlags", {
    enumerable: true,
    get: function () {
      return featureFlags;
    }
  });
  const RNS_CONTROLLED_BOTTOM_TABS_DEFAULT = true;

  // TODO: Migrate freeze here

  /**
   * Exposes information useful for downstream navigation library implementers,
   * so they can keep reasonable backward compatibility, if desired.
   *
   * We don't mean for this object to only grow in number of fields, however at the same time
   * we won't be very hasty to reduce it. Expect gradual changes.
   */
  const compatibilityFlags = {
    /**
     * Because of a bug introduced in https://github.com/software-mansion/react-native-screens/pull/1646
     * react-native-screens v3.21 changed how header's backTitle handles whitespace strings in https://github.com/software-mansion/react-native-screens/pull/1726
     * To allow for backwards compatibility in @react-navigation/native-stack we need a way to check if this version or newer is used.
     * See https://github.com/react-navigation/react-navigation/pull/11423 for more context.
     */
    isNewBackTitleImplementation: true,
    /**
     * With version 4.0.0 the header implementation has been changed. To allow for backward compat
     * with native-stack@v6 we want to expose a way to check whether the new implementation
     * is in use or not.
     *
     * See:
     * * https://github.com/software-mansion/react-native-screens/pull/2325
     * * https://github.com/react-navigation/react-navigation/pull/12125
     */
    usesHeaderFlexboxImplementation: true
  };
  const _featureFlags = {
    experiment: {
      controlledBottomTabs: RNS_CONTROLLED_BOTTOM_TABS_DEFAULT
    },
    stable: {}
  };

  /**
   * Exposes configurable global behaviour of the library.
   *
   * Most of these can be overridden on particular component level, these are global switches.
   */
  const featureFlags = {
    /**
     *  Flags to enable experimental features. These might be removed w/o notice or moved to stable.
     */
    experiment: {
      get controlledBottomTabs() {
        return _featureFlags.experiment.controlledBottomTabs;
      },
      set controlledBottomTabs(value) {
        if (value !== _featureFlags.experiment.controlledBottomTabs && _featureFlags.experiment.controlledBottomTabs !== RNS_CONTROLLED_BOTTOM_TABS_DEFAULT) {
          console.error(`[RNScreens] controlledBottomTabs feature flag modified for a second time; this might lead to unexpected effects`);
        }
        _featureFlags.experiment.controlledBottomTabs = value;
      }
    },
    /**
     * Section for stable flags, which can be used to configure library behaviour.
     */
    stable: {}
  };
  var _default = featureFlags;
},482,[],"node_modules/react-native-screens/lib/module/flags.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useTransitionProgress;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _TransitionProgressContext = require(_dependencyMap[1], "./TransitionProgressContext");
  var TransitionProgressContext = _interopDefault(_TransitionProgressContext);
  function useTransitionProgress() {
    const progress = React.useContext(TransitionProgressContext.default);
    if (progress === undefined) {
      throw new Error("Couldn't find values for transition progress. Are you inside a screen in Native Stack?");
    }
    return progress;
  }
},483,[9,484],"node_modules/react-native-screens/lib/module/useTransitionProgress.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _default = /*#__PURE__*/React.createContext(undefined);
},484,[9],"node_modules/react-native-screens/lib/module/TransitionProgressContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  const BottomTabs = View.default;
  var _default = BottomTabs;
},485,[110],"node_modules/react-native-screens/lib/module/components/bottom-tabs/BottomTabs.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  const BottomTabsScreen = View.default;
  var _default = BottomTabsScreen;
},486,[110],"node_modules/react-native-screens/lib/module/components/bottom-tabs/BottomTabsScreen.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  const ScreenStackHost = View.default;
  var _default = ScreenStackHost;
},487,[110],"node_modules/react-native-screens/lib/module/components/gamma/ScreenStackHost.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "StackScreenLifecycleState", {
    enumerable: true,
    get: function () {
      return StackScreenLifecycleState;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  const StackScreenLifecycleState = {
    INITIAL: 0,
    DETACHED: 1,
    ATTACHED: 2
  };
  const StackScreen = View.default;
  var _default = StackScreen;
},488,[110],"node_modules/react-native-screens/lib/module/components/gamma/StackScreen.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  const SplitViewHost = View.default;
  var _default = SplitViewHost;
},489,[110],"node_modules/react-native-screens/lib/module/components/gamma/SplitViewHost.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsView = require(_dependencyMap[0], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  const Column = View.default;
  const Inspector = View.default;
  var _default = {
    Column,
    Inspector
  };
},490,[110],"node_modules/react-native-screens/lib/module/components/gamma/SplitViewScreen.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.useBottomTabBarHeight = useBottomTabBarHeight;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _BottomTabBarHeightContextJs = require(_dependencyMap[1], "./BottomTabBarHeightContext.js");
  function useBottomTabBarHeight() {
    const height = React.useContext(_BottomTabBarHeightContextJs.BottomTabBarHeightContext);
    if (height === undefined) {
      throw new Error("Couldn't find the bottom tab bar height. Are you inside a screen in Bottom Tab Navigator?");
    }
    return height;
  }
},491,[9,452],"node_modules/@react-navigation/bottom-tabs/lib/module/utils/useBottomTabBarHeight.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "unstable_createElement", {
    enumerable: true,
    get: function () {
      return _exportsCreateElement2.default;
    }
  });
  Object.defineProperty(exports, "findNodeHandle", {
    enumerable: true,
    get: function () {
      return _exportsFindNodeHandle2.default;
    }
  });
  Object.defineProperty(exports, "processColor", {
    enumerable: true,
    get: function () {
      return _exportsProcessColor2.default;
    }
  });
  Object.defineProperty(exports, "render", {
    enumerable: true,
    get: function () {
      return _exportsRender2.default;
    }
  });
  Object.defineProperty(exports, "unmountComponentAtNode", {
    enumerable: true,
    get: function () {
      return _exportsUnmountComponentAtNode2.default;
    }
  });
  Object.defineProperty(exports, "NativeModules", {
    enumerable: true,
    get: function () {
      return _exportsNativeModules2.default;
    }
  });
  Object.defineProperty(exports, "AccessibilityInfo", {
    enumerable: true,
    get: function () {
      return _exportsAccessibilityInfo2.default;
    }
  });
  Object.defineProperty(exports, "Alert", {
    enumerable: true,
    get: function () {
      return _exportsAlert2.default;
    }
  });
  Object.defineProperty(exports, "Animated", {
    enumerable: true,
    get: function () {
      return _exportsAnimated2.default;
    }
  });
  Object.defineProperty(exports, "Appearance", {
    enumerable: true,
    get: function () {
      return _exportsAppearance2.default;
    }
  });
  Object.defineProperty(exports, "AppRegistry", {
    enumerable: true,
    get: function () {
      return _exportsAppRegistry2.default;
    }
  });
  Object.defineProperty(exports, "AppState", {
    enumerable: true,
    get: function () {
      return _exportsAppState2.default;
    }
  });
  Object.defineProperty(exports, "BackHandler", {
    enumerable: true,
    get: function () {
      return _exportsBackHandler2.default;
    }
  });
  Object.defineProperty(exports, "Clipboard", {
    enumerable: true,
    get: function () {
      return _exportsClipboard2.default;
    }
  });
  Object.defineProperty(exports, "Dimensions", {
    enumerable: true,
    get: function () {
      return _exportsDimensions2.default;
    }
  });
  Object.defineProperty(exports, "Easing", {
    enumerable: true,
    get: function () {
      return _exportsEasing2.default;
    }
  });
  Object.defineProperty(exports, "I18nManager", {
    enumerable: true,
    get: function () {
      return _exportsI18nManager2.default;
    }
  });
  Object.defineProperty(exports, "Keyboard", {
    enumerable: true,
    get: function () {
      return _exportsKeyboard2.default;
    }
  });
  Object.defineProperty(exports, "InteractionManager", {
    enumerable: true,
    get: function () {
      return _exportsInteractionManager2.default;
    }
  });
  Object.defineProperty(exports, "LayoutAnimation", {
    enumerable: true,
    get: function () {
      return _exportsLayoutAnimation2.default;
    }
  });
  Object.defineProperty(exports, "Linking", {
    enumerable: true,
    get: function () {
      return _exportsLinking2.default;
    }
  });
  Object.defineProperty(exports, "NativeEventEmitter", {
    enumerable: true,
    get: function () {
      return _exportsNativeEventEmitter2.default;
    }
  });
  Object.defineProperty(exports, "PanResponder", {
    enumerable: true,
    get: function () {
      return _exportsPanResponder2.default;
    }
  });
  Object.defineProperty(exports, "PixelRatio", {
    enumerable: true,
    get: function () {
      return _exportsPixelRatio2.default;
    }
  });
  Object.defineProperty(exports, "Platform", {
    enumerable: true,
    get: function () {
      return _exportsPlatform2.default;
    }
  });
  Object.defineProperty(exports, "Share", {
    enumerable: true,
    get: function () {
      return _exportsShare2.default;
    }
  });
  Object.defineProperty(exports, "StyleSheet", {
    enumerable: true,
    get: function () {
      return _exportsStyleSheet2.default;
    }
  });
  Object.defineProperty(exports, "UIManager", {
    enumerable: true,
    get: function () {
      return _exportsUIManager2.default;
    }
  });
  Object.defineProperty(exports, "Vibration", {
    enumerable: true,
    get: function () {
      return _exportsVibration2.default;
    }
  });
  Object.defineProperty(exports, "ActivityIndicator", {
    enumerable: true,
    get: function () {
      return _exportsActivityIndicator2.default;
    }
  });
  Object.defineProperty(exports, "Button", {
    enumerable: true,
    get: function () {
      return _exportsButton2.default;
    }
  });
  Object.defineProperty(exports, "CheckBox", {
    enumerable: true,
    get: function () {
      return _exportsCheckBox2.default;
    }
  });
  Object.defineProperty(exports, "FlatList", {
    enumerable: true,
    get: function () {
      return _exportsFlatList2.default;
    }
  });
  Object.defineProperty(exports, "Image", {
    enumerable: true,
    get: function () {
      return _exportsImage2.default;
    }
  });
  Object.defineProperty(exports, "ImageBackground", {
    enumerable: true,
    get: function () {
      return _exportsImageBackground2.default;
    }
  });
  Object.defineProperty(exports, "KeyboardAvoidingView", {
    enumerable: true,
    get: function () {
      return _exportsKeyboardAvoidingView2.default;
    }
  });
  Object.defineProperty(exports, "Modal", {
    enumerable: true,
    get: function () {
      return _exportsModal2.default;
    }
  });
  Object.defineProperty(exports, "Picker", {
    enumerable: true,
    get: function () {
      return _exportsPicker2.default;
    }
  });
  Object.defineProperty(exports, "Pressable", {
    enumerable: true,
    get: function () {
      return _exportsPressable2.default;
    }
  });
  Object.defineProperty(exports, "ProgressBar", {
    enumerable: true,
    get: function () {
      return _exportsProgressBar2.default;
    }
  });
  Object.defineProperty(exports, "RefreshControl", {
    enumerable: true,
    get: function () {
      return _exportsRefreshControl2.default;
    }
  });
  Object.defineProperty(exports, "SafeAreaView", {
    enumerable: true,
    get: function () {
      return _exportsSafeAreaView2.default;
    }
  });
  Object.defineProperty(exports, "ScrollView", {
    enumerable: true,
    get: function () {
      return _exportsScrollView2.default;
    }
  });
  Object.defineProperty(exports, "SectionList", {
    enumerable: true,
    get: function () {
      return _exportsSectionList2.default;
    }
  });
  Object.defineProperty(exports, "StatusBar", {
    enumerable: true,
    get: function () {
      return _exportsStatusBar2.default;
    }
  });
  Object.defineProperty(exports, "Switch", {
    enumerable: true,
    get: function () {
      return _exportsSwitch2.default;
    }
  });
  Object.defineProperty(exports, "Text", {
    enumerable: true,
    get: function () {
      return _exportsText2.default;
    }
  });
  Object.defineProperty(exports, "TextInput", {
    enumerable: true,
    get: function () {
      return _exportsTextInput2.default;
    }
  });
  Object.defineProperty(exports, "Touchable", {
    enumerable: true,
    get: function () {
      return _exportsTouchable2.default;
    }
  });
  Object.defineProperty(exports, "TouchableHighlight", {
    enumerable: true,
    get: function () {
      return _exportsTouchableHighlight2.default;
    }
  });
  Object.defineProperty(exports, "TouchableNativeFeedback", {
    enumerable: true,
    get: function () {
      return _exportsTouchableNativeFeedback2.default;
    }
  });
  Object.defineProperty(exports, "TouchableOpacity", {
    enumerable: true,
    get: function () {
      return _exportsTouchableOpacity2.default;
    }
  });
  Object.defineProperty(exports, "TouchableWithoutFeedback", {
    enumerable: true,
    get: function () {
      return _exportsTouchableWithoutFeedback2.default;
    }
  });
  Object.defineProperty(exports, "View", {
    enumerable: true,
    get: function () {
      return _exportsView2.default;
    }
  });
  Object.defineProperty(exports, "VirtualizedList", {
    enumerable: true,
    get: function () {
      return _exportsVirtualizedList2.default;
    }
  });
  Object.defineProperty(exports, "YellowBox", {
    enumerable: true,
    get: function () {
      return _exportsYellowBox2.default;
    }
  });
  Object.defineProperty(exports, "LogBox", {
    enumerable: true,
    get: function () {
      return _exportsLogBox2.default;
    }
  });
  Object.defineProperty(exports, "DeviceEventEmitter", {
    enumerable: true,
    get: function () {
      return _exportsDeviceEventEmitter2.default;
    }
  });
  Object.defineProperty(exports, "useColorScheme", {
    enumerable: true,
    get: function () {
      return _exportsUseColorScheme2.default;
    }
  });
  Object.defineProperty(exports, "useLocaleContext", {
    enumerable: true,
    get: function () {
      return _exportsUseLocaleContext2.default;
    }
  });
  Object.defineProperty(exports, "useWindowDimensions", {
    enumerable: true,
    get: function () {
      return _exportsUseWindowDimensions2.default;
    }
  });
  var _exportsCreateElement = require(_dependencyMap[0], "./exports/createElement");
  var _exportsCreateElement2 = _interopDefault(_exportsCreateElement);
  var _exportsFindNodeHandle = require(_dependencyMap[1], "./exports/findNodeHandle");
  var _exportsFindNodeHandle2 = _interopDefault(_exportsFindNodeHandle);
  var _exportsProcessColor = require(_dependencyMap[2], "./exports/processColor");
  var _exportsProcessColor2 = _interopDefault(_exportsProcessColor);
  var _exportsRender = require(_dependencyMap[3], "./exports/render");
  var _exportsRender2 = _interopDefault(_exportsRender);
  var _exportsUnmountComponentAtNode = require(_dependencyMap[4], "./exports/unmountComponentAtNode");
  var _exportsUnmountComponentAtNode2 = _interopDefault(_exportsUnmountComponentAtNode);
  var _exportsNativeModules = require(_dependencyMap[5], "./exports/NativeModules");
  var _exportsNativeModules2 = _interopDefault(_exportsNativeModules);
  var _exportsAccessibilityInfo = require(_dependencyMap[6], "./exports/AccessibilityInfo");
  var _exportsAccessibilityInfo2 = _interopDefault(_exportsAccessibilityInfo);
  var _exportsAlert = require(_dependencyMap[7], "./exports/Alert");
  var _exportsAlert2 = _interopDefault(_exportsAlert);
  var _exportsAnimated = require(_dependencyMap[8], "./exports/Animated");
  var _exportsAnimated2 = _interopDefault(_exportsAnimated);
  var _exportsAppearance = require(_dependencyMap[9], "./exports/Appearance");
  var _exportsAppearance2 = _interopDefault(_exportsAppearance);
  var _exportsAppRegistry = require(_dependencyMap[10], "./exports/AppRegistry");
  var _exportsAppRegistry2 = _interopDefault(_exportsAppRegistry);
  var _exportsAppState = require(_dependencyMap[11], "./exports/AppState");
  var _exportsAppState2 = _interopDefault(_exportsAppState);
  var _exportsBackHandler = require(_dependencyMap[12], "./exports/BackHandler");
  var _exportsBackHandler2 = _interopDefault(_exportsBackHandler);
  var _exportsClipboard = require(_dependencyMap[13], "./exports/Clipboard");
  var _exportsClipboard2 = _interopDefault(_exportsClipboard);
  var _exportsDimensions = require(_dependencyMap[14], "./exports/Dimensions");
  var _exportsDimensions2 = _interopDefault(_exportsDimensions);
  var _exportsEasing = require(_dependencyMap[15], "./exports/Easing");
  var _exportsEasing2 = _interopDefault(_exportsEasing);
  var _exportsI18nManager = require(_dependencyMap[16], "./exports/I18nManager");
  var _exportsI18nManager2 = _interopDefault(_exportsI18nManager);
  var _exportsKeyboard = require(_dependencyMap[17], "./exports/Keyboard");
  var _exportsKeyboard2 = _interopDefault(_exportsKeyboard);
  var _exportsInteractionManager = require(_dependencyMap[18], "./exports/InteractionManager");
  var _exportsInteractionManager2 = _interopDefault(_exportsInteractionManager);
  var _exportsLayoutAnimation = require(_dependencyMap[19], "./exports/LayoutAnimation");
  var _exportsLayoutAnimation2 = _interopDefault(_exportsLayoutAnimation);
  var _exportsLinking = require(_dependencyMap[20], "./exports/Linking");
  var _exportsLinking2 = _interopDefault(_exportsLinking);
  var _exportsNativeEventEmitter = require(_dependencyMap[21], "./exports/NativeEventEmitter");
  var _exportsNativeEventEmitter2 = _interopDefault(_exportsNativeEventEmitter);
  var _exportsPanResponder = require(_dependencyMap[22], "./exports/PanResponder");
  var _exportsPanResponder2 = _interopDefault(_exportsPanResponder);
  var _exportsPixelRatio = require(_dependencyMap[23], "./exports/PixelRatio");
  var _exportsPixelRatio2 = _interopDefault(_exportsPixelRatio);
  var _exportsPlatform = require(_dependencyMap[24], "./exports/Platform");
  var _exportsPlatform2 = _interopDefault(_exportsPlatform);
  var _exportsShare = require(_dependencyMap[25], "./exports/Share");
  var _exportsShare2 = _interopDefault(_exportsShare);
  var _exportsStyleSheet = require(_dependencyMap[26], "./exports/StyleSheet");
  var _exportsStyleSheet2 = _interopDefault(_exportsStyleSheet);
  var _exportsUIManager = require(_dependencyMap[27], "./exports/UIManager");
  var _exportsUIManager2 = _interopDefault(_exportsUIManager);
  var _exportsVibration = require(_dependencyMap[28], "./exports/Vibration");
  var _exportsVibration2 = _interopDefault(_exportsVibration);
  var _exportsActivityIndicator = require(_dependencyMap[29], "./exports/ActivityIndicator");
  var _exportsActivityIndicator2 = _interopDefault(_exportsActivityIndicator);
  var _exportsButton = require(_dependencyMap[30], "./exports/Button");
  var _exportsButton2 = _interopDefault(_exportsButton);
  var _exportsCheckBox = require(_dependencyMap[31], "./exports/CheckBox");
  var _exportsCheckBox2 = _interopDefault(_exportsCheckBox);
  var _exportsFlatList = require(_dependencyMap[32], "./exports/FlatList");
  var _exportsFlatList2 = _interopDefault(_exportsFlatList);
  var _exportsImage = require(_dependencyMap[33], "./exports/Image");
  var _exportsImage2 = _interopDefault(_exportsImage);
  var _exportsImageBackground = require(_dependencyMap[34], "./exports/ImageBackground");
  var _exportsImageBackground2 = _interopDefault(_exportsImageBackground);
  var _exportsKeyboardAvoidingView = require(_dependencyMap[35], "./exports/KeyboardAvoidingView");
  var _exportsKeyboardAvoidingView2 = _interopDefault(_exportsKeyboardAvoidingView);
  var _exportsModal = require(_dependencyMap[36], "./exports/Modal");
  var _exportsModal2 = _interopDefault(_exportsModal);
  var _exportsPicker = require(_dependencyMap[37], "./exports/Picker");
  var _exportsPicker2 = _interopDefault(_exportsPicker);
  var _exportsPressable = require(_dependencyMap[38], "./exports/Pressable");
  var _exportsPressable2 = _interopDefault(_exportsPressable);
  var _exportsProgressBar = require(_dependencyMap[39], "./exports/ProgressBar");
  var _exportsProgressBar2 = _interopDefault(_exportsProgressBar);
  var _exportsRefreshControl = require(_dependencyMap[40], "./exports/RefreshControl");
  var _exportsRefreshControl2 = _interopDefault(_exportsRefreshControl);
  var _exportsSafeAreaView = require(_dependencyMap[41], "./exports/SafeAreaView");
  var _exportsSafeAreaView2 = _interopDefault(_exportsSafeAreaView);
  var _exportsScrollView = require(_dependencyMap[42], "./exports/ScrollView");
  var _exportsScrollView2 = _interopDefault(_exportsScrollView);
  var _exportsSectionList = require(_dependencyMap[43], "./exports/SectionList");
  var _exportsSectionList2 = _interopDefault(_exportsSectionList);
  var _exportsStatusBar = require(_dependencyMap[44], "./exports/StatusBar");
  var _exportsStatusBar2 = _interopDefault(_exportsStatusBar);
  var _exportsSwitch = require(_dependencyMap[45], "./exports/Switch");
  var _exportsSwitch2 = _interopDefault(_exportsSwitch);
  var _exportsText = require(_dependencyMap[46], "./exports/Text");
  var _exportsText2 = _interopDefault(_exportsText);
  var _exportsTextInput = require(_dependencyMap[47], "./exports/TextInput");
  var _exportsTextInput2 = _interopDefault(_exportsTextInput);
  var _exportsTouchable = require(_dependencyMap[48], "./exports/Touchable");
  var _exportsTouchable2 = _interopDefault(_exportsTouchable);
  var _exportsTouchableHighlight = require(_dependencyMap[49], "./exports/TouchableHighlight");
  var _exportsTouchableHighlight2 = _interopDefault(_exportsTouchableHighlight);
  var _exportsTouchableNativeFeedback = require(_dependencyMap[50], "./exports/TouchableNativeFeedback");
  var _exportsTouchableNativeFeedback2 = _interopDefault(_exportsTouchableNativeFeedback);
  var _exportsTouchableOpacity = require(_dependencyMap[51], "./exports/TouchableOpacity");
  var _exportsTouchableOpacity2 = _interopDefault(_exportsTouchableOpacity);
  var _exportsTouchableWithoutFeedback = require(_dependencyMap[52], "./exports/TouchableWithoutFeedback");
  var _exportsTouchableWithoutFeedback2 = _interopDefault(_exportsTouchableWithoutFeedback);
  var _exportsView = require(_dependencyMap[53], "./exports/View");
  var _exportsView2 = _interopDefault(_exportsView);
  var _exportsVirtualizedList = require(_dependencyMap[54], "./exports/VirtualizedList");
  var _exportsVirtualizedList2 = _interopDefault(_exportsVirtualizedList);
  var _exportsYellowBox = require(_dependencyMap[55], "./exports/YellowBox");
  var _exportsYellowBox2 = _interopDefault(_exportsYellowBox);
  var _exportsLogBox = require(_dependencyMap[56], "./exports/LogBox");
  var _exportsLogBox2 = _interopDefault(_exportsLogBox);
  var _exportsDeviceEventEmitter = require(_dependencyMap[57], "./exports/DeviceEventEmitter");
  var _exportsDeviceEventEmitter2 = _interopDefault(_exportsDeviceEventEmitter);
  var _exportsUseColorScheme = require(_dependencyMap[58], "./exports/useColorScheme");
  var _exportsUseColorScheme2 = _interopDefault(_exportsUseColorScheme);
  var _exportsUseLocaleContext = require(_dependencyMap[59], "./exports/useLocaleContext");
  var _exportsUseLocaleContext2 = _interopDefault(_exportsUseLocaleContext);
  var _exportsUseWindowDimensions = require(_dependencyMap[60], "./exports/useWindowDimensions");
  var _exportsUseWindowDimensions2 = _interopDefault(_exportsUseWindowDimensions);
},492,[111,493,62,494,495,496,497,498,166,499,500,503,481,504,44,235,356,456,178,505,507,12,508,158,14,511,55,48,512,513,514,516,169,155,517,518,519,524,143,526,176,527,36,214,159,528,138,436,530,534,535,515,537,110,538,539,540,541,542,543,544],"node_modules/react-native-web/dist/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var findNodeHandle = component => {
    throw new Error('findNodeHandle is not supported on web. ' + 'Use the ref property on the component instead.');
  };
  var _default = findNodeHandle;
},493,[],"node_modules/react-native-web/dist/exports/findNodeHandle/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return render;
    }
  });
  exports.hydrate = hydrate;
  var _reactDomClient = require(_dependencyMap[0], "react-dom/client");
  var _StyleSheetDom = require(_dependencyMap[1], "../StyleSheet/dom");
  function hydrate(element, root) {
    (0, _StyleSheetDom.createSheet)(root);
    return (0, _reactDomClient.hydrateRoot)(root, element);
  }
  function render(element, root) {
    (0, _StyleSheetDom.createSheet)(root);
    var reactRoot = (0, _reactDomClient.createRoot)(root);
    reactRoot.render(element);
    return reactRoot;
  }
},494,[27,96],"node_modules/react-native-web/dist/exports/render/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return unmountComponentAtNode;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function unmountComponentAtNode(rootTag) {
    rootTag.unmount();
    return true;
  }
},495,[],"node_modules/react-native-web/dist/exports/unmountComponentAtNode/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _UIManager = require(_dependencyMap[0], "../UIManager");
  var UIManager = _interopDefault(_UIManager);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  // NativeModules shim
  var NativeModules = {
    UIManager: UIManager.default
  };
  var _default = NativeModules;
},496,[48],"node_modules/react-native-web/dist/exports/NativeModules/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesCanUseDom = require(_dependencyMap[0], "../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  function isScreenReaderEnabled() {
    return new Promise((resolve, reject) => {
      resolve(true);
    });
  }
  var prefersReducedMotionMedia = canUseDOM.default && typeof window.matchMedia === 'function' ? window.matchMedia('(prefers-reduced-motion: reduce)') : null;
  function isReduceMotionEnabled() {
    return new Promise((resolve, reject) => {
      resolve(prefersReducedMotionMedia ? prefersReducedMotionMedia.matches : true);
    });
  }
  function addChangeListener(fn) {
    if (prefersReducedMotionMedia != null) {
      prefersReducedMotionMedia.addEventListener != null ? prefersReducedMotionMedia.addEventListener('change', fn) : prefersReducedMotionMedia.addListener(fn);
    }
  }
  function removeChangeListener(fn) {
    if (prefersReducedMotionMedia != null) {
      prefersReducedMotionMedia.removeEventListener != null ? prefersReducedMotionMedia.removeEventListener('change', fn) : prefersReducedMotionMedia.removeListener(fn);
    }
  }
  var handlers = {};
  var AccessibilityInfo = {
    /**
     * Query whether a screen reader is currently enabled.
     *
     * Returns a promise which resolves to a boolean.
     * The result is `true` when a screen reader is enabled and `false` otherwise.
     */
    isScreenReaderEnabled,
    /**
     * Query whether the user prefers reduced motion.
     *
     * Returns a promise which resolves to a boolean.
     * The result is `true` when a screen reader is enabled and `false` otherwise.
     */
    isReduceMotionEnabled,
    /**
     * Deprecated
     */
    fetch: isScreenReaderEnabled,
    /**
     * Add an event handler. Supported events: reduceMotionChanged
     */
    addEventListener: function addEventListener(eventName, handler) {
      if (eventName === 'reduceMotionChanged') {
        if (!prefersReducedMotionMedia) {
          return;
        }
        var listener = event => {
          handler(event.matches);
        };
        addChangeListener(listener);
        handlers[handler] = listener;
      }
      return {
        remove: () => AccessibilityInfo.removeEventListener(eventName, handler)
      };
    },
    /**
     * Set accessibility focus to a react component.
     */
    setAccessibilityFocus: function setAccessibilityFocus(reactTag) {},
    /**
     * Post a string to be announced by the screen reader.
     */
    announceForAccessibility: function announceForAccessibility(announcement) {},
    /**
     * Remove an event handler.
     */
    removeEventListener: function removeEventListener(eventName, handler) {
      if (eventName === 'reduceMotionChanged') {
        var listener = handlers[handler];
        if (!listener || !prefersReducedMotionMedia) {
          return;
        }
        removeChangeListener(listener);
      }
      return;
    }
  };
  var _default = AccessibilityInfo;
},497,[45],"node_modules/react-native-web/dist/exports/AccessibilityInfo/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  class Alert {
    static alert() {}
  }
  var _default = Alert;
},498,[],"node_modules/react-native-web/dist/exports/Alert/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesCanUseDom = require(_dependencyMap[0], "../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  function getQuery() {
    return canUseDOM.default && window.matchMedia != null ? window.matchMedia('(prefers-color-scheme: dark)') : null;
  }
  var query = getQuery();
  var listenerMapping = new WeakMap();
  var Appearance = {
    getColorScheme() {
      return query && query.matches ? 'dark' : 'light';
    },
    addChangeListener(listener) {
      var mappedListener = listenerMapping.get(listener);
      if (!mappedListener) {
        mappedListener = _ref => {
          var matches = _ref.matches;
          listener({
            colorScheme: matches ? 'dark' : 'light'
          });
        };
        listenerMapping.set(listener, mappedListener);
      }
      if (query) {
        query.addListener(mappedListener);
      }
      function remove() {
        var mappedListener = listenerMapping.get(listener);
        if (query && mappedListener) {
          query.removeListener(mappedListener);
        }
        listenerMapping.delete(listener);
      }
      return {
        remove
      };
    }
  };
  var _default = Appearance;
},499,[45],"node_modules/react-native-web/dist/exports/Appearance/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return AppRegistry;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _fbjsLibInvariant = require(_dependencyMap[1], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _unmountComponentAtNode = require(_dependencyMap[2], "../unmountComponentAtNode");
  var unmountComponentAtNode = _interopDefault(_unmountComponentAtNode);
  var _renderApplication = require(_dependencyMap[3], "./renderApplication");
  var renderApplication = _interopDefault(_renderApplication);
  var emptyObject = {};
  var runnables = {};
  var componentProviderInstrumentationHook = component => component();
  var wrapperComponentProvider;

  /**
   * `AppRegistry` is the JS entry point to running all React Native apps.
   */
  class AppRegistry {
    static getAppKeys() {
      return Object.keys(runnables);
    }
    static getApplication(appKey, appParameters) {
      (0, invariant.default)(runnables[appKey] && runnables[appKey].getApplication, "Application " + appKey + " has not been registered. " + 'This is either due to an import error during initialization or failure to call AppRegistry.registerComponent.');
      return runnables[appKey].getApplication(appParameters);
    }
    static registerComponent(appKey, componentProvider) {
      runnables[appKey] = {
        getApplication: appParameters => (0, _renderApplication.getApplication)(componentProviderInstrumentationHook(componentProvider), appParameters ? appParameters.initialProps : emptyObject, wrapperComponentProvider && wrapperComponentProvider(appParameters)),
        run: appParameters => (0, renderApplication.default)(componentProviderInstrumentationHook(componentProvider), wrapperComponentProvider && wrapperComponentProvider(appParameters), appParameters.callback, {
          hydrate: appParameters.hydrate || false,
          initialProps: appParameters.initialProps || emptyObject,
          mode: appParameters.mode || 'concurrent',
          rootTag: appParameters.rootTag
        })
      };
      return appKey;
    }
    static registerConfig(config) {
      config.forEach(_ref => {
        var appKey = _ref.appKey,
          component = _ref.component,
          run = _ref.run;
        if (run) {
          AppRegistry.registerRunnable(appKey, run);
        } else {
          (0, invariant.default)(component, 'No component provider passed in');
          AppRegistry.registerComponent(appKey, component);
        }
      });
    }

    // TODO: fix style sheet creation when using this method
    static registerRunnable(appKey, run) {
      runnables[appKey] = {
        run
      };
      return appKey;
    }
    static runApplication(appKey, appParameters) {
      var isDevelopment = process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test';
      if (isDevelopment) {
        var params = (0, _objectSpread.default)({}, appParameters);
        params.rootTag = "#" + params.rootTag.id;
        console.log("Running application \"" + appKey + "\" with appParams:\n", params, "\nDevelopment-level warnings: " + (isDevelopment ? 'ON' : 'OFF') + "." + ("\nPerformance optimizations: " + (isDevelopment ? 'OFF' : 'ON') + "."));
      }
      (0, invariant.default)(runnables[appKey] && runnables[appKey].run, "Application \"" + appKey + "\" has not been registered. " + 'This is either due to an import error during initialization or failure to call AppRegistry.registerComponent.');
      return runnables[appKey].run(appParameters);
    }
    static setComponentProviderInstrumentationHook(hook) {
      componentProviderInstrumentationHook = hook;
    }
    static setWrapperComponentProvider(provider) {
      wrapperComponentProvider = provider;
    }
    static unmountApplicationComponentAtRootTag(rootTag) {
      (0, unmountComponentAtNode.default)(rootTag);
    }
  }
},500,[37,17,495,501],"node_modules/react-native-web/dist/exports/AppRegistry/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return renderApplication;
    }
  });
  exports.getApplication = getApplication;
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _AppContainer = require(_dependencyMap[1], "./AppContainer");
  var AppContainer = _interopDefault(_AppContainer);
  var _fbjsLibInvariant = require(_dependencyMap[2], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _render = require(_dependencyMap[3], "../render");
  var render = _interopDefault(_render);
  var _StyleSheet = require(_dependencyMap[4], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _react = require(_dependencyMap[5], "react");
  var React = _interopDefault(_react);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function renderApplication(RootComponent, WrapperComponent, callback, options) {
    var shouldHydrate = options.hydrate,
      initialProps = options.initialProps,
      rootTag = options.rootTag;
    var renderFn = shouldHydrate ? _render.hydrate : render.default;
    (0, invariant.default)(rootTag, 'Expect to have a valid rootTag, instead got ', rootTag);
    return renderFn(/*#__PURE__*/React.default.createElement(AppContainer.default, {
      WrapperComponent: WrapperComponent,
      ref: callback,
      rootTag: rootTag
    }, /*#__PURE__*/React.default.createElement(RootComponent, initialProps)), rootTag);
  }
  function getApplication(RootComponent, initialProps, WrapperComponent) {
    var element = /*#__PURE__*/React.default.createElement(AppContainer.default, {
      WrapperComponent: WrapperComponent,
      rootTag: {}
    }, /*#__PURE__*/React.default.createElement(RootComponent, initialProps));
    // Don't escape CSS text
    var getStyleElement = props => {
      var sheet = StyleSheet.default.getSheet();
      return /*#__PURE__*/React.default.createElement("style", (0, _extends.default)({}, props, {
        dangerouslySetInnerHTML: {
          __html: sheet.textContent
        },
        id: sheet.id
      }));
    };
    return {
      element,
      getStyleElement
    };
  }
},501,[42,502,17,494,55,9],"node_modules/react-native-web/dist/exports/AppRegistry/renderApplication.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  // NOTE(EvanBacon): `react-native-web` adds a extra `div`s around the root HTML, these
  // make static rendering much harder as we expect the root element to be `<html>`.
  // This resolution will alias to a simple in-out component to avoid the extra HTML.
  function AppContainer({
    children
  }) {
    return children;
  }
  _c = AppContainer;
  if (process.env.NODE_ENV !== 'production') {
    AppContainer.displayName = 'AppContainer';
  }
  var _default = AppContainer;
  var _c;
  $RefreshReg$(_c, "AppContainer");
},502,[],"\u0000shim:react-native-web/dist/exports/AppRegistry/AppContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return AppState;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _vendorReactNativeVendorEmitterEventEmitter = require(_dependencyMap[1], "../../vendor/react-native/vendor/emitter/EventEmitter");
  var EventEmitter = _interopDefault(_vendorReactNativeVendorEmitterEventEmitter);
  var _modulesCanUseDom = require(_dependencyMap[2], "../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  // Android 4.4 browser
  var isPrefixed = canUseDOM.default && !document.hasOwnProperty('hidden') && document.hasOwnProperty('webkitHidden');
  var EVENT_TYPES = ['change', 'memoryWarning'];
  var VISIBILITY_CHANGE_EVENT = isPrefixed ? 'webkitvisibilitychange' : 'visibilitychange';
  var VISIBILITY_STATE_PROPERTY = isPrefixed ? 'webkitVisibilityState' : 'visibilityState';
  var AppStates = {
    BACKGROUND: 'background',
    ACTIVE: 'active'
  };
  var changeEmitter = null;
  class AppState {
    static get currentState() {
      if (!AppState.isAvailable) {
        return AppStates.ACTIVE;
      }
      switch (document[VISIBILITY_STATE_PROPERTY]) {
        case 'hidden':
        case 'prerender':
        case 'unloaded':
          return AppStates.BACKGROUND;
        default:
          return AppStates.ACTIVE;
      }
    }
    static addEventListener(type, handler) {
      if (AppState.isAvailable) {
        (0, invariant.default)(EVENT_TYPES.indexOf(type) !== -1, 'Trying to subscribe to unknown event: "%s"', type);
        if (type === 'change') {
          if (!changeEmitter) {
            changeEmitter = new EventEmitter.default();
            document.addEventListener(VISIBILITY_CHANGE_EVENT, () => {
              if (changeEmitter) {
                changeEmitter.emit('change', AppState.currentState);
              }
            }, false);
          }
          return changeEmitter.addListener(type, handler);
        }
      }
    }
  }
  AppState.isAvailable = canUseDOM.default && !!document[VISIBILITY_STATE_PROPERTY];
},503,[17,16,45],"node_modules/react-native-web/dist/exports/AppState/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return Clipboard;
    }
  });
  var clipboardAvailable;
  class Clipboard {
    static isAvailable() {
      if (clipboardAvailable === undefined) {
        clipboardAvailable = typeof document.queryCommandSupported === 'function' && document.queryCommandSupported('copy');
      }
      return clipboardAvailable;
    }
    static getString() {
      return Promise.resolve('');
    }
    static setString(text) {
      var success = false;
      var body = document.body;
      if (body) {
        // add the text to a hidden node
        var node = document.createElement('span');
        node.textContent = text;
        node.style.opacity = '0';
        node.style.position = 'absolute';
        node.style.whiteSpace = 'pre-wrap';
        node.style.userSelect = 'auto';
        body.appendChild(node);

        // select the text
        var selection = window.getSelection();
        selection.removeAllRanges();
        var range = document.createRange();
        range.selectNodeContents(node);
        selection.addRange(range);

        // attempt to copy
        try {
          document.execCommand('copy');
          success = true;
        } catch (e) {}

        // remove selection and node
        selection.removeAllRanges();
        body.removeChild(node);
      }
      return success;
    }
  }
},504,[],"node_modules/react-native-web/dist/exports/Clipboard/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeLayoutAnimation = require(_dependencyMap[0], "../../vendor/react-native/LayoutAnimation");
  var LayoutAnimation = _interopDefault(_vendorReactNativeLayoutAnimation);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _default = LayoutAnimation.default;
},505,[506],"node_modules/react-native-web/dist/exports/LayoutAnimation/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _exportsPlatform = require(_dependencyMap[0], "../../../exports/Platform");
  var Platform = _interopDefault(_exportsPlatform);
  var _exportsUIManager = require(_dependencyMap[1], "../../../exports/UIManager");
  var UIManager = _interopDefault(_exportsUIManager);
  var __DEV__ = process.env.NODE_ENV !== 'production';
  function configureNext(config, onAnimationDidEnd) {
    if (!Platform.default.isTesting) {
      UIManager.default.configureNextLayoutAnimation(config, onAnimationDidEnd !== null && onAnimationDidEnd !== void 0 ? onAnimationDidEnd : function () {}, function () {} /* unused onError */);
    }
  }
  function create(duration, type, property) {
    return {
      duration,
      create: {
        type,
        property
      },
      update: {
        type
      },
      delete: {
        type,
        property
      }
    };
  }
  var Presets = {
    easeInEaseOut: create(300, 'easeInEaseOut', 'opacity'),
    linear: create(500, 'linear', 'opacity'),
    spring: {
      duration: 700,
      create: {
        type: 'linear',
        property: 'opacity'
      },
      update: {
        type: 'spring',
        springDamping: 0.4
      },
      delete: {
        type: 'linear',
        property: 'opacity'
      }
    }
  };

  /**
   * Automatically animates views to their new positions when the
   * next layout happens.
   *
   * A common way to use this API is to call it before calling `setState`.
   *
   * Note that in order to get this to work on **Android** you need to set the following flags via `UIManager`:
   *
   *     UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(true);
   */
  var LayoutAnimation = {
    /**
     * Schedules an animation to happen on the next layout.
     *
     * @param config Specifies animation properties:
     *
     *   - `duration` in milliseconds
     *   - `create`, `AnimationConfig` for animating in new views
     *   - `update`, `AnimationConfig` for animating views that have been updated
     *
     * @param onAnimationDidEnd Called when the animation finished.
     * Only supported on iOS.
     * @param onError Called on error. Only supported on iOS.
     */
    configureNext,
    /**
     * Helper for creating a config for `configureNext`.
     */
    create,
    Types: Object.freeze({
      spring: 'spring',
      linear: 'linear',
      easeInEaseOut: 'easeInEaseOut',
      easeIn: 'easeIn',
      easeOut: 'easeOut',
      keyboard: 'keyboard'
    }),
    Properties: Object.freeze({
      opacity: 'opacity',
      scaleX: 'scaleX',
      scaleY: 'scaleY',
      scaleXY: 'scaleXY'
    }),
    checkConfig() {
      console.error('LayoutAnimation.checkConfig(...) has been disabled.');
    },
    Presets,
    easeInEaseOut: configureNext.bind(null, Presets.easeInEaseOut),
    linear: configureNext.bind(null, Presets.linear),
    spring: configureNext.bind(null, Presets.spring)
  };
  var _default = LayoutAnimation;
},506,[14,48],"node_modules/react-native-web/dist/vendor/react-native/LayoutAnimation/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _modulesCanUseDom = require(_dependencyMap[1], "../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var initialURL = canUseDOM.default ? window.location.href : '';
  class Linking {
    constructor() {
      this._eventCallbacks = {};
    }
    /**
     * An object mapping of event name
     * and all the callbacks subscribing to it
     */
    _dispatchEvent(event) {
      for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }
      var listeners = this._eventCallbacks[event];
      if (listeners != null && Array.isArray(listeners)) {
        listeners.map(listener => {
          listener(...data);
        });
      }
    }

    /**
     * Adds a event listener for the specified event. The callback will be called when the
     * said event is dispatched.
     */
    addEventListener(eventType, callback) {
      var _this = this;
      if (!_this._eventCallbacks[eventType]) {
        _this._eventCallbacks[eventType] = [callback];
      }
      _this._eventCallbacks[eventType].push(callback);
      return {
        remove() {
          var callbacks = _this._eventCallbacks[eventType];
          var filteredCallbacks = callbacks.filter(c => c.toString() !== callback.toString());
          _this._eventCallbacks[eventType] = filteredCallbacks;
        }
      };
    }

    /**
     * Removes a previously added event listener for the specified event. The callback must
     * be the same object as the one passed to `addEventListener`.
     */
    removeEventListener(eventType, callback) {
      console.error("Linking.removeEventListener('" + eventType + "', ...): Method has been " + 'deprecated. Please instead use `remove()` on the subscription ' + 'returned by `Linking.addEventListener`.');
      var callbacks = this._eventCallbacks[eventType];
      var filteredCallbacks = callbacks.filter(c => c.toString() !== callback.toString());
      this._eventCallbacks[eventType] = filteredCallbacks;
    }
    canOpenURL() {
      return Promise.resolve(true);
    }
    getInitialURL() {
      return Promise.resolve(initialURL);
    }

    /**
     * Try to open the given url in a secure fashion. The method returns a Promise object.
     * If a target is passed (including undefined) that target will be used, otherwise '_blank'.
     * If the url opens, the promise is resolved. If not, the promise is rejected.
     * Dispatches the `onOpen` event if `url` is opened successfully.
     */
    openURL(url, target) {
      if (arguments.length === 1) {
        target = '_blank';
      }
      try {
        open(url, target);
        this._dispatchEvent('onOpen', url);
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    }
    _validateURL(url) {
      (0, invariant.default)(typeof url === 'string', 'Invalid URL: should be a string. Was: ' + url);
      (0, invariant.default)(url, 'Invalid URL: cannot be empty');
    }
  }
  var open = (url, target) => {
    if (canUseDOM.default) {
      var urlToOpen = new URL(url, window.location).toString();
      if (urlToOpen.indexOf('tel:') === 0) {
        window.location = urlToOpen;
      } else {
        window.open(urlToOpen, target, 'noopener');
      }
    }
  };
  var _default = new Linking();
},507,[17,45],"node_modules/react-native-web/dist/exports/Linking/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativePanResponder = require(_dependencyMap[0], "../../vendor/react-native/PanResponder");
  var PanResponder = _interopDefault(_vendorReactNativePanResponder);
  var _default = PanResponder.default;
},508,[509],"node_modules/react-native-web/dist/exports/PanResponder/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _exportsInteractionManager = require(_dependencyMap[0], "../../../exports/InteractionManager");
  var InteractionManager = _interopDefault(_exportsInteractionManager);
  var _TouchHistoryMath = require(_dependencyMap[1], "../TouchHistoryMath");
  var TouchHistoryMath = _interopDefault(_TouchHistoryMath);
  var currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.default.currentCentroidXOfTouchesChangedAfter;
  var currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.default.currentCentroidYOfTouchesChangedAfter;
  var previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.default.previousCentroidXOfTouchesChangedAfter;
  var previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.default.previousCentroidYOfTouchesChangedAfter;
  var currentCentroidX = TouchHistoryMath.default.currentCentroidX;
  var currentCentroidY = TouchHistoryMath.default.currentCentroidY;

  /**
   * `PanResponder` reconciles several touches into a single gesture. It makes
   * single-touch gestures resilient to extra touches, and can be used to
   * recognize simple multi-touch gestures.
   *
   * By default, `PanResponder` holds an `InteractionManager` handle to block
   * long-running JS events from interrupting active gestures.
   *
   * It provides a predictable wrapper of the responder handlers provided by the
   * [gesture responder system](docs/gesture-responder-system.html).
   * For each handler, it provides a new `gestureState` object alongside the
   * native event object:
   *
   * ```
   * onPanResponderMove: (event, gestureState) => {}
   * ```
   *
   * A native event is a synthetic touch event with the following form:
   *
   *  - `nativeEvent`
   *      + `changedTouches` - Array of all touch events that have changed since the last event
   *      + `identifier` - The ID of the touch
   *      + `locationX` - The X position of the touch, relative to the element
   *      + `locationY` - The Y position of the touch, relative to the element
   *      + `pageX` - The X position of the touch, relative to the root element
   *      + `pageY` - The Y position of the touch, relative to the root element
   *      + `target` - The node id of the element receiving the touch event
   *      + `timestamp` - A time identifier for the touch, useful for velocity calculation
   *      + `touches` - Array of all current touches on the screen
   *
   * A `gestureState` object has the following:
   *
   *  - `stateID` - ID of the gestureState- persisted as long as there at least
   *     one touch on screen
   *  - `moveX` - the latest screen coordinates of the recently-moved touch
   *  - `moveY` - the latest screen coordinates of the recently-moved touch
   *  - `x0` - the screen coordinates of the responder grant
   *  - `y0` - the screen coordinates of the responder grant
   *  - `dx` - accumulated distance of the gesture since the touch started
   *  - `dy` - accumulated distance of the gesture since the touch started
   *  - `vx` - current velocity of the gesture
   *  - `vy` - current velocity of the gesture
   *  - `numberActiveTouches` - Number of touches currently on screen
   *
   * ### Basic Usage
   *
   * ```
   *   componentWillMount: function() {
   *     this._panResponder = PanResponder.create({
   *       // Ask to be the responder:
   *       onStartShouldSetPanResponder: (evt, gestureState) => true,
   *       onStartShouldSetPanResponderCapture: (evt, gestureState) => true,
   *       onMoveShouldSetPanResponder: (evt, gestureState) => true,
   *       onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,
   *
   *       onPanResponderGrant: (evt, gestureState) => {
   *         // The gesture has started. Show visual feedback so the user knows
   *         // what is happening!
   *
   *         // gestureState.d{x,y} will be set to zero now
   *       },
   *       onPanResponderMove: (evt, gestureState) => {
   *         // The most recent move distance is gestureState.move{X,Y}
   *
   *         // The accumulated gesture distance since becoming responder is
   *         // gestureState.d{x,y}
   *       },
   *       onPanResponderTerminationRequest: (evt, gestureState) => true,
   *       onPanResponderRelease: (evt, gestureState) => {
   *         // The user has released all touches while this view is the
   *         // responder. This typically means a gesture has succeeded
   *       },
   *       onPanResponderTerminate: (evt, gestureState) => {
   *         // Another component has become the responder, so this gesture
   *         // should be cancelled
   *       },
   *       onShouldBlockNativeResponder: (evt, gestureState) => {
   *         // Returns whether this component should block native components from becoming the JS
   *         // responder. Returns true by default. Is currently only supported on android.
   *         return true;
   *       },
   *     });
   *   },
   *
   *   render: function() {
   *     return (
   *       <View {...this._panResponder.panHandlers} />
   *     );
   *   },
   *
   * ```
   *
   * ### Working Example
   *
   * To see it in action, try the
   * [PanResponder example in RNTester](https://github.com/facebook/react-native/blob/master/RNTester/js/PanResponderExample.js)
   */

  var PanResponder = {
    /**
     *
     * A graphical explanation of the touch data flow:
     *
     * +----------------------------+             +--------------------------------+
     * | ResponderTouchHistoryStore |             |TouchHistoryMath                |
     * +----------------------------+             +----------+---------------------+
     * |Global store of touchHistory|             |Allocation-less math util       |
     * |including activeness, start |             |on touch history (centroids     |
     * |position, prev/cur position.|             |and multitouch movement etc)    |
     * |                            |             |                                |
     * +----^-----------------------+             +----^---------------------------+
     *      |                                          |
     *      | (records relevant history                |
     *      |  of touches relevant for                 |
     *      |  implementing higher level               |
     *      |  gestures)                               |
     *      |                                          |
     * +----+-----------------------+             +----|---------------------------+
     * | ResponderEventPlugin       |             |    |   Your App/Component      |
     * +----------------------------+             +----|---------------------------+
     * |Negotiates which view gets  | Low level   |    |             High level    |
     * |onResponderMove events.     | events w/   |  +-+-------+     events w/     |
     * |Also records history into   | touchHistory|  |   Pan   |     multitouch +  |
     * |ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|
     * +----------------------------+ attached to |  |         |     distance and  |
     *                                 each event |  +---------+     velocity.     |
     *                                            |                                |
     *                                            |                                |
     *                                            +--------------------------------+
     *
     *
     *
     * Gesture that calculates cumulative movement over time in a way that just
     * "does the right thing" for multiple touches. The "right thing" is very
     * nuanced. When moving two touches in opposite directions, the cumulative
     * distance is zero in each dimension. When two touches move in parallel five
     * pixels in the same direction, the cumulative distance is five, not ten. If
     * two touches start, one moves five in a direction, then stops and the other
     * touch moves fives in the same direction, the cumulative distance is ten.
     *
     * This logic requires a kind of processing of time "clusters" of touch events
     * so that two touch moves that essentially occur in parallel but move every
     * other frame respectively, are considered part of the same movement.
     *
     * Explanation of some of the non-obvious fields:
     *
     * - moveX/moveY: If no move event has been observed, then `(moveX, moveY)` is
     *   invalid. If a move event has been observed, `(moveX, moveY)` is the
     *   centroid of the most recently moved "cluster" of active touches.
     *   (Currently all move have the same timeStamp, but later we should add some
     *   threshold for what is considered to be "moving"). If a palm is
     *   accidentally counted as a touch, but a finger is moving greatly, the palm
     *   will move slightly, but we only want to count the single moving touch.
     * - x0/y0: Centroid location (non-cumulative) at the time of becoming
     *   responder.
     * - dx/dy: Cumulative touch distance - not the same thing as sum of each touch
     *   distance. Accounts for touch moves that are clustered together in time,
     *   moving the same direction. Only valid when currently responder (otherwise,
     *   it only represents the drag distance below the threshold).
     * - vx/vy: Velocity.
     */

    _initializeGestureState(gestureState) {
      gestureState.moveX = 0;
      gestureState.moveY = 0;
      gestureState.x0 = 0;
      gestureState.y0 = 0;
      gestureState.dx = 0;
      gestureState.dy = 0;
      gestureState.vx = 0;
      gestureState.vy = 0;
      gestureState.numberActiveTouches = 0;
      // All `gestureState` accounts for timeStamps up until:
      gestureState._accountsForMovesUpTo = 0;
    },
    /**
     * This is nuanced and is necessary. It is incorrect to continuously take all
     * active *and* recently moved touches, find the centroid, and track how that
     * result changes over time. Instead, we must take all recently moved
     * touches, and calculate how the centroid has changed just for those
     * recently moved touches, and append that change to an accumulator. This is
     * to (at least) handle the case where the user is moving three fingers, and
     * then one of the fingers stops but the other two continue.
     *
     * This is very different than taking all of the recently moved touches and
     * storing their centroid as `dx/dy`. For correctness, we must *accumulate
     * changes* in the centroid of recently moved touches.
     *
     * There is also some nuance with how we handle multiple moved touches in a
     * single event. With the way `ReactNativeEventEmitter` dispatches touches as
     * individual events, multiple touches generate two 'move' events, each of
     * them triggering `onResponderMove`. But with the way `PanResponder` works,
     * all of the gesture inference is performed on the first dispatch, since it
     * looks at all of the touches (even the ones for which there hasn't been a
     * native dispatch yet). Therefore, `PanResponder` does not call
     * `onResponderMove` passed the first dispatch. This diverges from the
     * typical responder callback pattern (without using `PanResponder`), but
     * avoids more dispatches than necessary.
     */
    _updateGestureStateOnMove(gestureState, touchHistory) {
      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
      gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      var movedAfter = gestureState._accountsForMovesUpTo;
      var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
      var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
      var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
      var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
      var nextDX = gestureState.dx + (x - prevX);
      var nextDY = gestureState.dy + (y - prevY);

      // TODO: This must be filtered intelligently.
      var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
      gestureState.vx = (nextDX - gestureState.dx) / dt;
      gestureState.vy = (nextDY - gestureState.dy) / dt;
      gestureState.dx = nextDX;
      gestureState.dy = nextDY;
      gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
    },
    /**
     * @param {object} config Enhanced versions of all of the responder callbacks
     * that provide not only the typical `ResponderSyntheticEvent`, but also the
     * `PanResponder` gesture state.  Simply replace the word `Responder` with
     * `PanResponder` in each of the typical `onResponder*` callbacks. For
     * example, the `config` object would look like:
     *
     *  - `onMoveShouldSetPanResponder: (e, gestureState) => {...}`
     *  - `onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}`
     *  - `onStartShouldSetPanResponder: (e, gestureState) => {...}`
     *  - `onStartShouldSetPanResponderCapture: (e, gestureState) => {...}`
     *  - `onPanResponderReject: (e, gestureState) => {...}`
     *  - `onPanResponderGrant: (e, gestureState) => {...}`
     *  - `onPanResponderStart: (e, gestureState) => {...}`
     *  - `onPanResponderEnd: (e, gestureState) => {...}`
     *  - `onPanResponderRelease: (e, gestureState) => {...}`
     *  - `onPanResponderMove: (e, gestureState) => {...}`
     *  - `onPanResponderTerminate: (e, gestureState) => {...}`
     *  - `onPanResponderTerminationRequest: (e, gestureState) => {...}`
     *  - `onShouldBlockNativeResponder: (e, gestureState) => {...}`
     *
     *  In general, for events that have capture equivalents, we update the
     *  gestureState once in the capture phase and can use it in the bubble phase
     *  as well.
     *
     *  Be careful with onStartShould* callbacks. They only reflect updated
     *  `gestureState` for start/end events that bubble/capture to the Node.
     *  Once the node is the responder, you can rely on every start/end event
     *  being processed by the gesture and `gestureState` being updated
     *  accordingly. (numberActiveTouches) may not be totally accurate unless you
     *  are the responder.
     */
    create(config) {
      var interactionState = {
        handle: null,
        shouldCancelClick: false,
        timeout: null
      };
      var gestureState = {
        // Useful for debugging
        stateID: Math.random(),
        moveX: 0,
        moveY: 0,
        x0: 0,
        y0: 0,
        dx: 0,
        dy: 0,
        vx: 0,
        vy: 0,
        numberActiveTouches: 0,
        _accountsForMovesUpTo: 0
      };
      var panHandlers = {
        onStartShouldSetResponder(event) {
          return config.onStartShouldSetPanResponder == null ? false : config.onStartShouldSetPanResponder(event, gestureState);
        },
        onMoveShouldSetResponder(event) {
          return config.onMoveShouldSetPanResponder == null ? false : config.onMoveShouldSetPanResponder(event, gestureState);
        },
        onStartShouldSetResponderCapture(event) {
          // TODO: Actually, we should reinitialize the state any time
          // touches.length increases from 0 active to > 0 active.
          if (event.nativeEvent.touches.length === 1) {
            PanResponder._initializeGestureState(gestureState);
          }
          gestureState.numberActiveTouches = event.touchHistory.numberActiveTouches;
          return config.onStartShouldSetPanResponderCapture != null ? config.onStartShouldSetPanResponderCapture(event, gestureState) : false;
        },
        onMoveShouldSetResponderCapture(event) {
          var touchHistory = event.touchHistory;
          // Responder system incorrectly dispatches should* to current responder
          // Filter out any touch moves past the first one - we would have
          // already processed multi-touch geometry during the first event.
          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return false;
          }
          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);
          return config.onMoveShouldSetPanResponderCapture ? config.onMoveShouldSetPanResponderCapture(event, gestureState) : false;
        },
        onResponderGrant(event) {
          if (!interactionState.handle) {
            interactionState.handle = InteractionManager.default.createInteractionHandle();
          }
          if (interactionState.timeout) {
            clearInteractionTimeout(interactionState);
          }
          interactionState.shouldCancelClick = true;
          gestureState.x0 = currentCentroidX(event.touchHistory);
          gestureState.y0 = currentCentroidY(event.touchHistory);
          gestureState.dx = 0;
          gestureState.dy = 0;
          if (config.onPanResponderGrant) {
            config.onPanResponderGrant(event, gestureState);
          }
          // TODO: t7467124 investigate if this can be removed
          return config.onShouldBlockNativeResponder == null ? true : config.onShouldBlockNativeResponder(event, gestureState);
        },
        onResponderReject(event) {
          clearInteractionHandle(interactionState, config.onPanResponderReject, event, gestureState);
        },
        onResponderRelease(event) {
          clearInteractionHandle(interactionState, config.onPanResponderRelease, event, gestureState);
          setInteractionTimeout(interactionState);
          PanResponder._initializeGestureState(gestureState);
        },
        onResponderStart(event) {
          var touchHistory = event.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
          if (config.onPanResponderStart) {
            config.onPanResponderStart(event, gestureState);
          }
        },
        onResponderMove(event) {
          var touchHistory = event.touchHistory;
          // Guard against the dispatch of two touch moves when there are two
          // simultaneously changed touches.
          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return;
          }
          // Filter out any touch moves past the first one - we would have
          // already processed multi-touch geometry during the first event.
          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);
          if (config.onPanResponderMove) {
            config.onPanResponderMove(event, gestureState);
          }
        },
        onResponderEnd(event) {
          var touchHistory = event.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
          clearInteractionHandle(interactionState, config.onPanResponderEnd, event, gestureState);
        },
        onResponderTerminate(event) {
          clearInteractionHandle(interactionState, config.onPanResponderTerminate, event, gestureState);
          setInteractionTimeout(interactionState);
          PanResponder._initializeGestureState(gestureState);
        },
        onResponderTerminationRequest(event) {
          return config.onPanResponderTerminationRequest == null ? true : config.onPanResponderTerminationRequest(event, gestureState);
        },
        // We do not want to trigger 'click' activated gestures or native behaviors
        // on any pan target that is under a mouse cursor when it is released.
        // Browsers will natively cancel 'click' events on a target if a non-mouse
        // active pointer moves.
        onClickCapture: event => {
          if (interactionState.shouldCancelClick === true) {
            event.stopPropagation();
            event.preventDefault();
          }
        }
      };
      return {
        panHandlers,
        getInteractionHandle() {
          return interactionState.handle;
        }
      };
    }
  };
  function clearInteractionHandle(interactionState, callback, event, gestureState) {
    if (interactionState.handle) {
      InteractionManager.default.clearInteractionHandle(interactionState.handle);
      interactionState.handle = null;
    }
    if (callback) {
      callback(event, gestureState);
    }
  }
  function clearInteractionTimeout(interactionState) {
    clearTimeout(interactionState.timeout);
  }
  function setInteractionTimeout(interactionState) {
    interactionState.timeout = setTimeout(() => {
      interactionState.shouldCancelClick = false;
    }, 250);
  }
  var _default = PanResponder;
},509,[178,510],"node_modules/react-native-web/dist/vendor/react-native/PanResponder/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  var TouchHistoryMath = {
    /**
     * This code is optimized and not intended to look beautiful. This allows
     * computing of touch centroids that have moved after `touchesChangedAfter`
     * timeStamp. You can compute the current centroid involving all touches
     * moves after `touchesChangedAfter`, or you can compute the previous
     * centroid of all touches that were moved after `touchesChangedAfter`.
     *
     * @param {TouchHistoryMath} touchHistory Standard Responder touch track
     * data.
     * @param {number} touchesChangedAfter timeStamp after which moved touches
     * are considered "actively moving" - not just "active".
     * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.
     * @param {boolean} ofCurrent Compute current centroid for actively moving
     * touches vs. previous centroid of now actively moving touches.
     * @return {number} value of centroid in specified dimension.
     */
    centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
      var touchBank = touchHistory.touchBank;
      var total = 0;
      var count = 0;
      var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;
      if (oneTouchData !== null) {
        if (oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter) {
          total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;
          count = 1;
        }
      } else {
        for (var i = 0; i < touchBank.length; i++) {
          var touchTrack = touchBank[i];
          if (touchTrack !== null && touchTrack !== undefined && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {
            var toAdd = void 0; // Yuck, program temporarily in invalid state.
            if (ofCurrent && isXAxis) {
              toAdd = touchTrack.currentPageX;
            } else if (ofCurrent && !isXAxis) {
              toAdd = touchTrack.currentPageY;
            } else if (!ofCurrent && isXAxis) {
              toAdd = touchTrack.previousPageX;
            } else {
              toAdd = touchTrack.previousPageY;
            }
            total += toAdd;
            count++;
          }
        }
      }
      return count > 0 ? total / count : TouchHistoryMath.noCentroid;
    },
    currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true,
      // isXAxis
      true // ofCurrent
      );
    },
    currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false,
      // isXAxis
      true // ofCurrent
      );
    },
    previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true,
      // isXAxis
      false // ofCurrent
      );
    },
    previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false,
      // isXAxis
      false // ofCurrent
      );
    },
    currentCentroidX: function currentCentroidX(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0,
      // touchesChangedAfter
      true,
      // isXAxis
      true // ofCurrent
      );
    },
    currentCentroidY: function currentCentroidY(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0,
      // touchesChangedAfter
      false,
      // isXAxis
      true // ofCurrent
      );
    },
    noCentroid: -1
  };
  var _default = TouchHistoryMath;
},510,[],"node_modules/react-native-web/dist/vendor/react-native/TouchHistoryMath/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0], "fbjs/lib/invariant");
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  class Share {
    static share(content, options) {
      if (options === void 0) {
        options = {};
      }
      (0, invariant.default)(typeof content === 'object' && content !== null, 'Content to share must be a valid object');
      (0, invariant.default)(typeof content.url === 'string' || typeof content.message === 'string', 'At least one of URL and message is required');
      (0, invariant.default)(typeof options === 'object' && options !== null, 'Options must be a valid object');
      (0, invariant.default)(!content.title || typeof content.title === 'string', 'Invalid title: title should be a string.');
      if (window.navigator.share !== undefined) {
        return window.navigator.share({
          title: content.title,
          text: content.message,
          url: content.url
        });
      } else {
        return Promise.reject(new Error('Share is not supported in this browser'));
      }
    }

    /**
     * The content was successfully shared.
     */
    static get sharedAction() {
      return 'sharedAction';
    }

    /**
     * The dialog has been dismissed.
     * @platform ios
     */
    static get dismissedAction() {
      return 'dismissedAction';
    }
  }
  var _default = Share;
},511,[17],"node_modules/react-native-web/dist/exports/Share/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var vibrate = pattern => {
    if ('vibrate' in window.navigator) {
      window.navigator.vibrate(pattern);
    }
  };
  var Vibration = {
    cancel() {
      vibrate(0);
    },
    vibrate(pattern) {
      if (pattern === void 0) {
        pattern = 400;
      }
      vibrate(pattern);
    }
  };
  var _default = Vibration;
},512,[],"node_modules/react-native-web/dist/exports/Vibration/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[3], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[4], "../View");
  var View = _interopDefault(_View);
  var _excluded = ["animating", "color", "hidesWhenStopped", "size", "style"];
  var createSvgCircle = style => /*#__PURE__*/React.createElement("circle", {
    cx: "16",
    cy: "16",
    fill: "none",
    r: "14",
    strokeWidth: "4",
    style: style
  });
  var ActivityIndicator = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var _props$animating = props.animating,
      animating = _props$animating === void 0 ? true : _props$animating,
      _props$color = props.color,
      color = _props$color === void 0 ? '#1976D2' : _props$color,
      _props$hidesWhenStopp = props.hidesWhenStopped,
      hidesWhenStopped = _props$hidesWhenStopp === void 0 ? true : _props$hidesWhenStopp,
      _props$size = props.size,
      size = _props$size === void 0 ? 'small' : _props$size,
      style = props.style,
      other = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var svg = /*#__PURE__*/React.createElement("svg", {
      height: "100%",
      viewBox: "0 0 32 32",
      width: "100%"
    }, createSvgCircle({
      stroke: color,
      opacity: 0.2
    }), createSvgCircle({
      stroke: color,
      strokeDasharray: 80,
      strokeDashoffset: 60
    }));
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, other, {
      "aria-valuemax": 1,
      "aria-valuemin": 0,
      ref: forwardedRef,
      role: "progressbar",
      style: [styles.container, style]
    }), /*#__PURE__*/React.createElement(View.default, {
      children: svg,
      style: [typeof size === 'number' ? {
        height: size,
        width: size
      } : indicatorSizes[size], styles.animation, !animating && styles.animationPause, !animating && hidesWhenStopped && styles.hidesWhenStopped]
    }));
  });
  ActivityIndicator.displayName = 'ActivityIndicator';
  var styles = StyleSheet.default.create({
    container: {
      alignItems: 'center',
      justifyContent: 'center'
    },
    hidesWhenStopped: {
      visibility: 'hidden'
    },
    animation: {
      animationDuration: '0.75s',
      animationKeyframes: [{
        '0%': {
          transform: 'rotate(0deg)'
        },
        '100%': {
          transform: 'rotate(360deg)'
        }
      }],
      animationTimingFunction: 'linear',
      animationIterationCount: 'infinite'
    },
    animationPause: {
      animationPlayState: 'paused'
    }
  });
  var indicatorSizes = StyleSheet.default.create({
    small: {
      width: 20,
      height: 20
    },
    large: {
      width: 36,
      height: 36
    }
  });
  var _default = ActivityIndicator;
},513,[42,43,9,55,110],"node_modules/react-native-web/dist/exports/ActivityIndicator/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[1], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _TouchableOpacity = require(_dependencyMap[2], "../TouchableOpacity");
  var TouchableOpacity = _interopDefault(_TouchableOpacity);
  var _Text = require(_dependencyMap[3], "../Text");
  var Text = _interopDefault(_Text);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  //import { warnOnce } from '../../modules/warnOnce';

  var Button = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    // warnOnce('Button', 'Button is deprecated. Please use Pressable.');

    var accessibilityLabel = props.accessibilityLabel,
      color = props.color,
      disabled = props.disabled,
      onPress = props.onPress,
      testID = props.testID,
      title = props.title;
    return /*#__PURE__*/React.createElement(TouchableOpacity.default, {
      accessibilityLabel: accessibilityLabel,
      accessibilityRole: "button",
      disabled: disabled,
      focusable: !disabled,
      onPress: onPress,
      ref: forwardedRef,
      style: [styles.button, color && {
        backgroundColor: color
      }, disabled && styles.buttonDisabled],
      testID: testID
    }, /*#__PURE__*/React.createElement(Text.default, {
      style: [styles.text, disabled && styles.textDisabled]
    }, title));
  });
  Button.displayName = 'Button';
  var styles = StyleSheet.default.create({
    button: {
      backgroundColor: '#2196F3',
      borderRadius: 2
    },
    text: {
      color: '#fff',
      fontWeight: '500',
      padding: 8,
      textAlign: 'center',
      textTransform: 'uppercase'
    },
    buttonDisabled: {
      backgroundColor: '#dfdfdf'
    },
    textDisabled: {
      color: '#a1a1a1'
    }
  });
  var _default = Button;
},514,[9,55,515,138],"node_modules/react-native-web/dist/exports/Button/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _modulesUseMergeRefs = require(_dependencyMap[3], "../../modules/useMergeRefs");
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePressEvents = require(_dependencyMap[4], "../../modules/usePressEvents");
  var usePressEvents = _interopDefault(_modulesUsePressEvents);
  var _StyleSheet = require(_dependencyMap[5], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[6], "../View");
  var View = _interopDefault(_View);
  var _excluded = ["activeOpacity", "delayPressIn", "delayPressOut", "delayLongPress", "disabled", "focusable", "onLongPress", "onPress", "onPressIn", "onPressOut", "rejectResponderTermination", "style"];
  //import { warnOnce } from '../../modules/warnOnce';

  /**
   * A wrapper for making views respond properly to touches.
   * On press down, the opacity of the wrapped view is decreased, dimming it.
   */
  function TouchableOpacity(props, forwardedRef) {
    /*
    warnOnce(
      'TouchableOpacity',
      'TouchableOpacity is deprecated. Please use Pressable.'
    );
    */

    var activeOpacity = props.activeOpacity,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      rejectResponderTermination = props.rejectResponderTermination,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var hostRef = (0, _react.useRef)(null);
    var setRef = (0, useMergeRefs.default)(forwardedRef, hostRef);
    var _useState = (0, _react.useState)('0s'),
      duration = _useState[0],
      setDuration = _useState[1];
    var _useState2 = (0, _react.useState)(null),
      opacityOverride = _useState2[0],
      setOpacityOverride = _useState2[1];
    var setOpacityTo = (0, _react.useCallback)((value, duration) => {
      setOpacityOverride(value);
      setDuration(duration ? duration / 1000 + "s" : '0s');
    }, [setOpacityOverride, setDuration]);
    var setOpacityActive = (0, _react.useCallback)(duration => {
      setOpacityTo(activeOpacity !== null && activeOpacity !== void 0 ? activeOpacity : 0.2, duration);
    }, [activeOpacity, setOpacityTo]);
    var setOpacityInactive = (0, _react.useCallback)(duration => {
      setOpacityTo(null, duration);
    }, [setOpacityTo]);
    var pressConfig = (0, _react.useMemo)(() => ({
      cancelable: !rejectResponderTermination,
      disabled,
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      onLongPress,
      onPress,
      onPressStart(event) {
        var isGrant = event.dispatchConfig != null ? event.dispatchConfig.registrationName === 'onResponderGrant' : event.type === 'keydown';
        setOpacityActive(isGrant ? 0 : 150);
        if (onPressIn != null) {
          onPressIn(event);
        }
      },
      onPressEnd(event) {
        setOpacityInactive(250);
        if (onPressOut != null) {
          onPressOut(event);
        }
      }
    }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination, setOpacityActive, setOpacityInactive]);
    var pressEventHandlers = (0, usePressEvents.default)(hostRef, pressConfig);
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, pressEventHandlers, {
      accessibilityDisabled: disabled,
      focusable: !disabled && focusable !== false,
      pointerEvents: disabled ? 'box-none' : undefined,
      ref: setRef,
      style: [styles.root, !disabled && styles.actionable, style, opacityOverride != null && {
        opacity: opacityOverride
      }, {
        transitionDuration: duration
      }]
    }));
  }
  var styles = StyleSheet.default.create({
    root: {
      transitionProperty: 'opacity',
      transitionDuration: '0.15s',
      userSelect: 'none'
    },
    actionable: {
      cursor: 'pointer',
      touchAction: 'manipulation'
    }
  });
  var MemoedTouchableOpacity = /*#__PURE__*/React.memo(/*#__PURE__*/React.forwardRef(TouchableOpacity));
  MemoedTouchableOpacity.displayName = 'TouchableOpacity';
  var _default = MemoedTouchableOpacity;
},515,[42,43,9,123,148,55,110],"node_modules/react-native-web/dist/exports/TouchableOpacity/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersExtends = require(_dependencyMap[1], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[3], "react");
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[4], "../createElement");
  var createElement = _interopDefault(_createElement);
  var _StyleSheet = require(_dependencyMap[5], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[6], "../View");
  var View = _interopDefault(_View);
  var _excluded = ["aria-readonly", "color", "disabled", "onChange", "onValueChange", "readOnly", "style", "value"];
  var CheckBox = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var ariaReadOnly = props['aria-readonly'],
      color = props.color,
      disabled = props.disabled,
      onChange = props.onChange,
      onValueChange = props.onValueChange,
      readOnly = props.readOnly,
      style = props.style,
      value = props.value,
      other = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    function handleChange(event) {
      var value = event.nativeEvent.target.checked;
      event.nativeEvent.value = value;
      onChange && onChange(event);
      onValueChange && onValueChange(value);
    }
    var fakeControl = /*#__PURE__*/React.createElement(View.default, {
      style: [styles.fakeControl, value && styles.fakeControlChecked,
      // custom color
      value && color && {
        backgroundColor: color,
        borderColor: color
      }, disabled && styles.fakeControlDisabled, value && disabled && styles.fakeControlCheckedAndDisabled]
    });
    var nativeControl = (0, createElement.default)('input', {
      checked: value,
      disabled: disabled,
      onChange: handleChange,
      readOnly: readOnly === true || ariaReadOnly === true || other.accessibilityReadOnly === true,
      ref: forwardedRef,
      style: [styles.nativeControl, styles.cursorInherit],
      type: 'checkbox'
    });
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, other, {
      "aria-disabled": disabled,
      "aria-readonly": ariaReadOnly,
      style: [styles.root, style, disabled && styles.cursorDefault]
    }), fakeControl, nativeControl);
  });
  CheckBox.displayName = 'CheckBox';
  var styles = StyleSheet.default.create({
    root: {
      cursor: 'pointer',
      height: 16,
      userSelect: 'none',
      width: 16
    },
    cursorDefault: {
      cursor: 'default'
    },
    cursorInherit: {
      cursor: 'inherit'
    },
    fakeControl: {
      alignItems: 'center',
      backgroundColor: '#fff',
      borderColor: '#657786',
      borderRadius: 2,
      borderStyle: 'solid',
      borderWidth: 2,
      height: '100%',
      justifyContent: 'center',
      width: '100%'
    },
    fakeControlChecked: {
      backgroundColor: '#009688',
      backgroundImage: 'url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmVyc2lvbj0iMS4xIgogICB2aWV3Qm94PSIwIDAgMSAxIgogICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWluWU1pbiBtZWV0Ij4KICA8cGF0aAogICAgIGQ9Ik0gMC4wNDAzODA1OSwwLjYyNjc3NjcgMC4xNDY0NDY2MSwwLjUyMDcxMDY4IDAuNDI5Mjg5MzIsMC44MDM1NTMzOSAwLjMyMzIyMzMsMC45MDk2MTk0MSB6IE0gMC4yMTcxNTcyOSwwLjgwMzU1MzM5IDAuODUzNTUzMzksMC4xNjcxNTcyOSAwLjk1OTYxOTQxLDAuMjczMjIzMyAwLjMyMzIyMzMsMC45MDk2MTk0MSB6IgogICAgIGlkPSJyZWN0Mzc4MCIKICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lIiAvPgo8L3N2Zz4K")',
      backgroundRepeat: 'no-repeat',
      borderColor: '#009688'
    },
    fakeControlDisabled: {
      borderColor: '#CCD6DD'
    },
    fakeControlCheckedAndDisabled: {
      backgroundColor: '#AAB8C2',
      borderColor: '#AAB8C2'
    },
    nativeControl: (0, _objectSpread.default)((0, _objectSpread.default)({}, StyleSheet.default.absoluteFillObject), {}, {
      height: '100%',
      margin: 0,
      appearance: 'none',
      padding: 0,
      width: '100%'
    })
  });
  var _default = CheckBox;
},516,[37,42,43,9,111,55,110],"node_modules/react-native-web/dist/exports/CheckBox/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _Image = require(_dependencyMap[3], "../Image");
  var Image = _interopDefault(_Image);
  var _StyleSheet = require(_dependencyMap[4], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[5], "../View");
  var View = _interopDefault(_View);
  var _excluded = ["children", "style", "imageStyle", "imageRef"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyObject = {};

  /**
   * Very simple drop-in replacement for <Image> which supports nesting views.
   */
  var ImageBackground = /*#__PURE__*/(0, _react.forwardRef)((props, forwardedRef) => {
    var children = props.children,
      _props$style = props.style,
      style = _props$style === void 0 ? emptyObject : _props$style,
      imageStyle = props.imageStyle,
      imageRef = props.imageRef,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var _StyleSheet$flatten = StyleSheet.default.flatten(style),
      height = _StyleSheet$flatten.height,
      width = _StyleSheet$flatten.width;
    return /*#__PURE__*/React.createElement(View.default, {
      ref: forwardedRef,
      style: style
    }, /*#__PURE__*/React.createElement(Image.default, (0, _extends.default)({}, rest, {
      ref: imageRef,
      style: [{
        // Temporary Workaround:
        // Current (imperfect yet) implementation of <Image> overwrites width and height styles
        // (which is not quite correct), and these styles conflict with explicitly set styles
        // of <ImageBackground> and with our internal layout model here.
        // So, we have to proxy/reapply these styles explicitly for actual <Image> component.
        // This workaround should be removed after implementing proper support of
        // intrinsic content size of the <Image>.
        width,
        height,
        zIndex: -1
      }, StyleSheet.default.absoluteFill, imageStyle]
    })), children);
  });
  ImageBackground.displayName = 'ImageBackground';
  var _default = ImageBackground;
},517,[42,43,9,155,55,110],"node_modules/react-native-web/dist/exports/ImageBackground/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _View = require(_dependencyMap[3], "../View");
  var View = _interopDefault(_View);
  var _excluded = ["behavior", "contentContainerStyle", "keyboardVerticalOffset"];
  class KeyboardAvoidingView extends React.Component {
    constructor() {
      super(...arguments);
      this.frame = null;
      this.onLayout = event => {
        this.frame = event.nativeEvent.layout;
      };
    }
    relativeKeyboardHeight(keyboardFrame) {
      var frame = this.frame;
      if (!frame || !keyboardFrame) {
        return 0;
      }
      var keyboardY = keyboardFrame.screenY - (this.props.keyboardVerticalOffset || 0);
      return Math.max(frame.y + frame.height - keyboardY, 0);
    }
    onKeyboardChange(event) {}
    render() {
      var _this$props = this.props,
        behavior = _this$props.behavior,
        contentContainerStyle = _this$props.contentContainerStyle,
        keyboardVerticalOffset = _this$props.keyboardVerticalOffset,
        rest = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({
        onLayout: this.onLayout
      }, rest));
    }
  }
  var _default = KeyboardAvoidingView;
},518,[42,43,9,110],"node_modules/react-native-web/dist/exports/KeyboardAvoidingView/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _ModalPortal = require(_dependencyMap[3], "./ModalPortal");
  var ModalPortal = _interopDefault(_ModalPortal);
  var _ModalAnimation = require(_dependencyMap[4], "./ModalAnimation");
  var ModalAnimation = _interopDefault(_ModalAnimation);
  var _ModalContent = require(_dependencyMap[5], "./ModalContent");
  var ModalContent = _interopDefault(_ModalContent);
  var _ModalFocusTrap = require(_dependencyMap[6], "./ModalFocusTrap");
  var ModalFocusTrap = _interopDefault(_ModalFocusTrap);
  var _excluded = ["animationType", "children", "onDismiss", "onRequestClose", "onShow", "transparent", "visible"];
  var uniqueModalIdentifier = 0;
  var activeModalStack = [];
  var activeModalListeners = {};
  function notifyActiveModalListeners() {
    if (activeModalStack.length === 0) {
      return;
    }
    var activeModalId = activeModalStack[activeModalStack.length - 1];
    activeModalStack.forEach(modalId => {
      if (modalId in activeModalListeners) {
        activeModalListeners[modalId](modalId === activeModalId);
      }
    });
  }
  function removeActiveModal(modalId) {
    if (modalId in activeModalListeners) {
      // Before removing this listener we should probably tell it
      // that it's no longer the active modal for sure.
      activeModalListeners[modalId](false);
      delete activeModalListeners[modalId];
    }
    var index = activeModalStack.indexOf(modalId);
    if (index !== -1) {
      activeModalStack.splice(index, 1);
      notifyActiveModalListeners();
    }
  }
  function addActiveModal(modalId, listener) {
    removeActiveModal(modalId);
    activeModalStack.push(modalId);
    activeModalListeners[modalId] = listener;
    notifyActiveModalListeners();
  }
  var Modal = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var animationType = props.animationType,
      children = props.children,
      onDismiss = props.onDismiss,
      onRequestClose = props.onRequestClose,
      onShow = props.onShow,
      transparent = props.transparent,
      _props$visible = props.visible,
      visible = _props$visible === void 0 ? true : _props$visible,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);

    // Set a unique model identifier so we can correctly route
    // dismissals and check the layering of modals.
    var modalId = React.useMemo(() => uniqueModalIdentifier++, []);
    var _React$useState = React.useState(false),
      isActive = _React$useState[0],
      setIsActive = _React$useState[1];
    var onDismissCallback = React.useCallback(() => {
      removeActiveModal(modalId);
      if (onDismiss) {
        onDismiss();
      }
    }, [modalId, onDismiss]);
    var onShowCallback = React.useCallback(() => {
      addActiveModal(modalId, setIsActive);
      if (onShow) {
        onShow();
      }
    }, [modalId, onShow]);
    React.useEffect(() => {
      return () => removeActiveModal(modalId);
    }, [modalId]);
    return /*#__PURE__*/React.createElement(ModalPortal.default, null, /*#__PURE__*/React.createElement(ModalAnimation.default, {
      animationType: animationType,
      onDismiss: onDismissCallback,
      onShow: onShowCallback,
      visible: visible
    }, /*#__PURE__*/React.createElement(ModalFocusTrap.default, {
      active: isActive
    }, /*#__PURE__*/React.createElement(ModalContent.default, (0, _extends.default)({}, rest, {
      active: isActive,
      onRequestClose: onRequestClose,
      ref: forwardedRef,
      transparent: transparent
    }), children))));
  });
  var _default = Modal;
},519,[42,43,9,520,521,522,523],"node_modules/react-native-web/dist/exports/Modal/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _reactDom = require(_dependencyMap[1], "react-dom");
  var _modulesCanUseDom = require(_dependencyMap[2], "../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function ModalPortal(props) {
    var children = props.children;
    var elementRef = React.useRef(null);
    if (canUseDOM.default && !elementRef.current) {
      var element = document.createElement('div');
      if (element && document.body) {
        document.body.appendChild(element);
        elementRef.current = element;
      }
    }
    React.useEffect(() => {
      if (canUseDOM.default) {
        return () => {
          if (document.body && elementRef.current) {
            document.body.removeChild(elementRef.current);
            elementRef.current = null;
          }
        };
      }
    }, []);
    return elementRef.current && canUseDOM.default ? /*#__PURE__*/(0, _reactDom.createPortal)(children, elementRef.current) : null;
  }
  var _default = ModalPortal;
},520,[9,31,45],"node_modules/react-native-web/dist/exports/Modal/ModalPortal.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[1], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _createElement = require(_dependencyMap[2], "../createElement");
  var createElement = _interopDefault(_createElement);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var ANIMATION_DURATION = 250;
  function getAnimationStyle(animationType, visible) {
    if (animationType === 'slide') {
      return visible ? animatedSlideInStyles : animatedSlideOutStyles;
    }
    if (animationType === 'fade') {
      return visible ? animatedFadeInStyles : animatedFadeOutStyles;
    }
    return visible ? styles.container : styles.hidden;
  }
  function ModalAnimation(props) {
    var animationType = props.animationType,
      children = props.children,
      onDismiss = props.onDismiss,
      onShow = props.onShow,
      visible = props.visible;
    var _React$useState = React.useState(false),
      isRendering = _React$useState[0],
      setIsRendering = _React$useState[1];
    var wasVisible = React.useRef(false);
    var wasRendering = React.useRef(false);
    var isAnimated = animationType && animationType !== 'none';
    var animationEndCallback = React.useCallback(e => {
      if (e && e.currentTarget !== e.target) {
        // If the event was generated for something NOT this element we
        // should ignore it as it's not relevant to us
        return;
      }
      if (visible) {
        if (onShow) {
          onShow();
        }
      } else {
        setIsRendering(false);
      }
    }, [onShow, visible]);
    React.useEffect(() => {
      if (wasRendering.current && !isRendering && onDismiss) {
        onDismiss();
      }
      wasRendering.current = isRendering;
    }, [isRendering, onDismiss]);
    React.useEffect(() => {
      if (visible) {
        setIsRendering(true);
      }
      if (visible !== wasVisible.current && !isAnimated) {
        // Manually call `animationEndCallback` if no animation is used
        animationEndCallback();
      }
      wasVisible.current = visible;
    }, [isAnimated, visible, animationEndCallback]);
    return isRendering || visible ? (0, createElement.default)('div', {
      style: isRendering ? getAnimationStyle(animationType, visible) : styles.hidden,
      onAnimationEnd: animationEndCallback,
      children
    }) : null;
  }
  var styles = StyleSheet.default.create({
    container: {
      position: 'fixed',
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      zIndex: 9999
    },
    animatedIn: {
      animationDuration: ANIMATION_DURATION + "ms",
      animationTimingFunction: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
    },
    animatedOut: {
      pointerEvents: 'none',
      animationDuration: ANIMATION_DURATION + "ms",
      animationTimingFunction: 'cubic-bezier(0.47, 0, 0.745, 0.715)'
    },
    fadeIn: {
      opacity: 1,
      animationKeyframes: {
        '0%': {
          opacity: 0
        },
        '100%': {
          opacity: 1
        }
      }
    },
    fadeOut: {
      opacity: 0,
      animationKeyframes: {
        '0%': {
          opacity: 1
        },
        '100%': {
          opacity: 0
        }
      }
    },
    slideIn: {
      transform: 'translateY(0%)',
      animationKeyframes: {
        '0%': {
          transform: 'translateY(100%)'
        },
        '100%': {
          transform: 'translateY(0%)'
        }
      }
    },
    slideOut: {
      transform: 'translateY(100%)',
      animationKeyframes: {
        '0%': {
          transform: 'translateY(0%)'
        },
        '100%': {
          transform: 'translateY(100%)'
        }
      }
    },
    hidden: {
      opacity: 0
    }
  });
  var animatedSlideInStyles = [styles.container, styles.animatedIn, styles.slideIn];
  var animatedSlideOutStyles = [styles.container, styles.animatedOut, styles.slideOut];
  var animatedFadeInStyles = [styles.container, styles.animatedIn, styles.fadeIn];
  var animatedFadeOutStyles = [styles.container, styles.animatedOut, styles.fadeOut];
  var _default = ModalAnimation;
},521,[9,55,111],"node_modules/react-native-web/dist/exports/Modal/ModalAnimation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _View = require(_dependencyMap[3], "../View");
  var View = _interopDefault(_View);
  var _StyleSheet = require(_dependencyMap[4], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _modulesCanUseDom = require(_dependencyMap[5], "../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  var _excluded = ["active", "children", "onRequestClose", "transparent"];
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var ModalContent = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var active = props.active,
      children = props.children,
      onRequestClose = props.onRequestClose,
      transparent = props.transparent,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    React.useEffect(() => {
      if (canUseDOM.default) {
        var closeOnEscape = e => {
          if (active && e.key === 'Escape') {
            e.stopPropagation();
            if (onRequestClose) {
              onRequestClose();
            }
          }
        };
        document.addEventListener('keyup', closeOnEscape, false);
        return () => document.removeEventListener('keyup', closeOnEscape, false);
      }
    }, [active, onRequestClose]);
    var style = React.useMemo(() => {
      return [styles.modal, transparent ? styles.modalTransparent : styles.modalOpaque];
    }, [transparent]);
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, {
      "aria-modal": true,
      ref: forwardedRef,
      role: active ? 'dialog' : null,
      style: style
    }), /*#__PURE__*/React.createElement(View.default, {
      style: styles.container
    }, children));
  });
  var styles = StyleSheet.default.create({
    modal: {
      position: 'fixed',
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    },
    modalTransparent: {
      backgroundColor: 'transparent'
    },
    modalOpaque: {
      backgroundColor: 'white'
    },
    container: {
      top: 0,
      flex: 1
    }
  });
  var _default = ModalContent;
},522,[42,43,9,110,55,45],"node_modules/react-native-web/dist/exports/Modal/ModalContent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _View = require(_dependencyMap[1], "../View");
  var View = _interopDefault(_View);
  var _createElement = require(_dependencyMap[2], "../createElement");
  var createElement = _interopDefault(_createElement);
  var _StyleSheet = require(_dependencyMap[3], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _UIManager = require(_dependencyMap[4], "../UIManager");
  var UIManager = _interopDefault(_UIManager);
  var _modulesCanUseDom = require(_dependencyMap[5], "../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * This Component is used to "wrap" the modal we're opening
   * so that changing focus via tab will never leave the document.
   *
   * This allows us to properly trap the focus within a modal
   * even if the modal is at the start or end of a document.
   */

  var FocusBracket = () => {
    return (0, createElement.default)('div', {
      role: 'none',
      tabIndex: 0,
      style: styles.focusBracket
    });
  };
  function attemptFocus(element) {
    if (!canUseDOM.default) {
      return false;
    }
    try {
      element.focus();
    } catch (e) {
      // Do nothing
    }
    return document.activeElement === element;
  }
  function focusFirstDescendant(element) {
    for (var i = 0; i < element.childNodes.length; i++) {
      var child = element.childNodes[i];
      if (attemptFocus(child) || focusFirstDescendant(child)) {
        return true;
      }
    }
    return false;
  }
  function focusLastDescendant(element) {
    for (var i = element.childNodes.length - 1; i >= 0; i--) {
      var child = element.childNodes[i];
      if (attemptFocus(child) || focusLastDescendant(child)) {
        return true;
      }
    }
    return false;
  }
  var ModalFocusTrap = _ref => {
    var active = _ref.active,
      children = _ref.children;
    var trapElementRef = React.useRef();
    var focusRef = React.useRef({
      trapFocusInProgress: false,
      lastFocusedElement: null
    });
    React.useEffect(() => {
      if (canUseDOM.default) {
        var trapFocus = () => {
          // We should not trap focus if:
          // - The modal hasn't fully initialized with an HTMLElement ref
          // - Focus is already in the process of being trapped (e.g., we're refocusing)
          // - isTrapActive prop being falsey tells us to do nothing
          if (trapElementRef.current == null || focusRef.current.trapFocusInProgress || !active) {
            return;
          }
          try {
            focusRef.current.trapFocusInProgress = true;
            if (document.activeElement instanceof Node && !trapElementRef.current.contains(document.activeElement)) {
              // To handle keyboard focusing we can make an assumption here.
              // If you're tabbing through the focusable elements, the previously
              // active element will either be the first or the last.
              // If the previously selected element is the "first" descendant
              // and we're leaving it - this means that we should be looping
              // around to the other side of the modal.
              var hasFocused = focusFirstDescendant(trapElementRef.current);
              if (focusRef.current.lastFocusedElement === document.activeElement) {
                hasFocused = focusLastDescendant(trapElementRef.current);
              }
              // If we couldn't focus a new element then we need to focus onto the trap target
              if (!hasFocused && trapElementRef.current != null && document.activeElement) {
                UIManager.default.focus(trapElementRef.current);
              }
            }
          } finally {
            focusRef.current.trapFocusInProgress = false;
          }
          focusRef.current.lastFocusedElement = document.activeElement;
        };

        // Call the trapFocus callback at least once when this modal has been activated.
        trapFocus();
        document.addEventListener('focus', trapFocus, true);
        return () => document.removeEventListener('focus', trapFocus, true);
      }
    }, [active]);

    // To be fully compliant with WCAG we need to refocus element that triggered opening modal
    // after closing it
    React.useEffect(function () {
      if (canUseDOM.default) {
        var lastFocusedElementOutsideTrap = document.activeElement;
        return function () {
          if (lastFocusedElementOutsideTrap && document.contains(lastFocusedElementOutsideTrap)) {
            UIManager.default.focus(lastFocusedElementOutsideTrap);
          }
        };
      }
    }, []);
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(FocusBracket, null), /*#__PURE__*/React.createElement(View.default, {
      ref: trapElementRef
    }, children), /*#__PURE__*/React.createElement(FocusBracket, null));
  };
  var _default = ModalFocusTrap;
  var styles = StyleSheet.default.create({
    focusBracket: {
      outlineStyle: 'none'
    }
  });
},523,[9,110,111,55,48,45],"node_modules/react-native-web/dist/exports/Modal/ModalFocusTrap.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[3], "../createElement");
  var createElement = _interopDefault(_createElement);
  var _modulesUseMergeRefs = require(_dependencyMap[4], "../../modules/useMergeRefs");
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePlatformMethods = require(_dependencyMap[5], "../../modules/usePlatformMethods");
  var usePlatformMethods = _interopDefault(_modulesUsePlatformMethods);
  var _PickerItem = require(_dependencyMap[6], "./PickerItem");
  var PickerItem = _interopDefault(_PickerItem);
  var _StyleSheet = require(_dependencyMap[7], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _excluded = ["children", "enabled", "onValueChange", "selectedValue", "style", "testID", "itemStyle", "mode", "prompt"];
  var Picker = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var children = props.children,
      enabled = props.enabled,
      onValueChange = props.onValueChange,
      selectedValue = props.selectedValue,
      style = props.style,
      testID = props.testID,
      itemStyle = props.itemStyle,
      mode = props.mode,
      prompt = props.prompt,
      other = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var hostRef = React.useRef(null);
    function handleChange(e) {
      var _e$target = e.target,
        selectedIndex = _e$target.selectedIndex,
        value = _e$target.value;
      if (onValueChange) {
        onValueChange(value, selectedIndex);
      }
    }

    // $FlowFixMe
    var supportedProps = (0, _objectSpread.default)({
      children,
      disabled: enabled === false ? true : undefined,
      onChange: handleChange,
      style: [styles.initial, style],
      testID,
      value: selectedValue
    }, other);
    var platformMethodsRef = (0, usePlatformMethods.default)(supportedProps);
    var setRef = (0, useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
    supportedProps.ref = setRef;
    return (0, createElement.default)('select', supportedProps);
  });

  // $FlowFixMe
  Picker.Item = PickerItem.default;
  var styles = StyleSheet.default.create({
    initial: {
      fontFamily: 'System',
      fontSize: 'inherit',
      margin: 0
    }
  });
  var _default = Picker;
},524,[37,43,9,111,123,124,525,55],"node_modules/react-native-web/dist/exports/Picker/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return PickerItem;
    }
  });
  var _createElement = require(_dependencyMap[0], "../createElement");
  var createElement = _interopDefault(_createElement);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function PickerItem(props) {
    var color = props.color,
      label = props.label,
      testID = props.testID,
      value = props.value;
    var style = {
      color
    };
    return (0, createElement.default)('option', {
      children: label,
      style,
      testID,
      value
    });
  }
},525,[111],"node_modules/react-native-web/dist/exports/Picker/PickerItem.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[3], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[4], "../View");
  var View = _interopDefault(_View);
  var _excluded = ["color", "indeterminate", "progress", "trackColor", "style"];
  var ProgressBar = /*#__PURE__*/React.forwardRef((props, ref) => {
    var _props$color = props.color,
      color = _props$color === void 0 ? '#1976D2' : _props$color,
      _props$indeterminate = props.indeterminate,
      indeterminate = _props$indeterminate === void 0 ? false : _props$indeterminate,
      _props$progress = props.progress,
      progress = _props$progress === void 0 ? 0 : _props$progress,
      _props$trackColor = props.trackColor,
      trackColor = _props$trackColor === void 0 ? 'transparent' : _props$trackColor,
      style = props.style,
      other = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var percentageProgress = progress * 100;
    var width = indeterminate ? '25%' : percentageProgress + "%";
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, other, {
      "aria-valuemax": 100,
      "aria-valuemin": 0,
      "aria-valuenow": indeterminate ? null : percentageProgress,
      ref: ref,
      role: "progressbar",
      style: [styles.track, style, {
        backgroundColor: trackColor
      }]
    }), /*#__PURE__*/React.createElement(View.default, {
      style: [{
        backgroundColor: color,
        width
      }, styles.progress, indeterminate && styles.animation]
    }));
  });
  ProgressBar.displayName = 'ProgressBar';
  var styles = StyleSheet.default.create({
    track: {
      forcedColorAdjust: 'none',
      height: 5,
      overflow: 'hidden',
      userSelect: 'none',
      zIndex: 0
    },
    progress: {
      forcedColorAdjust: 'none',
      height: '100%',
      zIndex: -1
    },
    animation: {
      animationDuration: '1s',
      animationKeyframes: [{
        '0%': {
          transform: 'translateX(-100%)'
        },
        '100%': {
          transform: 'translateX(400%)'
        }
      }],
      animationTimingFunction: 'linear',
      animationIterationCount: 'infinite'
    }
  });
  var _default = ProgressBar;
},526,[42,43,9,55,110],"node_modules/react-native-web/dist/exports/ProgressBar/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[3], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[4], "../View");
  var View = _interopDefault(_View);
  var _modulesCanUseDom = require(_dependencyMap[5], "../../modules/canUseDom");
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  var _excluded = ["style"];
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var cssFunction = function () {
    if (canUseDOM.default && window.CSS && window.CSS.supports && window.CSS.supports('top: constant(safe-area-inset-top)')) {
      return 'constant';
    }
    return 'env';
  }();
  var SafeAreaView = /*#__PURE__*/React.forwardRef((props, ref) => {
    var style = props.style,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, {
      ref: ref,
      style: [styles.root, style]
    }));
  });
  SafeAreaView.displayName = 'SafeAreaView';
  var styles = StyleSheet.default.create({
    root: {
      paddingTop: cssFunction + "(safe-area-inset-top)",
      paddingRight: cssFunction + "(safe-area-inset-right)",
      paddingBottom: cssFunction + "(safe-area-inset-bottom)",
      paddingLeft: cssFunction + "(safe-area-inset-left)"
    }
  });
  var _default = SafeAreaView;
},527,[42,43,9,55,110,45],"node_modules/react-native-web/dist/exports/SafeAreaView/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersExtends = require(_dependencyMap[1], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[2], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[3], "react");
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[4], "../createElement");
  var createElement = _interopDefault(_createElement);
  var _modulesMultiplyStyleLengthValue = require(_dependencyMap[5], "../../modules/multiplyStyleLengthValue");
  var multiplyStyleLengthValue = _interopDefault(_modulesMultiplyStyleLengthValue);
  var _StyleSheet = require(_dependencyMap[6], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[7], "../View");
  var View = _interopDefault(_View);
  var _excluded = ["aria-label", "accessibilityLabel", "activeThumbColor", "activeTrackColor", "disabled", "onValueChange", "style", "thumbColor", "trackColor", "value"];
  var emptyObject = {};
  var thumbDefaultBoxShadow = '0px 1px 3px rgba(0,0,0,0.5)';
  var thumbFocusedBoxShadow = thumbDefaultBoxShadow + ", 0 0 0 10px rgba(0,0,0,0.1)";
  var defaultActiveTrackColor = '#A3D3CF';
  var defaultTrackColor = '#939393';
  var defaultDisabledTrackColor = '#D5D5D5';
  var defaultActiveThumbColor = '#009688';
  var defaultThumbColor = '#FAFAFA';
  var defaultDisabledThumbColor = '#BDBDBD';
  var Switch = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var ariaLabel = props['aria-label'],
      accessibilityLabel = props.accessibilityLabel,
      activeThumbColor = props.activeThumbColor,
      activeTrackColor = props.activeTrackColor,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      onValueChange = props.onValueChange,
      _props$style = props.style,
      style = _props$style === void 0 ? emptyObject : _props$style,
      thumbColor = props.thumbColor,
      trackColor = props.trackColor,
      _props$value = props.value,
      value = _props$value === void 0 ? false : _props$value,
      other = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var thumbRef = React.useRef(null);
    function handleChange(event) {
      if (onValueChange != null) {
        onValueChange(event.nativeEvent.target.checked);
      }
    }
    function handleFocusState(event) {
      var isFocused = event.nativeEvent.type === 'focus';
      var boxShadow = isFocused ? thumbFocusedBoxShadow : thumbDefaultBoxShadow;
      if (thumbRef.current != null) {
        thumbRef.current.style.boxShadow = boxShadow;
      }
    }
    var _StyleSheet$flatten = StyleSheet.default.flatten(style),
      styleHeight = _StyleSheet$flatten.height,
      styleWidth = _StyleSheet$flatten.width;
    var height = styleHeight || '20px';
    var minWidth = (0, multiplyStyleLengthValue.default)(height, 2);
    var width = styleWidth > minWidth ? styleWidth : minWidth;
    var trackBorderRadius = (0, multiplyStyleLengthValue.default)(height, 0.5);
    var trackCurrentColor = function () {
      if (value === true) {
        if (trackColor != null && typeof trackColor === 'object') {
          return trackColor.true;
        } else {
          return activeTrackColor !== null && activeTrackColor !== void 0 ? activeTrackColor : defaultActiveTrackColor;
        }
      } else {
        if (trackColor != null && typeof trackColor === 'object') {
          return trackColor.false;
        } else {
          return trackColor !== null && trackColor !== void 0 ? trackColor : defaultTrackColor;
        }
      }
    }();
    var thumbCurrentColor = value ? activeThumbColor !== null && activeThumbColor !== void 0 ? activeThumbColor : defaultActiveThumbColor : thumbColor !== null && thumbColor !== void 0 ? thumbColor : defaultThumbColor;
    var thumbHeight = height;
    var thumbWidth = thumbHeight;
    var rootStyle = [styles.root, style, disabled && styles.cursorDefault, {
      height,
      width
    }];
    var disabledTrackColor = function () {
      if (value === true) {
        if (typeof activeTrackColor === 'string' && activeTrackColor != null || typeof trackColor === 'object' && trackColor != null && trackColor.true) {
          return trackCurrentColor;
        } else {
          return defaultDisabledTrackColor;
        }
      } else {
        if (typeof trackColor === 'string' && trackColor != null || typeof trackColor === 'object' && trackColor != null && trackColor.false) {
          return trackCurrentColor;
        } else {
          return defaultDisabledTrackColor;
        }
      }
    }();
    var disabledThumbColor = function () {
      if (value === true) {
        if (activeThumbColor == null) {
          return defaultDisabledThumbColor;
        } else {
          return thumbCurrentColor;
        }
      } else {
        if (thumbColor == null) {
          return defaultDisabledThumbColor;
        } else {
          return thumbCurrentColor;
        }
      }
    }();
    var trackStyle = [styles.track, {
      backgroundColor: disabled ? disabledTrackColor : trackCurrentColor,
      borderRadius: trackBorderRadius
    }];
    var thumbStyle = [styles.thumb, value && styles.thumbActive, {
      backgroundColor: disabled ? disabledThumbColor : thumbCurrentColor,
      height: thumbHeight,
      marginStart: value ? (0, multiplyStyleLengthValue.default)(thumbWidth, -1) : 0,
      width: thumbWidth
    }];
    var nativeControl = (0, createElement.default)('input', {
      'aria-label': ariaLabel || accessibilityLabel,
      checked: value,
      disabled: disabled,
      onBlur: handleFocusState,
      onChange: handleChange,
      onFocus: handleFocusState,
      ref: forwardedRef,
      style: [styles.nativeControl, styles.cursorInherit],
      type: 'checkbox',
      role: 'switch'
    });
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, other, {
      style: rootStyle
    }), /*#__PURE__*/React.createElement(View.default, {
      style: trackStyle
    }), /*#__PURE__*/React.createElement(View.default, {
      ref: thumbRef,
      style: thumbStyle
    }), nativeControl);
  });
  Switch.displayName = 'Switch';
  var styles = StyleSheet.default.create({
    root: {
      cursor: 'pointer',
      userSelect: 'none'
    },
    cursorDefault: {
      cursor: 'default'
    },
    cursorInherit: {
      cursor: 'inherit'
    },
    track: (0, _objectSpread.default)((0, _objectSpread.default)({
      forcedColorAdjust: 'none'
    }, StyleSheet.default.absoluteFillObject), {}, {
      height: '70%',
      margin: 'auto',
      transitionDuration: '0.1s',
      width: '100%'
    }),
    thumb: {
      forcedColorAdjust: 'none',
      alignSelf: 'flex-start',
      borderRadius: '100%',
      boxShadow: thumbDefaultBoxShadow,
      start: '0%',
      transform: 'translateZ(0)',
      transitionDuration: '0.1s'
    },
    thumbActive: {
      insetInlineStart: '100%'
    },
    nativeControl: (0, _objectSpread.default)((0, _objectSpread.default)({}, StyleSheet.default.absoluteFillObject), {}, {
      height: '100%',
      margin: 0,
      appearance: 'none',
      padding: 0,
      width: '100%'
    })
  });
  var _default = Switch;
},528,[37,42,43,9,111,529,55,110],"node_modules/react-native-web/dist/exports/Switch/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var CSS_UNIT_RE = /^[+-]?\d*(?:\.\d+)?(?:[Ee][+-]?\d+)?(%|\w*)/;
  var getUnit = str => str.match(CSS_UNIT_RE)[1];
  var isNumeric = n => {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };
  var multiplyStyleLengthValue = (value, multiple) => {
    if (typeof value === 'string') {
      var number = parseFloat(value) * multiple;
      var unit = getUnit(value);
      return "" + number + unit;
    } else if (isNumeric(value)) {
      return value * multiple;
    }
  };
  var _default = multiplyStyleLengthValue;
},529,[],"node_modules/react-native-web/dist/modules/multiplyStyleLengthValue/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[1], "@babel/runtime/helpers/objectSpread2");
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _modulesAccessibilityUtil = require(_dependencyMap[2], "../../modules/AccessibilityUtil");
  var AccessibilityUtil = _interopDefault(_modulesAccessibilityUtil);
  var _BoundingDimensions = require(_dependencyMap[3], "./BoundingDimensions");
  var BoundingDimensions = _interopDefault(_BoundingDimensions);
  var _reactNativeNormalizeColors = require(_dependencyMap[4], "@react-native/normalize-colors");
  var normalizeColor = _interopDefault(_reactNativeNormalizeColors);
  var _Position = require(_dependencyMap[5], "./Position");
  var Position = _interopDefault(_Position);
  var _react = require(_dependencyMap[6], "react");
  var React = _interopDefault(_react);
  var _UIManager = require(_dependencyMap[7], "../UIManager");
  var UIManager = _interopDefault(_UIManager);
  var _View = require(_dependencyMap[8], "../View");
  var View = _interopDefault(_View);
  var _modulesWarnOnce = require(_dependencyMap[9], "../../modules/warnOnce");
  var extractSingleTouch = nativeEvent => {
    var touches = nativeEvent.touches;
    var changedTouches = nativeEvent.changedTouches;
    var hasTouches = touches && touches.length > 0;
    var hasChangedTouches = changedTouches && changedTouches.length > 0;
    return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;
  };

  /**
   * `Touchable`: Taps done right.
   *
   * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`
   * will measure time/geometry and tells you when to give feedback to the user.
   *
   * ====================== Touchable Tutorial ===============================
   * The `Touchable` mixin helps you handle the "press" interaction. It analyzes
   * the geometry of elements, and observes when another responder (scroll view
   * etc) has stolen the touch lock. It notifies your component when it should
   * give feedback to the user. (bouncing/highlighting/unhighlighting).
   *
   * - When a touch was activated (typically you highlight)
   * - When a touch was deactivated (typically you unhighlight)
   * - When a touch was "pressed" - a touch ended while still within the geometry
   *   of the element, and no other element (like scroller) has "stolen" touch
   *   lock ("responder") (Typically you bounce the element).
   *
   * A good tap interaction isn't as simple as you might think. There should be a
   * slight delay before showing a highlight when starting a touch. If a
   * subsequent touch move exceeds the boundary of the element, it should
   * unhighlight, but if that same touch is brought back within the boundary, it
   * should rehighlight again. A touch can move in and out of that boundary
   * several times, each time toggling highlighting, but a "press" is only
   * triggered if that touch ends while within the element's boundary and no
   * scroller (or anything else) has stolen the lock on touches.
   *
   * To create a new type of component that handles interaction using the
   * `Touchable` mixin, do the following:
   *
   * - Initialize the `Touchable` state.
   *
   *   getInitialState: function() {
   *     return merge(this.touchableGetInitialState(), yourComponentState);
   *   }
   *
   * - Add a method to get your touchable component's node.
   *   getTouchableNode: function() {
   *     return this.touchableRef.current
   *   }
   *
   * - Choose the rendered component who's touches should start the interactive
   *   sequence. On that rendered node, forward all `Touchable` responder
   *   handlers. You can choose any rendered node you like. Choose a node whose
   *   hit target you'd like to instigate the interaction sequence:
   *
   *   // In render function:
   *   return (
   *     <View
   *       ref={this.touchableRef}
   *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}
   *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}
   *       onResponderGrant={this.touchableHandleResponderGrant}
   *       onResponderMove={this.touchableHandleResponderMove}
   *       onResponderRelease={this.touchableHandleResponderRelease}
   *       onResponderTerminate={this.touchableHandleResponderTerminate}>
   *       <View>
   *         Even though the hit detection/interactions are triggered by the
   *         wrapping (typically larger) node, we usually end up implementing
   *         custom logic that highlights this inner one.
   *       </View>
   *     </View>
   *   );
   *
   * - You may set up your own handlers for each of these events, so long as you
   *   also invoke the `touchable*` handlers inside of your custom handler.
   *
   * - Implement the handlers on your component class in order to provide
   *   feedback to the user. See documentation for each of these class methods
   *   that you should implement.
   *
   *   touchableHandlePress: function() {
   *      this.performBounceAnimation();  // or whatever you want to do.
   *   },
   *   touchableHandleActivePressIn: function() {
   *     this.beginHighlighting(...);  // Whatever you like to convey activation
   *   },
   *   touchableHandleActivePressOut: function() {
   *     this.endHighlighting(...);  // Whatever you like to convey deactivation
   *   },
   *
   * - There are more advanced methods you can implement (see documentation below):
   *   touchableGetHighlightDelayMS: function() {
   *     return 20;
   *   }
   *   // In practice, *always* use a predeclared constant (conserve memory).
   *   touchableGetPressRectOffset: function() {
   *     return {top: 20, left: 20, right: 20, bottom: 100};
   *   }
   */

  /**
   * Touchable states.
   */

  var States = {
    NOT_RESPONDER: 'NOT_RESPONDER',
    // Not the responder
    RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN',
    // Responder, inactive, in the `PressRect`
    RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT',
    // Responder, inactive, out of `PressRect`
    RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN',
    // Responder, active, in the `PressRect`
    RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT',
    // Responder, active, out of `PressRect`
    RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN',
    // Responder, active, in the `PressRect`, after long press threshold
    RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',
    // Responder, active, out of `PressRect`, after long press threshold
    ERROR: 'ERROR'
  };
  /*
   * Quick lookup map for states that are considered to be "active"
   */

  var baseStatesConditions = {
    NOT_RESPONDER: false,
    RESPONDER_INACTIVE_PRESS_IN: false,
    RESPONDER_INACTIVE_PRESS_OUT: false,
    RESPONDER_ACTIVE_PRESS_IN: false,
    RESPONDER_ACTIVE_PRESS_OUT: false,
    RESPONDER_ACTIVE_LONG_PRESS_IN: false,
    RESPONDER_ACTIVE_LONG_PRESS_OUT: false,
    ERROR: false
  };
  var IsActive = (0, _objectSpread.default)((0, _objectSpread.default)({}, baseStatesConditions), {}, {
    RESPONDER_ACTIVE_PRESS_OUT: true,
    RESPONDER_ACTIVE_PRESS_IN: true
  });

  /**
   * Quick lookup for states that are considered to be "pressing" and are
   * therefore eligible to result in a "selection" if the press stops.
   */
  var IsPressingIn = (0, _objectSpread.default)((0, _objectSpread.default)({}, baseStatesConditions), {}, {
    RESPONDER_INACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  });
  var IsLongPressingIn = (0, _objectSpread.default)((0, _objectSpread.default)({}, baseStatesConditions), {}, {
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  });

  /**
   * Inputs to the state machine.
   */
  var Signals = {
    DELAY: 'DELAY',
    RESPONDER_GRANT: 'RESPONDER_GRANT',
    RESPONDER_RELEASE: 'RESPONDER_RELEASE',
    RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',
    ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',
    LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',
    LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'
  };
  /**
   * Mapping from States x Signals => States
   */
  var Transitions = {
    NOT_RESPONDER: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.ERROR,
      RESPONDER_TERMINATED: States.ERROR,
      ENTER_PRESS_RECT: States.ERROR,
      LEAVE_PRESS_RECT: States.ERROR,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_IN: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_IN,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_OUT: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_LONG_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_LONG_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    error: {
      DELAY: States.NOT_RESPONDER,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.NOT_RESPONDER,
      LEAVE_PRESS_RECT: States.NOT_RESPONDER,
      LONG_PRESS_DETECTED: States.NOT_RESPONDER
    }
  };

  // ==== Typical Constants for integrating into UI components ====
  // var HIT_EXPAND_PX = 20;
  // var HIT_VERT_OFFSET_PX = 10;
  var HIGHLIGHT_DELAY_MS = 130;
  var PRESS_EXPAND_PX = 20;
  var LONG_PRESS_THRESHOLD = 500;
  var LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;
  var LONG_PRESS_ALLOWED_MOVEMENT = 10;

  // Default amount "active" region protrudes beyond box

  /**
   * By convention, methods prefixed with underscores are meant to be @private,
   * and not @protected. Mixers shouldn't access them - not even to provide them
   * as callback handlers.
   *
   *
   * ========== Geometry =========
   * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`
   * is an abstract box that is extended beyond the `HitRect`.
   *
   *  +--------------------------+
   *  |                          | - "Start" events in `HitRect` cause `HitRect`
   *  |  +--------------------+  |   to become the responder.
   *  |  |  +--------------+  |  | - `HitRect` is typically expanded around
   *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.
   *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,
   *  |  |  |              |  |  |   and before letting up, the Visual React
   *  |  |  +--------------+  |  |   will become "active". This makes it eligible
   *  |  |     HitRect        |  |   for being highlighted (so long as the
   *  |  +--------------------+  |   press remains in the `PressRect`).
   *  |        PressRect     o   |
   *  +----------------------|---+
   *           Out Region    |
   *                         +-----+ This gap between the `HitRect` and
   *                                 `PressRect` allows a touch to move far away
   *                                 from the original hit rect, and remain
   *                                 highlighted, and eligible for a "Press".
   *                                 Customize this via
   *                                 `touchableGetPressRectOffset()`.
   *
   *
   *
   * ======= State Machine =======
   *
   * +-------------+ <---+ RESPONDER_RELEASE
   * |NOT_RESPONDER|
   * +-------------+ <---+ RESPONDER_TERMINATED
   *     +
   *     | RESPONDER_GRANT (HitRect)
   *     v
   * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+
   * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|
   * +---------------------------+          +-------------------------+                +------------------------------+
   *     +            ^                         +           ^                                 +           ^
   *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_
   *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT
   *     |            |                         |           |                                 |           |
   *     v            +                         v           +                                 v           +
   * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+
   * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|
   * +----------------------------+         +--------------------------+               +-------------------------------+
   *
   * T + DELAY => LONG_PRESS_DELAY_MS + DELAY
   *
   * Not drawn are the side effects of each transition. The most important side
   * effect is the `touchableHandlePress` abstract method invocation that occurs
   * when a responder is released while in either of the "Press" states.
   *
   * The other important side effects are the highlight abstract method
   * invocations (internal callbacks) to be implemented by the mixer.
   *
   *
   * @lends Touchable.prototype
   */
  var TouchableMixin = {
    // HACK (part 1): basic support for touchable interactions using a keyboard
    componentDidMount: function componentDidMount() {
      (0, _modulesWarnOnce.warnOnce)('TouchableMixin', 'TouchableMixin is deprecated. Please use Pressable.');
      var touchableNode = this.getTouchableNode && this.getTouchableNode();
      if (touchableNode && touchableNode.addEventListener) {
        this._touchableBlurListener = e => {
          if (this._isTouchableKeyboardActive) {
            if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {
              this.touchableHandleResponderTerminate({
                nativeEvent: e
              });
            }
            this._isTouchableKeyboardActive = false;
          }
        };
        touchableNode.addEventListener('blur', this._touchableBlurListener);
      }
    },
    /**
     * Clear all timeouts on unmount
     */
    componentWillUnmount: function componentWillUnmount() {
      var touchableNode = this.getTouchableNode && this.getTouchableNode();
      if (touchableNode && touchableNode.addEventListener) {
        touchableNode.removeEventListener('blur', this._touchableBlurListener);
      }
      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
      // Clear DOM nodes
      this.pressInLocation = null;
      this.state.touchable.responderID = null;
    },
    /**
     * It's prefer that mixins determine state in this way, having the class
     * explicitly mix the state in the one and only `getInitialState` method.
     *
     * @return {object} State object to be placed inside of
     * `this.state.touchable`.
     */
    touchableGetInitialState: function touchableGetInitialState() {
      return {
        touchable: {
          touchState: undefined,
          responderID: null
        }
      };
    },
    // ==== Hooks to Gesture Responder system ====
    /**
     * Must return true if embedded in a native platform scroll view.
     */
    touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {
      return !this.props.rejectResponderTermination;
    },
    /**
     * Must return true to start the process of `Touchable`.
     */
    touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {
      return !this.props.disabled;
    },
    /**
     * Return true to cancel press on long press.
     */
    touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {
      return true;
    },
    /**
     * Place as callback for a DOM element's `onResponderGrant` event.
     * @param {SyntheticEvent} e Synthetic event from event system.
     *
     */
    touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {
      var dispatchID = e.currentTarget;
      // Since e is used in a callback invoked on another event loop
      // (as in setTimeout etc), we need to call e.persist() on the
      // event to make sure it doesn't get reused in the event object pool.
      e.persist();
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
      this.pressOutDelayTimeout = null;
      this.state.touchable.touchState = States.NOT_RESPONDER;
      this.state.touchable.responderID = dispatchID;
      this._receiveSignal(Signals.RESPONDER_GRANT, e);
      var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;
      delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;
      if (delayMS !== 0) {
        this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);
      } else {
        this._handleDelay(e);
      }
      var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;
      longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;
      this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);
    },
    /**
     * Place as callback for a DOM element's `onResponderRelease` event.
     */
    touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {
      this.pressInLocation = null;
      this._receiveSignal(Signals.RESPONDER_RELEASE, e);
    },
    /**
     * Place as callback for a DOM element's `onResponderTerminate` event.
     */
    touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {
      this.pressInLocation = null;
      this._receiveSignal(Signals.RESPONDER_TERMINATED, e);
    },
    /**
     * Place as callback for a DOM element's `onResponderMove` event.
     */
    touchableHandleResponderMove: function touchableHandleResponderMove(e) {
      // Measurement may not have returned yet.
      if (!this.state.touchable.positionOnActivate) {
        return;
      }
      var positionOnActivate = this.state.touchable.positionOnActivate;
      var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;
      var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {
        left: PRESS_EXPAND_PX,
        right: PRESS_EXPAND_PX,
        top: PRESS_EXPAND_PX,
        bottom: PRESS_EXPAND_PX
      };
      var pressExpandLeft = pressRectOffset.left;
      var pressExpandTop = pressRectOffset.top;
      var pressExpandRight = pressRectOffset.right;
      var pressExpandBottom = pressRectOffset.bottom;
      var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;
      if (hitSlop) {
        pressExpandLeft += hitSlop.left || 0;
        pressExpandTop += hitSlop.top || 0;
        pressExpandRight += hitSlop.right || 0;
        pressExpandBottom += hitSlop.bottom || 0;
      }
      var touch = extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;
      if (this.pressInLocation) {
        var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);
        if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {
          this._cancelLongPressDelayTimeout();
        }
      }
      var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;
      if (isTouchWithinActive) {
        var prevState = this.state.touchable.touchState;
        this._receiveSignal(Signals.ENTER_PRESS_RECT, e);
        var curState = this.state.touchable.touchState;
        if (curState === States.RESPONDER_INACTIVE_PRESS_IN && prevState !== States.RESPONDER_INACTIVE_PRESS_IN) {
          // fix for t7967420
          this._cancelLongPressDelayTimeout();
        }
      } else {
        this._cancelLongPressDelayTimeout();
        this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);
      }
    },
    /**
     * Invoked when the item receives focus. Mixers might override this to
     * visually distinguish the `VisualRect` so that the user knows that it
     * currently has the focus. Most platforms only support a single element being
     * focused at a time, in which case there may have been a previously focused
     * element that was blurred just prior to this. This can be overridden when
     * using `Touchable.Mixin.withoutDefaultFocusAndBlur`.
     */
    touchableHandleFocus: function touchableHandleFocus(e) {
      this.props.onFocus && this.props.onFocus(e);
    },
    /**
     * Invoked when the item loses focus. Mixers might override this to
     * visually distinguish the `VisualRect` so that the user knows that it
     * no longer has focus. Most platforms only support a single element being
     * focused at a time, in which case the focus may have moved to another.
     * This can be overridden when using
     * `Touchable.Mixin.withoutDefaultFocusAndBlur`.
     */
    touchableHandleBlur: function touchableHandleBlur(e) {
      this.props.onBlur && this.props.onBlur(e);
    },
    // ==== Abstract Application Callbacks ====

    /**
     * Invoked when the item should be highlighted. Mixers should implement this
     * to visually distinguish the `VisualRect` so that the user knows that
     * releasing a touch will result in a "selection" (analog to click).
     *
     * @abstract
     * touchableHandleActivePressIn: function,
     */

    /**
     * Invoked when the item is "active" (in that it is still eligible to become
     * a "select") but the touch has left the `PressRect`. Usually the mixer will
     * want to unhighlight the `VisualRect`. If the user (while pressing) moves
     * back into the `PressRect` `touchableHandleActivePressIn` will be invoked
     * again and the mixer should probably highlight the `VisualRect` again. This
     * event will not fire on an `touchEnd/mouseUp` event, only move events while
     * the user is depressing the mouse/touch.
     *
     * @abstract
     * touchableHandleActivePressOut: function
     */

    /**
     * Invoked when the item is "selected" - meaning the interaction ended by
     * letting up while the item was either in the state
     * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.
     *
     * @abstract
     * touchableHandlePress: function
     */

    /**
     * Invoked when the item is long pressed - meaning the interaction ended by
     * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If
     * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will
     * be called as it normally is. If `touchableHandleLongPress` is provided, by
     * default any `touchableHandlePress` callback will not be invoked. To
     * override this default behavior, override `touchableLongPressCancelsPress`
     * to return false. As a result, `touchableHandlePress` will be called when
     * lifting up, even if `touchableHandleLongPress` has also been called.
     *
     * @abstract
     * touchableHandleLongPress: function
     */

    /**
     * Returns the number of millis to wait before triggering a highlight.
     *
     * @abstract
     * touchableGetHighlightDelayMS: function
     */

    /**
     * Returns the amount to extend the `HitRect` into the `PressRect`. Positive
     * numbers mean the size expands outwards.
     *
     * @abstract
     * touchableGetPressRectOffset: function
     */

    // ==== Internal Logic ====

    /**
     * Measures the `HitRect` node on activation. The Bounding rectangle is with
     * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`
     * should result in points that are in the same coordinate system as an
     * event's `globalX/globalY` data values.
     *
     * - Consider caching this for the lifetime of the component, or possibly
     *   being able to share this cache between any `ScrollMap` view.
     *
     * @sideeffects
     * @private
     */
    _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {
      var tag = this.state.touchable.responderID;
      if (tag == null) {
        return;
      }
      UIManager.default.measure(tag, this._handleQueryLayout);
    },
    _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {
      //don't do anything UIManager failed to measure node
      if (!l && !t && !w && !h && !globalX && !globalY) {
        return;
      }
      this.state.touchable.positionOnActivate && Position.default.release(this.state.touchable.positionOnActivate);
      this.state.touchable.dimensionsOnActivate &&
      // $FlowFixMe
      BoundingDimensions.default.release(this.state.touchable.dimensionsOnActivate);
      this.state.touchable.positionOnActivate = Position.default.getPooled(globalX, globalY);
      // $FlowFixMe
      this.state.touchable.dimensionsOnActivate = BoundingDimensions.default.getPooled(w, h);
    },
    _handleDelay: function _handleDelay(e) {
      this.touchableDelayTimeout = null;
      this._receiveSignal(Signals.DELAY, e);
    },
    _handleLongDelay: function _handleLongDelay(e) {
      this.longPressDelayTimeout = null;
      var curState = this.state.touchable.touchState;
      if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {
        console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');
      } else {
        this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);
      }
    },
    /**
     * Receives a state machine signal, performs side effects of the transition
     * and stores the new state. Validates the transition as well.
     *
     * @param {Signals} signal State machine signal.
     * @throws Error if invalid state transition or unrecognized signal.
     * @sideeffects
     */
    _receiveSignal: function _receiveSignal(signal, e) {
      var responderID = this.state.touchable.responderID;
      var curState = this.state.touchable.touchState;
      var nextState = Transitions[curState] && Transitions[curState][signal];
      if (!responderID && signal === Signals.RESPONDER_RELEASE) {
        return;
      }
      if (!nextState) {
        throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');
      }
      if (nextState === States.ERROR) {
        throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');
      }
      if (curState !== nextState) {
        this._performSideEffectsForTransition(curState, nextState, signal, e);
        this.state.touchable.touchState = nextState;
      }
    },
    _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.longPressDelayTimeout = null;
    },
    _isHighlight: function _isHighlight(state) {
      return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;
    },
    _savePressInLocation: function _savePressInLocation(e) {
      var touch = extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;
      var locationX = touch && touch.locationX;
      var locationY = touch && touch.locationY;
      this.pressInLocation = {
        pageX,
        pageY,
        locationX,
        locationY
      };
    },
    _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {
      var deltaX = aX - bX;
      var deltaY = aY - bY;
      return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    },
    /**
     * Will perform a transition between touchable states, and identify any
     * highlighting or unhighlighting that must be performed for this particular
     * transition.
     *
     * @param {States} curState Current Touchable state.
     * @param {States} nextState Next Touchable state.
     * @param {Signal} signal Signal that triggered the transition.
     * @param {Event} e Native event.
     * @sideeffects
     */
    _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {
      var curIsHighlight = this._isHighlight(curState);
      var newIsHighlight = this._isHighlight(nextState);
      var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;
      if (isFinalSignal) {
        this._cancelLongPressDelayTimeout();
      }
      var isInitialTransition = curState === States.NOT_RESPONDER && nextState === States.RESPONDER_INACTIVE_PRESS_IN;
      var isActiveTransition = !IsActive[curState] && IsActive[nextState];
      if (isInitialTransition || isActiveTransition) {
        this._remeasureMetricsOnActivation();
      }
      if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {
        this.touchableHandleLongPress && this.touchableHandleLongPress(e);
      }
      if (newIsHighlight && !curIsHighlight) {
        this._startHighlight(e);
      } else if (!newIsHighlight && curIsHighlight) {
        this._endHighlight(e);
      }
      if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {
        var hasLongPressHandler = !!this.props.onLongPress;
        var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && (
        // We *are* long pressing.. // But either has no long handler
        !hasLongPressHandler || !this.touchableLongPressCancelsPress()); // or we're told to ignore it.

        var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;
        if (shouldInvokePress && this.touchableHandlePress) {
          if (!newIsHighlight && !curIsHighlight) {
            // we never highlighted because of delay, but we should highlight now
            this._startHighlight(e);
            this._endHighlight(e);
          }
          this.touchableHandlePress(e);
        }
      }
      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.touchableDelayTimeout = null;
    },
    _playTouchSound: function _playTouchSound() {
      UIManager.default.playTouchSound();
    },
    _startHighlight: function _startHighlight(e) {
      this._savePressInLocation(e);
      this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);
    },
    _endHighlight: function _endHighlight(e) {
      if (this.touchableHandleActivePressOut) {
        if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {
          this.pressOutDelayTimeout = setTimeout(() => {
            this.touchableHandleActivePressOut(e);
          }, this.touchableGetPressOutDelayMS());
        } else {
          this.touchableHandleActivePressOut(e);
        }
      }
    },
    // HACK (part 2): basic support for touchable interactions using a keyboard (including
    // delays and longPress)
    touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {
      var type = e.type,
        key = e.key;
      if (key === 'Enter' || key === ' ') {
        if (type === 'keydown') {
          if (!this._isTouchableKeyboardActive) {
            if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {
              this.touchableHandleResponderGrant(e);
              this._isTouchableKeyboardActive = true;
            }
          }
        } else if (type === 'keyup') {
          if (this._isTouchableKeyboardActive) {
            if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {
              this.touchableHandleResponderRelease(e);
              this._isTouchableKeyboardActive = false;
            }
          }
        }
        e.stopPropagation();
        // prevent the default behaviour unless the Touchable functions as a link
        // and Enter is pressed
        if (!(key === 'Enter' && AccessibilityUtil.default.propsToAriaRole(this.props) === 'link')) {
          e.preventDefault();
        }
      }
    },
    withoutDefaultFocusAndBlur: {}
  };

  /**
   * Provide an optional version of the mixin where `touchableHandleFocus` and
   * `touchableHandleBlur` can be overridden. This allows appropriate defaults to
   * be set on TV platforms, without breaking existing implementations of
   * `Touchable`.
   */
  var touchableHandleFocus = TouchableMixin.touchableHandleFocus,
    touchableHandleBlur = TouchableMixin.touchableHandleBlur,
    TouchableMixinWithoutDefaultFocusAndBlur = (0, _objectWithoutPropertiesLoose.default)(TouchableMixin, ["touchableHandleFocus", "touchableHandleBlur"]);
  TouchableMixin.withoutDefaultFocusAndBlur = TouchableMixinWithoutDefaultFocusAndBlur;
  var Touchable = {
    Mixin: TouchableMixin,
    TOUCH_TARGET_DEBUG: false,
    // Highlights all touchable targets. Toggle with Inspector.
    /**
     * Renders a debugging overlay to visualize touch target with hitSlop (might not work on Android).
     */
    renderDebugView: _ref => {
      var color = _ref.color,
        hitSlop = _ref.hitSlop;
      if (!Touchable.TOUCH_TARGET_DEBUG) {
        return null;
      }
      if (process.env.NODE_ENV !== 'production') {
        throw Error('Touchable.TOUCH_TARGET_DEBUG should not be enabled in prod!');
      }
      var debugHitSlopStyle = {};
      hitSlop = hitSlop || {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      for (var key in hitSlop) {
        debugHitSlopStyle[key] = -hitSlop[key];
      }
      var normalizedColor = (0, normalizeColor.default)(color);
      if (typeof normalizedColor !== 'number') {
        return null;
      }
      var hexColor = '#' + ('00000000' + normalizedColor.toString(16)).substr(-8);
      return /*#__PURE__*/React.default.createElement(View.default, {
        pointerEvents: "none",
        style: (0, _objectSpread.default)({
          position: 'absolute',
          borderColor: hexColor.slice(0, -2) + '55',
          // More opaque
          borderWidth: 1,
          borderStyle: 'dashed',
          backgroundColor: hexColor.slice(0, -2) + '0F'
        }, debugHitSlopStyle)
      });
    }
  };
  var _default = Touchable;
},530,[43,37,112,531,63,533,9,48,110,102],"node_modules/react-native-web/dist/exports/Touchable/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativePooledClass = require(_dependencyMap[0], "../../vendor/react-native/PooledClass");
  var PooledClass = _interopDefault(_vendorReactNativePooledClass);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var twoArgumentPooler = PooledClass.default.twoArgumentPooler;

  /**
   * PooledClass representing the bounding rectangle of a region.
   */
  function BoundingDimensions(width, height) {
    this.width = width;
    this.height = height;
  }
  BoundingDimensions.prototype.destructor = function () {
    this.width = null;
    this.height = null;
  };
  BoundingDimensions.getPooledFromElement = function (element) {
    return BoundingDimensions.getPooled(element.offsetWidth, element.offsetHeight);
  };
  PooledClass.default.addPoolingTo(BoundingDimensions, twoArgumentPooler);
  var _default = BoundingDimensions;
},531,[532],"node_modules/react-native-web/dist/exports/Touchable/BoundingDimensions.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  require(_dependencyMap[0], "fbjs/lib/invariant");
  /* eslint-disable */

  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * From React 16.0.0
   */

  var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2);
      return instance;
    } else {
      return new Klass(a1, a2);
    }
  };
  var standardReleaser = function standardReleaser(instance) {
    var Klass = this;
    instance.destructor();
    if (Klass.instancePool.length < Klass.poolSize) {
      Klass.instancePool.push(instance);
    }
  };
  var DEFAULT_POOL_SIZE = 10;
  var DEFAULT_POOLER = twoArgumentPooler;

  /**
   * Augments `CopyConstructor` to be a poolable class, augmenting only the class
   * itself (statically) not adding any prototypical fields. Any CopyConstructor
   * you give this may have a `poolSize` property, and will look for a
   * prototypical `destructor` on instances.
   *
   * @param {Function} CopyConstructor Constructor that can be used to reset.
   * @param {Function} pooler Customizable pooler.
   */
  var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
    // Casting as any so that flow ignores the actual implementation and trusts
    // it to match the type we declared
    var NewKlass = CopyConstructor;
    NewKlass.instancePool = [];
    NewKlass.getPooled = pooler || DEFAULT_POOLER;
    if (!NewKlass.poolSize) {
      NewKlass.poolSize = DEFAULT_POOL_SIZE;
    }
    NewKlass.release = standardReleaser;
    return NewKlass;
  };
  var PooledClass = {
    addPoolingTo: addPoolingTo,
    twoArgumentPooler: twoArgumentPooler
  };
  var _default = PooledClass;
},532,[17],"node_modules/react-native-web/dist/vendor/react-native/PooledClass/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativePooledClass = require(_dependencyMap[0], "../../vendor/react-native/PooledClass");
  var PooledClass = _interopDefault(_vendorReactNativePooledClass);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var twoArgumentPooler = PooledClass.default.twoArgumentPooler;
  function Position(left, top) {
    this.left = left;
    this.top = top;
  }
  Position.prototype.destructor = function () {
    this.left = null;
    this.top = null;
  };
  PooledClass.default.addPoolingTo(Position, twoArgumentPooler);
  var _default = Position;
},533,[532],"node_modules/react-native-web/dist/exports/Touchable/Position.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _modulesUseMergeRefs = require(_dependencyMap[3], "../../modules/useMergeRefs");
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePressEvents = require(_dependencyMap[4], "../../modules/usePressEvents");
  var usePressEvents = _interopDefault(_modulesUsePressEvents);
  var _StyleSheet = require(_dependencyMap[5], "../StyleSheet");
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[6], "../View");
  var View = _interopDefault(_View);
  var _excluded = ["activeOpacity", "children", "delayPressIn", "delayPressOut", "delayLongPress", "disabled", "focusable", "onHideUnderlay", "onLongPress", "onPress", "onPressIn", "onPressOut", "onShowUnderlay", "rejectResponderTermination", "style", "testOnly_pressed", "underlayColor"];
  //import { warnOnce } from '../../modules/warnOnce';

  function createExtraStyles(activeOpacity, underlayColor) {
    return {
      child: {
        opacity: activeOpacity !== null && activeOpacity !== void 0 ? activeOpacity : 0.85
      },
      underlay: {
        backgroundColor: underlayColor === undefined ? 'black' : underlayColor
      }
    };
  }
  function hasPressHandler(props) {
    return props.onPress != null || props.onPressIn != null || props.onPressOut != null || props.onLongPress != null;
  }

  /**
   * A wrapper for making views respond properly to touches.
   * On press down, the opacity of the wrapped view is decreased, which allows
   * the underlay color to show through, darkening or tinting the view.
   *
   * The underlay comes from wrapping the child in a new View, which can affect
   * layout, and sometimes cause unwanted visual artifacts if not used correctly,
   * for example if the backgroundColor of the wrapped view isn't explicitly set
   * to an opaque color.
   *
   * TouchableHighlight must have one child (not zero or more than one).
   * If you wish to have several child components, wrap them in a View.
   */
  function TouchableHighlight(props, forwardedRef) {
    /*
    warnOnce(
      'TouchableHighlight',
      'TouchableHighlight is deprecated. Please use Pressable.'
    );
    */

    var activeOpacity = props.activeOpacity,
      children = props.children,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onHideUnderlay = props.onHideUnderlay,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      onShowUnderlay = props.onShowUnderlay,
      rejectResponderTermination = props.rejectResponderTermination,
      style = props.style,
      testOnly_pressed = props.testOnly_pressed,
      underlayColor = props.underlayColor,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var hostRef = (0, _react.useRef)(null);
    var setRef = (0, useMergeRefs.default)(forwardedRef, hostRef);
    var _useState = (0, _react.useState)(testOnly_pressed === true ? createExtraStyles(activeOpacity, underlayColor) : null),
      extraStyles = _useState[0],
      setExtraStyles = _useState[1];
    var showUnderlay = (0, _react.useCallback)(() => {
      if (!hasPressHandler(props)) {
        return;
      }
      setExtraStyles(createExtraStyles(activeOpacity, underlayColor));
      if (onShowUnderlay != null) {
        onShowUnderlay();
      }
    }, [activeOpacity, onShowUnderlay, props, underlayColor]);
    var hideUnderlay = (0, _react.useCallback)(() => {
      if (testOnly_pressed === true) {
        return;
      }
      if (hasPressHandler(props)) {
        setExtraStyles(null);
        if (onHideUnderlay != null) {
          onHideUnderlay();
        }
      }
    }, [onHideUnderlay, props, testOnly_pressed]);
    var pressConfig = (0, _react.useMemo)(() => ({
      cancelable: !rejectResponderTermination,
      disabled,
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      onLongPress,
      onPress,
      onPressStart(event) {
        showUnderlay();
        if (onPressIn != null) {
          onPressIn(event);
        }
      },
      onPressEnd(event) {
        hideUnderlay();
        if (onPressOut != null) {
          onPressOut(event);
        }
      }
    }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination, showUnderlay, hideUnderlay]);
    var pressEventHandlers = (0, usePressEvents.default)(hostRef, pressConfig);
    var child = React.Children.only(children);
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, pressEventHandlers, {
      accessibilityDisabled: disabled,
      focusable: !disabled && focusable !== false,
      pointerEvents: disabled ? 'box-none' : undefined,
      ref: setRef,
      style: [styles.root, style, !disabled && styles.actionable, extraStyles && extraStyles.underlay]
    }), /*#__PURE__*/React.cloneElement(child, {
      style: [child.props.style, extraStyles && extraStyles.child]
    }));
  }
  var styles = StyleSheet.default.create({
    root: {
      userSelect: 'none'
    },
    actionable: {
      cursor: 'pointer',
      touchAction: 'manipulation'
    }
  });
  var MemoedTouchableHighlight = /*#__PURE__*/React.memo(/*#__PURE__*/React.forwardRef(TouchableHighlight));
  MemoedTouchableHighlight.displayName = 'TouchableHighlight';
  var _default = MemoedTouchableHighlight;
},534,[42,43,9,123,148,55,110],"node_modules/react-native-web/dist/exports/TouchableHighlight/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesUnimplementedView = require(_dependencyMap[0], "../../modules/UnimplementedView");
  var UnimplementedView = _interopDefault(_modulesUnimplementedView);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _default = UnimplementedView.default;
},535,[536],"node_modules/react-native-web/dist/exports/TouchableNativeFeedback/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0], "@babel/runtime/helpers/extends");
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _exportsView = require(_dependencyMap[2], "../../exports/View");
  var View = _interopDefault(_exportsView);
  var _react = require(_dependencyMap[3], "react");
  var React = _interopDefault(_react);
  var _excluded = ["style"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Common implementation for a simple stubbed view.
   */
  function UnimplementedView(_ref) {
    var style = _ref.style,
      props = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    return /*#__PURE__*/React.default.createElement(View.default, (0, _extends.default)({}, props, {
      style: [unimplementedViewStyles, style]
    }));
  }
  var unimplementedViewStyles = process.env.NODE_ENV !== 'production' ? {
    alignSelf: 'flex-start',
    borderColor: 'red',
    borderWidth: 1
  } : {};
  var _default = UnimplementedView;
},536,[42,43,110,9],"node_modules/react-native-web/dist/modules/UnimplementedView/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _modulesPick = require(_dependencyMap[1], "../../modules/pick");
  var pick = _interopDefault(_modulesPick);
  var _modulesUseMergeRefs = require(_dependencyMap[2], "../../modules/useMergeRefs");
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePressEvents = require(_dependencyMap[3], "../../modules/usePressEvents");
  var usePressEvents = _interopDefault(_modulesUsePressEvents);
  var _modulesWarnOnce = require(_dependencyMap[4], "../../modules/warnOnce");
  var forwardPropsList = {
    accessibilityDisabled: true,
    accessibilityLabel: true,
    accessibilityLiveRegion: true,
    accessibilityRole: true,
    accessibilityState: true,
    accessibilityValue: true,
    children: true,
    disabled: true,
    focusable: true,
    nativeID: true,
    onBlur: true,
    onFocus: true,
    onLayout: true,
    testID: true
  };
  var pickProps = props => (0, pick.default)(props, forwardPropsList);
  function TouchableWithoutFeedback(props, forwardedRef) {
    (0, _modulesWarnOnce.warnOnce)('TouchableWithoutFeedback', 'TouchableWithoutFeedback is deprecated. Please use Pressable.');
    var delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      rejectResponderTermination = props.rejectResponderTermination;
    var hostRef = (0, _react.useRef)(null);
    var pressConfig = (0, _react.useMemo)(() => ({
      cancelable: !rejectResponderTermination,
      disabled,
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      onLongPress,
      onPress,
      onPressStart: onPressIn,
      onPressEnd: onPressOut
    }), [disabled, delayPressIn, delayPressOut, delayLongPress, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination]);
    var pressEventHandlers = (0, usePressEvents.default)(hostRef, pressConfig);
    var element = React.Children.only(props.children);
    var children = [element.props.children];
    var supportedProps = pickProps(props);
    supportedProps.accessibilityDisabled = disabled;
    supportedProps.focusable = !disabled && focusable !== false;
    supportedProps.ref = (0, useMergeRefs.default)(forwardedRef, hostRef, element.ref);
    var elementProps = Object.assign(supportedProps, pressEventHandlers);
    return /*#__PURE__*/React.cloneElement(element, elementProps, ...children);
  }
  var MemoedTouchableWithoutFeedback = /*#__PURE__*/React.memo(/*#__PURE__*/React.forwardRef(TouchableWithoutFeedback));
  MemoedTouchableWithoutFeedback.displayName = 'TouchableWithoutFeedback';
  var _default = MemoedTouchableWithoutFeedback;
},537,[9,120,123,148,102],"node_modules/react-native-web/dist/exports/TouchableWithoutFeedback/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeVirtualizedList = require(_dependencyMap[0], "../../vendor/react-native/VirtualizedList");
  var VirtualizedList = _interopDefault(_vendorReactNativeVirtualizedList);
  var _default = VirtualizedList.default;
},538,[172],"node_modules/react-native-web/dist/exports/VirtualizedList/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopDefault(_react);
  var _modulesUnimplementedView = require(_dependencyMap[1], "../../modules/UnimplementedView");
  var UnimplementedView = _interopDefault(_modulesUnimplementedView);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function YellowBox(props) {
    return /*#__PURE__*/React.default.createElement(UnimplementedView.default, props);
  }
  YellowBox.ignoreWarnings = () => {};
  var _default = YellowBox;
},539,[9,536],"node_modules/react-native-web/dist/exports/YellowBox/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) 2016-present, Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var LogBox = {
    ignoreLogs() {},
    ignoreAllLogs() {},
    uninstall() {},
    install() {}
  };
  var _default = LogBox;
},540,[],"node_modules/react-native-web/dist/exports/LogBox/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeEventEmitterRCTDeviceEventEmitter = require(_dependencyMap[0], "../../vendor/react-native/EventEmitter/RCTDeviceEventEmitter");
  var RCTDeviceEventEmitter = _interopDefault(_vendorReactNativeEventEmitterRCTDeviceEventEmitter);
  var _default = RCTDeviceEventEmitter.default;
},541,[15],"node_modules/react-native-web/dist/exports/DeviceEventEmitter/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useColorScheme;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  var _Appearance = require(_dependencyMap[1], "../Appearance");
  var Appearance = _interopDefault(_Appearance);
  function useColorScheme() {
    var _React$useState = React.useState(Appearance.default.getColorScheme()),
      colorScheme = _React$useState[0],
      setColorScheme = _React$useState[1];
    React.useEffect(() => {
      function listener(appearance) {
        setColorScheme(appearance.colorScheme);
      }
      var _Appearance$addChange = Appearance.default.addChangeListener(listener),
        remove = _Appearance$addChange.remove;
      return remove;
    });
    return colorScheme;
  }
},542,[9,499],"node_modules/react-native-web/dist/exports/useColorScheme/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesUseLocale = require(_dependencyMap[0], "../../modules/useLocale");
  var _default = _modulesUseLocale.useLocaleContext;
},543,[117],"node_modules/react-native-web/dist/exports/useLocaleContext/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useWindowDimensions;
    }
  });
  var _Dimensions = require(_dependencyMap[0], "../Dimensions");
  var Dimensions = _interopDefault(_Dimensions);
  var _react = require(_dependencyMap[1], "react");
  function useWindowDimensions() {
    var _useState = (0, _react.useState)(() => Dimensions.default.get('window')),
      dims = _useState[0],
      setDims = _useState[1];
    (0, _react.useEffect)(() => {
      function handleChange(_ref) {
        var window = _ref.window;
        if (window != null) {
          setDims(window);
        }
      }
      Dimensions.default.addEventListener('change', handleChange);
      // We might have missed an update between calling `get` in render and
      // `addEventListener` in this handler, so we set it here. If there was
      // no change, React will filter out this update as a no-op.
      setDims(Dimensions.default.get('window'));
      return () => {
        Dimensions.default.removeEventListener('change', handleChange);
      };
    }, []);
    return dims;
  }
},544,[44,9],"node_modules/react-native-web/dist/exports/useWindowDimensions/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/error.png",
    width: 48,
    height: 48
  };
},545,[],"node_modules/expo-router/assets/error.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\views\\SuspenseFallback.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SuspenseFallback = SuspenseFallback;
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  const Toast_1 = require(_dependencyMap[2], "./Toast");
  function SuspenseFallback({
    route
  }) {
    if (__DEV__) {
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Toast_1.ToastWrapper, {
        children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Toast_1.Toast, {
          filename: route?.contextKey,
          children: "Bundling..."
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 12,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 11,
        columnNumber: 17
      }, this);
    }
    // TODO: Support user's customizing the fallback.
    return null;
  }
},546,[33,9,393],"node_modules/expo-router/build/views/SuspenseFallback.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\views\\Try.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Try = void 0;
  const react_1 = __importStar(require(_dependencyMap[1], "react"));
  const SplashScreen = __importStar(require(_dependencyMap[2], "./Splash"));
  const errors_1 = require(_dependencyMap[3], "../rsc/router/errors");
  // No way to access `getDerivedStateFromError` from a function component afaict.
  class Try extends react_1.Component {
    state = {
      error: undefined
    };
    static getDerivedStateFromError(error) {
      // Force hide the splash screen if an error occurs.
      SplashScreen.hideAsync();
      if (__DEV__ && error instanceof errors_1.MetroServerError) {
        // Throw up to the LogBox.
        return null;
      }
      return {
        error
      };
    }
    retry = () => {
      return new Promise(resolve => {
        this.setState({
          error: undefined
        }, () => {
          resolve();
        });
      });
    };
    render() {
      const {
        error
      } = this.state;
      const {
        catch: ErrorBoundary,
        children
      } = this.props;
      if (!error) {
        return children;
      }
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(ErrorBoundary, {
        error: error,
        retry: this.retry
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 66,
        columnNumber: 16
      }, this);
    }
  }
  exports.Try = Try;
},547,[33,9,548,631],"node_modules/expo-router/build/views/Try.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = this && this.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  __exportStar(require(_dependencyMap[0], "../utils/splash"), exports);
},548,[549],"node_modules/expo-router/build/views/Splash.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.hide = hide;
  exports.hideAsync = hideAsync;
  exports.preventAutoHideAsync = preventAutoHideAsync;
  exports._internal_preventAutoHideAsync = _internal_preventAutoHideAsync;
  exports._internal_maybeHideAsync = _internal_maybeHideAsync;
  const expo_1 = require(_dependencyMap[0], "expo");
  const SplashModule = (0, expo_1.requireOptionalNativeModule)('ExpoSplashScreen');
  let _initializedErrorHandler = false;
  function hide() {
    if (!SplashModule) {
      return;
    }
    SplashModule.hide();
  }
  async function hideAsync() {
    hide();
  }
  async function preventAutoHideAsync() {
    if (!SplashModule) {
      return;
    }
    return SplashModule.preventAutoHideAsync();
  }
  async function _internal_preventAutoHideAsync() {
    // The internal function might be missing if an app is using an older version of the SplashModule
    if (!SplashModule || !SplashModule.internalPreventAutoHideAsync) {
      return false;
    }
    if (!_initializedErrorHandler) {
      // Append error handling to ensure any uncaught exceptions result in the splash screen being hidden.
      // This prevents the splash screen from floating over error screens.
      if (ErrorUtils?.getGlobalHandler) {
        const originalHandler = ErrorUtils.getGlobalHandler();
        ErrorUtils.setGlobalHandler((error, isFatal) => {
          hide();
          originalHandler(error, isFatal);
        });
      }
      _initializedErrorHandler = true;
    }
    return SplashModule.internalPreventAutoHideAsync();
  }
  async function _internal_maybeHideAsync() {
    // The internal function might be missing if an app is using an older version of the SplashModule
    if (!SplashModule || !SplashModule.internalMaybeHideAsync) {
      return false;
    }
    return SplashModule.internalMaybeHideAsync();
  }
},549,[550],"node_modules/expo-router/build/utils/splash.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "disableErrorHandling", {
    enumerable: true,
    get: function () {
      return _errorsExpoErrorManager.disableErrorHandling;
    }
  });
  Object.defineProperty(exports, "registerRootComponent", {
    enumerable: true,
    get: function () {
      return _launchRegisterRootComponent2.default;
    }
  });
  Object.defineProperty(exports, "isRunningInExpoGo", {
    enumerable: true,
    get: function () {
      return _environmentExpoGo.isRunningInExpoGo;
    }
  });
  Object.defineProperty(exports, "getExpoGoProjectConfig", {
    enumerable: true,
    get: function () {
      return _environmentExpoGo.getExpoGoProjectConfig;
    }
  });
  Object.defineProperty(exports, "EventEmitter", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.EventEmitter;
    }
  });
  Object.defineProperty(exports, "SharedObject", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.SharedObject;
    }
  });
  Object.defineProperty(exports, "SharedRef", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.SharedRef;
    }
  });
  Object.defineProperty(exports, "NativeModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.NativeModule;
    }
  });
  Object.defineProperty(exports, "requireNativeModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.requireNativeModule;
    }
  });
  Object.defineProperty(exports, "requireOptionalNativeModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.requireOptionalNativeModule;
    }
  });
  Object.defineProperty(exports, "requireNativeView", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.requireNativeViewManager;
    }
  });
  Object.defineProperty(exports, "registerWebModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.registerWebModule;
    }
  });
  Object.defineProperty(exports, "reloadAppAsync", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.reloadAppAsync;
    }
  });
  Object.defineProperty(exports, "useEvent", {
    enumerable: true,
    get: function () {
      return _hooksUseEvent.useEvent;
    }
  });
  Object.defineProperty(exports, "useEventListener", {
    enumerable: true,
    get: function () {
      return _hooksUseEvent.useEventListener;
    }
  });
  require(_dependencyMap[0], "./Expo.fx");
  var _errorsExpoErrorManager = require(_dependencyMap[1], "./errors/ExpoErrorManager");
  var _launchRegisterRootComponent = require(_dependencyMap[2], "./launch/registerRootComponent");
  var _launchRegisterRootComponent2 = _interopDefault(_launchRegisterRootComponent);
  var _environmentExpoGo = require(_dependencyMap[3], "./environment/ExpoGo");
  var _expoModulesCore = require(_dependencyMap[4], "expo-modules-core");
  var _hooksUseEvent = require(_dependencyMap[5], "./hooks/useEvent");
},550,[551,589,590,593,594,630],"node_modules/expo/src/Expo.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0], "./winter");
  require(_dependencyMap[1], "./async-require");
  require(_dependencyMap[2], "expo/virtual/rsc");
  // When users dangerously import a file inside of react-native, it breaks the web alias.
  // This is one of the most common, and cryptic web errors that users encounter.
  // This conditional side-effect provides a more helpful error message for debugging.
  // Use a wrapper `__DEV__` to remove this entire block in production.
  if (__DEV__) {
    if (
    // Skip mocking if someone is shimming this value out.
    !('__fbBatchedBridgeConfig' in global)) {
      Object.defineProperty(global, '__fbBatchedBridgeConfig', {
        get() {
          throw new Error("Your web project is importing a module from 'react-native' instead of 'react-native-web'. Learn more: https://expo.fyi/fb-batched-bridge-config-web");
        }
      });
    }
  }
},551,[552,579,588],"node_modules/expo/src/Expo.fx.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0], "./runtime");
},552,[553],"node_modules/expo/src/winter/index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0], "../async-require/setup");
  Object.defineProperty(globalThis, '__ExpoImportMetaRegistry', {
    value: require(_dependencyMap[1], "./ImportMetaRegistry").ImportMetaRegistry,
    enumerable: false,
    writable: true
  });
},553,[554,577],"node_modules/expo/src/winter/runtime.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // Only during development.
  if (__DEV__ &&
  // Disable for SSR
  typeof window !== 'undefined') {
    require(_dependencyMap[0], "./setupFastRefresh");
    require(_dependencyMap[1], "./setupHMR");
    require(_dependencyMap[2], "./messageSocket");
  }
},554,[555,558,576],"node_modules/expo/src/async-require/setup.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // This needs to run before the renderer initializes.

  const ReactRefreshRuntime = require(_dependencyMap[0], "react-refresh/runtime");
  ReactRefreshRuntime.injectIntoGlobalHook(global);
  const Refresh = {
    performFullRefresh() {
      location.reload();
    },
    createSignatureFunctionForTransform: ReactRefreshRuntime.createSignatureFunctionForTransform,
    isLikelyComponentType: ReactRefreshRuntime.isLikelyComponentType,
    getFamilyByType: ReactRefreshRuntime.getFamilyByType,
    register: ReactRefreshRuntime.register,
    performReactRefresh() {
      if (ReactRefreshRuntime.hasUnrecoverableErrors()) {
        location.reload();
        return;
      }
      ReactRefreshRuntime.performReactRefresh();
    }
  };

  // The metro require polyfill can not have dependencies (applies for all polyfills).
  // Expose `Refresh` by assigning it to global to make it available in the polyfill.
  global[(global.__METRO_GLOBAL_PREFIX__ || '') + '__ReactRefresh'] = Refresh;
},555,[556],"node_modules/expo/src/async-require/setupFastRefresh.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react-refresh-runtime.production.min.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-refresh-runtime.development.js");
  }
},556,[10,557],"node_modules/react-refresh/runtime.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-refresh-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      // ATTENTION
      var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
      var REACT_MEMO_TYPE = Symbol.for('react.memo');
      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.
      // It's OK to reference families, but use WeakMap/Set for types.

      var allFamiliesByID = new Map();
      var allFamiliesByType = new PossiblyWeakMap();
      var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families
      // that have actually been edited here. This keeps checks fast.
      // $FlowIssue

      var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.
      // It is an array of [Family, NextType] tuples.

      var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.

      var helpersByRendererID = new Map();
      var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.

      var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.

      var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.
      // It needs to be weak because we do this even for roots that failed to mount.
      // If there is no WeakMap, we won't attempt to do retrying.
      // $FlowIssue

      var rootElements =
      // $FlowIssue
      typeof WeakMap === 'function' ? new WeakMap() : null;
      var isPerformingRefresh = false;
      function computeFullKey(signature) {
        if (signature.fullKey !== null) {
          return signature.fullKey;
        }
        var fullKey = signature.ownKey;
        var hooks;
        try {
          hooks = signature.getCustomHooks();
        } catch (err) {
          // This can happen in an edge case, e.g. if expression like Foo.useSomething
          // depends on Foo which is lazily initialized during rendering.
          // In that case just assume we'll have to remount.
          signature.forceReset = true;
          signature.fullKey = fullKey;
          return fullKey;
        }
        for (var i = 0; i < hooks.length; i++) {
          var hook = hooks[i];
          if (typeof hook !== 'function') {
            // Something's wrong. Assume we need to remount.
            signature.forceReset = true;
            signature.fullKey = fullKey;
            return fullKey;
          }
          var nestedHookSignature = allSignaturesByType.get(hook);
          if (nestedHookSignature === undefined) {
            // No signature means Hook wasn't in the source code, e.g. in a library.
            // We'll skip it because we can assume it won't change during this session.
            continue;
          }
          var nestedHookKey = computeFullKey(nestedHookSignature);
          if (nestedHookSignature.forceReset) {
            signature.forceReset = true;
          }
          fullKey += '\n---\n' + nestedHookKey;
        }
        signature.fullKey = fullKey;
        return fullKey;
      }
      function haveEqualSignatures(prevType, nextType) {
        var prevSignature = allSignaturesByType.get(prevType);
        var nextSignature = allSignaturesByType.get(nextType);
        if (prevSignature === undefined && nextSignature === undefined) {
          return true;
        }
        if (prevSignature === undefined || nextSignature === undefined) {
          return false;
        }
        if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {
          return false;
        }
        if (nextSignature.forceReset) {
          return false;
        }
        return true;
      }
      function isReactClass(type) {
        return type.prototype && type.prototype.isReactComponent;
      }
      function canPreserveStateBetween(prevType, nextType) {
        if (isReactClass(prevType) || isReactClass(nextType)) {
          return false;
        }
        if (haveEqualSignatures(prevType, nextType)) {
          return true;
        }
        return false;
      }
      function resolveFamily(type) {
        // Only check updated types to keep lookups fast.
        return updatedFamiliesByType.get(type);
      } // If we didn't care about IE11, we could use new Map/Set(iterable).

      function cloneMap(map) {
        var clone = new Map();
        map.forEach(function (value, key) {
          clone.set(key, value);
        });
        return clone;
      }
      function cloneSet(set) {
        var clone = new Set();
        set.forEach(function (value) {
          clone.add(value);
        });
        return clone;
      } // This is a safety mechanism to protect against rogue getters and Proxies.

      function getProperty(object, property) {
        try {
          return object[property];
        } catch (err) {
          // Intentionally ignore.
          return undefined;
        }
      }
      function performReactRefresh() {
        if (pendingUpdates.length === 0) {
          return null;
        }
        if (isPerformingRefresh) {
          return null;
        }
        isPerformingRefresh = true;
        try {
          var staleFamilies = new Set();
          var updatedFamilies = new Set();
          var updates = pendingUpdates;
          pendingUpdates = [];
          updates.forEach(function (_ref) {
            var family = _ref[0],
              nextType = _ref[1];
            // Now that we got a real edit, we can create associations
            // that will be read by the React reconciler.
            var prevType = family.current;
            updatedFamiliesByType.set(prevType, family);
            updatedFamiliesByType.set(nextType, family);
            family.current = nextType; // Determine whether this should be a re-render or a re-mount.

            if (canPreserveStateBetween(prevType, nextType)) {
              updatedFamilies.add(family);
            } else {
              staleFamilies.add(family);
            }
          }); // TODO: rename these fields to something more meaningful.

          var update = {
            updatedFamilies: updatedFamilies,
            // Families that will re-render preserving state
            staleFamilies: staleFamilies // Families that will be remounted
          };
          helpersByRendererID.forEach(function (helpers) {
            // Even if there are no roots, set the handler on first update.
            // This ensures that if *new* roots are mounted, they'll use the resolve handler.
            helpers.setRefreshHandler(resolveFamily);
          });
          var didError = false;
          var firstError = null; // We snapshot maps and sets that are mutated during commits.
          // If we don't do this, there is a risk they will be mutated while
          // we iterate over them. For example, trying to recover a failed root
          // may cause another root to be added to the failed list -- an infinite loop.

          var failedRootsSnapshot = cloneSet(failedRoots);
          var mountedRootsSnapshot = cloneSet(mountedRoots);
          var helpersByRootSnapshot = cloneMap(helpersByRoot);
          failedRootsSnapshot.forEach(function (root) {
            var helpers = helpersByRootSnapshot.get(root);
            if (helpers === undefined) {
              throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
            }
            if (!failedRoots.has(root)) {// No longer failed.
            }
            if (rootElements === null) {
              return;
            }
            if (!rootElements.has(root)) {
              return;
            }
            var element = rootElements.get(root);
            try {
              helpers.scheduleRoot(root, element);
            } catch (err) {
              if (!didError) {
                didError = true;
                firstError = err;
              } // Keep trying other roots.
            }
          });
          mountedRootsSnapshot.forEach(function (root) {
            var helpers = helpersByRootSnapshot.get(root);
            if (helpers === undefined) {
              throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
            }
            if (!mountedRoots.has(root)) {// No longer mounted.
            }
            try {
              helpers.scheduleRefresh(root, update);
            } catch (err) {
              if (!didError) {
                didError = true;
                firstError = err;
              } // Keep trying other roots.
            }
          });
          if (didError) {
            throw firstError;
          }
          return update;
        } finally {
          isPerformingRefresh = false;
        }
      }
      function register(type, id) {
        {
          if (type === null) {
            return;
          }
          if (typeof type !== 'function' && typeof type !== 'object') {
            return;
          } // This can happen in an edge case, e.g. if we register
          // return value of a HOC but it returns a cached component.
          // Ignore anything but the first registration for each type.

          if (allFamiliesByType.has(type)) {
            return;
          } // Create family or remember to update it.
          // None of this bookkeeping affects reconciliation
          // until the first performReactRefresh() call above.

          var family = allFamiliesByID.get(id);
          if (family === undefined) {
            family = {
              current: type
            };
            allFamiliesByID.set(id, family);
          } else {
            pendingUpdates.push([family, type]);
          }
          allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.

          if (typeof type === 'object' && type !== null) {
            switch (getProperty(type, '$$typeof')) {
              case REACT_FORWARD_REF_TYPE:
                register(type.render, id + '$render');
                break;
              case REACT_MEMO_TYPE:
                register(type.type, id + '$type');
                break;
            }
          }
        }
      }
      function setSignature(type, key) {
        var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;
        {
          if (!allSignaturesByType.has(type)) {
            allSignaturesByType.set(type, {
              forceReset: forceReset,
              ownKey: key,
              fullKey: null,
              getCustomHooks: getCustomHooks || function () {
                return [];
              }
            });
          } // Visit inner types because we might not have signed them.

          if (typeof type === 'object' && type !== null) {
            switch (getProperty(type, '$$typeof')) {
              case REACT_FORWARD_REF_TYPE:
                setSignature(type.render, key, forceReset, getCustomHooks);
                break;
              case REACT_MEMO_TYPE:
                setSignature(type.type, key, forceReset, getCustomHooks);
                break;
            }
          }
        }
      } // This is lazily called during first render for a type.
      // It captures Hook list at that time so inline requires don't break comparisons.

      function collectCustomHooksForSignature(type) {
        {
          var signature = allSignaturesByType.get(type);
          if (signature !== undefined) {
            computeFullKey(signature);
          }
        }
      }
      function getFamilyByID(id) {
        {
          return allFamiliesByID.get(id);
        }
      }
      function getFamilyByType(type) {
        {
          return allFamiliesByType.get(type);
        }
      }
      function findAffectedHostInstances(families) {
        {
          var affectedInstances = new Set();
          mountedRoots.forEach(function (root) {
            var helpers = helpersByRoot.get(root);
            if (helpers === undefined) {
              throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
            }
            var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);
            instancesForRoot.forEach(function (inst) {
              affectedInstances.add(inst);
            });
          });
          return affectedInstances;
        }
      }
      function injectIntoGlobalHook(globalObject) {
        {
          // For React Native, the global hook will be set up by require('react-devtools-core').
          // That code will run before us. So we need to monkeypatch functions on existing hook.
          // For React Web, the global hook will be set up by the extension.
          // This will also run before us.
          var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook === undefined) {
            // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.
            // Note that in this case it's important that renderer code runs *after* this method call.
            // Otherwise, the renderer will think that there is no global hook, and won't do the injection.
            var nextID = 0;
            globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
              renderers: new Map(),
              supportsFiber: true,
              inject: function (injected) {
                return nextID++;
              },
              onScheduleFiberRoot: function (id, root, children) {},
              onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},
              onCommitFiberUnmount: function () {}
            };
          }
          if (hook.isDisabled) {
            // This isn't a real property on the hook, but it can be set to opt out
            // of DevTools integration and associated warnings and logs.
            // Using console['warn'] to evade Babel and ESLint
            console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');
            return;
          } // Here, we just want to get a reference to scheduleRefresh.

          var oldInject = hook.inject;
          hook.inject = function (injected) {
            var id = oldInject.apply(this, arguments);
            if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
              // This version supports React Refresh.
              helpersByRendererID.set(id, injected);
            }
            return id;
          }; // Do the same for any already injected roots.
          // This is useful if ReactDOM has already been initialized.
          // https://github.com/facebook/react/issues/17626

          hook.renderers.forEach(function (injected, id) {
            if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
              // This version supports React Refresh.
              helpersByRendererID.set(id, injected);
            }
          }); // We also want to track currently mounted roots.

          var oldOnCommitFiberRoot = hook.onCommitFiberRoot;
          var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};
          hook.onScheduleFiberRoot = function (id, root, children) {
            if (!isPerformingRefresh) {
              // If it was intentionally scheduled, don't attempt to restore.
              // This includes intentionally scheduled unmounts.
              failedRoots.delete(root);
              if (rootElements !== null) {
                rootElements.set(root, children);
              }
            }
            return oldOnScheduleFiberRoot.apply(this, arguments);
          };
          hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {
            var helpers = helpersByRendererID.get(id);
            if (helpers !== undefined) {
              helpersByRoot.set(root, helpers);
              var current = root.current;
              var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.
              // This logic is copy-pasted from similar logic in the DevTools backend.
              // If this breaks with some refactoring, you'll want to update DevTools too.

              if (alternate !== null) {
                var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);
                var isMounted = current.memoizedState != null && current.memoizedState.element != null;
                if (!wasMounted && isMounted) {
                  // Mount a new root.
                  mountedRoots.add(root);
                  failedRoots.delete(root);
                } else if (wasMounted && isMounted) ;else if (wasMounted && !isMounted) {
                  // Unmount an existing root.
                  mountedRoots.delete(root);
                  if (didError) {
                    // We'll remount it on future edits.
                    failedRoots.add(root);
                  } else {
                    helpersByRoot.delete(root);
                  }
                } else if (!wasMounted && !isMounted) {
                  if (didError) {
                    // We'll remount it on future edits.
                    failedRoots.add(root);
                  }
                }
              } else {
                // Mount a new root.
                mountedRoots.add(root);
              }
            } // Always call the decorated DevTools hook.

            return oldOnCommitFiberRoot.apply(this, arguments);
          };
        }
      }
      function hasUnrecoverableErrors() {
        // TODO: delete this after removing dependency in RN.
        return false;
      } // Exposed for testing.

      function _getMountedRootCount() {
        {
          return mountedRoots.size;
        }
      } // This is a wrapper over more primitive functions for setting signature.
      // Signatures let us decide whether the Hook order has changed on refresh.
      //
      // This function is intended to be used as a transform target, e.g.:
      // var _s = createSignatureFunctionForTransform()
      //
      // function Hello() {
      //   const [foo, setFoo] = useState(0);
      //   const value = useCustomHook();
      //   _s(); /* Call without arguments triggers collecting the custom Hook list.
      //          * This doesn't happen during the module evaluation because we
      //          * don't want to change the module order with inline requires.
      //          * Next calls are noops. */
      //   return <h1>Hi</h1>;
      // }
      //
      // /* Call with arguments attaches the signature to the type: */
      // _s(
      //   Hello,
      //   'useState{[foo, setFoo]}(0)',
      //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
      // );

      function createSignatureFunctionForTransform() {
        {
          var savedType;
          var hasCustomHooks;
          var didCollectHooks = false;
          return function (type, key, forceReset, getCustomHooks) {
            if (typeof key === 'string') {
              // We're in the initial phase that associates signatures
              // with the functions. Note this may be called multiple times
              // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).
              if (!savedType) {
                // We're in the innermost call, so this is the actual type.
                savedType = type;
                hasCustomHooks = typeof getCustomHooks === 'function';
              } // Set the signature for all types (even wrappers!) in case
              // they have no signatures of their own. This is to prevent
              // problems like https://github.com/facebook/react/issues/20417.

              if (type != null && (typeof type === 'function' || typeof type === 'object')) {
                setSignature(type, key, forceReset, getCustomHooks);
              }
              return type;
            } else {
              // We're in the _s() call without arguments, which means
              // this is the time to collect custom Hook signatures.
              // Only do this once. This path is hot and runs *inside* every render!
              if (!didCollectHooks && hasCustomHooks) {
                didCollectHooks = true;
                collectCustomHooksForSignature(savedType);
              }
            }
          };
        }
      }
      function isLikelyComponentType(type) {
        {
          switch (typeof type) {
            case 'function':
              {
                // First, deal with classes.
                if (type.prototype != null) {
                  if (type.prototype.isReactComponent) {
                    // React class.
                    return true;
                  }
                  var ownNames = Object.getOwnPropertyNames(type.prototype);
                  if (ownNames.length > 1 || ownNames[0] !== 'constructor') {
                    // This looks like a class.
                    return false;
                  } // eslint-disable-next-line no-proto

                  if (type.prototype.__proto__ !== Object.prototype) {
                    // It has a superclass.
                    return false;
                  } // Pass through.
                  // This looks like a regular function with empty prototype.
                } // For plain functions and arrows, use name as a heuristic.

                var name = type.name || type.displayName;
                return typeof name === 'string' && /^[A-Z]/.test(name);
              }
            case 'object':
              {
                if (type != null) {
                  switch (getProperty(type, '$$typeof')) {
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_MEMO_TYPE:
                      // Definitely React components.
                      return true;
                    default:
                      return false;
                  }
                }
                return false;
              }
            default:
              {
                return false;
              }
          }
        }
      }
      exports._getMountedRootCount = _getMountedRootCount;
      exports.collectCustomHooksForSignature = collectCustomHooksForSignature;
      exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;
      exports.findAffectedHostInstances = findAffectedHostInstances;
      exports.getFamilyByID = getFamilyByID;
      exports.getFamilyByType = getFamilyByType;
      exports.hasUnrecoverableErrors = hasUnrecoverableErrors;
      exports.injectIntoGlobalHook = injectIntoGlobalHook;
      exports.isLikelyComponentType = isLikelyComponentType;
      exports.performReactRefresh = performReactRefresh;
      exports.register = register;
      exports.setSignature = setSignature;
    })();
  }
},557,[],"node_modules/react-refresh/cjs/react-refresh-runtime.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  var _hmr = require(_dependencyMap[0], "./hmr");
  var HMRClient = _interopDefault(_hmr);
  if (typeof window !== 'undefined' &&
  // @ts-expect-error: Added via react-native-webview
  typeof window.$$EXPO_INITIAL_PROPS !== 'undefined') {
    // Sets up developer tools for web platforms when running in a webview. This ensures that logs are visible in the terminal.
    // We assume full control over the console and send JavaScript logs to Metro.
    const LEVELS = ['trace', 'info', 'warn', 'error', 'log', 'group', 'groupCollapsed', 'groupEnd', 'debug'];
    LEVELS.forEach(level => {
      const originalFunction = console[level];
      console[level] = function (...args) {
        HMRClient.default.log(level, args);
        originalFunction.apply(console, args);
      };
    });
    HMRClient.default.log('log', [`[webview] Logs will also appear in the Safari/Chrome debug console`]);
  } else {
    HMRClient.default.log('log', [`[web] Logs will appear in the browser console`]);
  }

  // This is called native on native platforms
  HMRClient.default.setup({
    isEnabled: true
  });
},558,[559],"node_modules/expo/src/async-require/setupHMR.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _expoMetroMetroRuntimeModulesHMRClient = require(_dependencyMap[0], "@expo/metro/metro-runtime/modules/HMRClient");
  var MetroHMRClient = _interopDefault(_expoMetroMetroRuntimeModulesHMRClient);
  var _prettyFormat = require(_dependencyMap[1], "pretty-format");
  var prettyFormat = _interopDefault(_prettyFormat);
  var _reactNativeWebDistExportsDeviceEventEmitter = require(_dependencyMap[2], "react-native-web/dist/exports/DeviceEventEmitter");
  var DeviceEventEmitter = _interopDefault(_reactNativeWebDistExportsDeviceEventEmitter);
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * Based on this but with web support:
   * https://github.com/facebook/react-native/blob/086714b02b0fb838dee5a66c5bcefe73b53cf3df/Libraries/Utilities/HMRClient.js
   */

  // Ensure events are sent so custom Fast Refresh views are shown.
  function showLoading(message, _type) {
    DeviceEventEmitter.default.emit('devLoadingView:showMessage', {
      message
    });
  }
  function hideLoading() {
    DeviceEventEmitter.default.emit('devLoadingView:hide', {});
  }
  const pendingEntryPoints = [];

  // @ts-expect-error: Account for multiple versions of pretty-format inside of a monorepo.
  const prettyFormatFunc = typeof prettyFormat.default === 'function' ? prettyFormat.default : prettyFormat.default.default;
  let hmrClient = null;
  let hmrUnavailableReason = null;
  let currentCompileErrorMessage = null;
  let didConnect = false;
  const pendingLogs = [];
  function assert(foo, msg) {
    if (!foo) throw new Error(msg);
  }

  /**
   * HMR Client that receives from the server HMR updates and propagates them
   * runtime to reflects those changes.
   */
  const HMRClient = {
    enable() {
      if (hmrUnavailableReason !== null) {
        // If HMR became unavailable while you weren't using it,
        // explain why when you try to turn it on.
        // This is an error (and not a warning) because it is shown
        // in response to a direct user action.
        throw new Error(hmrUnavailableReason);
      }
      assert(hmrClient, 'Expected HMRClient.setup() call at startup.');

      // We use this for internal logging only.
      // It doesn't affect the logic.
      hmrClient.send(JSON.stringify({
        type: 'log-opt-in'
      }));

      // When toggling Fast Refresh on, we might already have some stashed updates.
      // Since they'll get applied now, we'll show a banner.
      const hasUpdates = hmrClient.hasPendingUpdates();
      if (hasUpdates) {
        showLoading('Refreshing...', 'refresh');
      }
      try {
        hmrClient.enable();
      } finally {
        if (hasUpdates) {
          hideLoading();
        }
      }

      // There could be a compile error while Fast Refresh was off,
      // but we ignored it at the time. Show it now.
      showCompileError();
    },
    disable() {
      assert(hmrClient, 'Expected HMRClient.setup() call at startup.');
      hmrClient.disable();
    },
    registerBundle(requestUrl) {
      assert(hmrClient, 'Expected HMRClient.setup() call at startup.');
      pendingEntryPoints.push(requestUrl);
      registerBundleEntryPoints(hmrClient);
    },
    log(level, data) {
      if (!hmrClient) {
        // Catch a reasonable number of early logs
        // in case hmrClient gets initialized later.
        pendingLogs.push([level, data]);
        if (pendingLogs.length > 100) {
          pendingLogs.shift();
        }
        return;
      }
      try {
        hmrClient.send(JSON.stringify({
          type: 'log',
          level,
          platform: 'web',
          mode: 'BRIDGE',
          data: data.map(item => typeof item === 'string' ? item : prettyFormatFunc(item, {
            escapeString: true,
            highlight: true,
            maxDepth: 3,
            min: true,
            plugins: [_prettyFormat.plugins.ReactElement]
          }))
        }));
      } catch {
        // If sending logs causes any failures we want to silently ignore them
        // to ensure we do not cause infinite-logging loops.
      }
    },
    // Called once by the bridge on startup, even if Fast Refresh is off.
    // It creates the HMR client but doesn't actually set up the socket yet.
    setup({
      isEnabled
    }) {
      assert(!hmrClient, 'Cannot initialize hmrClient twice');
      const serverScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
      const client = new MetroHMRClient.default(`${serverScheme}://${window.location.host}/hot`);
      hmrClient = client;
      const fullBundleUrl = (() => {
        const currentScript = document?.currentScript;
        const bundleUrl = new URL(currentScript && 'src' in currentScript ? currentScript.src : location.href, location.href);
        if (!bundleUrl.searchParams.has('platform')) {
          bundleUrl.searchParams.set('platform', "web" ?? 'web');
        }
        return bundleUrl.toString();
      })();
      pendingEntryPoints.push(
      // HMRServer understands regular bundle URLs, so prefer that in case
      // there are any important URL parameters we can't reconstruct from
      // `setup()`'s arguments.
      fullBundleUrl);
      client.on('connection-error', e => {
        let error = `Cannot connect to Metro.
 
 Try the following to fix the issue:
 - Ensure the Metro dev server is running and available on the same network as this device`;
        error += `
 
 URL: ${window.location.host}
 
 Error: ${e.message}`;
        setHMRUnavailableReason(error);
      });
      client.on('update-start', ({
        isInitialUpdate
      }) => {
        currentCompileErrorMessage = null;
        didConnect = true;
        if (client.isEnabled() && !isInitialUpdate) {
          showLoading('Refreshing...', 'refresh');
        }
      });
      client.on('update', ({
        isInitialUpdate
      }) => {
        if (client.isEnabled() && !isInitialUpdate) {
          dismissRedbox();
          // @ts-expect-error
          globalThis.__expo_dev_resetErrors?.();
          // LogBox.clearAllLogs();
        }
      });
      client.on('update-done', () => {
        hideLoading();
      });
      client.on('error', data => {
        hideLoading();
        if (data.type === 'GraphNotFoundError') {
          client.close();
          setHMRUnavailableReason('Metro has restarted since the last edit. Reload to reconnect.');
        } else if (data.type === 'RevisionNotFoundError') {
          client.close();
          setHMRUnavailableReason('Metro and the client are out of sync. Reload to reconnect.');
        } else {
          currentCompileErrorMessage = `${data.type} ${data.message}`;
          if (client.isEnabled()) {
            showCompileError();
          }
        }
      });
      client.on('close', closeEvent => {
        hideLoading();
        const reason = closeEvent?.reason;
        const code = closeEvent?.code || 1000;
        // https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1
        // https://www.rfc-editor.org/rfc/rfc6455.html#section-7.1.5
        const title = reason && code !== 1000 && code !== 1001 && code !== 1005 ? `Disconnected from Metro (${code}: "${reason}")` : `Disconnected from Metro (${code})`;
        const message = title + '\nTo reconnect:' + '\n- Ensure that Metro is running and available on the same network' + '\n- Reload this app (will trigger further help if Metro cannot be connected to)';
        setHMRUnavailableReason(message);
      });
      if (isEnabled) {
        HMRClient.enable();
      } else {
        HMRClient.disable();
      }
      registerBundleEntryPoints(hmrClient);
      flushEarlyLogs();
    }
  };
  function setHMRUnavailableReason(reason) {
    assert(hmrClient, 'Expected HMRClient.setup() call at startup.');
    if (hmrUnavailableReason !== null) {
      // Don't show more than one warning.
      return;
    }
    hmrUnavailableReason = reason;

    // We only want to show a warning if Fast Refresh is on *and* if we ever
    // previously managed to connect successfully. We don't want to show
    // the warning to native engineers who use cached bundles without Metro.
    if (hmrClient.isEnabled() && didConnect) {
      // NOTE(@kitten): The timeout works around a Firefox quirk
      // In Firefox, unlike in Chrome, WebSockets fire a `close` event when a tab refreshes/navigates/closes, since this closes the WebSocket
      // However, there's no good way to detect that this is happening or that the client initiated the `close` event
      // To work around this, we schedule a timeout for our warning for 500ms which is long enough for this timer to never trigger
      setTimeout(() => {
        console.warn(reason);
      }, 500);
    }
  }
  function registerBundleEntryPoints(client) {
    if (hmrUnavailableReason != null) {
      // "Bundle Splitting – Metro disconnected"
      window.location.reload();
      return;
    }
    if (pendingEntryPoints.length > 0) {
      client?.send(JSON.stringify({
        type: 'register-entrypoints',
        entryPoints: pendingEntryPoints
      }));
      pendingEntryPoints.length = 0;
    }
  }
  function flushEarlyLogs() {
    try {
      pendingLogs.forEach(([level, data]) => {
        HMRClient.log(level, data);
      });
    } finally {
      pendingLogs.length = 0;
    }
  }
  function dismissRedbox() {
    // TODO(EvanBacon): Error overlay for web.
  }
  function showCompileError() {
    if (currentCompileErrorMessage === null) {
      return;
    }

    // Even if there is already a redbox, syntax errors are more important.
    // Otherwise you risk seeing a stale runtime error while a syntax error is more recent.
    dismissRedbox();
    const message = currentCompileErrorMessage;
    currentCompileErrorMessage = null;
    const error = new Error(message);
    // Symbolicating compile errors is wasted effort
    // because the stack trace is meaningless:
    // @ts-expect-error
    error.preventSymbolication = true;
    throw error;
  }
  var _default = HMRClient;
},559,[560,563,541],"node_modules/expo/src/async-require/hmr.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = require(_dependencyMap[0], "metro-runtime/src/modules/HMRClient.js");
},560,[561],"node_modules/@expo/metro/metro-runtime/modules/HMRClient.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const EventEmitter = require(_dependencyMap[0], "./vendor/eventemitter3");
  const inject = ({
    module: [id, code],
    sourceURL
  }) => {
    if (global.globalEvalWithSourceUrl) {
      global.globalEvalWithSourceUrl(code, sourceURL);
    } else {
      eval(code);
    }
  };
  const injectUpdate = update => {
    update.added.forEach(inject);
    update.modified.forEach(inject);
  };
  class HMRClient extends EventEmitter {
    _isEnabled = false;
    _pendingUpdate = null;
    _queue = [];
    _state = "opening";
    constructor(url) {
      super();
      this._ws = new global.WebSocket(url);
      this._ws.onopen = () => {
        this._state = "open";
        this.emit("open");
        this._flushQueue();
      };
      this._ws.onerror = error => {
        this.emit("connection-error", error);
      };
      this._ws.onclose = closeEvent => {
        this._state = "closed";
        this.emit("close", closeEvent);
      };
      this._ws.onmessage = message => {
        const data = JSON.parse(String(message.data));
        switch (data.type) {
          case "bundle-registered":
            this.emit("bundle-registered");
            break;
          case "update-start":
            this.emit("update-start", data.body);
            break;
          case "update":
            this.emit("update", data.body);
            break;
          case "update-done":
            this.emit("update-done");
            break;
          case "error":
            this.emit("error", data.body);
            break;
          default:
            this.emit("error", {
              type: "unknown-message",
              message: data
            });
        }
      };
      this.on("update", update => {
        if (this._isEnabled) {
          injectUpdate(update);
        } else if (this._pendingUpdate == null) {
          this._pendingUpdate = update;
        } else {
          this._pendingUpdate = mergeUpdates(this._pendingUpdate, update);
        }
      });
    }
    close() {
      this._ws.close();
    }
    send(message) {
      switch (this._state) {
        case "opening":
          this._queue.push(message);
          break;
        case "open":
          this._ws.send(message);
          break;
        case "closed":
          break;
        default:
          throw new Error("[WebSocketHMRClient] Unknown state: " + this._state);
      }
    }
    _flushQueue() {
      this._queue.forEach(message => this.send(message));
      this._queue.length = 0;
    }
    enable() {
      this._isEnabled = true;
      const update = this._pendingUpdate;
      this._pendingUpdate = null;
      if (update != null) {
        injectUpdate(update);
      }
    }
    disable() {
      this._isEnabled = false;
    }
    isEnabled() {
      return this._isEnabled;
    }
    hasPendingUpdates() {
      return this._pendingUpdate != null;
    }
  }
  function mergeUpdates(base, next) {
    const addedIDs = new Set();
    const deletedIDs = new Set();
    const moduleMap = new Map();
    applyUpdateLocally(base);
    applyUpdateLocally(next);
    function applyUpdateLocally(update) {
      update.deleted.forEach(id => {
        if (addedIDs.has(id)) {
          addedIDs.delete(id);
        } else {
          deletedIDs.add(id);
        }
        moduleMap.delete(id);
      });
      update.added.forEach(item => {
        const id = item.module[0];
        if (deletedIDs.has(id)) {
          deletedIDs.delete(id);
        } else {
          addedIDs.add(id);
        }
        moduleMap.set(id, item);
      });
      update.modified.forEach(item => {
        const id = item.module[0];
        moduleMap.set(id, item);
      });
    }
    const result = {
      isInitialUpdate: next.isInitialUpdate,
      revisionId: next.revisionId,
      added: [],
      modified: [],
      deleted: []
    };
    deletedIDs.forEach(id => {
      result.deleted.push(id);
    });
    moduleMap.forEach((item, id) => {
      if (deletedIDs.has(id)) {
        return;
      }
      if (addedIDs.has(id)) {
        result.added.push(item);
      } else {
        result.modified.push(item);
      }
    });
    return result;
  }
  module.exports = HMRClient;
},561,[562],"node_modules/metro-runtime/src/modules/HMRClient.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var has = Object.prototype.hasOwnProperty,
    prefix = "~";
  function Events() {}
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once),
      evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [],
      events,
      name;
    if (this._eventsCount === 0) return names;
    for (name in events = this._events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event,
      handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event,
      listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt],
      len = arguments.length,
      args,
      i;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length,
        j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if ("undefined" !== typeof module) {
    module.exports = EventEmitter;
  }
},562,[],"node_modules/metro-runtime/src/modules/vendor/eventemitter3.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.default = exports.DEFAULT_OPTIONS = void 0;
  exports.format = format;
  exports.plugins = void 0;
  var _ansiStyles = _interopRequireDefault(require(_dependencyMap[0], "ansi-styles"));
  var _collections = require(_dependencyMap[1], "./collections");
  var _AsymmetricMatcher = _interopRequireDefault(require(_dependencyMap[2], "./plugins/AsymmetricMatcher"));
  var _DOMCollection = _interopRequireDefault(require(_dependencyMap[3], "./plugins/DOMCollection"));
  var _DOMElement = _interopRequireDefault(require(_dependencyMap[4], "./plugins/DOMElement"));
  var _Immutable = _interopRequireDefault(require(_dependencyMap[5], "./plugins/Immutable"));
  var _ReactElement = _interopRequireDefault(require(_dependencyMap[6], "./plugins/ReactElement"));
  var _ReactTestComponent = _interopRequireDefault(require(_dependencyMap[7], "./plugins/ReactTestComponent"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /* eslint-disable local/ban-types-eventually */

  const toString = Object.prototype.toString;
  const toISOString = Date.prototype.toISOString;
  const errorToString = Error.prototype.toString;
  const regExpToString = RegExp.prototype.toString;

  /**
   * Explicitly comparing typeof constructor to function avoids undefined as name
   * when mock identity-obj-proxy returns the key as the value for any key.
   */
  const getConstructorName = val => typeof val.constructor === 'function' && val.constructor.name || 'Object';

  /* global window */
  /** Is val is equal to global window object? Works even if it does not exist :) */
  const isWindow = val => typeof window !== 'undefined' && val === window;
  const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
  const NEWLINE_REGEXP = /\n/gi;
  class PrettyFormatPluginError extends Error {
    constructor(message, stack) {
      super(message);
      this.stack = stack;
      this.name = this.constructor.name;
    }
  }
  function isToStringedArrayType(toStringed) {
    return toStringed === '[object Array]' || toStringed === '[object ArrayBuffer]' || toStringed === '[object DataView]' || toStringed === '[object Float32Array]' || toStringed === '[object Float64Array]' || toStringed === '[object Int8Array]' || toStringed === '[object Int16Array]' || toStringed === '[object Int32Array]' || toStringed === '[object Uint8Array]' || toStringed === '[object Uint8ClampedArray]' || toStringed === '[object Uint16Array]' || toStringed === '[object Uint32Array]';
  }
  function printNumber(val) {
    return Object.is(val, -0) ? '-0' : String(val);
  }
  function printBigInt(val) {
    return String(`${val}n`);
  }
  function printFunction(val, printFunctionName) {
    if (!printFunctionName) {
      return '[Function]';
    }
    return `[Function ${val.name || 'anonymous'}]`;
  }
  function printSymbol(val) {
    return String(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
  }
  function printError(val) {
    return `[${errorToString.call(val)}]`;
  }

  /**
   * The first port of call for printing an object, handles most of the
   * data-types in JS.
   */
  function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
    if (val === true || val === false) {
      return `${val}`;
    }
    if (val === undefined) {
      return 'undefined';
    }
    if (val === null) {
      return 'null';
    }
    const typeOf = typeof val;
    if (typeOf === 'number') {
      return printNumber(val);
    }
    if (typeOf === 'bigint') {
      return printBigInt(val);
    }
    if (typeOf === 'string') {
      if (escapeString) {
        return `"${val.replace(/"|\\/g, '\\$&')}"`;
      }
      return `"${val}"`;
    }
    if (typeOf === 'function') {
      return printFunction(val, printFunctionName);
    }
    if (typeOf === 'symbol') {
      return printSymbol(val);
    }
    const toStringed = toString.call(val);
    if (toStringed === '[object WeakMap]') {
      return 'WeakMap {}';
    }
    if (toStringed === '[object WeakSet]') {
      return 'WeakSet {}';
    }
    if (toStringed === '[object Function]' || toStringed === '[object GeneratorFunction]') {
      return printFunction(val, printFunctionName);
    }
    if (toStringed === '[object Symbol]') {
      return printSymbol(val);
    }
    if (toStringed === '[object Date]') {
      return isNaN(+val) ? 'Date { NaN }' : toISOString.call(val);
    }
    if (toStringed === '[object Error]') {
      return printError(val);
    }
    if (toStringed === '[object RegExp]') {
      if (escapeRegex) {
        // https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js
        return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
      }
      return regExpToString.call(val);
    }
    if (val instanceof Error) {
      return printError(val);
    }
    return null;
  }

  /**
   * Handles more complex objects ( such as objects with circular references.
   * maps and sets etc )
   */
  function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
    if (refs.indexOf(val) !== -1) {
      return '[Circular]';
    }
    refs = refs.slice();
    refs.push(val);
    const hitMaxDepth = ++depth > config.maxDepth;
    const min = config.min;
    if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === 'function' && !hasCalledToJSON) {
      return printer(val.toJSON(), config, indentation, depth, refs, true);
    }
    const toStringed = toString.call(val);
    if (toStringed === '[object Arguments]') {
      return hitMaxDepth ? '[Arguments]' : `${min ? '' : 'Arguments '}[${(0, _collections.printListItems)(val, config, indentation, depth, refs, printer)}]`;
    }
    if (isToStringedArrayType(toStringed)) {
      return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? '' : !config.printBasicPrototype && val.constructor.name === 'Array' ? '' : `${val.constructor.name} `}[${(0, _collections.printListItems)(val, config, indentation, depth, refs, printer)}]`;
    }
    if (toStringed === '[object Map]') {
      return hitMaxDepth ? '[Map]' : `Map {${(0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer, ' => ')}}`;
    }
    if (toStringed === '[object Set]') {
      return hitMaxDepth ? '[Set]' : `Set {${(0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer)}}`;
    }

    // Avoid failure to serialize global window object in jsdom test environment.
    // For example, not even relevant if window is prop of React element.
    return hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min ? '' : !config.printBasicPrototype && getConstructorName(val) === 'Object' ? '' : `${getConstructorName(val)} `}{${(0, _collections.printObjectProperties)(val, config, indentation, depth, refs, printer)}}`;
  }
  function isNewPlugin(plugin) {
    return plugin.serialize != null;
  }
  function printPlugin(plugin, val, config, indentation, depth, refs) {
    let printed;
    try {
      printed = isNewPlugin(plugin) ? plugin.serialize(val, config, indentation, depth, refs, printer) : plugin.print(val, valChild => printer(valChild, config, indentation, depth, refs), str => {
        const indentationNext = indentation + config.indent;
        return indentationNext + str.replace(NEWLINE_REGEXP, `\n${indentationNext}`);
      }, {
        edgeSpacing: config.spacingOuter,
        min: config.min,
        spacing: config.spacingInner
      }, config.colors);
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
    if (typeof printed !== 'string') {
      throw new Error(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
    }
    return printed;
  }
  function findPlugin(plugins, val) {
    for (let p = 0; p < plugins.length; p++) {
      try {
        if (plugins[p].test(val)) {
          return plugins[p];
        }
      } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
      }
    }
    return null;
  }
  function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
    const plugin = findPlugin(config.plugins, val);
    if (plugin !== null) {
      return printPlugin(plugin, val, config, indentation, depth, refs);
    }
    const basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString);
    if (basicResult !== null) {
      return basicResult;
    }
    return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON);
  }
  const DEFAULT_THEME = {
    comment: 'gray',
    content: 'reset',
    prop: 'yellow',
    tag: 'cyan',
    value: 'green'
  };
  const DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);

  // could be replaced by `satisfies` operator in the future: https://github.com/microsoft/TypeScript/issues/47920
  const toOptionsSubtype = options => options;
  const DEFAULT_OPTIONS = toOptionsSubtype({
    callToJSON: true,
    compareKeys: undefined,
    escapeRegex: false,
    escapeString: true,
    highlight: false,
    indent: 2,
    maxDepth: Infinity,
    maxWidth: Infinity,
    min: false,
    plugins: [],
    printBasicPrototype: true,
    printFunctionName: true,
    theme: DEFAULT_THEME
  });
  exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
  function validateOptions(options) {
    Object.keys(options).forEach(key => {
      if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) {
        throw new Error(`pretty-format: Unknown option "${key}".`);
      }
    });
    if (options.min && options.indent !== undefined && options.indent !== 0) {
      throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
    }
    if (options.theme !== undefined) {
      if (options.theme === null) {
        throw new Error('pretty-format: Option "theme" must not be null.');
      }
      if (typeof options.theme !== 'object') {
        throw new Error(`pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`);
      }
    }
  }
  const getColorsHighlight = options => DEFAULT_THEME_KEYS.reduce((colors, key) => {
    const value = options.theme && options.theme[key] !== undefined ? options.theme[key] : DEFAULT_THEME[key];
    const color = value && _ansiStyles.default[value];
    if (color && typeof color.close === 'string' && typeof color.open === 'string') {
      colors[key] = color;
    } else {
      throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
    }
    return colors;
  }, Object.create(null));
  const getColorsEmpty = () => DEFAULT_THEME_KEYS.reduce((colors, key) => {
    colors[key] = {
      close: '',
      open: ''
    };
    return colors;
  }, Object.create(null));
  const getPrintFunctionName = options => options?.printFunctionName ?? DEFAULT_OPTIONS.printFunctionName;
  const getEscapeRegex = options => options?.escapeRegex ?? DEFAULT_OPTIONS.escapeRegex;
  const getEscapeString = options => options?.escapeString ?? DEFAULT_OPTIONS.escapeString;
  const getConfig = options => ({
    callToJSON: options?.callToJSON ?? DEFAULT_OPTIONS.callToJSON,
    colors: options?.highlight ? getColorsHighlight(options) : getColorsEmpty(),
    compareKeys: typeof options?.compareKeys === 'function' || options?.compareKeys === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
    escapeRegex: getEscapeRegex(options),
    escapeString: getEscapeString(options),
    indent: options?.min ? '' : createIndent(options?.indent ?? DEFAULT_OPTIONS.indent),
    maxDepth: options?.maxDepth ?? DEFAULT_OPTIONS.maxDepth,
    maxWidth: options?.maxWidth ?? DEFAULT_OPTIONS.maxWidth,
    min: options?.min ?? DEFAULT_OPTIONS.min,
    plugins: options?.plugins ?? DEFAULT_OPTIONS.plugins,
    printBasicPrototype: options?.printBasicPrototype ?? true,
    printFunctionName: getPrintFunctionName(options),
    spacingInner: options?.min ? ' ' : '\n',
    spacingOuter: options?.min ? '' : '\n'
  });
  function createIndent(indent) {
    return new Array(indent + 1).join(' ');
  }

  /**
   * Returns a presentation string of your `val` object
   * @param val any potential JavaScript object
   * @param options Custom settings
   */
  function format(val, options) {
    if (options) {
      validateOptions(options);
      if (options.plugins) {
        const plugin = findPlugin(options.plugins, val);
        if (plugin !== null) {
          return printPlugin(plugin, val, getConfig(options), '', 0, []);
        }
      }
    }
    const basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
    if (basicResult !== null) {
      return basicResult;
    }
    return printComplexValue(val, getConfig(options), '', 0, []);
  }
  const plugins = {
    AsymmetricMatcher: _AsymmetricMatcher.default,
    DOMCollection: _DOMCollection.default,
    DOMElement: _DOMElement.default,
    Immutable: _Immutable.default,
    ReactElement: _ReactElement.default,
    ReactTestComponent: _ReactTestComponent.default
  };
  exports.plugins = plugins;
  var _default = format;
  exports.default = _default;
},563,[564,565,566,567,568,571,572,575],"node_modules/pretty-format/build/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  const ANSI_BACKGROUND_OFFSET = 10;
  const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;
  const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };

    // Alias bright black as gray (and grey)
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\u001B[${style[0]}m`,
          close: `\u001B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, 'codes', {
      value: codes,
      enumerable: false
    });
    styles.color.close = '\u001B[39m';
    styles.bgColor.close = '\u001B[49m';
    styles.color.ansi256 = wrapAnsi256();
    styles.color.ansi16m = wrapAnsi16m();
    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

    // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
    Object.defineProperties(styles, {
      rgbToAnsi256: {
        value: (red, green, blue) => {
          // We use the extended greyscale palette here, with the exception of
          // black and white. normal palette only has 4 greyscale shades.
          if (red === green && green === blue) {
            if (red < 8) {
              return 16;
            }
            if (red > 248) {
              return 231;
            }
            return Math.round((red - 8) / 247 * 24) + 232;
          }
          return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
        },
        enumerable: false
      },
      hexToRgb: {
        value: hex => {
          const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
          if (!matches) {
            return [0, 0, 0];
          }
          let {
            colorString
          } = matches.groups;
          if (colorString.length === 3) {
            colorString = colorString.split('').map(character => character + character).join('');
          }
          const integer = Number.parseInt(colorString, 16);
          return [integer >> 16 & 0xFF, integer >> 8 & 0xFF, integer & 0xFF];
        },
        enumerable: false
      },
      hexToAnsi256: {
        value: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
        enumerable: false
      }
    });
    return styles;
  }

  // Make the export immutable
  Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
  });
},564,[],"node_modules/pretty-format/node_modules/ansi-styles/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.printIteratorEntries = printIteratorEntries;
  exports.printIteratorValues = printIteratorValues;
  exports.printListItems = printListItems;
  exports.printObjectProperties = printObjectProperties;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  const getKeysOfEnumerableProperties = (object, compareKeys) => {
    const rawKeys = Object.keys(object);
    const keys = compareKeys !== null ? rawKeys.sort(compareKeys) : rawKeys;
    if (Object.getOwnPropertySymbols) {
      Object.getOwnPropertySymbols(object).forEach(symbol => {
        if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
          keys.push(symbol);
        }
      });
    }
    return keys;
  };

  /**
   * Return entries (for example, of a map)
   * with spacing, indentation, and comma
   * without surrounding punctuation (for example, braces)
   */
  function printIteratorEntries(iterator, config, indentation, depth, refs, printer,
  // Too bad, so sad that separator for ECMAScript Map has been ' => '
  // What a distracting diff if you change a data structure to/from
  // ECMAScript Object or Immutable.Map/OrderedMap which use the default.
  separator = ': ') {
    let result = '';
    let width = 0;
    let current = iterator.next();
    if (!current.done) {
      result += config.spacingOuter;
      const indentationNext = indentation + config.indent;
      while (!current.done) {
        result += indentationNext;
        if (width++ === config.maxWidth) {
          result += '…';
          break;
        }
        const name = printer(current.value[0], config, indentationNext, depth, refs);
        const value = printer(current.value[1], config, indentationNext, depth, refs);
        result += name + separator + value;
        current = iterator.next();
        if (!current.done) {
          result += `,${config.spacingInner}`;
        } else if (!config.min) {
          result += ',';
        }
      }
      result += config.spacingOuter + indentation;
    }
    return result;
  }

  /**
   * Return values (for example, of a set)
   * with spacing, indentation, and comma
   * without surrounding punctuation (braces or brackets)
   */
  function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
    let result = '';
    let width = 0;
    let current = iterator.next();
    if (!current.done) {
      result += config.spacingOuter;
      const indentationNext = indentation + config.indent;
      while (!current.done) {
        result += indentationNext;
        if (width++ === config.maxWidth) {
          result += '…';
          break;
        }
        result += printer(current.value, config, indentationNext, depth, refs);
        current = iterator.next();
        if (!current.done) {
          result += `,${config.spacingInner}`;
        } else if (!config.min) {
          result += ',';
        }
      }
      result += config.spacingOuter + indentation;
    }
    return result;
  }

  /**
   * Return items (for example, of an array)
   * with spacing, indentation, and comma
   * without surrounding punctuation (for example, brackets)
   **/
  function printListItems(list, config, indentation, depth, refs, printer) {
    let result = '';
    if (list.length) {
      result += config.spacingOuter;
      const indentationNext = indentation + config.indent;
      for (let i = 0; i < list.length; i++) {
        result += indentationNext;
        if (i === config.maxWidth) {
          result += '…';
          break;
        }
        if (i in list) {
          result += printer(list[i], config, indentationNext, depth, refs);
        }
        if (i < list.length - 1) {
          result += `,${config.spacingInner}`;
        } else if (!config.min) {
          result += ',';
        }
      }
      result += config.spacingOuter + indentation;
    }
    return result;
  }

  /**
   * Return properties of an object
   * with spacing, indentation, and comma
   * without surrounding punctuation (for example, braces)
   */
  function printObjectProperties(val, config, indentation, depth, refs, printer) {
    let result = '';
    const keys = getKeysOfEnumerableProperties(val, config.compareKeys);
    if (keys.length) {
      result += config.spacingOuter;
      const indentationNext = indentation + config.indent;
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const name = printer(key, config, indentationNext, depth, refs);
        const value = printer(val[key], config, indentationNext, depth, refs);
        result += `${indentationNext + name}: ${value}`;
        if (i < keys.length - 1) {
          result += `,${config.spacingInner}`;
        } else if (!config.min) {
          result += ',';
        }
      }
      result += config.spacingOuter + indentation;
    }
    return result;
  }
},565,[],"node_modules/pretty-format/build/collections.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var _collections = require(_dependencyMap[0], "../collections");
  var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  const asymmetricMatcher = typeof Symbol === 'function' && Symbol.for ? Symbol.for('jest.asymmetricMatcher') : 0x1357a5;
  const SPACE = ' ';
  const serialize = (val, config, indentation, depth, refs, printer) => {
    const stringedValue = val.toString();
    if (stringedValue === 'ArrayContaining' || stringedValue === 'ArrayNotContaining') {
      if (++depth > config.maxDepth) {
        return `[${stringedValue}]`;
      }
      return `${stringedValue + SPACE}[${(0, _collections.printListItems)(val.sample, config, indentation, depth, refs, printer)}]`;
    }
    if (stringedValue === 'ObjectContaining' || stringedValue === 'ObjectNotContaining') {
      if (++depth > config.maxDepth) {
        return `[${stringedValue}]`;
      }
      return `${stringedValue + SPACE}{${(0, _collections.printObjectProperties)(val.sample, config, indentation, depth, refs, printer)}}`;
    }
    if (stringedValue === 'StringMatching' || stringedValue === 'StringNotMatching') {
      return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
    }
    if (stringedValue === 'StringContaining' || stringedValue === 'StringNotContaining') {
      return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
    }
    if (typeof val.toAsymmetricMatcher !== 'function') {
      throw new Error(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
    }
    return val.toAsymmetricMatcher();
  };
  exports.serialize = serialize;
  const test = val => val && val.$$typeof === asymmetricMatcher;
  exports.test = test;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},566,[565],"node_modules/pretty-format/build/plugins/AsymmetricMatcher.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var _collections = require(_dependencyMap[0], "../collections");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const SPACE = ' ';
  const OBJECT_NAMES = ['DOMStringMap', 'NamedNodeMap'];
  const ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
  const testName = name => OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
  const test = val => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
  exports.test = test;
  const isNamedNodeMap = collection => collection.constructor.name === 'NamedNodeMap';
  const serialize = (collection, config, indentation, depth, refs, printer) => {
    const name = collection.constructor.name;
    if (++depth > config.maxDepth) {
      return `[${name}]`;
    }
    return (config.min ? '' : name + SPACE) + (OBJECT_NAMES.indexOf(name) !== -1 ? `{${(0, _collections.printObjectProperties)(isNamedNodeMap(collection) ? Array.from(collection).reduce((props, attribute) => {
      props[attribute.name] = attribute.value;
      return props;
    }, {}) : Object.assign({}, collection), config, indentation, depth, refs, printer)}}` : `[${(0, _collections.printListItems)(Array.from(collection), config, indentation, depth, refs, printer)}]`);
  };
  exports.serialize = serialize;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},567,[565],"node_modules/pretty-format/build/plugins/DOMCollection.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var _markup = require(_dependencyMap[0], "./lib/markup");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const ELEMENT_NODE = 1;
  const TEXT_NODE = 3;
  const COMMENT_NODE = 8;
  const FRAGMENT_NODE = 11;
  const ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
  const testHasAttribute = val => {
    try {
      return typeof val.hasAttribute === 'function' && val.hasAttribute('is');
    } catch {
      return false;
    }
  };
  const testNode = val => {
    const constructorName = val.constructor.name;
    const {
      nodeType,
      tagName
    } = val;
    const isCustomElement = typeof tagName === 'string' && tagName.includes('-') || testHasAttribute(val);
    return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === 'Text' || nodeType === COMMENT_NODE && constructorName === 'Comment' || nodeType === FRAGMENT_NODE && constructorName === 'DocumentFragment';
  };
  const test = val => val?.constructor?.name && testNode(val);
  exports.test = test;
  function nodeIsText(node) {
    return node.nodeType === TEXT_NODE;
  }
  function nodeIsComment(node) {
    return node.nodeType === COMMENT_NODE;
  }
  function nodeIsFragment(node) {
    return node.nodeType === FRAGMENT_NODE;
  }
  const serialize = (node, config, indentation, depth, refs, printer) => {
    if (nodeIsText(node)) {
      return (0, _markup.printText)(node.data, config);
    }
    if (nodeIsComment(node)) {
      return (0, _markup.printComment)(node.data, config);
    }
    const type = nodeIsFragment(node) ? 'DocumentFragment' : node.tagName.toLowerCase();
    if (++depth > config.maxDepth) {
      return (0, _markup.printElementAsLeaf)(type, config);
    }
    return (0, _markup.printElement)(type, (0, _markup.printProps)(nodeIsFragment(node) ? [] : Array.from(node.attributes, attr => attr.name).sort(), nodeIsFragment(node) ? {} : Array.from(node.attributes).reduce((props, attribute) => {
      props[attribute.name] = attribute.value;
      return props;
    }, {}), config, indentation + config.indent, depth, refs, printer), (0, _markup.printChildren)(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
  };
  exports.serialize = serialize;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},568,[569],"node_modules/pretty-format/build/plugins/DOMElement.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.printText = exports.printProps = exports.printElementAsLeaf = exports.printElement = exports.printComment = exports.printChildren = void 0;
  var _escapeHTML = _interopRequireDefault(require(_dependencyMap[0], "./escapeHTML"));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // Return empty string if keys is empty.
  const printProps = (keys, props, config, indentation, depth, refs, printer) => {
    const indentationNext = indentation + config.indent;
    const colors = config.colors;
    return keys.map(key => {
      const value = props[key];
      let printed = printer(value, config, indentationNext, depth, refs);
      if (typeof value !== 'string') {
        if (printed.indexOf('\n') !== -1) {
          printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
        }
        printed = `{${printed}}`;
      }
      return `${config.spacingInner + indentation + colors.prop.open + key + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;
    }).join('');
  };

  // Return empty string if children is empty.
  exports.printProps = printProps;
  const printChildren = (children, config, indentation, depth, refs, printer) => children.map(child => config.spacingOuter + indentation + (typeof child === 'string' ? printText(child, config) : printer(child, config, indentation, depth, refs))).join('');
  exports.printChildren = printChildren;
  const printText = (text, config) => {
    const contentColor = config.colors.content;
    return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
  };
  exports.printText = printText;
  const printComment = (comment, config) => {
    const commentColor = config.colors.comment;
    return `${commentColor.open}<!--${(0, _escapeHTML.default)(comment)}-->${commentColor.close}`;
  };

  // Separate the functions to format props, children, and element,
  // so a plugin could override a particular function, if needed.
  // Too bad, so sad: the traditional (but unnecessary) space
  // in a self-closing tagColor requires a second test of printedProps.
  exports.printComment = printComment;
  const printElement = (type, printedProps, printedChildren, config, indentation) => {
    const tagColor = config.colors.tag;
    return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config.min ? '' : ' '}/`}>${tagColor.close}`;
  };
  exports.printElement = printElement;
  const printElementAsLeaf = (type, config) => {
    const tagColor = config.colors.tag;
    return `${tagColor.open}<${type}${tagColor.close} …${tagColor.open} />${tagColor.close}`;
  };
  exports.printElementAsLeaf = printElementAsLeaf;
},569,[570],"node_modules/pretty-format/build/plugins/lib/markup.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.default = escapeHTML;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  function escapeHTML(str) {
    return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }
},570,[],"node_modules/pretty-format/build/plugins/lib/escapeHTML.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var _collections = require(_dependencyMap[0], "../collections");
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // SENTINEL constants are from https://github.com/facebook/immutable-js
  const IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  const IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
  const IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  const IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
  const IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
  const IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@'; // immutable v4
  const IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
  const IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
  const IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
  const getImmutableName = name => `Immutable.${name}`;
  const printAsLeaf = name => `[${name}]`;
  const SPACE = ' ';
  const LAZY = '…'; // Seq is lazy if it calls a method like filter

  const printImmutableEntries = (val, config, indentation, depth, refs, printer, type) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${(0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer)}}`;

  // Record has an entries method because it is a collection in immutable v3.
  // Return an iterator for Immutable Record from version v3 or v4.
  function getRecordEntries(val) {
    let i = 0;
    return {
      next() {
        if (i < val._keys.length) {
          const key = val._keys[i++];
          return {
            done: false,
            value: [key, val.get(key)]
          };
        }
        return {
          done: true,
          value: undefined
        };
      }
    };
  }
  const printImmutableRecord = (val, config, indentation, depth, refs, printer) => {
    // _name property is defined only for an Immutable Record instance
    // which was constructed with a second optional descriptive name arg
    const name = getImmutableName(val._name || 'Record');
    return ++depth > config.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${(0, _collections.printIteratorEntries)(getRecordEntries(val), config, indentation, depth, refs, printer)}}`;
  };
  const printImmutableSeq = (val, config, indentation, depth, refs, printer) => {
    const name = getImmutableName('Seq');
    if (++depth > config.maxDepth) {
      return printAsLeaf(name);
    }
    if (val[IS_KEYED_SENTINEL]) {
      return `${name + SPACE}{${
      // from Immutable collection of entries or from ECMAScript object
      val._iter || val._object ? (0, _collections.printIteratorEntries)(val.entries(), config, indentation, depth, refs, printer) : LAZY}}`;
    }
    return `${name + SPACE}[${val._iter ||
    // from Immutable collection of values
    val._array ||
    // from ECMAScript array
    val._collection ||
    // from ECMAScript collection in immutable v4
    val._iterable // from ECMAScript collection in immutable v3
    ? (0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer) : LAZY}]`;
  };
  const printImmutableValues = (val, config, indentation, depth, refs, printer, type) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${(0, _collections.printIteratorValues)(val.values(), config, indentation, depth, refs, printer)}]`;
  const serialize = (val, config, indentation, depth, refs, printer) => {
    if (val[IS_MAP_SENTINEL]) {
      return printImmutableEntries(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedMap' : 'Map');
    }
    if (val[IS_LIST_SENTINEL]) {
      return printImmutableValues(val, config, indentation, depth, refs, printer, 'List');
    }
    if (val[IS_SET_SENTINEL]) {
      return printImmutableValues(val, config, indentation, depth, refs, printer, val[IS_ORDERED_SENTINEL] ? 'OrderedSet' : 'Set');
    }
    if (val[IS_STACK_SENTINEL]) {
      return printImmutableValues(val, config, indentation, depth, refs, printer, 'Stack');
    }
    if (val[IS_SEQ_SENTINEL]) {
      return printImmutableSeq(val, config, indentation, depth, refs, printer);
    }

    // For compatibility with immutable v3 and v4, let record be the default.
    return printImmutableRecord(val, config, indentation, depth, refs, printer);
  };

  // Explicitly comparing sentinel properties to true avoids false positive
  // when mock identity-obj-proxy returns the key as the value for any key.
  exports.serialize = serialize;
  const test = val => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
  exports.test = test;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},571,[565],"node_modules/pretty-format/build/plugins/Immutable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var ReactIs = _interopRequireWildcard(require(_dependencyMap[0], "react-is"));
  var _markup = require(_dependencyMap[1], "./lib/markup");
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== 'function') return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {
      return {
        default: obj
      };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // Given element.props.children, or subtree during recursive traversal,
  // return flattened array of children.
  const getChildren = (arg, children = []) => {
    if (Array.isArray(arg)) {
      arg.forEach(item => {
        getChildren(item, children);
      });
    } else if (arg != null && arg !== false) {
      children.push(arg);
    }
    return children;
  };
  const getType = element => {
    const type = element.type;
    if (typeof type === 'string') {
      return type;
    }
    if (typeof type === 'function') {
      return type.displayName || type.name || 'Unknown';
    }
    if (ReactIs.isFragment(element)) {
      return 'React.Fragment';
    }
    if (ReactIs.isSuspense(element)) {
      return 'React.Suspense';
    }
    if (typeof type === 'object' && type !== null) {
      if (ReactIs.isContextProvider(element)) {
        return 'Context.Provider';
      }
      if (ReactIs.isContextConsumer(element)) {
        return 'Context.Consumer';
      }
      if (ReactIs.isForwardRef(element)) {
        if (type.displayName) {
          return type.displayName;
        }
        const functionName = type.render.displayName || type.render.name || '';
        return functionName !== '' ? `ForwardRef(${functionName})` : 'ForwardRef';
      }
      if (ReactIs.isMemo(element)) {
        const functionName = type.displayName || type.type.displayName || type.type.name || '';
        return functionName !== '' ? `Memo(${functionName})` : 'Memo';
      }
    }
    return 'UNDEFINED';
  };
  const getPropKeys = element => {
    const {
      props
    } = element;
    return Object.keys(props).filter(key => key !== 'children' && props[key] !== undefined).sort();
  };
  const serialize = (element, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(getType(element), config) : (0, _markup.printElement)(getType(element), (0, _markup.printProps)(getPropKeys(element), element.props, config, indentation + config.indent, depth, refs, printer), (0, _markup.printChildren)(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
  exports.serialize = serialize;
  const test = val => val != null && ReactIs.isElement(val);
  exports.test = test;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},572,[573,569],"node_modules/pretty-format/build/plugins/ReactElement.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (process.env.NODE_ENV === 'production') {
    module.exports = require(_dependencyMap[0], "./cjs/react-is.production.min.js");
  } else {
    module.exports = require(_dependencyMap[1], "./cjs/react-is.development.js");
  }
},573,[10,574],"node_modules/pretty-format/node_modules/react-is/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  if (process.env.NODE_ENV !== "production") {
    (function () {
      'use strict';

      // ATTENTION
      // When adding new symbols to this file,
      // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
      // The Symbol used to tag the ReactElement-like types.
      var REACT_ELEMENT_TYPE = Symbol.for('react.element');
      var REACT_PORTAL_TYPE = Symbol.for('react.portal');
      var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
      var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
      var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
      var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
      var REACT_CONTEXT_TYPE = Symbol.for('react.context');
      var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
      var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
      var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
      var REACT_MEMO_TYPE = Symbol.for('react.memo');
      var REACT_LAZY_TYPE = Symbol.for('react.lazy');
      var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');

      // -----------------------------------------------------------------------------

      var enableScopeAPI = false; // Experimental Create Event Handle API.
      var enableCacheElement = false;
      var enableTransitionTracing = false; // No known bugs, but needs performance testing

      var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
      // stuff. Intended to enable React core members to more easily debug scheduling
      // issues in DEV builds.

      var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
      }
      function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') {
          return true;
        } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === 'object' && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
          // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_SERVER_CONTEXT_TYPE:
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return undefined;
      }
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }
      function isConcurrentMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
            hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
          }
        }
        return false;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      function isSuspenseList(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      }
      exports.ContextConsumer = ContextConsumer;
      exports.ContextProvider = ContextProvider;
      exports.Element = Element;
      exports.ForwardRef = ForwardRef;
      exports.Fragment = Fragment;
      exports.Lazy = Lazy;
      exports.Memo = Memo;
      exports.Portal = Portal;
      exports.Profiler = Profiler;
      exports.StrictMode = StrictMode;
      exports.Suspense = Suspense;
      exports.SuspenseList = SuspenseList;
      exports.isAsyncMode = isAsyncMode;
      exports.isConcurrentMode = isConcurrentMode;
      exports.isContextConsumer = isContextConsumer;
      exports.isContextProvider = isContextProvider;
      exports.isElement = isElement;
      exports.isForwardRef = isForwardRef;
      exports.isFragment = isFragment;
      exports.isLazy = isLazy;
      exports.isMemo = isMemo;
      exports.isPortal = isPortal;
      exports.isProfiler = isProfiler;
      exports.isStrictMode = isStrictMode;
      exports.isSuspense = isSuspense;
      exports.isSuspenseList = isSuspenseList;
      exports.isValidElementType = isValidElementType;
      exports.typeOf = typeOf;
    })();
  }
},574,[],"node_modules/pretty-format/node_modules/react-is/cjs/react-is.development.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.test = exports.serialize = exports.default = void 0;
  var _markup = require(_dependencyMap[0], "./lib/markup");
  var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  // Child can be `number` in Stack renderer but not in Fiber renderer.

  const testSymbol = typeof Symbol === 'function' && Symbol.for ? Symbol.for('react.test.json') : 0xea71357;
  const getPropKeys = object => {
    const {
      props
    } = object;
    return props ? Object.keys(props).filter(key => props[key] !== undefined).sort() : [];
  };
  const serialize = (object, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config) : (0, _markup.printElement)(object.type, object.props ? (0, _markup.printProps)(getPropKeys(object), object.props, config, indentation + config.indent, depth, refs, printer) : '', object.children ? (0, _markup.printChildren)(object.children, config, indentation + config.indent, depth, refs, printer) : '', config, indentation);
  exports.serialize = serialize;
  const test = val => val && val.$$typeof === testSymbol;
  exports.test = test;
  const plugin = {
    serialize,
    test
  };
  var _default = plugin;
  exports.default = _default;
},575,[569],"node_modules/pretty-format/build/plugins/ReactTestComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /* eslint-env browser */

  // Setup websocket messages for reloading the page from the command line.
  // This is normally setup on the native client.

  if (__DEV__) {
    const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const messageSocket = new WebSocket(`${protocol}://${window.location.host}/message`);
    messageSocket.onmessage = message => {
      const data = JSON.parse(String(message.data));
      switch (data.method) {
        case 'sendDevCommand':
          switch (data.params.name) {
            case 'reload':
              window.location.reload();
              break;
            case 'rsc-reload':
              if (data.params.platform && data.params.platform !== "web") {
                return;
              }
              globalThis.__EXPO_RSC_RELOAD_LISTENERS__?.forEach(l => l());
              break;
            // Inject CSS modules from server components into the root client bundle in development.
            case 'module-import':
              {
                const {
                  data: moduleData
                } = data.params;
                // remove element with the same 'expo-module-id'
                const id = `expo-module-id="${moduleData.id}"`;
                const style = document.querySelector(`style[${id}]`);
                document.querySelector(`script[${id}]`)?.remove();
                const code = moduleData.code;
                const script = document.createElement('script');
                script.type = 'module';
                script.text = code;
                script.setAttribute('expo-module-id', moduleData.id);
                document.head.appendChild(script);
                if (style) {
                  // remove the previous block after the new one is loaded to mitigate FOUC.
                  queueMicrotask(() => style.parentElement?.removeChild(style));
                }
              }
              break;
          }
          break;
        case 'reload':
          window.location.reload();
          break;
        case 'devMenu':
          // no-op
          break;
      }
    };
  }
},576,[],"node_modules/expo/src/async-require/messageSocket.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "ImportMetaRegistry", {
    enumerable: true,
    get: function () {
      return ImportMetaRegistry;
    }
  });
  var _utilsGetBundleUrl = require(_dependencyMap[0], "../utils/getBundleUrl");
  // Copyright 2015-present 650 Industries. All rights reserved.

  /**
   * Registry to handle import.meta functionality for React Native environment
   * Similar to how it works in the web, but adapted for the RN context
   * https://github.com/wintercg/import-meta-registry
   */
  const ImportMetaRegistry = {
    get url() {
      return (0, _utilsGetBundleUrl.getBundleUrl)();
    }
  };
},577,[578],"node_modules/expo/src/winter/ImportMetaRegistry.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.getBundleUrl = getBundleUrl;
  // Copyright 2015-present 650 Industries. All rights reserved.

  function getBundleUrl() {
    let scriptURL = null;
    if (typeof window === 'undefined') {
      // For server runtime, we use the filename of the current script
      // @ts-ignore The react-native tsconfig doesn't support CJS
      scriptURL = 'file://' + __filename;
    } else {
      // TODO: Try to support `import.meta.url` when the ecosystem supports ESM,
      // and jest doesn't throw SyntaxError when accessing `import.meta`.
      scriptURL = document.currentScript?.src;
    }
    if (scriptURL == null) {
      return null;
    }
    const url = new URL(scriptURL);
    return `${url.protocol}//${url.host}${url.pathname}`;
  }
},578,[],"node_modules/expo/src/utils/getBundleUrl.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _buildAsyncRequire = require(_dependencyMap[0], "./buildAsyncRequire");
  /**
   * Copyright © 2024 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // @ts-ignore: ignore the global which may not always be defined in jest environments.
  global[`${global.__METRO_GLOBAL_PREFIX__ ?? ''}__loadBundleAsync`] = (0, _buildAsyncRequire.buildAsyncRequire)();
},579,[580],"node_modules/expo/src/async-require/index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.buildAsyncRequire = buildAsyncRequire;
  var _loadBundle = require(_dependencyMap[0], "./loadBundle");
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Must satisfy the requirements of the Metro bundler.
   * https://github.com/react-native-community/discussions-and-proposals/blob/main/proposals/0605-lazy-bundling.md#__loadbundleasync-in-metro
   */

  /** Create an `loadBundleAsync` function in the expected shape for Metro bundler. */
  function buildAsyncRequire() {
    const cache = new Map();
    return async function universal_loadBundleAsync(path) {
      if (cache.has(path)) {
        return cache.get(path);
      }
      const promise = (0, _loadBundle.loadBundleAsync)(path).catch(error => {
        cache.delete(path);
        throw error;
      });
      cache.set(path, promise);
      return promise;
    };
  }
},580,[581],"node_modules/expo/src/async-require/buildAsyncRequire.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.loadBundleAsync = loadBundleAsync;
  var _buildUrlForBundle = require(_dependencyMap[0], "./buildUrlForBundle");
  var _fetchThenEval = require(_dependencyMap[1], "./fetchThenEval");
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Load a bundle for a URL using fetch + eval on native and script tag injection on web.
   *
   * @param bundlePath Given a statement like `import('./Bacon')` `bundlePath` would be `Bacon.bundle?params=from-metro`.
   */
  async function loadBundleAsync(bundlePath) {
    const requestUrl = (0, _buildUrlForBundle.buildUrlForBundle)(bundlePath);
    if (process.env.NODE_ENV === 'production') {
      return (0, _fetchThenEval.fetchThenEvalAsync)(requestUrl);
    } else {
      return (0, _fetchThenEval.fetchThenEvalAsync)(requestUrl).then(() => {
        const HMRClient = require(_dependencyMap[2], "./hmr").default;
        HMRClient.registerBundle(requestUrl);
      });
    }
  }
},581,[582,584,559],"node_modules/expo/src/async-require/loadBundle.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.buildUrlForBundle = buildUrlForBundle;
  var _getDevServer = require(_dependencyMap[0], "./getDevServer");
  var getDevServer = _interopDefault(_getDevServer);
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Given a path and some optional additional query parameters, create the dev server bundle URL.
   * @param bundlePath like `/foobar`
   * @param params like `{ platform: "web" }`
   * @returns a URL like "/foobar.bundle?platform=android&modulesOnly=true&runModule=false&runtimeBytecodeVersion=null"
   */
  function buildUrlForBundle(bundlePath) {
    if (/^https?:\/\//.test(bundlePath)) {
      return bundlePath;
    }
    const {
      url: baseURL
    } = (0, getDevServer.default)();
    return baseURL ? new URL(bundlePath, baseURL).toString() : `//${bundlePath.replace(/^\/+/, '')}`;
  }
},582,[583],"node_modules/expo/src/async-require/buildUrlForBundle.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  const getDevServer = () => {
    // Disable for SSR
    if (typeof window === 'undefined') {
      return {
        bundleLoadedFromServer: true,
        fullBundleUrl: '',
        url: ''
      };
    }
    return {
      // The bundle is always loaded from a server in the browser.
      bundleLoadedFromServer: true,
      /** URL but ensures that platform query param is added. */
      get fullBundleUrl() {
        if (document?.currentScript && 'src' in document.currentScript) {
          return document.currentScript.src;
        }
        const bundleUrl = new URL(location.href);
        bundleUrl.searchParams.set('platform', 'web');
        return bundleUrl.toString();
      },
      url: location.origin + location.pathname
    };
  };
  var _default = getDevServer;
},583,[],"node_modules/expo/src/async-require/getDevServer.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.fetchThenEvalAsync = fetchThenEvalAsync;
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const currentSrc = typeof document !== 'undefined' && document.currentScript ? 'src' in document.currentScript && document.currentScript.src || null : null;

  // Basically `__webpack_require__.l`.
  function fetchThenEvalAsync(url, {
    scriptType,
    nonce,
    crossOrigin
  } = {}) {
    if (typeof window === 'undefined' ||
    // In development, use the fetch/eval method to detect the server error codes and parse bundler errors for the error overlay.
    __DEV__) {
      return require(_dependencyMap[0], "./fetchThenEvalJs").fetchThenEvalAsync(url);
    }
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      if (scriptType) script.type = scriptType;
      if (nonce) script.setAttribute('nonce', nonce);
      // script.setAttribute('data-expo-metro', ...);
      script.src = url;
      if (crossOrigin && script.src.indexOf(window.location.origin + '/') !== 0) {
        script.crossOrigin = crossOrigin;
      }
      script.onload = () => {
        script.parentNode && script.parentNode.removeChild(script);
        resolve();
      };
      // Create a new error object to preserve the original stack trace.
      const error = new AsyncRequireError();

      // Server error or network error.
      script.onerror = ev => {
        let event;
        if (typeof ev === 'string') {
          event = {
            type: 'error',
            target: {
              // @ts-expect-error
              src: event
            }
          };
        } else {
          event = ev;
        }
        const errorType = event && (event.type === 'load' ? 'missing' : event.type);
        // @ts-expect-error
        const realSrc = event?.target?.src;
        error.message = 'Loading module ' + url + ' failed.\n(' + errorType + ': ' + realSrc + ')';
        error.type = errorType;
        error.request = realSrc;
        script.parentNode && script.parentNode.removeChild(script);
        reject(error);
      };
      if (script.src === currentSrc) {
        // NOTE(kitten): We always prevent `fetchThenEval` from loading the "current script".
        // This points at our entrypoint bundle, and we should never reload and reevaluate the
        // entrypoint bundle
        resolve();
      } else {
        document.head.appendChild(script);
      }
    });
  }
  class AsyncRequireError extends Error {
    name = 'AsyncRequireError';
  }
},584,[585],"node_modules/expo/src/async-require/fetchThenEval.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.fetchThenEvalAsync = fetchThenEvalAsync;
  var _errors = require(_dependencyMap[0], "./errors");
  var _fetchAsync = require(_dependencyMap[1], "./fetchAsync");
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Load a bundle for a URL using fetch + eval on native and script tag injection on web.
   *
   * @param url Given a statement like `import('./Bacon')` `bundlePath` would be `Bacon`.
   */
  function fetchThenEvalAsync(url) {
    return (0, _fetchAsync.fetchAsync)(url).then(({
      body,
      status,
      headers
    }) => {
      if (headers?.has?.('Content-Type') != null && headers.get('Content-Type').includes('application/json')) {
        // Errors are returned as JSON.
        throw new Error(JSON.parse(body).message || `Unknown error fetching '${url}'`);
      }
      if (status === 200) {
        // eslint-disable-next-line no-eval
        return eval(body);
      } else {
        // Format Metro errors if possible.
        if (process.env.NODE_ENV === 'development') {
          // body can be an error from Metro if a module is missing.
          // {"originModulePath":"/Users/evanbacon/Documents/GitHub/expo/.","targetModuleName":"./http://localhost:8081/node_modules/react-native/index.js","message":"..."}
          const error = jsonParseOptional(body);
          if (error) {
            // TODO: This is essentially like the Metro native red box errors. We should do a better job formatting them so
            // the user experience doesn't feel bad. This can be tested by loading a split bundle that results in a missing module error from Metro.
            throw new _errors.MetroServerError(error, url);
          }
        }
        throw new Error(`Failed to load split bundle from URL: ${url}\n${body}`);
      }
    });
  }
  function jsonParseOptional(json) {
    try {
      return JSON.parse(json);
    } catch {
      return null;
    }
  }
},585,[586,587],"node_modules/expo/src/async-require/fetchThenEvalJs.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "MetroServerError", {
    enumerable: true,
    get: function () {
      return MetroServerError;
    }
  });
  class MetroServerError extends Error {
    code = 'METRO_SERVER_ERROR';
    constructor(errorObject, url) {
      super(errorObject.message);
      this.name = 'MetroServerError';
      this.url = url;
      for (const key in errorObject) {
        this[key] = errorObject[key];
      }
    }
  }
},586,[],"node_modules/expo/src/async-require/errors.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.fetchAsync = fetchAsync;
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  async function fetchAsync(url) {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        // No real reason for this but we try to use this format for everything.
        'expo-platform': 'web'
      }
    });
    return {
      body: await response.text(),
      status: response.status,
      headers: response.headers
    };
  }
},587,[],"node_modules/expo/src/async-require/fetchAsync.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},588,[],"node_modules/expo/virtual/rsc.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.createErrorHandler = createErrorHandler;
  exports.disableErrorHandling = disableErrorHandling;
  function createErrorHandler(originalHandler) {
    return (error, isFatal) => originalHandler(error, isFatal);
  }

  /**
   * @hidden
   * @deprecated Will be removed in the future.
   */
  function disableErrorHandling() {}
},589,[],"node_modules/expo/src/errors/ExpoErrorManager.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return registerRootComponent;
    }
  });
  require(_dependencyMap[0], "../Expo.fx");
  var _reactNativeWebDistExportsAppRegistry = require(_dependencyMap[1], "react-native-web/dist/exports/AppRegistry");
  var AppRegistry = _interopDefault(_reactNativeWebDistExportsAppRegistry);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[2], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  // @needsAudit
  /**
   * Sets the initial React component to render natively in the app's root React Native view on Android, iOS, tvOS and the web.
   *
   * This method does the following:
   * - Invokes React Native's `AppRegistry.registerComponent`.
   * - Invokes React Native web's `AppRegistry.runApplication` on web to render to the root `index.html` file.
   * - Polyfills the `process.nextTick` function globally.
   *
   * This method also adds the following dev-only features that are removed in production bundles.
   * - Adds the Fast Refresh and bundle splitting indicator to the app.
   * - Asserts if the `expo-updates` package is misconfigured.
   * - Asserts if `react-native` is not aliased to `react-native-web` when running in the browser.
   * @param component The React component class that renders the rest of your app.
   * @see For information on how to setup `registerRootComponent` in an existing (bare) React Native app, see [Common questions](#rootregistercomponent-setup-for-existing-react-native-projects) below.
   */
  function registerRootComponent(component) {
    let qualifiedComponent = component;
    if (process.env.NODE_ENV !== 'production') {
      const {
        withDevTools
      } = require(_dependencyMap[3], "./withDevTools");
      qualifiedComponent = withDevTools(component);
    }
    AppRegistry.default.registerComponent('main', () => qualifiedComponent);
    // Skip querying the DOM if we're in a Node.js environment.
    if (Platform.default.OS === 'web' && typeof window !== 'undefined') {
      const rootTag = document.getElementById('root');
      if (process.env.NODE_ENV !== 'production') {
        if (!rootTag) {
          throw new Error('Required HTML element with id "root" was not found in the document HTML.');
        }
      }
      AppRegistry.default.runApplication('main', {
        rootTag,
        // Injected by SSR HTML tags.
        hydrate: globalThis.__EXPO_ROUTER_HYDRATE__
      });
    }
  }
},590,[551,500,14,591],"node_modules/expo/src/launch/registerRootComponent.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo\\src\\launch\\withDevTools.web.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.withDevTools = withDevTools;
  require(_dependencyMap[0], "react");
  var _environmentDevLoadingView = require(_dependencyMap[1], "../environment/DevLoadingView");
  var DevLoadingView = _interopDefault(_environmentDevLoadingView);
  var _reactJsxDevRuntime = require(_dependencyMap[2], "react/jsx-dev-runtime");
  function withDevTools(AppRootComponent) {
    function WithDevTools(props) {
      return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_reactJsxDevRuntime.Fragment, {
        children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(AppRootComponent, Object.assign({}, props), void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 11,
          columnNumber: 9
        }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(DevLoadingView.default, {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 12,
          columnNumber: 9
        }, this)]
      }, void 0, true);
    }
    if (process.env.NODE_ENV !== 'production') {
      const name = AppRootComponent.displayName || AppRootComponent.name || 'Anonymous';
      WithDevTools.displayName = `withDevTools(${name})`;
    }
    return WithDevTools;
  }
},591,[9,592,33],"node_modules/expo/src/launch/withDevTools.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo\\src\\environment\\DevLoadingView.web.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return DevLoadingView;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsNativeEventEmitter = require(_dependencyMap[1], "react-native-web/dist/exports/NativeEventEmitter");
  var NativeEventEmitter = _interopDefault(_reactNativeWebDistExportsNativeEventEmitter);
  var _reactJsxDevRuntime = require(_dependencyMap[2], "react/jsx-dev-runtime");
  const MIN_DURATION = 400;
  const ANIMATION_DURATION = 150;
  const emitter = new NativeEventEmitter.default({
    addListener() {},
    removeListeners() {}
  });
  function DevLoadingView() {
    const show = useFastRefresh();
    const timer = (0, _react.useRef)(null);
    const toast = (0, _react.useMemo)(() => /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 48 48",
      width: 24,
      height: 24,
      children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)("path", {
        fill: "#ECEDEE",
        d: "M36.764 1.716a1.477 1.477 0 0 0-2.325-.268L11.721 24.609c-1.464 1.493-.438 4.064 1.623 4.064h4.484a1 1 0 0 1 .889 1.46l-7.54 14.591a1.588 1.588 0 0 0 .059 1.56 1.477 1.477 0 0 0 2.325.268l22.718-23.161c1.464-1.493.438-4.064-1.623-4.064H28.53l8.295-16.051a1.588 1.588 0 0 0-.06-1.56Z"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 20,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 7
    }, this), []);
    const style = (0, _react.useMemo)(() => /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)("style", {
      dangerouslySetInnerHTML: {
        __html: `
.__expo_fast_refresh {  
  position: fixed;
  pointer-events: none;
  bottom: 8px;
  left: 8px;
  z-index: 9999;
  display: flex;
  background-color: #1B1D1E;
  border: 1px solid #4D5155;
  padding: 8px;
  border-radius: 8px;
  transition: all ${ANIMATION_DURATION}ms;
  opacity: 0; 
  filter: blur(4px); 
  transform: translateY(20%);
}

.__expo_fast_refresh_show { opacity: 1; filter: blur(0); transform: scale(1); }
`
      }
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 7
    }, this), []);
    const [isAnimating, setIsAnimating] = (0, _react.useState)(false);
    const [animationClass, setAnimationClass] = (0, _react.useState)('');
    const refreshIndicator = (0, _react.useMemo)(() => /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_reactJsxDevRuntime.Fragment, {
      children: [style, /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)("div", {
        className: '__expo_fast_refresh ' + animationClass,
        children: toast
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 66,
        columnNumber: 9
      }, this)]
    }, void 0, true), [animationClass, style, toast]);
    (0, _react.useEffect)(() => {
      timer.current && clearTimeout(timer.current);
      if (show) {
        setAnimationClass('__expo_fast_refresh_show');
      } else {
        setIsAnimating(true);
        setAnimationClass('');
        timer.current = setTimeout(() => {
          setIsAnimating(false);
        }, MIN_DURATION - ANIMATION_DURATION);
      }
      return () => {
        timer.current && clearTimeout(timer.current);
      };
    }, [show]);
    if (!isAnimating && !show) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_reactJsxDevRuntime.Fragment, {
      children: refreshIndicator
    }, void 0, false);
  }
  function useFastRefresh() {
    const [isShown, setShown] = (0, _react.useState)(false);
    const duration = (0, _react.useRef)(null);
    const timeout = (0, _react.useRef)(null);
    (0, _react.useEffect)(() => {
      function handleShowMessage() {
        setShown(true);
        duration.current = Date.now();
      }
      function handleHide() {
        // Bail out if the timeout is already set
        if (timeout.current) {
          return;
        }
        const timeVisible = duration.current ? Date.now() - duration.current : 0;
        const min = Math.max(0, MIN_DURATION - timeVisible);
        timeout.current = setTimeout(() => {
          timeout.current = null;
          setShown(false);
        }, min);
      }
      const show = emitter.addListener('devLoadingView:showMessage', handleShowMessage);
      const hide = emitter.addListener('devLoadingView:hide', handleHide);
      return () => {
        if (timeout.current) {
          clearTimeout(timeout.current);
          timeout.current = null;
        }
        show.remove();
        hide.remove();
      };
    }, [emitter]);
    return isShown;
  }
},592,[9,12,33],"node_modules/expo/src/environment/DevLoadingView.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.isRunningInExpoGo = isRunningInExpoGo;
  exports.getExpoGoProjectConfig = getExpoGoProjectConfig;
  function isRunningInExpoGo() {
    return false;
  }
  function getExpoGoProjectConfig() {
    return null;
  }
},593,[],"node_modules/expo/src/environment/ExpoGo.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "EventEmitter", {
    enumerable: true,
    get: function () {
      return _EventEmitter.EventEmitter;
    }
  });
  Object.defineProperty(exports, "NativeModule", {
    enumerable: true,
    get: function () {
      return _NativeModule.NativeModule;
    }
  });
  Object.defineProperty(exports, "SharedObject", {
    enumerable: true,
    get: function () {
      return _SharedObject.SharedObject;
    }
  });
  Object.defineProperty(exports, "SharedRef", {
    enumerable: true,
    get: function () {
      return _SharedRef.SharedRef;
    }
  });
  Object.defineProperty(exports, "Platform", {
    enumerable: true,
    get: function () {
      return _Platform2.default;
    }
  });
  Object.defineProperty(exports, "uuid", {
    enumerable: true,
    get: function () {
      return _uuid2.default;
    }
  });
  Object.defineProperty(exports, "requireNativeViewManager", {
    enumerable: true,
    get: function () {
      return _NativeViewManagerAdapter.requireNativeViewManager;
    }
  });
  Object.defineProperty(exports, "CodedError", {
    enumerable: true,
    get: function () {
      return _errorsCodedError.CodedError;
    }
  });
  Object.defineProperty(exports, "UnavailabilityError", {
    enumerable: true,
    get: function () {
      return _errorsUnavailabilityError.UnavailabilityError;
    }
  });
  Object.defineProperty(exports, "LegacyEventEmitter", {
    enumerable: true,
    get: function () {
      return _LegacyEventEmitter.LegacyEventEmitter;
    }
  });
  Object.defineProperty(exports, "NativeModulesProxy", {
    enumerable: true,
    get: function () {
      return _NativeModulesProxy2.default;
    }
  });
  require(_dependencyMap[0], "./sweet/setUpJsLogger.fx");
  require(_dependencyMap[1], "./polyfill");
  var _EventEmitter = require(_dependencyMap[2], "./EventEmitter");
  var _NativeModule = require(_dependencyMap[3], "./NativeModule");
  var _SharedObject = require(_dependencyMap[4], "./SharedObject");
  var _SharedRef = require(_dependencyMap[5], "./SharedRef");
  var _Platform = require(_dependencyMap[6], "./Platform");
  var _Platform2 = _interopDefault(_Platform);
  var _uuid = require(_dependencyMap[7], "./uuid");
  var _uuid2 = _interopDefault(_uuid);
  var _NativeViewManagerAdapter = require(_dependencyMap[8], "./NativeViewManagerAdapter");
  var _requireNativeModule = require(_dependencyMap[9], "./requireNativeModule");
  Object.keys(_requireNativeModule).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _requireNativeModule[k];
        }
      });
    }
  });
  var _registerWebModule = require(_dependencyMap[10], "./registerWebModule");
  Object.keys(_registerWebModule).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _registerWebModule[k];
        }
      });
    }
  });
  var _TypedArraysTypes = require(_dependencyMap[11], "./TypedArrays.types");
  Object.keys(_TypedArraysTypes).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _TypedArraysTypes[k];
        }
      });
    }
  });
  var _PermissionsInterface = require(_dependencyMap[12], "./PermissionsInterface");
  Object.keys(_PermissionsInterface).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _PermissionsInterface[k];
        }
      });
    }
  });
  var _PermissionsHook = require(_dependencyMap[13], "./PermissionsHook");
  Object.keys(_PermissionsHook).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _PermissionsHook[k];
        }
      });
    }
  });
  var _Refs = require(_dependencyMap[14], "./Refs");
  Object.keys(_Refs).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _Refs[k];
        }
      });
    }
  });
  var _hooksUseReleasingSharedObject = require(_dependencyMap[15], "./hooks/useReleasingSharedObject");
  Object.keys(_hooksUseReleasingSharedObject).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _hooksUseReleasingSharedObject[k];
        }
      });
    }
  });
  var _reload = require(_dependencyMap[16], "./reload");
  Object.keys(_reload).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _reload[k];
        }
      });
    }
  });
  var _errorsCodedError = require(_dependencyMap[17], "./errors/CodedError");
  var _errorsUnavailabilityError = require(_dependencyMap[18], "./errors/UnavailabilityError");
  var _LegacyEventEmitter = require(_dependencyMap[19], "./LegacyEventEmitter");
  var _NativeModulesProxy = require(_dependencyMap[20], "./NativeModulesProxy");
  var _NativeModulesProxy2 = _interopDefault(_NativeModulesProxy);
},594,[595,596,609,611,612,613,614,599,616,619,620,621,622,623,624,625,626,618,617,627,629],"node_modules/expo-modules-core/src/index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},595,[],"node_modules/expo-modules-core/src/sweet/setUpJsLogger.fx.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _dangerousInternal = require(_dependencyMap[0], "./dangerous-internal");
  (0, _dangerousInternal.installExpoGlobalPolyfill)();
},596,[597],"node_modules/expo-modules-core/src/polyfill/index.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.installExpoGlobalPolyfill = installExpoGlobalPolyfill;
  var _CoreModule = require(_dependencyMap[0], "./CoreModule");
  var _uuidIndexWeb = require(_dependencyMap[1], "../uuid/index.web");
  var uuid = _interopDefault(_uuidIndexWeb);
  var _tsDeclarationsGlobal = require(_dependencyMap[2], "../ts-declarations/global");
  Object.keys(_tsDeclarationsGlobal).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _tsDeclarationsGlobal[k];
        }
      });
    }
  });
  // jest-expo imports to this file directly without going through the global types
  // Exporting the types to let jest-expo to know the globalThis types

  function installExpoGlobalPolyfill() {
    if (globalThis.expo) return;
    globalThis.expo = {
      EventEmitter: _CoreModule.EventEmitter,
      NativeModule: _CoreModule.NativeModule,
      SharedObject: _CoreModule.SharedObject,
      SharedRef: _CoreModule.SharedRef,
      modules: globalThis.ExpoDomWebView?.expoModulesProxy ?? {},
      uuidv4: uuid.default.v4,
      uuidv5: uuid.default.v5,
      getViewConfig: () => {
        throw new Error('Method not implemented.');
      },
      reloadAppAsync: async () => {
        window.location.reload();
      },
      expoModulesCoreVersion: undefined,
      cacheDir: undefined,
      documentsDir: undefined
    };
  }
},597,[598,599,604],"node_modules/expo-modules-core/src/polyfill/dangerous-internal.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "EventEmitter", {
    enumerable: true,
    get: function () {
      return EventEmitter;
    }
  });
  Object.defineProperty(exports, "NativeModule", {
    enumerable: true,
    get: function () {
      return NativeModule;
    }
  });
  Object.defineProperty(exports, "SharedObject", {
    enumerable: true,
    get: function () {
      return SharedObject;
    }
  });
  Object.defineProperty(exports, "SharedRef", {
    enumerable: true,
    get: function () {
      return SharedRef;
    }
  });
  class EventEmitter {
    addListener(eventName, listener) {
      if (!this.listeners) {
        this.listeners = new Map();
      }
      if (!this.listeners?.has(eventName)) {
        this.listeners?.set(eventName, new Set());
      }
      const previousListenerCount = this.listenerCount(eventName);
      this.listeners?.get(eventName)?.add(listener);
      if (previousListenerCount === 0 && this.listenerCount(eventName) === 1) {
        this.startObserving(eventName);
      }
      return {
        remove: () => {
          this.removeListener(eventName, listener);
        }
      };
    }
    removeListener(eventName, listener) {
      const hasRemovedListener = this.listeners?.get(eventName)?.delete(listener);
      if (this.listenerCount(eventName) === 0 && hasRemovedListener) {
        this.stopObserving(eventName);
      }
    }
    removeAllListeners(eventName) {
      const previousListenerCount = this.listenerCount(eventName);
      this.listeners?.get(eventName)?.clear();
      if (previousListenerCount > 0) {
        this.stopObserving(eventName);
      }
    }
    emit(eventName, ...args) {
      const listeners = new Set(this.listeners?.get(eventName));
      listeners.forEach(listener => {
        // When the listener throws an error, don't stop the execution of subsequent listeners and
        // don't propagate the error to the `emit` function. The motivation behind this is that
        // errors thrown from a module or user's code shouldn't affect other modules' behavior.
        try {
          listener(...args);
        } catch (error) {
          console.error(error);
        }
      });
    }
    listenerCount(eventName) {
      return this.listeners?.get(eventName)?.size ?? 0;
    }
    startObserving(eventName) {}
    stopObserving(eventName) {}
  }
  class NativeModule extends EventEmitter {}
  class SharedObject extends EventEmitter {
    release() {
      // no-op on Web, but subclasses can override it if needed.
    }
  }
  class SharedRef extends SharedObject {
    nativeRefType = 'unknown';
  }
},598,[],"node_modules/expo-modules-core/src/polyfill/CoreModule.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _libSha = require(_dependencyMap[0], "./lib/sha1");
  var sha1 = _interopDefault(_libSha);
  var _libV = require(_dependencyMap[1], "./lib/v35");
  var v35 = _interopDefault(_libV);
  var _uuidTypes = require(_dependencyMap[2], "./uuid.types");
  function uuidv4() {
    if (
    // We use this code path in jest-expo.
    process.env.NODE_ENV === 'test' ||
    // Node.js has supported global crypto since v15.
    typeof crypto === 'undefined' &&
    // Only use abstract imports in server environments.
    typeof window === 'undefined') {
      // NOTE: Metro statically extracts all `require` statements to resolve them for environments
      // that don't support `require` natively. Here we check if we're running in a server environment
      // by using the standard `typeof window` check, then running `eval` to skip Metro's static
      // analysis and keep the `require` statement intact for runtime evaluation.
      // eslint-disable-next-line no-eval
      return eval('require')('node:crypto').randomUUID();
    }
    return crypto.randomUUID();
  }
  const uuid = {
    v4: uuidv4,
    v5: (0, v35.default)('v5', 0x50, sha1.default),
    namespace: _uuidTypes.Uuidv5Namespace
  };
  var _default = uuid;
},599,[600,601,603],"node_modules/expo-modules-core/src/uuid/index.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // Adapted from Chris Veness' SHA1 code at
  // http://www.movable-type.co.uk/scripts/sha1.html
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  function f(s, x, y, z) {
    switch (s) {
      case 0:
        return x & y ^ ~x & z;
      case 1:
        return x ^ y ^ z;
      case 2:
        return x & y ^ x & z ^ y & z;
      case 3:
        return x ^ y ^ z;
      default:
        return 0;
    }
  }
  function ROTL(x, n) {
    return x << n | x >>> 32 - n;
  }
  function sha1(bytes) {
    const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
    const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    if (typeof bytes == 'string') {
      const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
      bytes = new Array(msg.length);
      for (let i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
    }
    bytes.push(0x80);
    const l = bytes.length / 4 + 2;
    const N = Math.ceil(l / 16);
    const M = new Array(N);
    for (let i = 0; i < N; i++) {
      M[i] = new Array(16);
      for (let j = 0; j < 16; j++) {
        M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
      }
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
    for (let i = 0; i < N; i++) {
      const W = new Array(80);
      for (let t = 0; t < 16; t++) W[t] = M[i][t];
      for (let t = 16; t < 80; t++) {
        W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
      }
      let a = H[0];
      let b = H[1];
      let c = H[2];
      let d = H[3];
      let e = H[4];
      for (let t = 0; t < 80; t++) {
        const s = Math.floor(t / 20);
        const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
        e = d;
        d = c;
        c = ROTL(b, 30) >>> 0;
        b = a;
        a = T;
      }
      H[0] = H[0] + a >>> 0;
      H[1] = H[1] + b >>> 0;
      H[2] = H[2] + c >>> 0;
      H[3] = H[3] + d >>> 0;
      H[4] = H[4] + e >>> 0;
    }
    return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
  }
  var _default = sha1;
},600,[],"node_modules/expo-modules-core/src/uuid/lib/sha1.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _ref;
    }
  });
  var _bytesToUuid = require(_dependencyMap[0], "./bytesToUuid");
  var bytesToUuid = _interopDefault(_bytesToUuid);
  function uuidToBytes(uuid) {
    // Note: We assume we're being passed a valid uuid string
    const bytes = [];
    uuid.replace(/[a-fA-F0-9]{2}/g, hex => {
      bytes.push(parseInt(hex, 16));
      return '';
    });
    return bytes;
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    const bytes = new Array(str.length);
    for (let i = 0; i < str.length; i++) {
      bytes[i] = str.charCodeAt(i);
    }
    return bytes;
  }
  function _ref(name, version, hashfunc) {
    const generateUUID = function (value, namespace, buf, offset) {
      const off = buf && offset || 0;
      if (typeof value == 'string') value = stringToBytes(value);
      if (typeof namespace == 'string') namespace = uuidToBytes(namespace);
      if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
      if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values');

      // Per 4.3
      const bytes = hashfunc(namespace.concat(value));
      bytes[6] = bytes[6] & 0x0f | version;
      bytes[8] = bytes[8] & 0x3f | 0x80;
      if (buf) {
        for (let idx = 0; idx < 16; ++idx) {
          buf[off + idx] = bytes[idx];
        }
      }
      return (0, bytesToUuid.default)(bytes);
    };

    // Function#name is not settable on some platforms (#270)
    try {
      generateUUID.name = name;
    } catch {}

    // Pre-defined namespaces, per Appendix C
    generateUUID.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    generateUUID.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
    return generateUUID;
  }
},601,[602],"node_modules/expo-modules-core/src/uuid/lib/v35.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */
  const byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substr(1);
  }
  function bytesToUuid(buf, offset) {
    let i = offset || 0;
    const bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
  }
  var _default = bytesToUuid;
},602,[],"node_modules/expo-modules-core/src/uuid/lib/bytesToUuid.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "Uuidv5Namespace", {
    enumerable: true,
    get: function () {
      return Uuidv5Namespace;
    }
  });
  /**
   * Collection of utilities used for generating Universally Unique Identifiers.
   */
  /**
   * Default namespaces for UUID v5 defined in RFC 4122
   */
  let Uuidv5Namespace = /*#__PURE__*/function (Uuidv5Namespace) {
    // Source of the UUIDs: https://datatracker.ietf.org/doc/html/rfc4122
    Uuidv5Namespace["dns"] = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    Uuidv5Namespace["url"] = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    Uuidv5Namespace["oid"] = "6ba7b812-9dad-11d1-80b4-00c04fd430c8";
    Uuidv5Namespace["x500"] = "6ba7b814-9dad-11d1-80b4-00c04fd430c8";
    return Uuidv5Namespace;
  }({});
},603,[],"node_modules/expo-modules-core/src/uuid/uuid.types.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0], "./EventEmitter");
  require(_dependencyMap[1], "./NativeModule");
  require(_dependencyMap[2], "./SharedObject");
  require(_dependencyMap[3], "./SharedRef");
},604,[605,606,607,608],"node_modules/expo-modules-core/src/ts-declarations/global.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},605,[],"node_modules/expo-modules-core/src/ts-declarations/EventEmitter.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},606,[],"node_modules/expo-modules-core/src/ts-declarations/NativeModule.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},607,[],"node_modules/expo-modules-core/src/ts-declarations/SharedObject.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},608,[],"node_modules/expo-modules-core/src/ts-declarations/SharedRef.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "EventEmitter", {
    enumerable: true,
    get: function () {
      return EventEmitter;
    }
  });
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0], "./ensureNativeModulesAreInstalled");
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();

  /**
   * A subscription object that allows to conveniently remove an event listener from the emitter.
   */

  const EventEmitter = globalThis.expo.EventEmitter;
},609,[610],"node_modules/expo-modules-core/src/EventEmitter.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.ensureNativeModulesAreInstalled = ensureNativeModulesAreInstalled;
  require(_dependencyMap[0], "./polyfill");
  // Installs the expo global on web

  /**
   * Ensures that the native modules are installed in the current runtime.
   * Otherwise, it synchronously calls a native function that installs them.
   */
  function ensureNativeModulesAreInstalled() {
    // No-op on web
  }
},610,[596],"node_modules/expo-modules-core/src/ensureNativeModulesAreInstalled.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "NativeModule", {
    enumerable: true,
    get: function () {
      return NativeModule;
    }
  });
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0], "./ensureNativeModulesAreInstalled");
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
  const NativeModule = globalThis.expo.NativeModule;
},611,[610],"node_modules/expo-modules-core/src/NativeModule.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "SharedObject", {
    enumerable: true,
    get: function () {
      return SharedObject;
    }
  });
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0], "./ensureNativeModulesAreInstalled");
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
  const SharedObject = globalThis.expo.SharedObject;
},612,[610],"node_modules/expo-modules-core/src/SharedObject.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "SharedRef", {
    enumerable: true,
    get: function () {
      return SharedRef;
    }
  });
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0], "./ensureNativeModulesAreInstalled");
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
  const SharedRef = globalThis.expo.SharedRef;
},613,[610],"node_modules/expo-modules-core/src/SharedRef.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[0], "react-native-web/dist/exports/Platform");
  var ReactNativePlatform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _environmentBrowser = require(_dependencyMap[1], "./environment/browser");
  if (__DEV__ && typeof "web" === 'undefined') {
    console.warn(`The global process.env.EXPO_OS is not defined. This should be inlined by babel-preset-expo during transformation.`);
  }
  const nativeSelect = typeof window !== 'undefined' ? ReactNativePlatform.default.select :
  // process.env.EXPO_OS is injected by `babel-preset-expo` and available in both client and `react-server` environments.
  // Opt to use the env var when possible, and fallback to the React Native Platform module when it's not (arbitrary bundlers and transformers).
  function select(specifics) {
    if (!"web") return undefined;
    if (specifics.hasOwnProperty("web")) {
      return specifics["web"];
    } else if (false && specifics.hasOwnProperty('native')) {
      return specifics.native;
    } else if (specifics.hasOwnProperty('default')) {
      return specifics.default;
    }
    // do nothing...
    return undefined;
  };
  const Platform = {
    /**
     * Denotes the currently running platform.
     * Can be one of ios, android, web.
     */
    OS: "web" || ReactNativePlatform.default.OS,
    /**
     * Returns the value with the matching platform.
     * Object keys can be any of ios, android, native, web, default.
     *
     * @ios ios, native, default
     * @android android, native, default
     * @web web, default
     */
    select: nativeSelect,
    /**
     * Denotes if the DOM API is available in the current environment.
     * The DOM is not available in native React runtimes and Node.js.
     */
    isDOMAvailable: _environmentBrowser.isDOMAvailable,
    /**
     * Denotes if the current environment can attach event listeners
     * to the window. This will return false in native React
     * runtimes and Node.js.
     */
    canUseEventListeners: _environmentBrowser.canUseEventListeners,
    /**
     * Denotes if the current environment can inspect properties of the
     * screen on which the current window is being rendered. This will
     * return false in native React runtimes and Node.js.
     */
    canUseViewport: _environmentBrowser.canUseViewport,
    /**
     * If the JavaScript is being executed in a remote JavaScript environment.
     * When `true`, synchronous native invocations cannot be executed.
     */
    isAsyncDebugging: _environmentBrowser.isAsyncDebugging
  };
  var _default = Platform;
},614,[14,615],"node_modules/expo-modules-core/src/Platform.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "isDOMAvailable", {
    enumerable: true,
    get: function () {
      return isDOMAvailable;
    }
  });
  Object.defineProperty(exports, "canUseEventListeners", {
    enumerable: true,
    get: function () {
      return canUseEventListeners;
    }
  });
  Object.defineProperty(exports, "canUseViewport", {
    enumerable: true,
    get: function () {
      return canUseViewport;
    }
  });
  Object.defineProperty(exports, "isAsyncDebugging", {
    enumerable: true,
    get: function () {
      return isAsyncDebugging;
    }
  });
  // Used for delegating node actions when browser APIs aren't available
  // like in SSR websites.
  const isDOMAvailable = typeof window !== 'undefined' && !!window.document?.createElement;
  const canUseEventListeners = isDOMAvailable && !!(window.addEventListener || window.attachEvent);
  const canUseViewport = isDOMAvailable && !!window.screen;
  const isAsyncDebugging = false;
},615,[],"node_modules/expo-modules-core/src/environment/browser.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.requireNativeViewManager = requireNativeViewManager;
  var _errorsUnavailabilityError = require(_dependencyMap[0], "./errors/UnavailabilityError");
  /**
   * A drop-in replacement for `requireNativeComponent`.
   */
  function requireNativeViewManager(moduleName, viewName) {
    throw new _errorsUnavailabilityError.UnavailabilityError('expo-modules-core', 'requireNativeViewManager');
  }
},616,[617],"node_modules/expo-modules-core/src/NativeViewManagerAdapter.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "UnavailabilityError", {
    enumerable: true,
    get: function () {
      return UnavailabilityError;
    }
  });
  var _CodedError = require(_dependencyMap[0], "./CodedError");
  var _Platform = require(_dependencyMap[1], "../Platform");
  var Platform = _interopDefault(_Platform);
  /**
   * A class for errors to be thrown when a property is accessed which is
   * unavailable, unsupported, or not currently implemented on the running
   * platform.
   */
  class UnavailabilityError extends _CodedError.CodedError {
    constructor(moduleName, propertyName) {
      super('ERR_UNAVAILABLE', `The method or property ${moduleName}.${propertyName} is not available on ${Platform.default.OS}, are you sure you've linked all the native dependencies properly?`);
    }
  }
},617,[618,614],"node_modules/expo-modules-core/src/errors/UnavailabilityError.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "CodedError", {
    enumerable: true,
    get: function () {
      return CodedError;
    }
  });
  /**
   * A general error class that should be used for all errors in Expo modules.
   * Guarantees a `code` field that can be used to differentiate between different
   * types of errors without further subclassing Error.
   */
  class CodedError extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
    }
  }
},618,[],"node_modules/expo-modules-core/src/errors/CodedError.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.requireNativeModule = requireNativeModule;
  exports.requireOptionalNativeModule = requireOptionalNativeModule;
  function requireNativeModule(moduleName) {
    const nativeModule = requireOptionalNativeModule(moduleName);
    if (nativeModule != null) {
      return nativeModule;
    }
    if (typeof window === 'undefined') {
      // For SSR, we expect not to have native modules available, but to avoid crashing from SSR resolutions, we return an empty object.
      return {};
    }
    throw new Error(`Cannot find native module '${moduleName}'`);
  }
  function requireOptionalNativeModule(moduleName) {
    if (typeof globalThis.ExpoDomWebView === 'object' && globalThis?.expo?.modules != null) {
      return globalThis.expo?.modules?.[moduleName] ?? null;
    }
    return null;
  }
},619,[],"node_modules/expo-modules-core/src/requireNativeModule.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.registerWebModule = registerWebModule;
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0], "./ensureNativeModulesAreInstalled");
  /**
   * Registers a web module.
   * @param moduleImplementation A class that extends `NativeModule`. The class is registered under `globalThis.expo.modules[className]`.
   * @param moduleName – a name to register the module under `globalThis.expo.modules[className]`.
   * @returns A singleton instance of the class passed into arguments.
   */

  function registerWebModule(moduleImplementation, moduleName) {
    (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
    moduleName = moduleName ?? moduleImplementation.name;
    if (!moduleName) {
      throw new Error('Web module implementation is missing a name - it is either not a class or has been minified. Pass the name as a second argument to the `registerWebModule` function.');
    }
    if (!globalThis?.expo?.modules) {
      globalThis.expo.modules = {};
    }
    if (globalThis.expo.modules[moduleName]) {
      return globalThis.expo.modules[moduleName];
    }
    globalThis.expo.modules[moduleName] = new moduleImplementation();
    return globalThis.expo.modules[moduleName];
  }
},620,[610],"node_modules/expo-modules-core/src/registerWebModule.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},621,[],"node_modules/expo-modules-core/src/TypedArrays.types.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "PermissionStatus", {
    enumerable: true,
    get: function () {
      return PermissionStatus;
    }
  });
  let PermissionStatus = /*#__PURE__*/function (PermissionStatus) {
    /**
     * User has granted the permission.
     */
    PermissionStatus["GRANTED"] = "granted";
    /**
     * User hasn't granted or denied the permission yet.
     */
    PermissionStatus["UNDETERMINED"] = "undetermined";
    /**
     * User has denied the permission.
     */
    PermissionStatus["DENIED"] = "denied";
    return PermissionStatus;
  }({});
  /**
   * Permission expiration time. Currently, all permissions are granted permanently.
   */
  /**
   * An object obtained by permissions get and request functions.
   */
},622,[],"node_modules/expo-modules-core/src/PermissionsInterface.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // Copyright © 2024 650 Industries.

  'use client';
  "use strict";

  const _excluded = ["get", "request"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.createPermissionHook = createPermissionHook;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1], "react");
  // These types are identical, but improves the readability for suggestions in editors

  /**
   * Get or request permission for protected functionality within the app.
   * It uses separate permission requesters to interact with a single permission.
   * By default, the hook will only retrieve the permission status.
   */
  function usePermission(methods, options) {
    const isMounted = (0, _react.useRef)(true);
    const [status, setStatus] = (0, _react.useState)(null);
    const _ref = options || {},
      {
        get = true,
        request = false
      } = _ref,
      permissionOptions = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const getPermission = (0, _react.useCallback)(async () => {
      let response;
      if (Object.keys(permissionOptions).length > 0) {
        response = await methods.getMethod(permissionOptions);
      } else {
        response = await methods.getMethod();
      }
      if (isMounted.current) setStatus(response);
      return response;
    }, [methods.getMethod]);
    const requestPermission = (0, _react.useCallback)(async () => {
      let response;
      if (Object.keys(permissionOptions).length > 0) {
        response = await methods.requestMethod(permissionOptions);
      } else {
        response = await methods.requestMethod();
      }
      if (isMounted.current) setStatus(response);
      return response;
    }, [methods.requestMethod]);
    (0, _react.useEffect)(function runMethods() {
      if (request) requestPermission();
      if (!request && get) getPermission();
    }, [get, request, requestPermission, getPermission]);

    // Workaround for unmounting components receiving state updates
    (0, _react.useEffect)(function didMount() {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return [status, requestPermission, getPermission];
  }

  /**
   * Create a new permission hook with the permission methods built-in.
   * This can be used to quickly create specific permission hooks in every module.
   */
  function createPermissionHook(methods) {
    return options => usePermission(methods, options);
  }
},623,[759,9],"node_modules/expo-modules-core/src/PermissionsHook.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.createSnapshotFriendlyRef = createSnapshotFriendlyRef;
  var _react = require(_dependencyMap[0], "react");
  /**
   * Create a React ref object that is friendly for snapshots.
   * It will be represented as `[React.ref]` in snapshots.
   * @returns A React ref object.
   */
  function createSnapshotFriendlyRef() {
    return /*#__PURE__*/(0, _react.createRef)();
  }
},624,[9],"node_modules/expo-modules-core/src/Refs.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.useReleasingSharedObject = useReleasingSharedObject;
  var _react = require(_dependencyMap[0], "react");
  /**
   * Returns a shared object, which is automatically cleaned up when the component is unmounted.
   */
  function useReleasingSharedObject(factory, dependencies) {
    const objectRef = (0, _react.useRef)(null);
    const isFastRefresh = (0, _react.useRef)(false);
    const previousDependencies = (0, _react.useRef)(dependencies);
    if (objectRef.current == null) {
      objectRef.current = factory();
    }
    const object = (0, _react.useMemo)(() => {
      let newObject = objectRef.current;
      const dependenciesAreEqual = previousDependencies.current?.length === dependencies.length && dependencies.every((value, index) => value === previousDependencies.current[index]);

      // If the dependencies have changed, release the previous object and create a new one, otherwise this has been called
      // because of an unrelated fast refresh, and we don't want to release the object.
      if (!newObject || !dependenciesAreEqual) {
        objectRef.current?.release();
        newObject = factory();
        objectRef.current = newObject;
        previousDependencies.current = dependencies;
      }
      return newObject;
    }, dependencies);
    (0, _react.useMemo)(() => {
      isFastRefresh.current = true;
    }, []);
    (0, _react.useEffect)(() => {
      isFastRefresh.current = false;
      return () => {
        // This will be called on every fast refresh and on unmount, but we only want to release the object on unmount.
        if (!isFastRefresh.current && objectRef.current) {
          objectRef.current.release();
        }
      };
    }, []);
    return object;
  }
},625,[9],"node_modules/expo-modules-core/src/hooks/useReleasingSharedObject.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.reloadAppAsync = reloadAppAsync;
  /**
   * Reloads the app. This method works for both release and debug builds.
   *
   * Unlike [`Updates.reloadAsync()`](/versions/latest/sdk/updates/#updatesreloadasync),
   * this function does not use a new update even if one is available. It only reloads the app using the same JavaScript bundle that is currently running.
   *
   * @param reason The reason for reloading the app. This is used only for some platforms.
   */
  async function reloadAppAsync(reason = 'Reloaded from JS call') {
    await globalThis.expo?.reloadAppAsync(reason);
  }
},626,[],"node_modules/expo-modules-core/src/reload.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "LegacyEventEmitter", {
    enumerable: true,
    get: function () {
      return LegacyEventEmitter;
    }
  });
  var _invariant = require(_dependencyMap[0], "invariant");
  var invariant = _interopDefault(_invariant);
  var _reactNativeWebDistExportsNativeEventEmitter = require(_dependencyMap[1], "react-native-web/dist/exports/NativeEventEmitter");
  var NativeEventEmitter = _interopDefault(_reactNativeWebDistExportsNativeEventEmitter);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[2], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  const nativeEmitterSubscriptionKey = '@@nativeEmitterSubscription@@';
  /**
   * @deprecated Deprecated in favor of `EventEmitter`.
   */
  class LegacyEventEmitter {
    _listenerCount = 0;

    // @ts-expect-error

    // @ts-expect-error

    constructor(nativeModule) {
      // If the native module is a new module, just return it back as it's already an event emitter.
      // This is for backwards compatibility until we stop using this legacy class in other packages.
      if (nativeModule.__expo_module_name__) {
        // @ts-expect-error
        return nativeModule;
      }
      this._nativeModule = nativeModule;
      this._eventEmitter = new NativeEventEmitter.default(nativeModule);
    }
    addListener(eventName, listener) {
      if (!this._listenerCount && Platform.default.OS !== 'ios' && this._nativeModule.startObserving) {
        this._nativeModule.startObserving();
      }
      this._listenerCount++;
      const nativeEmitterSubscription = this._eventEmitter.addListener(eventName, listener);
      const subscription = {
        [nativeEmitterSubscriptionKey]: nativeEmitterSubscription,
        remove: () => {
          this.removeSubscription(subscription);
        }
      };
      return subscription;
    }
    removeAllListeners(eventName) {
      // @ts-ignore: the EventEmitter interface has been changed in react-native@0.64.0
      const removedListenerCount = this._eventEmitter.listenerCount ?
      // @ts-ignore: this is available since 0.64
      this._eventEmitter.listenerCount(eventName) :
      // @ts-ignore: this is available in older versions
      this._eventEmitter.listeners(eventName).length;
      this._eventEmitter.removeAllListeners(eventName);
      this._listenerCount -= removedListenerCount;
      (0, invariant.default)(this._listenerCount >= 0, `EventEmitter must have a non-negative number of listeners`);
      if (!this._listenerCount && Platform.default.OS !== 'ios' && this._nativeModule.stopObserving) {
        this._nativeModule.stopObserving();
      }
    }
    removeSubscription(subscription) {
      const state = subscription;
      const nativeEmitterSubscription = state[nativeEmitterSubscriptionKey];
      if (!nativeEmitterSubscription) {
        return;
      }
      if ('remove' in nativeEmitterSubscription) {
        nativeEmitterSubscription.remove?.();
      }
      this._listenerCount--;

      // Ensure that the emitter's internal state remains correct even if `removeSubscription` is
      // called again with the same subscription
      delete state[nativeEmitterSubscriptionKey];

      // Release closed-over references to the emitter
      subscription.remove = () => {};
      if (!this._listenerCount && Platform.default.OS !== 'ios' && this._nativeModule.stopObserving) {
        this._nativeModule.stopObserving();
      }
    }
    emit(eventName, ...params) {
      this._eventEmitter.emit(eventName, ...params);
    }
  }
},627,[628,12,14],"node_modules/expo-modules-core/src/LegacyEventEmitter.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */
  var invariant = function (condition, format, a, b, c, d, e, f) {
    if (process.env.NODE_ENV !== 'production') {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }
      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  };
  module.exports = invariant;
},628,[],"node_modules/invariant/browser.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  // We default to an empty object shim wherever we don't have an environment-specific implementation

  /**
   * @deprecated `NativeModulesProxy` is deprecated and might be removed in the future releases.
   * Use `requireNativeModule` or `requireOptionalNativeModule` instead.
   */
  var _default = {};
},629,[],"node_modules/expo-modules-core/src/NativeModulesProxy.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.useEvent = useEvent;
  exports.useEventListener = useEventListener;
  var _react = require(_dependencyMap[0], "react");
  /**
   * Type helper that infers the event name from the emitter's events map.
   */

  /**
   * Type helper that infers the event listener from the emitter's events map.
   */

  /**
   * Type helper that infers the first parameter of the event listener.
   */

  /**
   * React hook that listens to events emitted by the given object. The returned value is an event parameter
   * that gets updated whenever a new event is dispatched.
   * @param eventEmitter An object that emits events. For example, a native module or shared object or an instance of [`EventEmitter`](#eventemitter).
   * @param eventName Name of the event to listen to.
   * @param initialValue An event parameter to use until the event is called for the first time.
   * @returns A parameter of the event listener.
   * @example
   * ```tsx
   * import { useEvent } from 'expo';
   * import { VideoPlayer } from 'expo-video';
   *
   * export function PlayerStatus({ videoPlayer }: { videoPlayer: VideoPlayer }) {
   *   const { status } = useEvent(videoPlayer, 'statusChange', { status: videoPlayer.status });
   *
   *   return <Text>{`Player status: ${status}`}</Text>;
   * }
   * ```
   */
  function useEvent(eventEmitter, eventName, initialValue = null) {
    const [event, setEvent] = (0, _react.useState)(initialValue);
    const listener = event => setEvent(event);
    useEventListener(eventEmitter, eventName, listener);
    return event;
  }

  /**
   * React hook that listens to events emitted by the given object and calls the listener function whenever a new event is dispatched.
   * The event listener is automatically added during the first render and removed when the component unmounts.
   * @param eventEmitter An object that emits events. For example, a native module or shared object or an instance of [`EventEmitter`](#eventemitter).
   * @param eventName Name of the event to listen to.
   * @param listener A function to call when the event is dispatched.
   * @example
   * ```tsx
   * import { useEventListener } from 'expo';
   * import { useVideoPlayer, VideoView } from 'expo-video';
   *
   * export function VideoPlayerView() {
   *   const player = useVideoPlayer(videoSource);
   *
   *   useEventListener(player, 'playingChange', ({ isPlaying }) => {
   *     console.log('Player is playing:', isPlaying);
   *   });
   *
   *   return <VideoView player={player} />;
   * }
   * ```
   */
  function useEventListener(eventEmitter, eventName, listener) {
    // Always use the most recent version of the listener inside the effect,
    // without memoization so the listeners don't have to be swapped with every render.
    const listenerRef = (0, _react.useRef)(listener);
    listenerRef.current = listener;
    (0, _react.useEffect)(() => {
      const callback = (...args) => listenerRef.current(...args);
      const subscription = eventEmitter.addListener(eventName, callback);
      return () => subscription.remove();
    }, [eventEmitter, eventName, listenerRef]);
  }
},630,[9],"node_modules/expo/src/hooks/useEvent.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Copyright © 2024 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NetworkError = exports.ReactServerError = exports.MetroServerError = void 0;
  class MetroServerError extends Error {
    code = 'METRO_SERVER_ERROR';
    constructor(errorObject, url) {
      super(errorObject.message);
      this.url = url;
      this.name = 'MetroServerError';
      for (const key in errorObject) {
        this[key] = errorObject[key];
      }
    }
  }
  exports.MetroServerError = MetroServerError;
  class ReactServerError extends Error {
    code = 'REACT_SERVER_ERROR';
    constructor(message, url, statusCode, /** Response headers from the server. */
    headers) {
      super(message);
      this.url = url;
      this.statusCode = statusCode;
      this.headers = headers;
      this.name = 'ReactServerError';
    }
  }
  exports.ReactServerError = ReactServerError;
  class NetworkError extends Error {
    code = 'NETWORK_ERROR';
    constructor(message, url) {
      super(message);
      this.url = url;
      this.name = 'NetworkError';
    }
  }
  exports.NetworkError = NetworkError;
},631,[],"node_modules/expo-router/build/rsc/router/errors.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Protected = void 0;
  exports.isProtectedReactElement = isProtectedReactElement;
  const react_1 = require(_dependencyMap[0], "react");
  const primitives_1 = require(_dependencyMap[1], "../primitives");
  exports.Protected = primitives_1.Group;
  function isProtectedReactElement(child) {
    return Boolean((0, react_1.isValidElement)(child) && child.type === primitives_1.Group && child.props && 'guard' in child.props);
  }
},632,[9,391],"node_modules/expo-router/build/views/Protected.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Screen = Screen;
  exports.isScreen = isScreen;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const react_1 = require(_dependencyMap[1], "react");
  const useNavigation_1 = require(_dependencyMap[2], "../useNavigation");
  const useSafeLayoutEffect_1 = require(_dependencyMap[3], "./useSafeLayoutEffect");
  const stack_1 = require(_dependencyMap[4], "../utils/stack");
  /** Component for setting the current screen's options dynamically. */
  function Screen({
    name,
    options
  }) {
    if (name) {
      throw new Error(`The name prop on the Screen component may only be used when it is inside a Layout route`);
    }
    const route = (0, native_1.useRoute)();
    const navigation = (0, useNavigation_1.useNavigation)();
    const isFocused = navigation.isFocused();
    const isPreloaded = (0, stack_1.isRoutePreloadedInStack)(navigation.getState(), route);
    (0, useSafeLayoutEffect_1.useSafeLayoutEffect)(() => {
      if (options && Object.keys(options).length) {
        // React Navigation will infinitely loop in some cases if an empty object is passed to setOptions.
        // https://github.com/expo/router/issues/452
        if (!isPreloaded || isPreloaded && isFocused) {
          navigation.setOptions(options);
        }
      }
    }, [isFocused, isPreloaded, navigation, options]);
    return null;
  }
  function isScreen(child, contextKey) {
    if ((0, react_1.isValidElement)(child) && child && child.type === Screen) {
      if (typeof child.props === 'object' && child.props && 'name' in child.props && !child.props.name) {
        throw new Error(`<Screen /> component in \`default export\` at \`app${contextKey}/_layout\` must have a \`name\` prop when used as a child of a Layout Route.`);
      }
      if (process.env.NODE_ENV !== 'production') {
        if (['children', 'component', 'getComponent'].some(key => child.props && typeof child.props === 'object' && key in child.props)) {
          throw new Error(`<Screen /> component in \`default export\` at \`app${contextKey}/_layout\` must not have a \`children\`, \`component\`, or \`getComponent\` prop when used as a child of a Layout Route`);
        }
      }
      return true;
    }
    return false;
  }
},633,[253,9,634,386,641],"node_modules/expo-router/build/views/Screen.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useNavigation = useNavigation;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const utils_1 = require(_dependencyMap[1], "./global-state/utils");
  const href_1 = require(_dependencyMap[2], "./link/href");
  /**
   * Returns the underlying React Navigation [`navigation` object](https://reactnavigation.org/docs/navigation-object)
   * to imperatively access layout-specific functionality like `navigation.openDrawer()` in a
   * [Drawer](/router/advanced/drawer/) layout.
   *
   * @example
   * ```tsx app/index.tsx
   * import { useNavigation } from 'expo-router';
   *
   * export default function Route() {
   *   // Access the current navigation object for the current route.
   *   const navigation = useNavigation();
   *
   *   return (
   *     <View>
   *       <Text onPress={() => {
   *         // Open the drawer view.
   *         navigation.openDrawer();
   *       }}>
   *         Open Drawer
   *       </Text>
   *     </View>
   *   );
   * }
   * ```
   *
   * When using nested layouts, you can access higher-order layouts by passing a secondary argument denoting the layout route.
   * For example, `/menu/_layout.tsx` is nested inside `/app/orders/`, you can use `useNavigation('/orders/menu/')`.
   *
   * @example
   * ```tsx app/orders/menu/index.tsx
   * import { useNavigation } from 'expo-router';
   *
   * export default function MenuRoute() {
   *   const rootLayout = useNavigation('/');
   *   const ordersLayout = useNavigation('/orders');
   *
   *   // Same as the default results of `useNavigation()` when invoked in this route.
   *   const parentLayout = useNavigation('/orders/menu');
   * }
   * ```
   *
   * If you attempt to access a layout that doesn't exist, an error such as
   * `Could not find parent navigation with route "/non-existent"` is thrown.
   *
   *
   * @param parent Provide an absolute path such as `/(root)` to the parent route or a relative path like `../../` to the parent route.
   * @returns The navigation object for the current route.
   *
   * @see React Navigation documentation on [navigation dependent functions](https://reactnavigation.org/docs/navigation-object/#navigator-dependent-functions)
   * for more information.
   */
  function useNavigation(parent) {
    const rnNavigation = (0, native_1.useNavigation)();
    let navigation = rnNavigation;
    let state = (0, native_1.useStateForPath)();
    if (parent === undefined) {
      // If no parent is provided, return the current navigation object
      return navigation;
    }
    // Check for the top-level navigator - we cannot fetch anything higher!
    const currentId = navigation.getId();
    if (currentId === '' || currentId === `/expo-router/build/views/Navigator`) {
      return navigation;
    }
    if (typeof parent === 'object') {
      parent = (0, href_1.resolveHref)(parent);
    }
    if (parent === '/') {
      // This is the root navigator
      return navigation.getParent(`/expo-router/build/views/Navigator`) ?? navigation.getParent(``);
    } else if (parent?.startsWith('../')) {
      const names = [];
      while (state) {
        const route = state.routes[0];
        state = route.state;
        // Don't include the last router, as thats the current route
        if (state) {
          names.push(route.name);
        }
      }
      // Removing the trailing slash to make splitting easier
      const originalParent = parent;
      if (parent.endsWith('/')) {
        parent = parent.slice(0, -1);
      }
      const segments = parent.split('/');
      if (!segments.every(segment => segment === '..')) {
        throw new Error(`Invalid parent path "${originalParent}". Only "../" segments are allowed when using relative paths.`);
      }
      const levels = segments.length;
      const index = names.length - 1 - levels;
      if (index < 0) {
        throw new Error(`Invalid parent path "${originalParent}". Cannot go up ${levels} levels from the current route.`);
      }
      parent = names[index];
      // Expo Router navigators use the context key as the name which has a leading `/`
      // The exception to this are the root stack routes, and the root navigator which uses ''
      if (parent && !(0, utils_1.getRootStackRouteNames)().includes(parent)) {
        parent = `/${parent}`;
      }
    }
    navigation = navigation.getParent(parent);
    if (process.env.NODE_ENV !== 'production') {
      if (!navigation) {
        navigation = rnNavigation;
        const ids = [];
        while (navigation) {
          if (navigation.getId()) ids.push(navigation.getId());
          navigation = navigation.getParent();
        }
        throw new Error(`Could not find parent navigation with route "${parent}". Available routes are: '${ids.join("', '")}'`);
      }
    }
    return navigation;
  }
},634,[253,635,640],"node_modules/expo-router/build/useNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shouldAppendSitemap = shouldAppendSitemap;
  exports.shouldAppendNotFound = shouldAppendNotFound;
  exports.getRootStackRouteNames = getRootStackRouteNames;
  const expo_constants_1 = __importDefault(require(_dependencyMap[0], "expo-constants"));
  const constants_1 = require(_dependencyMap[1], "../constants");
  function shouldAppendSitemap() {
    const config = expo_constants_1.default.expoConfig?.extra?.router;
    return config?.sitemap !== false;
  }
  function shouldAppendNotFound() {
    const config = expo_constants_1.default.expoConfig?.extra?.router;
    return config?.notFound !== false;
  }
  function getRootStackRouteNames() {
    const routes = [constants_1.INTERNAL_SLOT_NAME];
    if (shouldAppendNotFound()) {
      routes.push(constants_1.NOT_FOUND_ROUTE_NAME);
    }
    if (shouldAppendSitemap()) {
      routes.push(constants_1.SITEMAP_ROUTE_NAME);
    }
    return routes;
  }
},635,[636,639],"node_modules/expo-router/build/global-state/utils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "AppOwnership", {
    enumerable: true,
    get: function () {
      return _ConstantsTypes.AppOwnership;
    }
  });
  Object.defineProperty(exports, "ExecutionEnvironment", {
    enumerable: true,
    get: function () {
      return _ConstantsTypes.ExecutionEnvironment;
    }
  });
  Object.defineProperty(exports, "UserInterfaceIdiom", {
    enumerable: true,
    get: function () {
      return _ConstantsTypes.UserInterfaceIdiom;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[2], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsNativeModules = require(_dependencyMap[3], "react-native-web/dist/exports/NativeModules");
  var NativeModules = _interopDefault(_reactNativeWebDistExportsNativeModules);
  var _ConstantsTypes = require(_dependencyMap[4], "./Constants.types");
  var _ExponentConstants = require(_dependencyMap[5], "./ExponentConstants");
  var ExponentConstants = _interopDefault(_ExponentConstants);
  if (!ExponentConstants.default) {
    console.warn("No native ExponentConstants module found, are you sure the expo-constants's module is linked properly?");
  }
  const ExpoUpdates = (0, _expoModulesCore.requireOptionalNativeModule)('ExpoUpdates');
  let rawUpdatesManifest = null;
  // If expo-updates defines a non-empty manifest, prefer that one
  if (ExpoUpdates) {
    let updatesManifest;
    if (ExpoUpdates.manifest) {
      updatesManifest = ExpoUpdates.manifest;
    } else if (ExpoUpdates.manifestString) {
      updatesManifest = JSON.parse(ExpoUpdates.manifestString);
    }
    if (updatesManifest && Object.keys(updatesManifest).length > 0) {
      rawUpdatesManifest = updatesManifest;
    }
  }
  // If dev-launcher defines a non-empty manifest, prefer that one
  let rawDevLauncherManifest = null;
  if (NativeModules.default.EXDevLauncher) {
    let devLauncherManifest;
    if (NativeModules.default.EXDevLauncher.manifestString) {
      devLauncherManifest = JSON.parse(NativeModules.default.EXDevLauncher.manifestString);
    }
    if (devLauncherManifest && Object.keys(devLauncherManifest).length > 0) {
      rawDevLauncherManifest = devLauncherManifest;
    }
  }
  // Fall back to ExponentConstants.manifest if we don't have one from Updates
  let rawAppConfig = null;
  if (ExponentConstants.default && ExponentConstants.default.manifest) {
    const appConfig = ExponentConstants.default.manifest;
    // On Android we pass the manifest in JSON form so this step is necessary
    if (typeof appConfig === 'string') {
      rawAppConfig = JSON.parse(appConfig);
    } else {
      rawAppConfig = appConfig;
    }
  }
  let rawManifest = rawUpdatesManifest ?? rawDevLauncherManifest ?? rawAppConfig;
  const _ref = ExponentConstants.default || {},
    {
      appOwnership
    } = _ref,
    nativeConstants = (0, _objectWithoutPropertiesLoose.default)(_ref, ["name", "appOwnership"]);
  const constants = Object.assign({}, nativeConstants, {
    // Ensure this is null in bare workflow
    appOwnership: appOwnership ?? null
  });
  Object.defineProperties(constants, {
    /**
     * Use `manifest` property by default.
     * This property is only used for internal purposes.
     * It behaves similarly to the original one, but suppresses warning upon no manifest available.
     * `expo-asset` uses it to prevent users from seeing mentioned warning.
     */
    __unsafeNoWarnManifest: {
      get() {
        const maybeManifest = getManifest(true);
        if (!maybeManifest || !isEmbeddedManifest(maybeManifest)) {
          return null;
        }
        return maybeManifest;
      },
      enumerable: false
    },
    __unsafeNoWarnManifest2: {
      get() {
        const maybeManifest = getManifest(true);
        if (!maybeManifest || !isExpoUpdatesManifest(maybeManifest)) {
          return null;
        }
        return maybeManifest;
      },
      enumerable: false
    },
    manifest: {
      get() {
        const maybeManifest = getManifest();
        if (!maybeManifest || !isEmbeddedManifest(maybeManifest)) {
          return null;
        }
        return maybeManifest;
      },
      enumerable: true
    },
    manifest2: {
      get() {
        const maybeManifest = getManifest();
        if (!maybeManifest || !isExpoUpdatesManifest(maybeManifest)) {
          return null;
        }
        return maybeManifest;
      },
      enumerable: true
    },
    expoConfig: {
      get() {
        const maybeManifest = getManifest(true);
        if (!maybeManifest) {
          return null;
        }
        // if running an embedded update, maybeManifest is a EmbeddedManifest which doesn't have
        // the expo config. Instead, the embedded expo-constants app.config should be used.
        if (ExpoUpdates && ExpoUpdates.isEmbeddedLaunch) {
          return rawAppConfig;
        }
        if (isExpoUpdatesManifest(maybeManifest)) {
          return maybeManifest.extra?.expoClient ?? null;
        } else if (isEmbeddedManifest(maybeManifest)) {
          return maybeManifest;
        }
        return null;
      },
      enumerable: true
    },
    expoGoConfig: {
      get() {
        const maybeManifest = getManifest(true);
        if (!maybeManifest) {
          return null;
        }
        if (isExpoUpdatesManifest(maybeManifest)) {
          return maybeManifest.extra?.expoGo ?? null;
        } else if (isEmbeddedManifest(maybeManifest)) {
          return maybeManifest;
        }
        return null;
      },
      enumerable: true
    },
    easConfig: {
      get() {
        const maybeManifest = getManifest(true);
        if (!maybeManifest) {
          return null;
        }
        if (isExpoUpdatesManifest(maybeManifest)) {
          return maybeManifest.extra?.eas ?? null;
        } else if (isEmbeddedManifest(maybeManifest)) {
          return maybeManifest;
        }
        return null;
      },
      enumerable: true
    },
    __rawManifest_TEST: {
      get() {
        return rawManifest;
      },
      set(value) {
        rawManifest = value;
      },
      enumerable: false
    }
  });
  function isEmbeddedManifest(manifest) {
    return !isExpoUpdatesManifest(manifest);
  }
  function isExpoUpdatesManifest(manifest) {
    return 'metadata' in manifest;
  }
  function getManifest(suppressWarning = false) {
    if (!rawManifest) {
      const invalidManifestType = rawManifest === null ? 'null' : 'undefined';
      if (nativeConstants.executionEnvironment === _ConstantsTypes.ExecutionEnvironment.Bare && Platform.default.OS !== 'web') {
        if (!suppressWarning) {
          console.warn(`Constants.manifest is ${invalidManifestType} because the embedded app.config could not be read. Ensure that you have installed the expo-constants build scripts if you need to read from Constants.manifest.`);
        }
      } else if (nativeConstants.executionEnvironment === _ConstantsTypes.ExecutionEnvironment.StoreClient || nativeConstants.executionEnvironment === _ConstantsTypes.ExecutionEnvironment.Standalone) {
        // If we somehow get here, this is a truly exceptional state to be in.
        // Constants.manifest should *always* be defined in those contexts.
        throw new _expoModulesCore.CodedError('ERR_CONSTANTS_MANIFEST_UNAVAILABLE', `Constants.manifest is ${invalidManifestType}, must be an object.`);
      }
    }
    return rawManifest;
  }
  var _default = constants;
},636,[759,594,14,496,637,638],"node_modules/expo-constants/build/Constants.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "AppOwnership", {
    enumerable: true,
    get: function () {
      return AppOwnership;
    }
  });
  Object.defineProperty(exports, "ExecutionEnvironment", {
    enumerable: true,
    get: function () {
      return ExecutionEnvironment;
    }
  });
  Object.defineProperty(exports, "UserInterfaceIdiom", {
    enumerable: true,
    get: function () {
      return UserInterfaceIdiom;
    }
  });
  var AppOwnership;
  (function (AppOwnership) {
    /**
     * The experience is running inside the Expo Go app.
     * @deprecated Use [`Constants.executionEnvironment`](#executionenvironment) instead.
     */
    AppOwnership["Expo"] = "expo";
  })(AppOwnership || (AppOwnership = {}));
  // @docsMissing
  var ExecutionEnvironment;
  (function (ExecutionEnvironment) {
    ExecutionEnvironment["Bare"] = "bare";
    ExecutionEnvironment["Standalone"] = "standalone";
    ExecutionEnvironment["StoreClient"] = "storeClient";
  })(ExecutionEnvironment || (ExecutionEnvironment = {}));
  // @needsAudit
  /**
   * Current supported values are `handset`, `tablet`, `desktop` and `tv`. CarPlay will show up
   * as `unsupported`.
   */
  var UserInterfaceIdiom;
  (function (UserInterfaceIdiom) {
    UserInterfaceIdiom["Handset"] = "handset";
    UserInterfaceIdiom["Tablet"] = "tablet";
    UserInterfaceIdiom["Desktop"] = "desktop";
    UserInterfaceIdiom["TV"] = "tv";
    UserInterfaceIdiom["Unsupported"] = "unsupported";
  })(UserInterfaceIdiom || (UserInterfaceIdiom = {}));
},637,[],"node_modules/expo-constants/build/Constants.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _ConstantsTypes = require(_dependencyMap[0], "./Constants.types");
  const _sessionId = (Date.now() + '-' + Math.floor(Math.random() * 1000000000)).toString();
  function getBrowserName() {
    if (typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string') {
      const agent = navigator.userAgent.toLowerCase();
      if (agent.includes('edge')) {
        return 'Edge';
      } else if (agent.includes('edg')) {
        return 'Chromium Edge';
      } else if (agent.includes('opr') && 'opr' in window && !!window['opr']) {
        return 'Opera';
      } else if (agent.includes('chrome') && 'chrome' in window && !!window['chrome']) {
        return 'Chrome';
      } else if (agent.includes('trident')) {
        return 'IE';
      } else if (agent.includes('firefox')) {
        return 'Firefox';
      } else if (agent.includes('safari')) {
        return 'Safari';
      }
    }
    return undefined;
  }
  var _default = {
    get appOwnership() {
      return null;
    },
    get executionEnvironment() {
      return _ConstantsTypes.ExecutionEnvironment.Bare;
    },
    get sessionId() {
      return _sessionId;
    },
    get isHeadless() {
      if (typeof navigator === 'undefined') return true;
      return /\bHeadlessChrome\//.test(navigator.userAgent);
    },
    get expoVersion() {
      return this.manifest.sdkVersion || null;
    },
    get linkingUri() {
      if (typeof location !== 'undefined') {
        // On native this is `exp://`
        // On web we should use the protocol and hostname (location.origin)
        return location.origin;
      } else {
        return '';
      }
    },
    get expoRuntimeVersion() {
      return this.expoVersion;
    },
    get deviceName() {
      return getBrowserName();
    },
    get systemFonts() {
      // TODO: Bacon: Maybe possible.
      return [];
    },
    get statusBarHeight() {
      return 0;
    },
    get deviceYearClass() {
      // TODO: Bacon: The android version isn't very accurate either, maybe we could try and guess this value.
      return null;
    },
    get manifest() {
      // This is defined by @expo/webpack-config or babel-preset-expo.
      // If your site is bundled with a different config then you may not have access to the app.json automatically.
      return "{\"name\":\"pedro-kauan-iot\",\"slug\":\"pedro-kauan-iot\",\"version\":\"1.0.0\",\"orientation\":\"portrait\",\"icon\":\"./assets/images/icon.png\",\"scheme\":\"pedrokauaniot\",\"userInterfaceStyle\":\"automatic\",\"newArchEnabled\":true,\"web\":{\"output\":\"static\",\"favicon\":\"./assets/images/favicon.png\",\"shortName\":\"pedro-kauan-iot\",\"orientation\":\"portrait\",\"name\":\"pedro-kauan-iot\"},\"experiments\":{\"typedRoutes\":true,\"reactCompiler\":true},\"sdkVersion\":\"54.0.0\",\"platforms\":[\"ios\",\"android\",\"web\"],\"extra\":{\"router\":{}}}" || {};
    },
    get manifest2() {
      return null;
    },
    get experienceUrl() {
      if (typeof location !== 'undefined') {
        return location.origin;
      } else {
        return '';
      }
    },
    get debugMode() {
      return __DEV__;
    },
    async getWebViewUserAgentAsync() {
      if (typeof navigator !== 'undefined') {
        return navigator.userAgent;
      } else {
        return null;
      }
    }
  };
},638,[637],"node_modules/expo-constants/build/ExponentConstants.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SITEMAP_ROUTE_NAME = exports.NOT_FOUND_ROUTE_NAME = exports.INTERNAL_SLOT_NAME = void 0;
  exports.INTERNAL_SLOT_NAME = '__root';
  exports.NOT_FOUND_ROUTE_NAME = '+not-found';
  exports.SITEMAP_ROUTE_NAME = '_sitemap';
},639,[],"node_modules/expo-router/build/constants.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.resolveHref = void 0;
  exports.resolveHrefStringWithSegments = resolveHrefStringWithSegments;
  /** Resolve an href object into a fully qualified, relative href. */
  const resolveHref = href => {
    if (typeof href === 'string') {
      return (0, exports.resolveHref)({
        pathname: href
      });
    }
    const path = href.pathname ?? '';
    if (!href?.params) {
      return path;
    }
    const {
      pathname,
      params
    } = createQualifiedPathname(path, Object.assign({}, href.params));
    const paramsString = createQueryParams(params);
    return pathname + (paramsString ? `?${paramsString}` : '');
  };
  exports.resolveHref = resolveHref;
  function resolveHrefStringWithSegments(href, {
    segments = [],
    params = {}
  } = {}, {
    relativeToDirectory
  } = {}) {
    if (href.startsWith('.')) {
      // Resolve base path by merging the current segments with the params
      let base = segments?.map(segment => {
        if (!segment.startsWith('[')) return segment;
        if (segment.startsWith('[...')) {
          segment = segment.slice(4, -1);
          const param = params[segment];
          if (Array.isArray(param)) {
            return param.join('/');
          } else {
            return param?.split(',')?.join('/') ?? '';
          }
        } else {
          segment = segment.slice(1, -1);
          return params[segment];
        }
      }).filter(Boolean).join('/') ?? '/';
      if (relativeToDirectory) {
        base = `${base}/`;
      }
      const url = new URL(href, `http://hostname/${base}`);
      href = `${url.pathname}${url.search}`;
    }
    return href;
  }
  function createQualifiedPathname(pathname, params) {
    for (const [key, value = ''] of Object.entries(params)) {
      const dynamicKey = `[${key}]`;
      const deepDynamicKey = `[...${key}]`;
      if (pathname.includes(dynamicKey)) {
        pathname = pathname.replace(dynamicKey, encodeParam(value));
      } else if (pathname.includes(deepDynamicKey)) {
        pathname = pathname.replace(deepDynamicKey, encodeParam(value));
      } else {
        continue;
      }
      delete params[key];
    }
    return {
      pathname,
      params
    };
  }
  function encodeParam(param) {
    if (Array.isArray(param)) {
      return param.map(p => encodeParam(p)).join('/');
    }
    return encodeURIComponent(param.toString());
  }
  function createQueryParams(params) {
    return Object.entries(params)
    // Allow nullish params
    .filter(([, value]) => value != null).map(([key, value]) => `${key}=${encodeURIComponent(value.toString())}`).join('&');
  }
},640,[],"node_modules/expo-router/build/link/href.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isRoutePreloadedInStack = isRoutePreloadedInStack;
  function isRoutePreloadedInStack(navigationState, route) {
    if (!navigationState || navigationState.type !== 'stack') {
      return false;
    }
    return navigationState.preloadedRoutes.some(preloaded => preloaded.key === route.key);
  }
},641,[],"node_modules/expo-router/build/utils/stack.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["id", "initialRouteName", "children", "layout", "screenListeners", "screenOptions", "screenLayout", "UNSTABLE_router"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\fork\\native-stack\\createNativeStackNavigator.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createNativeStackNavigator = createNativeStackNavigator;
  const native_1 = require(_dependencyMap[2], "@react-navigation/native");
  const native_stack_1 = require(_dependencyMap[3], "@react-navigation/native-stack");
  const React = __importStar(require(_dependencyMap[4], "react"));
  const LinkPreviewContext_1 = require(_dependencyMap[5], "../../link/preview/LinkPreviewContext");
  function NativeStackNavigator(_ref) {
    let {
        id,
        initialRouteName,
        children,
        layout,
        screenListeners,
        screenOptions,
        screenLayout,
        UNSTABLE_router
      } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);
    const {
      state,
      describe,
      descriptors,
      navigation,
      NavigationContent
    } = (0, native_1.useNavigationBuilder)(native_1.StackRouter, {
      id,
      initialRouteName,
      children,
      layout,
      screenListeners,
      screenOptions,
      screenLayout,
      UNSTABLE_router
    });
    React.useEffect(() =>
    // @ts-expect-error: there may not be a tab navigator in parent
    navigation?.addListener?.('tabPress', e => {
      const isFocused = navigation.isFocused();
      // Run the operation in the next frame so we're sure all listeners have been run
      // This is necessary to know if preventDefault() has been called
      requestAnimationFrame(() => {
        if (state.index > 0 && isFocused && !e.defaultPrevented) {
          // When user taps on already focused tab and we're inside the tab,
          // reset the stack to replicate native behaviour
          navigation.dispatch(Object.assign({}, native_1.StackActions.popToTop(), {
            target: state.key
          }));
        }
      });
    }), [navigation, state.index, state.key]);
    // START FORK
    const {
      openPreviewKey,
      setOpenPreviewKey
    } = (0, LinkPreviewContext_1.useLinkPreviewContext)();
    // This is used to track the preview screen that is currently transitioning on the native side
    const [previewTransitioningScreenId, setPreviewTransitioningScreenId] = React.useState();
    React.useEffect(() => {
      if (previewTransitioningScreenId) {
        // This means that the state was updated after the preview transition
        if (state.routes.some(route => route.key === previewTransitioningScreenId)) {
          // We no longer need to track the preview transitioning screen
          setPreviewTransitioningScreenId(undefined);
        }
      }
    }, [state, previewTransitioningScreenId]);
    const navigationWrapper = React.useMemo(() => {
      if (openPreviewKey) {
        const emit = (...args) => {
          const {
            target,
            type,
            data
          } = args[0];
          if (target === openPreviewKey && data && 'closing' in data && !data.closing) {
            // onWillAppear
            if (type === 'transitionStart') {
              // The screen from preview will appear, so we need to start tracking it
              setPreviewTransitioningScreenId(openPreviewKey);
            }
            // onAppear
            else if (type === 'transitionEnd') {
              // The screen from preview appeared.
              // We can now restore the stack animation
              setOpenPreviewKey(undefined);
            }
          }
          return navigation.emit(...args);
        };
        return Object.assign({}, navigation, {
          emit
        });
      }
      return navigation;
    }, [navigation, openPreviewKey, setOpenPreviewKey]);
    const {
      computedState,
      computedDescriptors
    } = React.useMemo(() => {
      // The preview screen was pushed on the native side, but react-navigation state was not updated yet
      if (previewTransitioningScreenId) {
        const preloadedRoute = state.preloadedRoutes.find(route => route.key === previewTransitioningScreenId);
        if (preloadedRoute) {
          const newState = Object.assign({}, state, {
            // On native side the screen is already pushed, so we need to update the state
            preloadedRoutes: state.preloadedRoutes.filter(route => route.key !== previewTransitioningScreenId),
            routes: [...state.routes, preloadedRoute],
            index: state.index + 1
          });
          const newDescriptors = previewTransitioningScreenId in descriptors ? descriptors : Object.assign({}, descriptors, {
            // We need to add the descriptor. For react-navigation this is still preloaded screen
            // Replicating the logic from https://github.com/react-navigation/react-navigation/blob/eaf1100ac7d99cb93ba11a999549dd0752809a78/packages/native-stack/src/views/NativeStackView.native.tsx#L489
            [previewTransitioningScreenId]: describe(preloadedRoute, true)
          });
          return {
            computedState: newState,
            computedDescriptors: newDescriptors
          };
        }
      }
      return {
        computedState: state,
        computedDescriptors: descriptors
      };
    }, [state, previewTransitioningScreenId, describe, descriptors]);
    // END FORK
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(NavigationContent, {
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(native_stack_1.NativeStackView, Object.assign({}, rest, {
        // START FORK
        state: computedState,
        navigation: navigationWrapper,
        descriptors: computedDescriptors
        // state={state}
        // navigation={navigation}
        // descriptors={descriptors}
        // END FORK
        ,
        describe: describe
      }), void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 141,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 140,
      columnNumber: 13
    }, this);
  }
  function createNativeStackNavigator(config) {
    return (0, native_1.createNavigatorFactory)(NativeStackNavigator)(config);
  }
},642,[33,759,253,643,9,647],"node_modules/expo-router/build/fork/native-stack/createNativeStackNavigator.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Navigators
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "createNativeStackNavigator", {
    enumerable: true,
    get: function () {
      return _navigatorsCreateNativeStackNavigatorJs.createNativeStackNavigator;
    }
  });
  Object.defineProperty(exports, "NativeStackView", {
    enumerable: true,
    get: function () {
      return _viewsNativeStackView.NativeStackView;
    }
  });
  Object.defineProperty(exports, "useAnimatedHeaderHeight", {
    enumerable: true,
    get: function () {
      return _utilsUseAnimatedHeaderHeightJs.useAnimatedHeaderHeight;
    }
  });
  var _navigatorsCreateNativeStackNavigatorJs = require(_dependencyMap[0], "./navigators/createNativeStackNavigator.js");
  var _viewsNativeStackView = require(_dependencyMap[1], "./views/NativeStackView");
  var _utilsUseAnimatedHeaderHeightJs = require(_dependencyMap[2], "./utils/useAnimatedHeaderHeight.js");
},643,[644,645,646],"node_modules/@react-navigation/native-stack/lib/module/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["id", "initialRouteName", "UNSTABLE_routeNamesChangeBehavior", "children", "layout", "screenListeners", "screenOptions", "screenLayout", "UNSTABLE_router"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.createNativeStackNavigator = createNativeStackNavigator;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationNative = require(_dependencyMap[1], "@react-navigation/native");
  var _react = require(_dependencyMap[2], "react");
  var React = _interopNamespace(_react);
  var _viewsNativeStackView = require(_dependencyMap[3], "../views/NativeStackView");
  var _reactJsxRuntime = require(_dependencyMap[4], "react/jsx-runtime");
  function NativeStackNavigator(_ref) {
    let {
        id,
        initialRouteName,
        UNSTABLE_routeNamesChangeBehavior,
        children,
        layout,
        screenListeners,
        screenOptions,
        screenLayout,
        UNSTABLE_router
      } = _ref,
      rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const {
      state,
      describe,
      descriptors,
      navigation,
      NavigationContent
    } = (0, _reactNavigationNative.useNavigationBuilder)(_reactNavigationNative.StackRouter, {
      id,
      initialRouteName,
      UNSTABLE_routeNamesChangeBehavior,
      children,
      layout,
      screenListeners,
      screenOptions,
      screenLayout,
      UNSTABLE_router
    });
    const meta = React.useContext(_reactNavigationNative.NavigationMetaContext);
    React.useEffect(() => {
      if (meta && 'type' in meta && meta.type === 'native-tabs') {
        // If we're inside native tabs, we don't need to handle popToTop
        // It's handled natively by native tabs
        return;
      }

      // @ts-expect-error: there may not be a tab navigator in parent
      return navigation?.addListener?.('tabPress', e => {
        const isFocused = navigation.isFocused();

        // Run the operation in the next frame so we're sure all listeners have been run
        // This is necessary to know if preventDefault() has been called
        requestAnimationFrame(() => {
          if (state.index > 0 && isFocused && !e.defaultPrevented) {
            // When user taps on already focused tab and we're inside the tab,
            // reset the stack to replicate native behaviour
            navigation.dispatch(Object.assign({}, _reactNavigationNative.StackActions.popToTop(), {
              target: state.key
            }));
          }
        });
      });
    }, [meta, navigation, state.index, state.key]);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(NavigationContent, {
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_viewsNativeStackView.NativeStackView, Object.assign({}, rest, {
        state: state,
        navigation: navigation,
        descriptors: descriptors,
        describe: describe
      }))
    });
  }
  function createNativeStackNavigator(config) {
    return (0, _reactNavigationNative.createNavigatorFactory)(NativeStackNavigator)(config);
  }
},644,[759,253,9,645,274],"node_modules/@react-navigation/native-stack/lib/module/navigators/createNativeStackNavigator.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["header", "headerShown", "headerBackIcon", "headerBackImageSource", "headerLeft", "headerTransparent", "headerBackTitle", "presentation", "contentStyle"],
    _excluded2 = ["label"],
    _excluded3 = ["tintColor", "label"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.NativeStackView = NativeStackView;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _reactNavigationElements = require(_dependencyMap[1], "@react-navigation/elements");
  var _reactNavigationNative = require(_dependencyMap[2], "@react-navigation/native");
  var _react = require(_dependencyMap[3], "react");
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[4], "react-native-web/dist/exports/Animated");
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsImage = require(_dependencyMap[5], "react-native-web/dist/exports/Image");
  var Image = _interopDefault(_reactNativeWebDistExportsImage);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[6], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsView = require(_dependencyMap[7], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _utilsUseAnimatedHeaderHeightJs = require(_dependencyMap[8], "../utils/useAnimatedHeaderHeight.js");
  var _reactJsxRuntime = require(_dependencyMap[9], "react/jsx-runtime");
  const TRANSPARENT_PRESENTATIONS = ['transparentModal', 'containedTransparentModal'];
  function NativeStackView({
    state,
    descriptors,
    describe
  }) {
    const parentHeaderBack = React.useContext(_reactNavigationElements.HeaderBackContext);
    const {
      buildHref
    } = (0, _reactNavigationNative.useLinkBuilder)();
    const preloadedDescriptors = state.preloadedRoutes.reduce((acc, route) => {
      acc[route.key] = acc[route.key] || describe(route, true);
      return acc;
    }, {});
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationElements.SafeAreaProviderCompat, {
      children: state.routes.concat(state.preloadedRoutes).map((route, i) => {
        const isFocused = state.index === i;
        const previousKey = state.routes[i - 1]?.key;
        const nextKey = state.routes[i + 1]?.key;
        const previousDescriptor = previousKey ? descriptors[previousKey] : undefined;
        const nextDescriptor = nextKey ? descriptors[nextKey] : undefined;
        const {
          options,
          navigation,
          render
        } = descriptors[route.key] ?? preloadedDescriptors[route.key];
        const headerBack = previousDescriptor ? {
          title: (0, _reactNavigationElements.getHeaderTitle)(previousDescriptor.options, previousDescriptor.route.name),
          href: buildHref(previousDescriptor.route.name, previousDescriptor.route.params)
        } : parentHeaderBack;
        const canGoBack = headerBack != null;
        const {
            header,
            headerShown,
            headerBackIcon,
            headerBackImageSource,
            headerLeft,
            headerTransparent,
            headerBackTitle,
            presentation,
            contentStyle
          } = options,
          rest = (0, _objectWithoutPropertiesLoose.default)(options, _excluded);
        const nextPresentation = nextDescriptor?.options.presentation;
        const isPreloaded = preloadedDescriptors[route.key] !== undefined && descriptors[route.key] === undefined;
        return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationElements.Screen, {
          focused: isFocused,
          route: route,
          navigation: navigation,
          headerShown: headerShown,
          headerTransparent: headerTransparent,
          header: header !== undefined ? header({
            back: headerBack,
            options,
            route,
            navigation
          }) : /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationElements.Header, Object.assign({}, rest, {
            back: headerBack,
            title: (0, _reactNavigationElements.getHeaderTitle)(options, route.name),
            headerLeft: typeof headerLeft === 'function' ? _ref => {
              let {
                  label
                } = _ref,
                rest = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded2);
              return headerLeft(Object.assign({}, rest, {
                label: headerBackTitle ?? label
              }));
            } : headerLeft === undefined && canGoBack ? _ref2 => {
              let {
                  tintColor,
                  label
                } = _ref2,
                rest = (0, _objectWithoutPropertiesLoose.default)(_ref2, _excluded3);
              return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationElements.HeaderBackButton, Object.assign({}, rest, {
                label: headerBackTitle ?? label,
                tintColor: tintColor,
                backImage: headerBackIcon !== undefined || headerBackImageSource !== undefined ? () => /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Image.default, {
                  source: headerBackIcon?.source ?? headerBackImageSource,
                  resizeMode: "contain",
                  tintColor: tintColor,
                  style: styles.backImage
                }) : undefined,
                onPress: navigation.goBack
              }));
            } : headerLeft,
            headerTransparent: headerTransparent
          })),
          style: [StyleSheet.default.absoluteFill, {
            display: (isFocused || nextPresentation != null && TRANSPARENT_PRESENTATIONS.includes(nextPresentation)) && !isPreloaded ? 'flex' : 'none'
          }, presentation != null && TRANSPARENT_PRESENTATIONS.includes(presentation) ? {
            backgroundColor: 'transparent'
          } : null],
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactNavigationElements.HeaderBackContext.Provider, {
            value: headerBack,
            children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(AnimatedHeaderHeightProvider, {
              children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
                style: [styles.contentContainer, contentStyle],
                children: render()
              })
            })
          })
        }, route.key);
      })
    });
  }
  const AnimatedHeaderHeightProvider = ({
    children
  }) => {
    const headerHeight = (0, _reactNavigationElements.useHeaderHeight)();
    const [animatedHeaderHeight] = React.useState(() => new Animated.default.Value(headerHeight));
    React.useEffect(() => {
      animatedHeaderHeight.setValue(headerHeight);
    }, [animatedHeaderHeight, headerHeight]);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_utilsUseAnimatedHeaderHeightJs.AnimatedHeaderHeightContext.Provider, {
      value: animatedHeaderHeight,
      children: children
    });
  };
  const styles = StyleSheet.default.create({
    contentContainer: {
      flex: 1
    },
    backImage: {
      height: 24,
      width: 24,
      margin: 3
    }
  });
},645,[759,400,253,9,166,155,55,110,646,274],"node_modules/@react-navigation/native-stack/lib/module/views/NativeStackView.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "AnimatedHeaderHeightContext", {
    enumerable: true,
    get: function () {
      return AnimatedHeaderHeightContext;
    }
  });
  exports.useAnimatedHeaderHeight = useAnimatedHeaderHeight;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopNamespace(_react);
  const AnimatedHeaderHeightContext = /*#__PURE__*/React.createContext(undefined);
  function useAnimatedHeaderHeight() {
    const animatedValue = React.useContext(AnimatedHeaderHeightContext);
    if (animatedValue === undefined) {
      throw new Error("Couldn't find the header height. Are you inside a screen in a native stack navigator?");
    }
    return animatedValue;
  }
},646,[9],"node_modules/@react-navigation/native-stack/lib/module/utils/useAnimatedHeaderHeight.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\link\\preview\\LinkPreviewContext.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useLinkPreviewContext = void 0;
  exports.LinkPreviewContextProvider = LinkPreviewContextProvider;
  const react_1 = require(_dependencyMap[1], "react");
  const LinkPreviewContext = (0, react_1.createContext)(undefined);
  function LinkPreviewContextProvider({
    children
  }) {
    const [openPreviewKey, setOpenPreviewKey] = (0, react_1.useState)(undefined);
    const isStackAnimationDisabled = openPreviewKey !== undefined;
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(LinkPreviewContext.Provider, {
      value: {
        isStackAnimationDisabled,
        openPreviewKey,
        setOpenPreviewKey
      },
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 10,
      columnNumber: 13
    }, this);
  }
  const useLinkPreviewContext = () => {
    const context = (0, react_1.use)(LinkPreviewContext);
    if (context == null) {
      throw new Error('useLinkPreviewContext must be used within a LinkPreviewContextProvider. This is likely a bug in Expo Router.');
    }
    return context;
  };
  exports.useLinkPreviewContext = useLinkPreviewContext;
},647,[33,9],"node_modules/expo-router/build/link/preview/LinkPreviewContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.appendInternalExpoRouterParams = appendInternalExpoRouterParams;
  exports.getInternalExpoRouterParams = getInternalExpoRouterParams;
  exports.removeInternalExpoRouterParams = removeInternalExpoRouterParams;
  const INTERNAL_EXPO_ROUTER_NO_ANIMATION_PARAM_NAME = '__internal_expo_router_no_animation';
  const INTERNAL_EXPO_ROUTER_IS_PREVIEW_NAVIGATION_PARAM_NAME = '__internal__expo_router_is_preview_navigation';
  const internalExpoRouterParamNames = [INTERNAL_EXPO_ROUTER_NO_ANIMATION_PARAM_NAME, INTERNAL_EXPO_ROUTER_IS_PREVIEW_NAVIGATION_PARAM_NAME];
  function appendInternalExpoRouterParams(params, expoParams) {
    let newParams = {};
    // Using nested params is a workaround for the issue with the preview key not being passed to the params
    // https://github.com/Ubax/react-navigation/blob/main/packages/core/src/useNavigationBuilder.tsx#L573
    // Another solution would be to propagate the preview key in the useNavigationBuilder,
    // but that would require us to fork the @react-navigation/core package.
    let nestedParams = {};
    if (params) {
      newParams = Object.assign({}, params);
      if ('params' in params) {
        if (typeof params.params === 'object' && params.params) {
          nestedParams = params.params;
        }
      }
    }
    nestedParams = Object.assign({}, nestedParams, expoParams);
    newParams = Object.assign({}, newParams, expoParams);
    if (Object.keys(nestedParams).length > 0) {
      newParams.params = nestedParams;
    }
    if (Object.keys(newParams).length === 0 && params === undefined) {
      return undefined;
    }
    return newParams;
  }
  function getInternalExpoRouterParams(_params) {
    const expoParams = {};
    const params = _params ? _params : {};
    const nestedParams = 'params' in params && typeof params.params === 'object' && params.params ? params.params : {};
    for (const key of internalExpoRouterParamNames) {
      if (key in params) {
        expoParams[key] = params[key];
      } else if (key in nestedParams) {
        expoParams[key] = nestedParams[key];
      }
    }
    return expoParams;
  }
  function removeInternalExpoRouterParams(params) {
    if (!params) {
      return undefined;
    }
    const newNestedParams = 'params' in params && typeof params.params === 'object' && params.params ? Object.fromEntries(Object.entries(params.params).filter(([key]) => !internalExpoRouterParamNames.includes(key))) : {};
    const newParams = Object.fromEntries(Object.entries(params).filter(([key]) => !internalExpoRouterParamNames.includes(key) && key !== 'params'));
    if (Object.keys(newNestedParams).length > 0) {
      return Object.assign({}, newParams, {
        params: newNestedParams
      });
    }
    return newParams;
  }
},648,[],"node_modules/expo-router/build/navigationParams.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Tabs = void 0;
  const TabsClient_1 = __importDefault(require(_dependencyMap[0], "./TabsClient"));
  exports.Tabs = TabsClient_1.default;
  const Screen_1 = require(_dependencyMap[1], "../views/Screen");
  TabsClient_1.default.Screen = Screen_1.Screen;
  exports.default = TabsClient_1.default;
},649,[650,633],"node_modules/expo-router/build/layouts/Tabs.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["href"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\layouts\\TabsClient.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const bottom_tabs_1 = require(_dependencyMap[2], "@react-navigation/bottom-tabs");
  const react_1 = __importDefault(require(_dependencyMap[3], "react"));
  const react_native_1 = require(_dependencyMap[4], "react-native-web/dist/index");
  const withLayoutContext_1 = require(_dependencyMap[5], "./withLayoutContext");
  const Link_1 = require(_dependencyMap[6], "../link/Link");
  const TabRouter_1 = require(_dependencyMap[7], "./TabRouter");
  const Protected_1 = require(_dependencyMap[8], "../views/Protected");
  // This is the only way to access the navigator.
  const BottomTabNavigator = (0, bottom_tabs_1.createBottomTabNavigator)().Navigator;
  const ExpoTabs = (0, withLayoutContext_1.withLayoutContext)(BottomTabNavigator, screens => {
    // Support the `href` shortcut prop.
    return screens.map(screen => {
      if (typeof screen.options !== 'function' && screen.options?.href !== undefined) {
        const _screen$options = screen.options,
          {
            href
          } = _screen$options,
          options = _objectWithoutPropertiesLoose(_screen$options, _excluded);
        if (options.tabBarButton) {
          throw new Error('Cannot use `href` and `tabBarButton` together.');
        }
        return Object.assign({}, screen, {
          options: Object.assign({}, options, {
            tabBarItemStyle: href == null ? {
              display: 'none'
            } : options.tabBarItemStyle,
            // @ts-expect-error: TODO(@kitten): This isn't properly typed
            tabBarButton: props => {
              if (href == null) {
                return null;
              }
              const children = react_native_1.Platform.OS === 'web' ? props.children : /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Pressable, {
                children: props.children
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 34,
                columnNumber: 98
              }, this);
              // TODO: React Navigation types these props as Animated.WithAnimatedValue<StyleProp<ViewStyle>>
              //       While Link expects a TextStyle. We need to reconcile these types.
              return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Link_1.Link, Object.assign({}, props, {
                style: [{
                  display: 'flex'
                }, props.style],
                href: href,
                asChild: react_native_1.Platform.OS !== 'web',
                children: children
              }), void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 37,
                columnNumber: 33
              }, this);
            }
          })
        });
      }
      return screen;
    });
  });
  const Tabs = Object.assign(props => {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(ExpoTabs, Object.assign({}, props, {
      UNSTABLE_router: TabRouter_1.tabRouterOverride
    }), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 46,
      columnNumber: 12
    }, this);
  }, {
    Screen: ExpoTabs.Screen,
    Protected: Protected_1.Protected
  });
  exports.default = Tabs;
},650,[33,759,394,9,492,378,651,718,632],"node_modules/expo-router/build/layouts/TabsClient.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\link\\Link.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Redirect = exports.Link = void 0;
  const ExpoLink_1 = require(_dependencyMap[1], "./ExpoLink");
  const elements_1 = require(_dependencyMap[2], "./elements");
  const href_1 = require(_dependencyMap[3], "./href");
  exports.Link = Object.assign(
  /**
   * Component that renders a link using [`href`](#href) to another route.
   * By default, it accepts children and wraps them in a `<Text>` component.
   *
   * Uses an anchor tag (`<a>`) on web and performs a client-side navigation to preserve
   * the state of the website and navigate faster. The web-only attributes such as `target`,
   * `rel`, and `download` are supported and passed to the anchor tag on web. See
   * [`WebAnchorProps`](#webanchorprops) for more details.
   *
   * > **Note**: Client-side navigation works with both single-page apps,
   * and [static-rendering](/router/reference/static-rendering/).
   *
   * @example
   * ```tsx
   * import { Link } from 'expo-router';
   * import { View } from 'react-native';
   *
   * export default function Route() {
   *  return (
   *   <View>
   *    <Link href="/about">About</Link>
   *   </View>
   *  );
   *}
   * ```
   */
  function Link(props) {
    // Re-exporting ExpoLink here so that Link.* can be used in server components.
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(ExpoLink_1.ExpoLink, Object.assign({}, props), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 12
    }, this);
  }, {
    resolveHref: href_1.resolveHref,
    Menu: elements_1.LinkMenu,
    Trigger: elements_1.LinkTrigger,
    Preview: elements_1.LinkPreview,
    MenuAction: elements_1.LinkMenuAction
  });
  var Redirect_1 = require(_dependencyMap[4], "./Redirect");
  Object.defineProperty(exports, "Redirect", {
    enumerable: true,
    get: function () {
      return Redirect_1.Redirect;
    }
  });
},651,[33,652,711,640,716],"node_modules/expo-router/build/link/Link.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\link\\ExpoLink.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ExpoLink = ExpoLink;
  const expo_constants_1 = __importDefault(require(_dependencyMap[1], "expo-constants"));
  const react_1 = __importStar(require(_dependencyMap[2], "react"));
  const BaseExpoRouterLink_1 = require(_dependencyMap[3], "./BaseExpoRouterLink");
  const LinkWithPreview_1 = require(_dependencyMap[4], "./LinkWithPreview");
  const elements_1 = require(_dependencyMap[5], "./elements");
  const PreviewRouteContext_1 = require(_dependencyMap[6], "./preview/PreviewRouteContext");
  const url_1 = require(_dependencyMap[7], "../utils/url");
  function ExpoLink(props) {
    const isPreview = (0, PreviewRouteContext_1.useIsPreview)();
    if (false && isLinkWithPreview(props) && !isPreview && expo_constants_1.default?.expoConfig?.newArchEnabled !== false) {
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(LinkWithPreview_1.LinkWithPreview, Object.assign({}, props), void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 54,
        columnNumber: 16
      }, this);
    }
    let children = props.children;
    if (react_1.default.Children.count(props.children) > 1) {
      const arrayChildren = react_1.default.Children.toArray(props.children).filter(child => !(0, react_1.isValidElement)(child) || child.type !== elements_1.LinkPreview && child.type !== elements_1.LinkMenu);
      children = arrayChildren.length === 1 ? arrayChildren[0] : props.children;
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(BaseExpoRouterLink_1.BaseExpoRouterLink, Object.assign({}, props, {
      children: children
    }), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 61,
      columnNumber: 12
    }, this);
  }
  function isLinkWithPreview(props) {
    const isExternal = (0, url_1.shouldLinkExternally)(String(props.href));
    return react_1.Children.toArray(props.children).some(child => (0, react_1.isValidElement)(child) && (!isExternal && child.type === elements_1.LinkPreview || child.type === elements_1.LinkMenu));
  }
},652,[33,636,9,653,709,711,385,677],"node_modules/expo-router/build/link/ExpoLink.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["href", "replace", "push", "dismissTo", "relativeToDirectory", "asChild", "rel", "target", "download", "withAnchor", "dangerouslySingular", "prefetch"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\link\\BaseExpoRouterLink.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BaseExpoRouterLink = BaseExpoRouterLink;
  // Fork of @react-navigation/native Link.tsx with `href` and `replace` support added and
  // `to` / `action` support removed.
  const react_1 = __importStar(require(_dependencyMap[2], "react"));
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const href_1 = require(_dependencyMap[4], "./href");
  const useLinkHooks_1 = require(_dependencyMap[5], "./useLinkHooks");
  const useLinkToPathProps_1 = __importDefault(require(_dependencyMap[6], "./useLinkToPathProps"));
  const Prefetch_1 = require(_dependencyMap[7], "../Prefetch");
  const Slot_1 = require(_dependencyMap[8], "../ui/Slot");
  function BaseExpoRouterLink(_ref) {
    let {
        href,
        replace,
        push,
        dismissTo,
        // TODO: This does not prevent default on the anchor tag.
        relativeToDirectory,
        asChild,
        rel,
        target,
        download,
        withAnchor,
        dangerouslySingular: singular,
        prefetch
      } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);
    // Mutate the style prop to add the className on web.
    const style = (0, useLinkHooks_1.useInteropClassName)(rest);
    // If not passing asChild, we need to forward the props to the anchor tag using React Native Web's `hrefAttrs`.
    const hrefAttrs = (0, useLinkHooks_1.useHrefAttrs)({
      asChild,
      rel,
      target,
      download
    });
    const resolvedHref = (0, react_1.useMemo)(() => {
      if (href == null) {
        throw new Error('Link: href is required');
      }
      return (0, href_1.resolveHref)(href);
    }, [href]);
    let event;
    if (push) event = 'PUSH';
    if (replace) event = 'REPLACE';
    if (dismissTo) event = 'POP_TO';
    const props = (0, useLinkToPathProps_1.default)({
      href: resolvedHref,
      event,
      relativeToDirectory,
      withAnchor,
      dangerouslySingular: singular
    });
    const onPress = e => {
      if ('onPress' in rest) {
        rest.onPress?.(e);
      }
      props.onPress(e);
    };
    const Component = asChild ? Slot_1.Slot : react_native_1.Text;
    if (asChild && react_1.default.Children.count(rest.children) > 1) {
      throw new Error('Link: When using `asChild`, you must pass a single child element that will emit the `onPress` event.');
    }
    // Avoid using createElement directly, favoring JSX, to allow tools like NativeWind to perform custom JSX handling on native.
    const element = /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Component, Object.assign({}, props, hrefAttrs, rest, {
      style: style
    }, react_native_1.Platform.select({
      web: {
        onClick: onPress
      },
      default: {
        onPress
      }
    })), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 88,
      columnNumber: 22
    }, this);
    return prefetch ? /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(_reactJsxDevRuntime.Fragment, {
      children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Prefetch_1.Prefetch, {
        href: href
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 95,
        columnNumber: 7
      }, this), element]
    }, void 0, true) : element;
  }
},653,[33,759,9,492,640,654,655,704,706],"node_modules/expo-router/build/link/BaseExpoRouterLink.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useHrefAttrs = void 0;
  exports.useInteropClassName = useInteropClassName;
  // Fork of @react-navigation/native Link.tsx with `href` and `replace` support added and
  // `to` / `action` support removed.
  const react_1 = require(_dependencyMap[0], "react");
  const react_native_1 = require(_dependencyMap[1], "react-native-web/dist/index"); // Mutate the style prop to add the className on web.
  function useInteropClassName(props) {
    if (react_native_1.Platform.OS !== 'web') {
      return props.style;
    }
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return (0, react_1.useMemo)(() => {
      if (props.className == null) {
        return props.style;
      }
      const cssStyle = {
        $$css: true,
        __routerLinkClassName: props.className
      };
      if (Array.isArray(props.style)) {
        return [...props.style, cssStyle];
      }
      return [props.style, cssStyle];
    }, [props.style, props.className]);
  }
  exports.useHrefAttrs = react_native_1.Platform.select({
    web: function useHrefAttrs({
      asChild,
      rel,
      target,
      download
    }) {
      return (0, react_1.useMemo)(() => {
        const hrefAttrs = {
          rel,
          target,
          download
        };
        if (asChild) {
          return hrefAttrs;
        }
        return {
          hrefAttrs
        };
      }, [asChild, rel, target, download]);
    },
    default: function useHrefAttrs() {
      return {};
    }
  });
},654,[9,492],"node_modules/expo-router/build/link/useLinkHooks.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["href"];
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useLinkToPathProps;
  exports.shouldHandleMouseEvent = shouldHandleMouseEvent;
  const react_native_1 = require(_dependencyMap[1], "react-native-web/dist/index");
  const emitDomEvent_1 = require(_dependencyMap[2], "../domComponents/emitDomEvent");
  const getPathFromState_forks_1 = require(_dependencyMap[3], "../fork/getPathFromState-forks");
  const routing_1 = require(_dependencyMap[4], "../global-state/routing");
  const matchers_1 = require(_dependencyMap[5], "../matchers");
  const url_1 = require(_dependencyMap[6], "../utils/url");
  function eventShouldPreventDefault(e) {
    if (e?.defaultPrevented) {
      return false;
    }
    if (
    // Only check MouseEvents
    'button' in e &&
    // ignore clicks with modifier keys
    !e.metaKey && !e.altKey && !e.ctrlKey && !e.shiftKey && (e.button == null || e.button === 0) &&
    // Only accept left clicks
    [undefined, null, '', 'self'].includes(e.currentTarget.target) // let browser handle "target=_blank" etc.
    ) {
      return true;
    }
    return false;
  }
  function useLinkToPathProps(_ref) {
    let {
        href
      } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, _excluded);
    const onPress = event => {
      if (shouldHandleMouseEvent(event)) {
        if ((0, emitDomEvent_1.emitDomLinkEvent)(href, options)) {
          return;
        }
        (0, routing_1.linkTo)(href, options);
      }
    };
    let strippedHref = (0, matchers_1.stripGroupSegmentsFromPath)(href) || '/';
    // Append base url only if needed.
    if (!(0, url_1.shouldLinkExternally)(strippedHref)) {
      strippedHref = (0, getPathFromState_forks_1.appendBaseUrl)(strippedHref);
    }
    return {
      href: strippedHref,
      role: 'link',
      onPress
    };
  }
  function shouldHandleMouseEvent(event) {
    if (react_native_1.Platform.OS !== 'web') {
      return !event?.defaultPrevented;
    }
    if (event && eventShouldPreventDefault(event)) {
      event.preventDefault();
      return true;
    }
    return false;
  }
},655,[759,492,656,658,659,380,677],"node_modules/expo-router/build/link/useLinkToPathProps.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.emitDomSetParams = emitDomSetParams;
  exports.emitDomDismiss = emitDomDismiss;
  exports.emitDomGoBack = emitDomGoBack;
  exports.emitDomDismissAll = emitDomDismissAll;
  exports.emitDomLinkEvent = emitDomLinkEvent;
  const events_1 = require(_dependencyMap[0], "./events");
  function emitDomEvent(type, data = {}) {
    // @ts-expect-error: ReactNativeWebView is a global variable injected by the WebView
    if (typeof $$EXPO_INITIAL_PROPS !== 'undefined' && typeof ReactNativeWebView !== 'undefined') {
      window.ReactNativeWebView.postMessage(JSON.stringify({
        type,
        data
      }));
      return true;
    }
    return false;
  }
  function emitDomSetParams(params = {}) {
    return emitDomEvent(events_1.ROUTER_SET_PARAMS_TYPE, {
      params
    });
  }
  function emitDomDismiss(count) {
    return emitDomEvent(events_1.ROUTER_DISMISS_TYPE, {
      count
    });
  }
  function emitDomGoBack() {
    return emitDomEvent(events_1.ROUTER_BACK_TYPE);
  }
  function emitDomDismissAll() {
    return emitDomEvent(events_1.ROUTER_DISMISS_ALL_TYPE);
  }
  function emitDomLinkEvent(href, options) {
    return emitDomEvent(events_1.ROUTER_LINK_TYPE, {
      href,
      options
    });
  }
},656,[657],"node_modules/expo-router/build/domComponents/emitDomEvent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ROUTER_SET_PARAMS_TYPE = exports.ROUTER_BACK_TYPE = exports.ROUTER_DISMISS_TYPE = exports.ROUTER_DISMISS_ALL_TYPE = exports.ROUTER_LINK_TYPE = void 0;
  exports.ROUTER_LINK_TYPE = '$$router_link';
  exports.ROUTER_DISMISS_ALL_TYPE = '$$router_dismissAll';
  exports.ROUTER_DISMISS_TYPE = '$$router_dismiss';
  exports.ROUTER_BACK_TYPE = '$$router_goBack';
  exports.ROUTER_SET_PARAMS_TYPE = '$$router_setParams';
},657,[],"node_modules/expo-router/build/domComponents/events.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["preserveDynamicRoutes", "preserveGroups", "shouldEncodeURISegment"],
    _excluded2 = ["#"];
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getParamName = void 0;
  exports.validatePathConfig = validatePathConfig;
  exports.fixCurrentParams = fixCurrentParams;
  exports.appendQueryAndHash = appendQueryAndHash;
  exports.appendBaseUrl = appendBaseUrl;
  exports.getPathWithConventionsCollapsed = getPathWithConventionsCollapsed;
  exports.isDynamicPart = isDynamicPart;
  const native_1 = require(_dependencyMap[1], "@react-navigation/native");
  const queryString = __importStar(require(_dependencyMap[2], "query-string"));
  const matchers_1 = require(_dependencyMap[3], "../matchers");
  function validatePathConfig(_ref) {
    let options = _objectWithoutPropertiesLoose(_ref, _excluded);
    (0, native_1.validatePathConfig)(options);
  }
  function fixCurrentParams(allParams, route, stringify) {
    // Better handle array params
    const currentParams = Object.fromEntries(Object.entries(route.params).flatMap(([key, value]) => {
      if (key === 'screen' || key === 'params') {
        return [];
      }
      return [[key, stringify?.[key] ? stringify[key](value) : Array.isArray(value) ? value.map(String) : String(value)]];
    }));
    // We always assign params, as non pattern routes may still have query params
    Object.assign(allParams, currentParams);
    return currentParams;
  }
  function appendQueryAndHash(path, _ref2) {
    let {
        '#': hash
      } = _ref2,
      focusedParams = _objectWithoutPropertiesLoose(_ref2, _excluded2);
    const query = queryString.stringify(focusedParams, {
      sort: false
    });
    if (query) {
      path += `?${query}`;
    }
    if (hash) {
      path += `#${hash}`;
    }
    return path;
  }
  function appendBaseUrl(path, baseUrl = "") {
    if (process.env.NODE_ENV !== 'development') {
      if (baseUrl) {
        return `/${baseUrl.replace(/^\/+/, '').replace(/\/$/, '')}${path}`;
      }
    }
    return path;
  }
  function getPathWithConventionsCollapsed({
    pattern,
    route,
    params,
    preserveGroups,
    preserveDynamicRoutes,
    shouldEncodeURISegment = true,
    initialRouteName
  }) {
    const segments = pattern.split('/');
    return segments.map((p, i) => {
      const name = (0, exports.getParamName)(p);
      // Showing the route name seems ok, though whatever we show here will be incorrect
      // Since the page doesn't actually exist
      if (p.startsWith('*')) {
        if (preserveDynamicRoutes) {
          if (name === 'not-found') {
            return '+not-found';
          }
          return `[...${name}]`;
        } else if (params[name]) {
          if (Array.isArray(params[name])) {
            return params[name].join('/');
          }
          return params[name];
        } else if (route.name.startsWith('[') && route.name.endsWith(']')) {
          return '';
        } else if (p === '*not-found') {
          return '';
        } else {
          return route.name;
        }
      }
      // If the path has a pattern for a param, put the param in the path
      if (p.startsWith(':')) {
        if (preserveDynamicRoutes) {
          return `[${name}]`;
        }
        // Optional params without value assigned in route.params should be ignored
        const value = params[name];
        if (value === undefined && p.endsWith('?')) {
          return;
        }
        return (shouldEncodeURISegment ? encodeURISegment(value) : value) ?? 'undefined';
      }
      if (!preserveGroups && (0, matchers_1.matchGroupName)(p) != null) {
        // When the last part is a group it could be a shared URL
        // if the route has an initialRouteName defined, then we should
        // use that as the component path as we can assume it will be shown.
        if (segments.length - 1 === i) {
          if (initialRouteName) {
            // Return an empty string if the init route is ambiguous.
            if (segmentMatchesConvention(initialRouteName)) {
              return '';
            }
            return shouldEncodeURISegment ? encodeURISegment(initialRouteName, {
              preserveBrackets: true
            }) : initialRouteName;
          }
        }
        return '';
      }
      // Preserve dynamic syntax for rehydration
      return shouldEncodeURISegment ? encodeURISegment(p, {
        preserveBrackets: true
      }) : p;
    }).map(v => v ?? '').join('/');
  }
  const getParamName = pattern => pattern.replace(/^[:*]/, '').replace(/\?$/, '');
  exports.getParamName = getParamName;
  function isDynamicPart(p) {
    return p.startsWith(':') || p.startsWith('*');
  }
  function segmentMatchesConvention(segment) {
    return segment === 'index' || (0, matchers_1.matchGroupName)(segment) != null || (0, matchers_1.matchDynamicName)(segment) != null;
  }
  function encodeURISegment(str, {
    preserveBrackets = false
  } = {}) {
    // Valid characters according to
    // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)
    str = String(str).replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]/g, char => encodeURIComponent(char));
    if (preserveBrackets) {
      // Preserve brackets
      str = str.replace(/%5B/g, '[').replace(/%5D/g, ']');
    }
    return str;
  }
},658,[759,253,300,380],"node_modules/expo-router/build/fork/getPathFromState-forks.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.routingQueue = void 0;
  exports.navigate = navigate;
  exports.reload = reload;
  exports.prefetch = prefetch;
  exports.push = push;
  exports.dismiss = dismiss;
  exports.dismissTo = dismissTo;
  exports.replace = replace;
  exports.dismissAll = dismissAll;
  exports.goBack = goBack;
  exports.canGoBack = canGoBack;
  exports.canDismiss = canDismiss;
  exports.setParams = setParams;
  exports.linkTo = linkTo;
  exports.getPayloadFromStateRoute = getPayloadFromStateRoute;
  exports.findDivergentState = findDivergentState;
  const dom_1 = require(_dependencyMap[0], "expo/dom");
  const Linking = __importStar(require(_dependencyMap[1], "expo-linking"));
  const react_native_1 = require(_dependencyMap[2], "react-native-web/dist/index");
  const router_store_1 = require(_dependencyMap[3], "./router-store");
  const emitDomEvent_1 = require(_dependencyMap[4], "../domComponents/emitDomEvent");
  const getRoutesRedirects_1 = require(_dependencyMap[5], "../getRoutesRedirects");
  const href_1 = require(_dependencyMap[6], "../link/href");
  const matchers_1 = require(_dependencyMap[7], "../matchers");
  const navigationParams_1 = require(_dependencyMap[8], "../navigationParams");
  const url_1 = require(_dependencyMap[9], "../utils/url");
  function assertIsReady() {
    if (!router_store_1.store.navigationRef.isReady()) {
      throw new Error('Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.');
    }
  }
  exports.routingQueue = {
    queue: [],
    subscribers: new Set(),
    subscribe(callback) {
      exports.routingQueue.subscribers.add(callback);
      return () => {
        exports.routingQueue.subscribers.delete(callback);
      };
    },
    snapshot() {
      return exports.routingQueue.queue;
    },
    add(action) {
      exports.routingQueue.queue.push(action);
      for (const callback of exports.routingQueue.subscribers) {
        callback();
      }
    },
    run(ref) {
      // Reset the identity of the queue.
      const events = exports.routingQueue.queue;
      exports.routingQueue.queue = [];
      let action;
      while (action = events.shift()) {
        if (ref.current) {
          ref.current.dispatch(action);
        }
      }
    }
  };
  function navigate(url, options) {
    return linkTo((0, href_1.resolveHref)(url), Object.assign({}, options, {
      event: 'NAVIGATE'
    }));
  }
  function reload() {
    // TODO(EvanBacon): add `reload` support.
    throw new Error('The reload method is not implemented in the client-side router yet.');
  }
  function prefetch(href, options) {
    return linkTo((0, href_1.resolveHref)(href), Object.assign({}, options, {
      event: 'PRELOAD'
    }));
  }
  function push(url, options) {
    return linkTo((0, href_1.resolveHref)(url), Object.assign({}, options, {
      event: 'PUSH'
    }));
  }
  function dismiss(count = 1) {
    if ((0, emitDomEvent_1.emitDomDismiss)(count)) {
      return;
    }
    exports.routingQueue.add({
      type: 'POP',
      payload: {
        count
      }
    });
  }
  function dismissTo(href, options) {
    return linkTo((0, href_1.resolveHref)(href), Object.assign({}, options, {
      event: 'POP_TO'
    }));
  }
  function replace(url, options) {
    return linkTo((0, href_1.resolveHref)(url), Object.assign({}, options, {
      event: 'REPLACE'
    }));
  }
  function dismissAll() {
    if ((0, emitDomEvent_1.emitDomDismissAll)()) {
      return;
    }
    exports.routingQueue.add({
      type: 'POP_TO_TOP'
    });
  }
  function goBack() {
    if ((0, emitDomEvent_1.emitDomGoBack)()) {
      return;
    }
    assertIsReady();
    exports.routingQueue.add({
      type: 'GO_BACK'
    });
  }
  function canGoBack() {
    if (dom_1.IS_DOM) {
      throw new Error('canGoBack imperative method is not supported. Pass the property to the DOM component instead.');
    }
    // Return a default value here if the navigation hasn't mounted yet.
    // This can happen if the user calls `canGoBack` from the Root Layout route
    // before mounting a navigator. This behavior exists due to React Navigation being dynamically
    // constructed at runtime. We can get rid of this in the future if we use
    // the static configuration internally.
    if (!router_store_1.store.navigationRef.isReady()) {
      return false;
    }
    return router_store_1.store.navigationRef?.current?.canGoBack() ?? false;
  }
  function canDismiss() {
    if (dom_1.IS_DOM) {
      throw new Error('canDismiss imperative method is not supported. Pass the property to the DOM component instead.');
    }
    let state = router_store_1.store.state;
    // Keep traversing down the state tree until we find a stack navigator that we can pop
    while (state) {
      if (state.type === 'stack' && state.routes.length > 1) {
        return true;
      }
      if (state.index === undefined) return false;
      state = state.routes?.[state.index]?.state;
    }
    return false;
  }
  function setParams(params = {}) {
    if ((0, emitDomEvent_1.emitDomSetParams)(params)) {
      return;
    }
    assertIsReady();
    return (router_store_1.store.navigationRef?.current?.setParams)(params);
  }
  function linkTo(originalHref, options = {}) {
    originalHref = typeof originalHref == 'string' ? originalHref : (0, href_1.resolveHref)(originalHref);
    let href = originalHref;
    if ((0, emitDomEvent_1.emitDomLinkEvent)(href, options)) {
      return;
    }
    if ((0, url_1.shouldLinkExternally)(href)) {
      if (href.startsWith('//') && react_native_1.Platform.OS !== 'web') {
        href = `https:${href}`;
      }
      Linking.openURL(href);
      return;
    }
    assertIsReady();
    const navigationRef = router_store_1.store.navigationRef.current;
    if (navigationRef == null) {
      throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }
    if (!router_store_1.store.linking) {
      throw new Error('Attempted to link to route when no routes are present');
    }
    if (href === '..' || href === '../') {
      navigationRef.goBack();
      return;
    }
    const rootState = navigationRef.getRootState();
    href = (0, href_1.resolveHrefStringWithSegments)(href, router_store_1.store.getRouteInfo(), options);
    href = (0, getRoutesRedirects_1.applyRedirects)(href, router_store_1.store.redirects);
    // If the href is undefined, it means that the redirect has already been handled the navigation
    if (!href) {
      return;
    }
    const state = router_store_1.store.linking.getStateFromPath(href, router_store_1.store.linking.config);
    if (!state || state.routes.length === 0) {
      console.error('Could not generate a valid navigation state for the given path: ' + href);
      return;
    }
    exports.routingQueue.add(getNavigateAction(state, rootState, options.event, options.withAnchor, options.dangerouslySingular, !!options.__internal__PreviewKey));
  }
  function getNavigateAction(_actionState, _navigationState, type = 'NAVIGATE', withAnchor, singular, isPreviewNavigation) {
    /**
     * We need to find the deepest navigator where the action and current state diverge, If they do not diverge, the
     * lowest navigator is the target.
     *
     * By default React Navigation will target the current navigator, but this doesn't work for all actions
     * For example:
     *  - /deeply/nested/route -> /top-level-route the target needs to be the top-level navigator
     *  - /stack/nestedStack/page -> /stack1/nestedStack/other-page needs to target the nestedStack navigator
     *
     * This matching needs to done by comparing the route names and the dynamic path, for example
     * - /1/page -> /2/anotherPage needs to target the /[id] navigator
     *
     * Other parameters such as search params and hash are not evaluated.
     */
    const {
      actionStateRoute,
      navigationState
    } = findDivergentState(_actionState, _navigationState, type === 'PRELOAD');
    /*
     * We found the target navigator, but the payload is in the incorrect format
     * We need to convert the action state to a payload that can be dispatched
     */
    const rootPayload = getPayloadFromStateRoute(actionStateRoute || {});
    if (type === 'PUSH' && navigationState.type !== 'stack') {
      type = 'NAVIGATE';
    } else if (navigationState.type === 'expo-tab') {
      type = 'JUMP_TO';
    } else if (type === 'REPLACE' && navigationState.type === 'drawer') {
      type = 'JUMP_TO';
    }
    if (withAnchor) {
      if (rootPayload.params.initial) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn(`The parameter 'initial' is a reserved parameter name in React Navigation`);
        }
      }
      /*
       * The logic for initial can seen backwards depending on your perspective
       *   True: The initialRouteName is not loaded. The incoming screen is the initial screen (default)
       *   False: The initialRouteName is loaded. THe incoming screen is placed after the initialRouteName
       *
       * withAnchor flips the perspective.
       *   True: You want the initialRouteName to load.
       *   False: You do not want the initialRouteName to load.
       */
      // Set initial on root and all nested params so anchors are loaded at every level
      let currentParams = rootPayload.params;
      while (currentParams) {
        currentParams.initial = !withAnchor;
        currentParams = currentParams.params;
      }
    }
    const expoParams = isPreviewNavigation ? {
      __internal__expo_router_is_preview_navigation: true,
      __internal_expo_router_no_animation: true
    } : {};
    const params = (0, navigationParams_1.appendInternalExpoRouterParams)(rootPayload.params, expoParams);
    return {
      type,
      target: navigationState.key,
      payload: {
        // key: rootPayload.key,
        name: rootPayload.screen,
        params,
        singular
      }
    };
  }
  /**
   * React Navigation uses params to store information about the screens, rather then create new state for each level.
   * This function traverses the action state that will not be part of state and returns a payload that can be used in action.
   */
  function getPayloadFromStateRoute(_actionStateRoute) {
    const rootPayload = {
      params: {}
    };
    let payload = rootPayload;
    let params = payload.params;
    let actionStateRoute = _actionStateRoute;
    while (actionStateRoute) {
      Object.assign(params, Object.assign({}, payload.params, actionStateRoute.params));
      // Assign the screen name to the payload
      payload.screen = actionStateRoute.name;
      // Merge the params, ensuring that we create a new object
      payload.params = Object.assign({}, params);
      // Params don't include the screen, thats a separate attribute
      delete payload.params['screen'];
      // Continue down the payload tree
      // Initially these values are separate, but React Nav merges them after the first layer
      payload = payload.params;
      params = payload;
      actionStateRoute = actionStateRoute.state?.routes[actionStateRoute.state?.routes.length - 1];
    }
    return rootPayload;
  }
  /*
   * Traverse the state tree comparing the current state and the action state until we find where they diverge
   */
  function findDivergentState(_actionState, _navigationState,
  // If true, look through all tabs to find the target state, rather then just the current tab
  lookThroughAllTabs = false) {
    let actionState = _actionState;
    let navigationState = _navigationState;
    let actionStateRoute;
    const navigationRoutes = [];
    while (actionState && navigationState) {
      actionStateRoute = actionState.routes[actionState.routes.length - 1];
      const stateRoute = (() => {
        if (navigationState.type === 'tab' && lookThroughAllTabs) {
          return navigationState.routes.find(route => route.name === actionStateRoute?.name) || navigationState.routes[navigationState.index ?? 0];
        }
        return navigationState.routes[navigationState.index ?? 0];
      })();
      const childState = actionStateRoute.state;
      const nextNavigationState = stateRoute.state;
      const dynamicName = (0, matchers_1.matchDynamicName)(actionStateRoute.name);
      const didActionAndCurrentStateDiverge = actionStateRoute.name !== stateRoute.name || !childState || !nextNavigationState || dynamicName &&
      // @ts-expect-error: TODO(@kitten): This isn't properly typed, so the index access fails
      actionStateRoute.params?.[dynamicName.name] !== stateRoute.params?.[dynamicName.name];
      if (didActionAndCurrentStateDiverge) {
        // If we are looking through all tabs, we need to add new tab id if this is the last route
        // Otherwise we wouldn't be able to change the tab
        if (navigationState.type === 'tab' && lookThroughAllTabs) {
          navigationRoutes.push(stateRoute);
        }
        break;
      }
      navigationRoutes.push(stateRoute);
      actionState = childState;
      navigationState = nextNavigationState;
    }
    return {
      actionState,
      navigationState,
      actionStateRoute,
      navigationRoutes
    };
  }
},659,[660,664,492,671,656,676,640,380,648,677],"node_modules/expo-router/build/global-state/routing.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  var _srcDomDom = require(_dependencyMap[0], "../src/dom/dom");
  Object.keys(_srcDomDom).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _srcDomDom[k];
        }
      });
    }
  });
},660,[661],"node_modules/expo/dom/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "IS_DOM", {
    enumerable: true,
    get: function () {
      return IS_DOM;
    }
  });
  var _domHooks = require(_dependencyMap[0], "./dom-hooks");
  Object.keys(_domHooks).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _domHooks[k];
        }
      });
    }
  });
  // TODO: Maybe this could be a bundler global instead.
  const IS_DOM =
  // @ts-expect-error: Added via react-native-webview
  typeof $$EXPO_INITIAL_PROPS !== 'undefined';
},661,[662],"node_modules/expo/src/dom/dom.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.useDOMImperativeHandle = useDOMImperativeHandle;
  var _react = require(_dependencyMap[0], "react");
  var _injection = require(_dependencyMap[1], "./injection");
  /**
   * A React `useImperativeHandle` like hook for DOM components.
   *
   */
  function useDOMImperativeHandle(ref, init, deps) {
    const isTargetWeb =
    // @ts-expect-error: Added via react-native-webview
    typeof window.ReactNativeWebView === 'undefined' &&
    // @ts-expect-error: Added via expo/dom
    typeof window.$$EXPO_INITIAL_PROPS === 'undefined';
    const stubHandlerFactory = (0, _react.useCallback)(() => ({}), deps ?? []);

    // This standard useImperativeHandle hook is serving for web
    (0, _react.useImperativeHandle)(ref, isTargetWeb ? init : stubHandlerFactory, deps);

    // This `globalThis._domRefProxy` is serving for native
    (0, _react.useEffect)(() => {
      if (!isTargetWeb) {
        globalThis._domRefProxy = init();
        // TODO(@kitten): Type `ReactNativeWebView` and the message data
        // @ts-expect-error: Added via react-native-webview
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: _injection.REGISTER_DOM_IMPERATIVE_HANDLE_PROPS,
          data: Object.keys(globalThis._domRefProxy)
        }));
      }
      return () => {
        if (!isTargetWeb) {
          globalThis._domRefProxy = undefined;
        }
      };
    }, deps);
  }
},662,[9,663],"node_modules/expo/src/dom/dom-hooks.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "NATIVE_ACTION", {
    enumerable: true,
    get: function () {
      return NATIVE_ACTION;
    }
  });
  Object.defineProperty(exports, "NATIVE_ACTION_RESULT", {
    enumerable: true,
    get: function () {
      return NATIVE_ACTION_RESULT;
    }
  });
  Object.defineProperty(exports, "DOM_EVENT", {
    enumerable: true,
    get: function () {
      return DOM_EVENT;
    }
  });
  Object.defineProperty(exports, "MATCH_CONTENTS_EVENT", {
    enumerable: true,
    get: function () {
      return MATCH_CONTENTS_EVENT;
    }
  });
  Object.defineProperty(exports, "REGISTER_DOM_IMPERATIVE_HANDLE_PROPS", {
    enumerable: true,
    get: function () {
      return REGISTER_DOM_IMPERATIVE_HANDLE_PROPS;
    }
  });
  Object.defineProperty(exports, "getInjectEventScript", {
    enumerable: true,
    get: function () {
      return getInjectEventScript;
    }
  });
  exports.getInjectBodySizeObserverScript = getInjectBodySizeObserverScript;
  const NATIVE_ACTION = '$$native_action';
  const NATIVE_ACTION_RESULT = '$$native_action_result';
  const DOM_EVENT = '$$dom_event';
  const MATCH_CONTENTS_EVENT = '$$match_contents_event';
  const REGISTER_DOM_IMPERATIVE_HANDLE_PROPS = '$$register_dom_imperative_handle_props';
  const getInjectEventScript = detail => {
    return `;(function() {
  try {
  window.dispatchEvent(new CustomEvent("${DOM_EVENT}",${JSON.stringify({
      detail
    })}));
  } catch (e) {}
  })();
  true;`;
  };
  function getInjectBodySizeObserverScript() {
    return `;(function observeDocumentBodySize() {
  window.addEventListener('DOMContentLoaded', () => {
    new ResizeObserver(entries => {
      const { width, height } = entries[0].contentRect;
      window.ReactNativeWebView?.postMessage(JSON.stringify({
        type: '${MATCH_CONTENTS_EVENT}',
        data: {
          width,
          height,
        },
      }));
    })
    .observe(document.body);
    window.ReactNativeWebView?.postMessage(JSON.stringify({
      type: '${MATCH_CONTENTS_EVENT}',
      data: {
        width: document.body.clientWidth,
        height: document.body.clientHeight,
      },
    }));
  });
  })();
  true;`;
  }
},663,[],"node_modules/expo/src/dom/injection.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function () {
      return _createURL.parse;
    }
  });
  Object.defineProperty(exports, "createURL", {
    enumerable: true,
    get: function () {
      return _createURL.createURL;
    }
  });
  exports.addEventListener = addEventListener;
  exports.parseInitialURLAsync = parseInitialURLAsync;
  exports.sendIntent = sendIntent;
  exports.openSettings = openSettings;
  exports.getInitialURL = getInitialURL;
  exports.getLinkingURL = getLinkingURL;
  exports.openURL = openURL;
  exports.canOpenURL = canOpenURL;
  exports.useURL = useURL;
  exports.useLinkingURL = useLinkingURL;
  var _expoModulesCore = require(_dependencyMap[0], "expo-modules-core");
  var _react = require(_dependencyMap[1], "react");
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[2], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _ExpoLinking = require(_dependencyMap[3], "./ExpoLinking");
  var ExpoLinking = _interopDefault(_ExpoLinking);
  var _RNLinking = require(_dependencyMap[4], "./RNLinking");
  var RNLinking = _interopDefault(_RNLinking);
  var _createURL = require(_dependencyMap[5], "./createURL");
  var _validateURL = require(_dependencyMap[6], "./validateURL");
  var _LinkingTypes = require(_dependencyMap[7], "./Linking.types");
  Object.keys(_LinkingTypes).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _LinkingTypes[k];
        }
      });
    }
  });
  var _Schemes = require(_dependencyMap[8], "./Schemes");
  Object.keys(_Schemes).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _Schemes[k];
        }
      });
    }
  });
  // @needsAudit
  /**
   * Add a handler to `Linking` changes by listening to the `url` event type and providing the handler.
   * It is recommended to use the [`useURL()`](#useurl) hook instead.
   * @param type The only valid type is `'url'`.
   * @param handler An [`URLListener`](#urllistener) function that takes an `event` object of the type
   * [`EventType`](#eventtype).
   * @return An EmitterSubscription that has the remove method from EventSubscription
   * @see [React Native documentation on Linking](https://reactnative.dev/docs/linking#addeventlistener).
   */
  function addEventListener(type, handler) {
    return RNLinking.default.addEventListener(type, handler);
  }
  // @needsAudit
  /**
   * Helper method which wraps React Native's `Linking.getInitialURL()` in `Linking.parse()`.
   * Parses the deep link information out of the URL used to open the experience initially.
   * If no link opened the app, all the fields will be `null`.
   * > On the web it parses the current window URL.
   * @return A promise that resolves with `ParsedURL` object.
   */
  async function parseInitialURLAsync() {
    const initialUrl = await RNLinking.default.getInitialURL();
    if (!initialUrl) {
      return {
        scheme: null,
        hostname: null,
        path: null,
        queryParams: null
      };
    }
    return (0, _createURL.parse)(initialUrl);
  }
  // @needsAudit
  /**
   * Launch an Android intent with extras.
   * > Use [`expo-intent-launcher`](./intent-launcher) instead. `sendIntent` is only included in
   * > `Linking` for API compatibility with React Native's Linking API.
   * @platform android
   */
  async function sendIntent(action, extras) {
    if (Platform.default.OS === 'android') {
      return await RNLinking.default.sendIntent(action, extras);
    }
    throw new _expoModulesCore.UnavailabilityError('Linking', 'sendIntent');
  }
  // @needsAudit
  /**
   * Open the operating system settings app and displays the app’s custom settings, if it has any.
   */
  async function openSettings() {
    if (Platform.default.OS === 'web') {
      throw new _expoModulesCore.UnavailabilityError('Linking', 'openSettings');
    }
    if (RNLinking.default.openSettings) {
      return await RNLinking.default.openSettings();
    }
    await openURL('app-settings:');
  }
  // @needsAudit
  /**
   * Get the URL that was used to launch the app if it was launched by a link.
   * @return The URL string that launched your app, or `null`.
   */
  async function getInitialURL() {
    return (await RNLinking.default.getInitialURL()) ?? null;
  }
  /**
   * Get the URL that was used to launch the app if it was launched by a link.
   * @return The URL string that launched your app, or `null`.
   */
  function getLinkingURL() {
    return ExpoLinking.default.getLinkingURL();
  }
  // @needsAudit
  /**
   * Attempt to open the given URL with an installed app. See the [Linking guide](/guides/linking)
   * for more information.
   * @param url A URL for the operating system to open. For example: `tel:5555555`, `exp://`.
   * @return A `Promise` that is fulfilled with `true` if the link is opened operating system
   * automatically or the user confirms the prompt to open the link. The `Promise` rejects if there
   * are no applications registered for the URL or the user cancels the dialog.
   */
  async function openURL(url) {
    (0, _validateURL.validateURL)(url);
    return await RNLinking.default.openURL(url);
  }
  // @needsAudit
  /**
   * Determine whether or not an installed app can handle a given URL.
   * On web this always returns `true` because there is no API for detecting what URLs can be opened.
   * @param url The URL that you want to test can be opened.
   * @return A `Promise` object that is fulfilled with `true` if the URL can be handled, otherwise it
   * `false` if not.
   * The `Promise` will reject on Android if it was impossible to check if the URL can be opened, and
   * on iOS if you didn't [add the specific scheme in the `LSApplicationQueriesSchemes` key inside **Info.plist**](/guides/linking#linking-from-your-app).
   */
  async function canOpenURL(url) {
    (0, _validateURL.validateURL)(url);
    return await RNLinking.default.canOpenURL(url);
  }
  // @needsAudit
  /**
   * Returns the initial URL followed by any subsequent changes to the URL.
   * @deprecated Use `useLinkingURL` hook instead.
   * @return Returns the initial URL or `null`.
   */
  function useURL() {
    const [url, setLink] = (0, _react.useState)(null);
    function onChange(event) {
      setLink(event.url);
    }
    (0, _react.useEffect)(() => {
      getInitialURL().then(url => setLink(url));
      const subscription = addEventListener('url', onChange);
      return () => subscription.remove();
    }, []);
    return url;
  }
  /**
   * Returns the linking URL followed by any subsequent changes to the URL.
   * Always returns the initial URL immediately on reload.
   * @return Returns the initial URL or `null`.
   */
  function useLinkingURL() {
    const [url, setLink] = (0, _react.useState)(ExpoLinking.default.getLinkingURL);
    function onChange(event) {
      setLink(event.url);
    }
    (0, _react.useEffect)(() => {
      const subscription = ExpoLinking.default.addListener('onURLReceived', onChange);
      return () => subscription.remove();
    }, []);
    return url ?? null;
  }
},664,[594,9,14,665,666,667,668,669,670],"node_modules/expo-linking/build/Linking.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _invariant = require(_dependencyMap[0], "invariant");
  var invariant = _interopDefault(_invariant);
  var _default = {
    addListener(eventName, listener) {
      (0, invariant.default)(eventName === 'onURLReceived', `Linking.addListener(): ${eventName} is not a valid event`);
      // Do nothing in Node.js environments
      if (typeof window === 'undefined') {
        return {
          remove() {}
        };
      }
      const nativeListener = nativeEvent => listener({
        url: window.location.href,
        nativeEvent
      });
      window.addEventListener('message', nativeListener, false);
      return {
        remove: () => {
          window.removeEventListener('message', nativeListener);
        }
      };
    },
    getLinkingURL() {
      if (typeof window === 'undefined') return '';
      return window.location.href;
    }
  };
},665,[628],"node_modules/expo-linking/build/ExpoLinking.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _invariant = require(_dependencyMap[0], "invariant");
  var invariant = _interopDefault(_invariant);
  const listeners = [];
  var _default = {
    addEventListener(type, listener) {
      // Do nothing in Node.js environments
      if (typeof window === 'undefined') {
        return {
          remove() {}
        };
      }
      (0, invariant.default)(type === 'url', `Linking.addEventListener(): ${type} is not a valid event`);
      const nativeListener = nativeEvent => listener({
        url: window.location.href,
        nativeEvent
      });
      listeners.push({
        listener,
        nativeListener
      });
      window.addEventListener('message', nativeListener, false);
      return {
        remove: () => {
          this.removeEventListener(type, listener);
        }
      };
    },
    removeEventListener(type, listener) {
      // Do nothing in Node.js environments
      if (typeof window === 'undefined') {
        return;
      }
      (0, invariant.default)(type === 'url', `Linking.addEventListener(): ${type} is not a valid event`);
      const listenerIndex = listeners.findIndex(pair => pair.listener === listener);
      (0, invariant.default)(listenerIndex !== -1, 'Linking.removeEventListener(): cannot remove an unregistered event listener.');
      const nativeListener = listeners[listenerIndex].nativeListener;
      window.removeEventListener('message', nativeListener, false);
      listeners.splice(listenerIndex, 1);
    },
    async canOpenURL() {
      // In reality this should be able to return false for links like `chrome://` on chrome.
      return true;
    },
    async getInitialURL() {
      if (typeof window === 'undefined') return '';
      return window.location.href;
    },
    async openURL(url) {
      if (typeof window !== 'undefined') {
        // @ts-ignore
        window.location = new URL(url, window.location).toString();
      }
    }
  };
},666,[628],"node_modules/expo-linking/build/RNLinking.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.createURL = createURL;
  exports.parse = parse;
  function createURL(path, {
    queryParams = {}
  } = {}) {
    if (typeof window === 'undefined') return '';
    const url = new URL(path, window.location.origin);
    Object.entries(queryParams).forEach(([key, value]) => {
      if (typeof value === 'string') {
        url.searchParams.set(key, encodeURIComponent(value));
      } else if (value != null) {
        url.searchParams.set(key,
        // @ts-expect-error: browser supports using array
        value);
      }
    });
    return url.toString().replace(/\/$/, '');
  }
  function parse(url) {
    let parsed;
    try {
      parsed = new URL(url);
    } catch {
      if (typeof window === 'undefined') {
        return {
          hostname: null,
          path: url,
          queryParams: {},
          scheme: null
        };
      }
      return {
        hostname: 'localhost',
        path: url,
        queryParams: {},
        scheme: 'http'
      };
    }
    const queryParams = {};
    parsed.searchParams.forEach((value, key) => {
      queryParams[key] = decodeURIComponent(value);
    });
    return {
      hostname: parsed.hostname || null,
      // TODO: We should probably update native to follow the default URL behavior closer.
      path: !parsed.hostname && !parsed.pathname ? null : parsed.pathname === '' ? null : parsed.pathname.replace(/^\//, ''),
      queryParams,
      scheme: parsed.protocol.replace(/:$/, '')
    };
  }
},667,[],"node_modules/expo-linking/build/createURL.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.validateURL = validateURL;
  var _invariant = require(_dependencyMap[0], "invariant");
  var invariant = _interopDefault(_invariant);
  function validateURL(url) {
    (0, invariant.default)(typeof url === 'string', 'Invalid URL: should be a string. Was: ' + url);
    (0, invariant.default)(url, 'Invalid URL: cannot be empty');
  }
},668,[628],"node_modules/expo-linking/build/validateURL.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},669,[],"node_modules/expo-linking/build/Linking.types.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.hasCustomScheme = hasCustomScheme;
  exports.collectManifestSchemes = collectManifestSchemes;
  exports.hasConstantsManifest = hasConstantsManifest;
  exports.resolveScheme = resolveScheme;
  function hasCustomScheme() {
    return true;
  }
  function collectManifestSchemes() {
    return [];
  }
  function hasConstantsManifest() {
    return false;
  }
  function resolveScheme() {
    return 'https';
  }
},670,[],"node_modules/expo-linking/build/Schemes.web.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.store = void 0;
  exports.useStore = useStore;
  exports.useRouteInfo = useRouteInfo;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const expo_constants_1 = __importDefault(require(_dependencyMap[1], "expo-constants"));
  const react_1 = require(_dependencyMap[2], "react");
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const extractPathFromURL_1 = require(_dependencyMap[4], "../fork/extractPathFromURL");
  const getStateFromPath_forks_1 = require(_dependencyMap[5], "../fork/getStateFromPath-forks");
  const getLinkingConfig_1 = require(_dependencyMap[6], "../getLinkingConfig");
  const getReactNavigationConfig_1 = require(_dependencyMap[7], "../getReactNavigationConfig");
  const getRoutes_1 = require(_dependencyMap[8], "../getRoutes");
  const routeInfo_1 = require(_dependencyMap[9], "./routeInfo");
  const href_1 = require(_dependencyMap[10], "../link/href");
  const useScreens_1 = require(_dependencyMap[11], "../useScreens");
  const PreviewRouteContext_1 = require(_dependencyMap[12], "../link/preview/PreviewRouteContext");
  const url_1 = require(_dependencyMap[13], "../utils/url");
  const SplashScreen = __importStar(require(_dependencyMap[14], "../views/Splash"));
  const storeRef = {
    current: {}
  };
  const routeInfoCache = new WeakMap();
  const routeInfoValuesCache = new Map();
  let splashScreenAnimationFrame;
  let hasAttemptedToHideSplash = false;
  exports.store = {
    shouldShowTutorial() {
      return !storeRef.current.routeNode && process.env.NODE_ENV === 'development';
    },
    get state() {
      return storeRef.current.state;
    },
    get navigationRef() {
      return storeRef.current.navigationRef;
    },
    get routeNode() {
      return storeRef.current.routeNode;
    },
    getRouteInfo() {
      return storeRef.current.routeInfo || routeInfo_1.defaultRouteInfo;
    },
    get redirects() {
      return storeRef.current.redirects || [];
    },
    get rootComponent() {
      return storeRef.current.rootComponent;
    },
    getStateForHref(href, options) {
      href = (0, href_1.resolveHref)(href);
      href = (0, href_1.resolveHrefStringWithSegments)(href, exports.store.getRouteInfo(), options);
      return this.linking?.getStateFromPath(href, this.linking.config);
    },
    get linking() {
      return storeRef.current.linking;
    },
    setFocusedState(state) {
      const routeInfo = getCachedRouteInfo(state);
      storeRef.current.routeInfo = routeInfo;
    },
    onReady() {
      if (!hasAttemptedToHideSplash) {
        hasAttemptedToHideSplash = true;
        // NOTE(EvanBacon): `navigationRef.isReady` is sometimes not true when state is called initially.
        splashScreenAnimationFrame = requestAnimationFrame(() => {
          SplashScreen._internal_maybeHideAsync?.();
        });
      }
      storeRef.current.navigationRef.addListener('state', e => {
        if (!e.data.state) {
          return;
        }
        let isStale = false;
        let state = e.data.state;
        while (!isStale && state) {
          isStale = state.stale;
          state = state.routes?.['index' in state && typeof state.index === 'number' ? state.index : state.routes.length - 1]?.state;
        }
        storeRef.current.state = e.data.state;
        if (!isStale) {
          storeRef.current.routeInfo = getCachedRouteInfo(e.data.state);
        }
        for (const callback of routeInfoSubscribers) {
          callback();
        }
      });
    },
    assertIsReady() {
      if (!storeRef.current.navigationRef.isReady()) {
        throw new Error('Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.');
      }
    }
  };
  function useStore(context, linkingConfigOptions, serverUrl) {
    const navigationRef = (0, native_1.useNavigationContainerRef)();
    const config = expo_constants_1.default.expoConfig?.extra?.router;
    let linking;
    let rootComponent = react_1.Fragment;
    let initialState;
    const routeNode = (0, getRoutes_1.getRoutes)(context, Object.assign({}, config, {
      skipGenerated: true,
      ignoreEntryPoints: true,
      platform: react_native_1.Platform.OS,
      preserveRedirectAndRewrites: true
    }));
    const redirects = [config?.redirects, config?.rewrites].filter(Boolean).flat().map(route => {
      return [(0, getStateFromPath_forks_1.routePatternToRegex)((0, getReactNavigationConfig_1.parseRouteSegments)(route.source)), route, (0, url_1.shouldLinkExternally)(route.destination)];
    });
    if (routeNode) {
      // We have routes, so get the linking config and the root component
      linking = (0, getLinkingConfig_1.getLinkingConfig)(routeNode, context, () => exports.store.getRouteInfo(), {
        metaOnly: linkingConfigOptions.metaOnly,
        serverUrl,
        redirects,
        skipGenerated: config?.skipGenerated ?? false,
        sitemap: config?.sitemap ?? true,
        notFound: config?.notFound ?? true
      });
      rootComponent = (0, useScreens_1.getQualifiedRouteComponent)(routeNode);
      // By default React Navigation is async and does not render anything in the first pass as it waits for `getInitialURL`
      // This will cause static rendering to fail, which once performs a single pass.
      // If the initialURL is a string, we can prefetch the state and routeInfo, skipping React Navigation's async behavior.
      const initialURL = linking?.getInitialURL?.();
      if (typeof initialURL === 'string') {
        let initialPath = (0, extractPathFromURL_1.extractExpoPathFromURL)(linking.prefixes, initialURL);
        // It does not matter if the path starts with a `/` or not, but this keeps the behavior consistent
        if (!initialPath.startsWith('/')) initialPath = '/' + initialPath;
        initialState = linking.getStateFromPath(initialPath, linking.config);
        const initialRouteInfo = (0, routeInfo_1.getRouteInfoFromState)(initialState);
        routeInfoCache.set(initialState, initialRouteInfo);
        routeInfoValuesCache.set(JSON.stringify(initialRouteInfo), initialRouteInfo);
      }
    } else {
      // Only error in production, in development we will show the onboarding screen
      if (process.env.NODE_ENV === 'production') {
        throw new Error('No routes found');
      }
      // In development, we will show the onboarding screen
      rootComponent = react_1.Fragment;
    }
    storeRef.current = {
      navigationRef,
      routeNode,
      config,
      rootComponent,
      linking,
      redirects,
      state: initialState
    };
    if (initialState) {
      storeRef.current.routeInfo = getCachedRouteInfo(initialState);
    }
    (0, react_1.useEffect)(() => {
      return () => {
        // listener();
        if (splashScreenAnimationFrame) {
          cancelAnimationFrame(splashScreenAnimationFrame);
          splashScreenAnimationFrame = undefined;
        }
      };
    });
    return exports.store;
  }
  const routeInfoSubscribers = new Set();
  const routeInfoSubscribe = callback => {
    routeInfoSubscribers.add(callback);
    return () => {
      routeInfoSubscribers.delete(callback);
    };
  };
  function useRouteInfo() {
    const routeInfo = (0, react_1.useSyncExternalStore)(routeInfoSubscribe, exports.store.getRouteInfo, exports.store.getRouteInfo);
    const {
      isPreview,
      segments,
      params,
      pathname
    } = (0, PreviewRouteContext_1.usePreviewInfo)();
    if (isPreview) {
      return {
        pathname: pathname ?? '',
        segments: segments ?? [],
        unstable_globalHref: '',
        params: params ?? {},
        searchParams: new URLSearchParams(),
        pathnameWithParams: pathname ?? '',
        isIndex: false
      };
    }
    return routeInfo;
  }
  function getCachedRouteInfo(state) {
    let routeInfo = routeInfoCache.get(state);
    if (!routeInfo) {
      routeInfo = (0, routeInfo_1.getRouteInfoFromState)(state);
      const routeInfoString = JSON.stringify(routeInfo);
      // Using cached values to avoid re-renders, to increase the chance that the object reference is the same
      const cachedRouteInfo = routeInfoValuesCache.get(routeInfoString);
      if (cachedRouteInfo) {
        routeInfo = cachedRouteInfo;
      } else {
        routeInfoValuesCache.set(routeInfoString, routeInfo);
      }
      routeInfoCache.set(state, routeInfo);
    }
    return routeInfo;
  }
},671,[253,636,9,492,672,673,674,675,687,703,640,388,385,677,548],"node_modules/expo-router/build/global-state/router-store.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parsePathAndParamsFromExpoGoLink = parsePathAndParamsFromExpoGoLink;
  exports.parsePathFromExpoGoLink = parsePathFromExpoGoLink;
  exports.extractExpoPathFromURL = extractExpoPathFromURL;
  function parsePathAndParamsFromExpoGoLink(url) {
    // If the URL is defined (default in Expo Go dev apps) and the URL has no path:
    // `exp://192.168.87.39:19000/` then use the default `exp://192.168.87.39:19000/--/`
    const href = parsePathFromExpoGoLink(url);
    const results = href.match(/([^?]*)(\?.*)?/);
    return {
      pathname: results?.[1] ?? '',
      queryString: results?.[2] ?? ''
    };
  }
  function parsePathFromExpoGoLink(url) {
    // If the URL is defined (default in Expo Go dev apps) and the URL has no path:
    // `exp://192.168.87.39:19000/` then use the default `exp://192.168.87.39:19000/--/`
    return url.match(/exps?:\/\/.*?\/--\/(.*)/)?.[1] ?? '';
  }
  // This is only run on native.
  function extractExactPathFromURL(url) {
    if (
    // If a universal link / app link / web URL is used, we should use the path
    // from the URL, while stripping the origin.
    url.match(/^https?:\/\//)) {
      const {
        origin,
        href,
        hostname
      } = new URL(url);
      if (hostname === 'exp.host' || hostname === 'u.expo.dev') {
        // These are QR code generate deep-link that always like to the '/' path
        // TODO: In the future, QR code may link to a specific path and this logic will need to be udpated
        return '';
      }
      return href.replace(origin, '');
    }
    const isExpoGo = typeof expo !== 'undefined' && globalThis.expo?.modules?.ExpoGo;
    // Handle special URLs used in Expo Go: `/--/pathname` -> `pathname`
    if (isExpoGo &&
    // while not exhaustive, `exp` and `exps` are the only two schemes which
    // are passed through to other apps in Expo Go.
    url.match(/^exp(s)?:\/\//)) {
      const pathname = parsePathFromExpoGoLink(url);
      if (pathname) {
        return fromDeepLink('a://' + pathname);
      }
      // Match the `?.*` segment of the URL.
      const queryParams = url.match(/exps?:\/\/.*\?(.*)/)?.[1];
      if (queryParams) {
        return fromDeepLink('a://?' + queryParams);
      }
      return '';
    }
    // TODO: Support dev client URLs
    return fromDeepLink(url);
  }
  /** Major hack to support the makeshift expo-development-client system. */
  function isExpoDevelopmentClient(url) {
    return url.hostname === 'expo-development-client';
  }
  function fromDeepLink(url) {
    let res;
    try {
      // This is for all standard deep links, e.g. `foobar://` where everything
      // after the `://` is the path.
      res = new URL(url);
    } catch {
      /**
       * We failed to parse the URL. This can occur for a variety of reasons, including:
       * - Its a partial URL (e.g. `/route?query=param`).
       * - It has a valid App scheme, but the scheme isn't a valid URL scheme (e.g. `my_app://`)
       */
      // If `url` is already a path (starts with `/`), return it as-is
      if (url.startsWith('/')) {
        return url;
      }
      /**
       * App schemes are not valid URL schemes, so they will fail to parse.
       * We need to strip the scheme from these URLs
       */
      return url.replace(/^[^:]+:\/\//, '');
    }
    if (isExpoDevelopmentClient(res)) {
      if (!res.searchParams.get('url')) {
        return '';
      }
      const incomingUrl = res.searchParams.get('url');
      return extractExactPathFromURL(decodeURI(incomingUrl));
    }
    let results = '';
    if (res.host) {
      results += res.host;
    }
    if (res.pathname) {
      results += res.pathname;
    }
    const qs = !res.search ? '' :
    // @ts-ignore: `entries` is not on `URLSearchParams` in some typechecks.
    [...res.searchParams.entries()].map(([k, v]) => `${k}=${decodeURIComponent(v)}`).join('&');
    if (qs) {
      results += '?' + qs;
    }
    return results;
  }
  function extractExpoPathFromURL(_prefixes, url = '') {
    return extractExactPathFromURL(url)
    // TODO: We should get rid of this, dropping specificities is not good
    .replace(/^\//, '');
  }
},672,[],"node_modules/expo-router/build/fork/extractPathFromURL.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.populateParams = populateParams;
  exports.safelyDecodeURIComponent = safelyDecodeURIComponent;
  exports.getUrlWithReactNavigationConcessions = getUrlWithReactNavigationConcessions;
  exports.createConfig = createConfig;
  exports.assertScreens = assertScreens;
  exports.configRegExp = configRegExp;
  exports.isDynamicPart = isDynamicPart;
  exports.replacePart = replacePart;
  exports.getParamValue = getParamValue;
  exports.handleUrlParams = handleUrlParams;
  exports.spreadParamsAcrossAllStates = spreadParamsAcrossAllStates;
  exports.stripBaseUrl = stripBaseUrl;
  exports.matchForEmptyPath = matchForEmptyPath;
  exports.appendIsInitial = appendIsInitial;
  exports.getRouteConfigSorter = getRouteConfigSorter;
  exports.parseQueryParams = parseQueryParams;
  exports.cleanPath = cleanPath;
  exports.routePatternToRegex = routePatternToRegex;
  const escape_string_regexp_1 = __importDefault(require(_dependencyMap[0], "escape-string-regexp"));
  const matchers_1 = require(_dependencyMap[1], "../matchers");
  /**
   * In Expo Router, the params are available at all levels of the routing config
   * @param routes
   * @returns
   */
  function populateParams(routes, params) {
    if (!routes || !params || Object.keys(params).length === 0) return;
    for (const route of routes) {
      Object.assign(route, {
        params
      });
    }
    return routes;
  }
  function safelyDecodeURIComponent(str) {
    try {
      return decodeURIComponent(str);
    } catch {
      return str;
    }
  }
  function getUrlWithReactNavigationConcessions(path, baseUrl = "") {
    const pathWithoutGroups = (0, matchers_1.stripGroupSegmentsFromPath)(stripBaseUrl(path, baseUrl));
    let pathname = '';
    let hash = '';
    try {
      // NOTE(@kitten): This used to use a dummy base URL for parsing (phony [.] example)
      // However, this seems to get flagged since it's preserved 1:1 in the output bytecode by certain scanners
      // Instead, we use an empty `file:` URL. This will still perform `pathname` normalization, search parameter parsing
      // encoding, and all other logic, except the logic that applies to hostnames and protocols, and also not leave a
      // dummy URL in the output bytecode
      const parsed = new URL(path, 'file:');
      pathname = parsed.pathname;
      hash = parsed.hash;
    } catch {
      // Do nothing with invalid URLs.
    }
    const withoutBaseUrl = stripBaseUrl(pathname, baseUrl);
    return {
      path,
      // Make sure there is a trailing slash
      // The slashes are at the end, not the beginning
      nonstandardPathname: withoutBaseUrl.replace(/^\/+/g, '').replace(/\/+$/g, '') + '/',
      hash,
      pathWithoutGroups
    };
  }
  function createConfig(screen, pattern, routeNames, config = {}) {
    const parts = [];
    let isDynamic = false;
    const isIndex = screen === 'index' || screen.endsWith('/index');
    let staticPartCount = 0;
    for (const part of pattern.split('/')) {
      if (part) {
        // If any part is dynamic, then the route is dynamic
        const isDynamicPart = part.startsWith(':') || part.startsWith('*') || part.includes('*not-found');
        isDynamic ||= isDynamicPart;
        if (!(0, matchers_1.matchGroupName)(part)) {
          parts.push(part);
          if (!isDynamicPart) {
            staticPartCount++;
          }
        }
      }
    }
    const hasChildren = config.screens ? !!Object.keys(config.screens)?.length : false;
    const type = hasChildren ? 'layout' : isDynamic ? 'dynamic' : 'static';
    if (isIndex) {
      parts.push('index');
      staticPartCount++;
    }
    return {
      type,
      isIndex,
      hasChildren,
      parts,
      staticPartCount,
      userReadableName: [...routeNames.slice(0, -1), config.path || screen].join('/'),
      // Don't include the __root route name
      expandedRouteNames: routeNames.slice(1).flatMap(name => {
        return name.split('/');
      })
    };
  }
  function assertScreens(options) {
    if (!options?.screens) {
      throw Error("You must pass a 'screens' object to 'getStateFromPath' to generate a path.");
    }
  }
  function configRegExp(config) {
    return config.pattern ? new RegExp(`^(${config.pattern.split('/').map(formatRegexPattern).join('')})$`) : undefined;
  }
  function isDynamicPart(p) {
    return p.length > 1 && (p.startsWith(':') || p.startsWith('*'));
  }
  function replacePart(p) {
    return p.replace(/^[:*]/, '').replace(/\?$/, '');
  }
  function getParamValue(p, value) {
    if (p.startsWith('*')) {
      const values = value.split('/').filter(v => v !== '');
      return values.length === 0 && p.endsWith('?') ? undefined : values;
    } else {
      return value;
    }
  }
  function formatRegexPattern(it) {
    // Allow spaces in file path names.
    it = it.replace(' ', '%20');
    if (it.startsWith(':')) {
      // TODO: Remove unused match group
      return `(([^/]+\\/)${it.endsWith('?') ? '?' : ''})`;
    } else if (it.startsWith('*')) {
      return `((.*\\/)${it.endsWith('?') ? '?' : ''})`;
    }
    // Strip groups from the matcher
    if ((0, matchers_1.matchGroupName)(it) != null) {
      // Groups are optional segments
      // this enables us to match `/bar` and `/(foo)/bar` for the same route
      // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group
      return `(?:${(0, escape_string_regexp_1.default)(it)}\\/)?`;
    }
    return (0, escape_string_regexp_1.default)(it) + `\\/`;
  }
  function handleUrlParams(route, params) {
    if (params) {
      route.params = Object.assign(Object.create(null), route.params);
      for (const [name, value] of Object.entries(params)) {
        if (route.params?.[name]) {
          if (process.env.NODE_ENV !== 'production') {
            console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);
          }
        }
        if (!route.params?.[name]) {
          route.params[name] = value;
          continue;
        }
      }
      if (Object.keys(route.params).length === 0) {
        delete route.params;
      }
    }
  }
  function spreadParamsAcrossAllStates(state, params) {
    while (state) {
      const route = state.routes[0];
      route.params = Object.assign({}, route.params, params);
    }
  }
  function stripBaseUrl(path, baseUrl = "") {
    if (process.env.NODE_ENV !== 'development') {
      if (baseUrl) {
        return path.replace(/^\/+/g, '/').replace(new RegExp(`^\\/?${(0, escape_string_regexp_1.default)(baseUrl)}`, 'g'), '');
      }
    }
    return path;
  }
  function matchForEmptyPath(configs) {
    // We need to add special handling of empty path so navigation to empty path also works
    // When handling empty path, we should only look at the root level config
    // NOTE(EvanBacon): We only care about matching leaf nodes.
    const leafNodes = configs.filter(config => !config.hasChildren).map(value => {
      return Object.assign({}, value, {
        // Collapse all levels of group segments before testing.
        // This enables `app/(one)/(two)/index.js` to be matched.
        path: (0, matchers_1.stripGroupSegmentsFromPath)(value.path)
      });
    });
    const match = leafNodes.find(config =>
    // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.
    config.path === '' && (!config.regex || config.regex.test(''))) ?? leafNodes.find(config =>
    // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.
    config.path.startsWith(':') && config.regex.test('')) ??
    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.
    // This should be done last to enable dynamic routes having a higher priority.
    leafNodes.find(config => config.path.startsWith('*') && config.regex.test('/'));
    return match;
  }
  function appendIsInitial(initialRoutes) {
    const resolvedInitialPatterns = initialRoutes.map(route => joinPaths(...route.parentScreens, route.initialRouteName));
    return function (config) {
      // TODO(EvanBacon): Probably a safer way to do this
      // Mark initial routes to give them potential priority over other routes that match.
      config.isInitial = resolvedInitialPatterns.includes(config.routeNames.join('/'));
      return config;
    };
  }
  const joinPaths = (...paths) => [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');
  function getRouteConfigSorter(previousSegments = []) {
    return function sortConfigs(a, b) {
      // Sort config so that:
      // - the most exhaustive ones are always at the beginning
      // - patterns with wildcard are always at the end
      // If 2 patterns are same, move the one with less route names up
      // This is an error state, so it's only useful for consistent error messages
      if (a.pattern === b.pattern) {
        return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));
      }
      /*
       * If one of the patterns starts with the other, it is earlier in the config sorting.
       * However, configs are a mix of route configs and layout configs
       * e.g There will be a config for `/(group)`, but maybe there isn't a `/(group)/index.tsx`
       *
       * This is because you can navigate to a directory and its navigator will determine the route
       * These routes should be later in the config sorting, as their patterns are very open
       * and will prevent routes from being matched
       *
       * Therefore before we compare segment parts, we force these layout configs later in the sorting
       *
       * NOTE(marklawlor): Is this a feature we want? I'm unsure if this is a gimmick or a feature.
       */
      if (a.pattern.startsWith(b.pattern) && !b.isIndex) {
        return -1;
      }
      if (b.pattern.startsWith(a.pattern) && !a.isIndex) {
        return 1;
      }
      /*
       * Static routes should always be higher than dynamic and layout routes.
       */
      if (a.type === 'static' && b.type !== 'static') {
        return -1;
      } else if (a.type !== 'static' && b.type === 'static') {
        return 1;
      }
      /*
       * If the routes have any static segments, the one the most static segments should be higher
       */
      if (a.staticPartCount !== b.staticPartCount) {
        return b.staticPartCount - a.staticPartCount;
      }
      /*
       * If both are static/dynamic or a layout file, then we check group similarity
       */
      const similarToPreviousA = previousSegments.filter((value, index) => {
        return value === a.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');
      });
      const similarToPreviousB = previousSegments.filter((value, index) => {
        return value === b.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');
      });
      if ((similarToPreviousA.length > 0 || similarToPreviousB.length > 0) && similarToPreviousA.length !== similarToPreviousB.length) {
        // One matches more than the other, so pick the one that matches more
        return similarToPreviousB.length - similarToPreviousA.length;
      }
      /*
       * If there is not difference in similarity, then each non-group segment is compared against each other
       */
      for (let i = 0; i < Math.max(a.parts.length, b.parts.length); i++) {
        // if b is longer, b get higher priority
        if (a.parts[i] == null) {
          return 1;
        }
        // if a is longer, a get higher priority
        if (b.parts[i] == null) {
          return -1;
        }
        const aWildCard = a.parts[i].startsWith('*');
        const bWildCard = b.parts[i].startsWith('*');
        // if both are wildcard we compare next component
        if (aWildCard && bWildCard) {
          const aNotFound = a.parts[i].match(/^[*]not-found$/);
          const bNotFound = b.parts[i].match(/^[*]not-found$/);
          if (aNotFound && bNotFound) {
            continue;
          } else if (aNotFound) {
            return 1;
          } else if (bNotFound) {
            return -1;
          }
          continue;
        }
        // if only a is wild card, b get higher priority
        if (aWildCard) {
          return 1;
        }
        // if only b is wild card, a get higher priority
        if (bWildCard) {
          return -1;
        }
        const aSlug = a.parts[i].startsWith(':');
        const bSlug = b.parts[i].startsWith(':');
        // if both are wildcard we compare next component
        if (aSlug && bSlug) {
          const aNotFound = a.parts[i].match(/^[*]not-found$/);
          const bNotFound = b.parts[i].match(/^[*]not-found$/);
          if (aNotFound && bNotFound) {
            continue;
          } else if (aNotFound) {
            return 1;
          } else if (bNotFound) {
            return -1;
          }
          continue;
        }
        // if only a is wild card, b get higher priority
        if (aSlug) {
          return 1;
        }
        // if only b is wild card, a get higher priority
        if (bSlug) {
          return -1;
        }
      }
      /*
       * Both configs are identical in specificity and segments count/type
       * Try and sort by initial instead.
       *
       * TODO: We don't differentiate between the default initialRoute and group specific default routes
       *
       * const unstable_settings = {
       *   "group": {
       *     initialRouteName: "article"
       *  }
       * }
       *
       * "article" will be ranked higher because its an initialRoute for a group - even if not your not currently in
       * that group. The current work around is to ways provide initialRouteName for all groups
       */
      if (a.isInitial && !b.isInitial) {
        return -1;
      } else if (!a.isInitial && b.isInitial) {
        return 1;
      }
      return b.parts.length - a.parts.length;
    };
  }
  function parseQueryParams(path, route, parseConfig, hash) {
    const searchParams = new URL(path, 'https://phony.example').searchParams;
    const params = Object.create(null);
    if (hash) {
      params['#'] = hash.slice(1);
    }
    for (const name of searchParams.keys()) {
      if (route.params?.[name]) {
        if (process.env.NODE_ENV !== 'production') {
          console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);
        }
      } else {
        const values = parseConfig?.hasOwnProperty(name) ? searchParams.getAll(name).map(value => parseConfig[name](value)) : searchParams.getAll(name);
        // searchParams.getAll returns an array.
        // if we only have a single value, and its not an array param, we need to extract the value
        params[name] = values.length === 1 ? values[0] : values;
      }
    }
    return Object.keys(params).length ? params : undefined;
  }
  function cleanPath(path) {
    path = path
    // let remaining = path
    // END FORK
    .replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
    .replace(/^\//, '') // Remove extra leading slash
    .replace(/\?.*$/, ''); // Remove query params which we will handle later
    // Make sure there is a trailing slash
    return path.endsWith('/') ? path : `${path}/`;
  }
  function routePatternToRegex(pattern) {
    return new RegExp(`^(${pattern.split('/').map(it => {
      if (it.startsWith('(') && it.endsWith(')')) {
        return `${it}?`;
      } else if (it.startsWith(':')) {
        return `(([^/]+\\/)${it.endsWith('?') ? '?' : ''})`;
      }
      return `${it === '*' ? '.*' : (0, escape_string_regexp_1.default)(it)}\\/`;
    }).join('')})`);
  }
},673,[308,380],"node_modules/expo-router/build/fork/getStateFromPath-forks.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getNavigationConfig = getNavigationConfig;
  exports.getLinkingConfig = getLinkingConfig;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const expo_modules_core_1 = require(_dependencyMap[1], "expo-modules-core");
  const constants_1 = require(_dependencyMap[2], "./constants");
  const getReactNavigationConfig_1 = require(_dependencyMap[3], "./getReactNavigationConfig");
  const getRoutesRedirects_1 = require(_dependencyMap[4], "./getRoutesRedirects");
  const linking_1 = require(_dependencyMap[5], "./link/linking");
  function getNavigationConfig(routes, metaOnly, {
    sitemap,
    notFound
  }) {
    const config = (0, getReactNavigationConfig_1.getReactNavigationConfig)(routes, metaOnly);
    const sitemapRoute = (() => {
      const path = '_sitemap';
      if (sitemap === false || isPathInRootConfig(config, path)) {
        return {};
      }
      return generateLinkingPathInRoot(constants_1.SITEMAP_ROUTE_NAME, path, metaOnly);
    })();
    const notFoundRoute = (() => {
      const path = '*not-found';
      if (notFound === false || isPathInRootConfig(config, path)) {
        return {};
      }
      return generateLinkingPathInRoot(constants_1.NOT_FOUND_ROUTE_NAME, path, metaOnly);
    })();
    return {
      screens: Object.assign({
        [constants_1.INTERNAL_SLOT_NAME]: Object.assign({
          path: ''
        }, config)
      }, sitemapRoute, notFoundRoute)
    };
  }
  function getLinkingConfig(routes, context, getRouteInfo, {
    metaOnly = true,
    serverUrl,
    redirects,
    skipGenerated,
    sitemap,
    notFound
  }) {
    // Returning `undefined` / `null from `getInitialURL` are valid values, so we need to track if it's been called.
    let hasCachedInitialUrl = false;
    let initialUrl;
    const nativeLinkingKey = context.keys().find(key => key.match(/^\.\/\+native-intent\.[tj]sx?$/));
    const nativeLinking = nativeLinkingKey ? context(nativeLinkingKey) : undefined;
    const config = getNavigationConfig(routes, metaOnly, {
      sitemap: skipGenerated ? false : sitemap,
      notFound: skipGenerated ? false : notFound
    });
    return {
      prefixes: [],
      config,
      // A custom getInitialURL is used on native to ensure the app always starts at
      // the root path if it's launched from something other than a deep link.
      // This helps keep the native functionality working like the web functionality.
      // For example, if you had a root navigator where the first screen was `/settings` and the second was `/index`
      // then `/index` would be used on web and `/settings` would be used on native.
      getInitialURL() {
        // Expo Router calls `getInitialURL` twice, which may confuse the user if they provide a custom `getInitialURL`.
        // Therefor we memoize the result.
        if (!hasCachedInitialUrl) {
          if (expo_modules_core_1.Platform.OS === 'web') {
            initialUrl = serverUrl ?? (0, linking_1.getInitialURL)();
          } else {
            initialUrl = serverUrl ?? (0, linking_1.getInitialURL)();
            if (typeof initialUrl === 'string') {
              initialUrl = (0, getRoutesRedirects_1.applyRedirects)(initialUrl, redirects);
              if (initialUrl && typeof nativeLinking?.redirectSystemPath === 'function') {
                initialUrl = nativeLinking.redirectSystemPath({
                  path: initialUrl,
                  initial: true
                });
              }
            } else if (initialUrl) {
              initialUrl = initialUrl.then(url => {
                url = (0, getRoutesRedirects_1.applyRedirects)(url, redirects);
                if (url && typeof nativeLinking?.redirectSystemPath === 'function') {
                  return nativeLinking.redirectSystemPath({
                    path: url,
                    initial: true
                  });
                }
                return url;
              });
            }
          }
          hasCachedInitialUrl = true;
        }
        return initialUrl;
      },
      subscribe: (0, linking_1.subscribe)(nativeLinking, redirects),
      getStateFromPath: (path, options) => {
        return (0, linking_1.getStateFromPath)(path, options, getRouteInfo().segments);
      },
      getPathFromState(state, options) {
        return (0, linking_1.getPathFromState)(state, Object.assign({}, config, options, {
          screens: config.screens ?? options?.screens ?? {}
        })) ?? '/';
      },
      // Add all functions to ensure the types never need to fallback.
      // This is a convenience for usage in the package.
      getActionFromState: native_1.getActionFromState
    };
  }
  function isPathInRootConfig(config, path) {
    return Object.values(config.screens).some(screenConfig => typeof screenConfig === 'string' ? screenConfig === path : screenConfig.path === path);
  }
  function generateLinkingPathInRoot(name, path, metaOnly) {
    if (metaOnly) {
      return {
        [name]: path
      };
    }
    return {
      [name]: {
        path
      }
    };
  }
},674,[253,594,639,675,676,680],"node_modules/expo-router/build/getLinkingConfig.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parseRouteSegments = parseRouteSegments;
  exports.getReactNavigationScreensConfig = getReactNavigationScreensConfig;
  exports.getReactNavigationConfig = getReactNavigationConfig;
  const matchers_1 = require(_dependencyMap[0], "./matchers");
  // `[page]` -> `:page`
  // `page` -> `page`
  function convertDynamicRouteToReactNavigation(segment) {
    // NOTE(EvanBacon): To support shared routes we preserve group segments.
    if (segment === 'index') {
      return '';
    }
    if (segment === '+not-found') {
      return '*not-found';
    }
    const dynamicName = (0, matchers_1.matchDynamicName)(segment);
    if (dynamicName && !dynamicName.deep) {
      return `:${dynamicName.name}`;
    } else if (dynamicName?.deep) {
      return '*' + dynamicName.name;
    } else {
      return segment;
    }
  }
  function parseRouteSegments(segments) {
    return (
      // NOTE(EvanBacon): When there are nested routes without layouts
      // the node.route will be something like `app/home/index`
      // this needs to be split to ensure each segment is parsed correctly.
      segments.split('/')
      // Convert each segment to a React Navigation format.
      .map(convertDynamicRouteToReactNavigation)
      // Remove any empty paths from groups or index routes.
      .filter(Boolean)
      // Join to return as a path.
      .join('/')
    );
  }
  function convertRouteNodeToScreen(node, metaOnly) {
    const path = parseRouteSegments(node.route);
    if (!node.children.length) {
      if (!metaOnly) {
        return {
          path,
          screens: {},
          _route: node
        };
      }
      return path;
    }
    const screens = getReactNavigationScreensConfig(node.children, metaOnly);
    const screen = {
      path,
      screens
    };
    if (node.initialRouteName) {
      // NOTE(EvanBacon): This is bad because it forces all Layout Routes
      // to be loaded into memory. We should move towards a system where
      // the initial route name is either loaded asynchronously in the Layout Route
      // or defined via a file system convention.
      screen.initialRouteName = node.initialRouteName;
    }
    if (!metaOnly) {
      screen._route = node;
    }
    return screen;
  }
  function getReactNavigationScreensConfig(nodes, metaOnly) {
    return Object.fromEntries(nodes.map(node => [node.route, convertRouteNodeToScreen(node, metaOnly)]));
  }
  function getReactNavigationConfig(routes, metaOnly) {
    const config = {
      initialRouteName: undefined,
      screens: getReactNavigationScreensConfig(routes.children, metaOnly)
    };
    if (routes.initialRouteName) {
      // We're using LinkingOptions the generic type is `object` instead of a proper ParamList.
      // So we need to cast the initialRouteName to `any` to avoid type errors.
      config.initialRouteName = routes.initialRouteName;
    }
    return config;
  }
},675,[380],"node_modules/expo-router/build/getReactNavigationConfig.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.applyRedirects = applyRedirects;
  exports.getRedirectModule = getRedirectModule;
  exports.convertRedirect = convertRedirect;
  exports.mergeVariablesWithPath = mergeVariablesWithPath;
  const Linking = __importStar(require(_dependencyMap[0], "expo-linking"));
  const react_1 = require(_dependencyMap[1], "react");
  const getStateFromPath_forks_1 = require(_dependencyMap[2], "./fork/getStateFromPath-forks");
  const matchers_1 = require(_dependencyMap[3], "./matchers");
  const url_1 = require(_dependencyMap[4], "./utils/url");
  function applyRedirects(url, redirects) {
    if (typeof url !== 'string' || !redirects) {
      return url;
    }
    const nextUrl = (0, getStateFromPath_forks_1.cleanPath)(url);
    const redirect = redirects.find(([regex]) => regex.test(nextUrl));
    if (!redirect) {
      return url;
    }
    // If the redirect is external, open the URL
    if (redirect[2]) {
      let href = redirect[1].destination;
      if (href.startsWith('//') && false) {
        href = `https:${href}`;
      }
      Linking.openURL(href);
      return href;
    }
    return applyRedirects(convertRedirect(url, redirect[1]), redirects);
  }
  function getRedirectModule(redirectConfig) {
    return {
      default: function RedirectComponent() {
        const pathname = require(_dependencyMap[5], "./hooks").usePathname();
        const isExternal = (0, url_1.shouldLinkExternally)(redirectConfig.destination);
        (0, react_1.useEffect)(() => {
          if (isExternal) {
            let href = redirectConfig.destination;
            if (href.startsWith('//') && false) {
              href = `https:${href}`;
            }
            Linking.openURL(href);
          }
        }, []);
        if (isExternal) {
          return null;
        }
        const href = convertRedirect(pathname, redirectConfig);
        return (0, react_1.createElement)(require(_dependencyMap[6], "./link/Link").Redirect, {
          href
        });
      }
    };
  }
  function convertRedirect(path, config) {
    const params = {};
    const parts = path.split('/');
    const sourceParts = config.source.split('/');
    for (const [index, sourcePart] of sourceParts.entries()) {
      const dynamicName = (0, matchers_1.matchDynamicName)(sourcePart);
      if (!dynamicName) {
        continue;
      } else if (!dynamicName.deep) {
        params[dynamicName.name] = parts[index];
        continue;
      } else {
        params[dynamicName.name] = parts.slice(index);
        break;
      }
    }
    return mergeVariablesWithPath(config.destination, params);
  }
  function mergeVariablesWithPath(path, params) {
    return path.split('/').map(part => {
      const dynamicName = (0, matchers_1.matchDynamicName)(part);
      if (!dynamicName) {
        return part;
      } else {
        const param = params[dynamicName.name];
        delete params[dynamicName.name];
        return param;
      }
    }).filter(Boolean).join('/');
  }
},676,[664,9,673,380,677,678,651],"node_modules/expo-router/build/getRoutesRedirects.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.hasUrlProtocolPrefix = hasUrlProtocolPrefix;
  exports.isWellKnownUri = isWellKnownUri;
  exports.shouldLinkExternally = shouldLinkExternally;
  /**
   * Does the input string start with a valid URL scheme.
   * NOTE: Additional strictness added to ensure URLs sent in query parameters for in-app navigation are not matched.
   */
  function hasUrlProtocolPrefix(href) {
    return /^([\w\d_+.-]+:)?\/\//.test(href);
  }
  function isWellKnownUri(href) {
    // This is a hack and we should change this to work like the web in the future where we have full confidence in the
    // ability to match URLs and send anything unmatched to the OS. The main difference between this and `hasUrlProtocolPrefix` is
    // that we don't require `//`, e.g. `mailto:` is valid and common, and `mailto://bacon` is invalid.
    return /^(https?|mailto|tel|sms|geo|maps|market|itmss?|itms-apps|content|file):/.test(href);
  }
  function shouldLinkExternally(href) {
    // Cheap check first to avoid regex if the href is not a path fragment.
    return !href.startsWith('.') && (hasUrlProtocolPrefix(href) || isWellKnownUri(href));
  }
},677,[],"node_modules/expo-router/build/utils/url.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useRouteInfo = void 0;
  exports.useRootNavigationState = useRootNavigationState;
  exports.useRootNavigation = useRootNavigation;
  exports.useNavigationContainerRef = useNavigationContainerRef;
  exports.useRouter = useRouter;
  exports.useUnstableGlobalHref = useUnstableGlobalHref;
  exports.useSegments = useSegments;
  exports.usePathname = usePathname;
  exports.useGlobalSearchParams = useGlobalSearchParams;
  exports.useLocalSearchParams = useLocalSearchParams;
  exports.useSearchParams = useSearchParams;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  const Route_1 = require(_dependencyMap[2], "./Route");
  const constants_1 = require(_dependencyMap[3], "./constants");
  const router_store_1 = require(_dependencyMap[4], "./global-state/router-store");
  Object.defineProperty(exports, "useRouteInfo", {
    enumerable: true,
    get: function () {
      return router_store_1.useRouteInfo;
    }
  });
  const imperative_api_1 = require(_dependencyMap[5], "./imperative-api");
  const PreviewRouteContext_1 = require(_dependencyMap[6], "./link/preview/PreviewRouteContext");
  /**
   * Returns the [navigation state](https://reactnavigation.org/docs/navigation-state/)
   * of the navigator which contains the current screen.
   *
   * @example
   * ```tsx
   * import { useRootNavigationState } from 'expo-router';
   *
   * export default function Route() {
   *  const { routes } = useRootNavigationState();
   *
   *  return <Text>{routes[0].name}</Text>;
   * }
   * ```
   */
  function useRootNavigationState() {
    const parent =
    // We assume that this is called from routes in __root
    // Users cannot customize the generated Sitemap or NotFound routes, so we should be safe
    (0, native_1.useNavigation)().getParent(constants_1.INTERNAL_SLOT_NAME);
    if (!parent) {
      throw new Error('useRootNavigationState was called from a generated route. This is likely a bug in Expo Router.');
    }
    return parent.getState();
  }
  /**
   * @deprecated Use [`useNavigationContainerRef`](#usenavigationcontainerref) instead,
   * which returns a React `ref`.
   */
  function useRootNavigation() {
    return router_store_1.store.navigationRef.current;
  }
  /**
   * @return The root `<NavigationContainer />` ref for the app. The `ref.current` may be `null`
   * if the `<NavigationContainer />` hasn't mounted yet.
   */
  function useNavigationContainerRef() {
    return router_store_1.store.navigationRef;
  }
  const displayWarningForProp = prop => {
    if (process.env.NODE_ENV !== 'production') {
      console.warn(`router.${prop} should not be used in a previewed screen. To fix this issue, wrap navigation calls with 'if (!isPreview) { ... }'.`);
    }
  };
  const createNOOPWithWarning = prop => () => displayWarningForProp(prop);
  const routerWithWarnings = {
    back: createNOOPWithWarning('back'),
    canGoBack: () => {
      displayWarningForProp('canGoBack');
      return false;
    },
    push: createNOOPWithWarning('push'),
    navigate: createNOOPWithWarning('navigate'),
    replace: createNOOPWithWarning('replace'),
    dismiss: createNOOPWithWarning('dismiss'),
    dismissTo: createNOOPWithWarning('dismissTo'),
    dismissAll: createNOOPWithWarning('dismissAll'),
    canDismiss: () => {
      displayWarningForProp('canDismiss');
      return false;
    },
    setParams: createNOOPWithWarning('setParams'),
    reload: createNOOPWithWarning('reload'),
    prefetch: createNOOPWithWarning('prefetch')
  };
  /**
   *
   * Returns the [Router](#router) object for imperative navigation.
   *
   * @example
   *```tsx
   * import { useRouter } from 'expo-router';
   * import { Text } from 'react-native';
   *
   * export default function Route() {
   *  const router = useRouter();
   *
   *  return (
   *   <Text onPress={() => router.push('/home')}>Go Home</Text>
   *  );
   *}
   * ```
   */
  function useRouter() {
    const {
      isPreview
    } = (0, PreviewRouteContext_1.usePreviewInfo)();
    if (isPreview) {
      return routerWithWarnings;
    }
    return imperative_api_1.router;
  }
  /**
   * @private
   * @returns The current global pathname with query params attached. This may change in the future to include the hostname
   * from a predefined universal link. For example, `/foobar?hey=world` becomes `https://acme.dev/foobar?hey=world`.
   */
  function useUnstableGlobalHref() {
    return (0, router_store_1.useRouteInfo)().unstable_globalHref;
  }
  function useSegments() {
    return (0, router_store_1.useRouteInfo)().segments;
  }
  /**
   * Returns the currently selected route location without search parameters. For example, `/acme?foo=bar` returns `/acme`.
   * Segments will be normalized. For example, `/[id]?id=normal` becomes `/normal`.
   *
   * @example
   * ```tsx app/profile/[user].tsx
   * import { Text } from 'react-native';
   * import { usePathname } from 'expo-router';
   *
   * export default function Route() {
   *   // pathname = "/profile/baconbrix"
   *   const pathname = usePathname();
   *
   *   return <Text>Pathname: {pathname}</Text>;
   * }
   * ```
   */
  function usePathname() {
    return (0, router_store_1.useRouteInfo)().pathname;
  }
  function useGlobalSearchParams() {
    return (0, router_store_1.useRouteInfo)().params;
  }
  function useLocalSearchParams() {
    const params = react_1.default.use(Route_1.LocalRouteParamsContext) ?? {};
    const {
      params: previewParams
    } = (0, PreviewRouteContext_1.usePreviewInfo)();
    return Object.fromEntries(Object.entries(previewParams ?? params).map(([key, value]) => {
      // React Navigation doesn't remove "undefined" values from the params object, and you cannot remove them via
      // navigation.setParams as it shallow merges. Hence, we hide them here
      if (value === undefined) {
        return [key, undefined];
      }
      if (Array.isArray(value)) {
        return [key, value.map(v => {
          try {
            return decodeURIComponent(v);
          } catch {
            return v;
          }
        })];
      } else {
        try {
          return [key, decodeURIComponent(value)];
        } catch {
          return [key, value];
        }
      }
    }));
  }
  function useSearchParams({
    global = false
  } = {}) {
    const globalRef = react_1.default.useRef(global);
    if (process.env.NODE_ENV !== 'production') {
      if (global !== globalRef.current) {
        console.warn(`Detected change in 'global' option of useSearchParams. This value cannot change between renders`);
      }
    }
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const params = global ? useGlobalSearchParams() : useLocalSearchParams();
    const entries = Object.entries(params).flatMap(([key, value]) => {
      if (global) {
        if (key === 'params') return [];
        if (key === 'screen') return [];
      }
      return Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]];
    });
    return new ReadOnlyURLSearchParams(entries);
  }
  class ReadOnlyURLSearchParams extends URLSearchParams {
    set() {
      throw new Error('The URLSearchParams object return from useSearchParams is read-only');
    }
    append() {
      throw new Error('The URLSearchParams object return from useSearchParams is read-only');
    }
    delete() {
      throw new Error('The URLSearchParams object return from useSearchParams is read-only');
    }
  }
},678,[253,9,379,639,671,679,385],"node_modules/expo-router/build/hooks.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.router = void 0;
  exports.useImperativeApiEmitter = useImperativeApiEmitter;
  const react_1 = require(_dependencyMap[0], "react");
  const routing_1 = require(_dependencyMap[1], "./global-state/routing");
  /**
   * @hidden
   */
  exports.router = {
    navigate: routing_1.navigate,
    push: routing_1.push,
    dismiss: routing_1.dismiss,
    dismissAll: routing_1.dismissAll,
    dismissTo: routing_1.dismissTo,
    canDismiss: routing_1.canDismiss,
    replace: routing_1.replace,
    back: () => (0, routing_1.goBack)(),
    canGoBack: routing_1.canGoBack,
    reload: routing_1.reload,
    prefetch: routing_1.prefetch,
    setParams: routing_1.setParams
  };
  function useImperativeApiEmitter(ref) {
    const events = (0, react_1.useSyncExternalStore)(routing_1.routingQueue.subscribe, routing_1.routingQueue.snapshot, routing_1.routingQueue.snapshot);
    (0, react_1.useEffect)(() => {
      routing_1.routingQueue.run(ref);
    }, [events, ref]);
    return null;
  }
},679,[9,659],"node_modules/expo-router/build/imperative-api.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getPathFromState = exports.getStateFromPath = void 0;
  exports.getInitialURL = getInitialURL;
  exports.getRootURL = getRootURL;
  exports.subscribe = subscribe;
  const Linking = __importStar(require(_dependencyMap[0], "expo-linking"));
  const react_native_1 = require(_dependencyMap[1], "react-native-web/dist/index");
  const extractPathFromURL_1 = require(_dependencyMap[2], "../fork/extractPathFromURL");
  const getPathFromState_1 = require(_dependencyMap[3], "../fork/getPathFromState");
  Object.defineProperty(exports, "getPathFromState", {
    enumerable: true,
    get: function () {
      return getPathFromState_1.getPathFromState;
    }
  });
  const getStateFromPath_1 = require(_dependencyMap[4], "../fork/getStateFromPath");
  Object.defineProperty(exports, "getStateFromPath", {
    enumerable: true,
    get: function () {
      return getStateFromPath_1.getStateFromPath;
    }
  });
  const useLinking_1 = require(_dependencyMap[5], "../fork/useLinking");
  const getRoutesRedirects_1 = require(_dependencyMap[6], "../getRoutesRedirects");
  const isExpoGo = typeof expo !== 'undefined' && globalThis.expo?.modules?.ExpoGo;
  // A custom getInitialURL is used on native to ensure the app always starts at
  // the root path if it's launched from something other than a deep link.
  // This helps keep the native functionality working like the web functionality.
  // For example, if you had a root navigator where the first screen was `/settings` and the second was `/index`
  // then `/index` would be used on web and `/settings` would be used on native.
  function getInitialURL() {
    if (typeof window === 'undefined') {
      return '';
    }
    if (react_native_1.Platform.OS === 'web' && window.location?.href) {
      return window.location.href;
    }
    if (react_native_1.Platform.OS === 'ios') {
      // Use the new Expo API for iOS. This has better support for App Clips and handoff.
      const url = Linking.getLinkingURL();
      return parseExpoGoUrlFromListener(url) ??
      // The path will be nullish in bare apps when the app is launched from the home screen.
      // TODO(EvanBacon): define some policy around notifications.
      getRootURL();
    }
    // TODO: Figure out if expo-linking on Android has full interop with the React Native implementation.
    return Promise.resolve((0, useLinking_1.getInitialURLWithTimeout)()).then(url => parseExpoGoUrlFromListener(url) ??
    // The path will be nullish in bare apps when the app is launched from the home screen.
    // TODO(EvanBacon): define some policy around notifications.
    getRootURL());
  }
  let _rootURL;
  function getRootURL() {
    if (_rootURL === undefined) {
      _rootURL = Linking.createURL('/');
      if (isExpoGo) {
        _rootURL = (0, extractPathFromURL_1.parsePathFromExpoGoLink)(_rootURL);
      }
    }
    return _rootURL;
  }
  // Expo Go is weird and requires the root path to be `/--/`
  function parseExpoGoUrlFromListener(url) {
    if (!url || !isExpoGo) {
      return url;
    }
    const {
      pathname,
      queryString
    } = (0, extractPathFromURL_1.parsePathAndParamsFromExpoGoLink)(url);
    // If the URL is defined (default in Expo Go dev apps) and the URL has no path:
    // `exp://192.168.87.39:19000/` then use the default `exp://192.168.87.39:19000/--/`
    if (!pathname || pathname === '/') {
      return getRootURL() + queryString;
    }
    return url;
  }
  function subscribe(nativeLinking, redirects) {
    return listener => {
      let callback;
      const legacySubscription = nativeLinking?.legacy_subscribe?.(listener);
      if (isExpoGo) {
        // This extra work is only done in the Expo Go app.
        callback = async ({
          url
        }) => {
          let href = parseExpoGoUrlFromListener(url);
          href = (0, getRoutesRedirects_1.applyRedirects)(href, redirects);
          if (href && nativeLinking?.redirectSystemPath) {
            href = await nativeLinking.redirectSystemPath({
              path: href,
              initial: false
            });
          }
          if (href) {
            listener(href);
          }
        };
      } else {
        callback = async ({
          url
        }) => {
          let href = (0, getRoutesRedirects_1.applyRedirects)(url, redirects);
          if (href && nativeLinking?.redirectSystemPath) {
            href = await nativeLinking.redirectSystemPath({
              path: href,
              initial: false
            });
          }
          if (href) {
            listener(href);
          }
        };
      }
      const subscription = Linking.addEventListener('url', callback);
      return () => {
        // https://github.com/facebook/react-native/commit/6d1aca806cee86ad76de771ed3a1cc62982ebcd7
        subscription?.remove?.();
        legacySubscription?.();
      };
    };
  }
},680,[664,492,672,681,682,684,676],"node_modules/expo-router/build/link/linking.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getPathFromState = getPathFromState;
  exports.getPathDataFromState = getPathDataFromState;
  exports.appendBaseUrl = appendBaseUrl;
  const queryString = __importStar(require(_dependencyMap[0], "query-string"));
  const expo = __importStar(require(_dependencyMap[1], "./getPathFromState-forks"));
  const navigationParams_1 = require(_dependencyMap[2], "../navigationParams");
  // END FORK
  const getActiveRoute = state => {
    const route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];
    if (route.state) {
      return getActiveRoute(route.state);
    }
    return route;
  };
  let cachedNormalizedConfigs = [undefined, {}];
  /**
   * Utility to serialize a navigation state object to a path string.
   *
   * @example
   * ```js
   * getPathFromState(
   *   {
   *     routes: [
   *       {
   *         name: 'Chat',
   *         params: { author: 'Jane', id: 42 },
   *       },
   *     ],
   *   },
   *   {
   *     screens: {
   *       Chat: {
   *         path: 'chat/:author/:id',
   *         stringify: { author: author => author.toLowerCase() }
   *       }
   *     }
   *   }
   * )
   * ```
   *
   * @param state Navigation state to serialize.
   * @param options Extra options to fine-tune how to serialize the path.
   * @returns Path representing the state, e.g. /foo/bar?count=42.
   */
  function getPathFromState(state, options) {
    return getPathDataFromState(state, options).path;
  }
  function getPathDataFromState(state, options) {
    if (state == null) {
      throw Error("Got 'undefined' for the navigation state. You must pass a valid state object.");
    }
    if (options) {
      // START FORK
      expo.validatePathConfig(options);
      // validatePathConfig(options);
      // END FORK
    }
    // Create a normalized configs object which will be easier to use
    if (cachedNormalizedConfigs[0] !== options?.screens) {
      cachedNormalizedConfigs = [options?.screens, options?.screens ? createNormalizedConfigs(options.screens) : {}];
    }
    const configs = cachedNormalizedConfigs[1];
    let path = '/';
    let current = state;
    const allParams = {};
    while (current) {
      let index = typeof current.index === 'number' ? current.index : 0;
      let route = current.routes[index];
      let pattern;
      let focusedParams;
      const focusedRoute = getActiveRoute(state);
      let currentOptions = configs;
      // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined
      const nestedRouteNames = [];
      let hasNext = true;
      while (route.name in currentOptions && hasNext) {
        pattern = currentOptions[route.name].pattern;
        nestedRouteNames.push(route.name);
        if (route.params) {
          const stringify = currentOptions[route.name]?.stringify;
          // START FORK
          // This mutates allParams
          const currentParams = expo.fixCurrentParams(allParams, route, stringify);
          // const currentParams = Object.fromEntries(
          //   Object.entries(route.params).map(([key, value]) => [
          //     key,
          //     stringify?.[key] ? stringify[key](value) : String(value),
          //   ])
          // );
          // if (pattern) {
          //   Object.assign(allParams, currentParams);
          // }
          // END FORK
          if (focusedRoute === route) {
            // If this is the focused route, keep the params for later use
            // We save it here since it's been stringified already
            focusedParams = Object.assign({}, currentParams);
            pattern?.split('/').filter(p => expo.isDynamicPart(p))
            // eslint-disable-next-line no-loop-func
            .forEach(p => {
              const name = expo.getParamName(p);
              // Remove the params present in the pattern since we'll only use the rest for query string
              if (focusedParams) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete focusedParams[name];
              }
            });
          }
        }
        // If there is no `screens` property or no nested state, we return pattern
        if (!currentOptions[route.name].screens || route.state === undefined) {
          // START FORK
          // Expo Router allows you to navigate to a (group) and not specify a target screen
          // This is different from React Navigation, which requires a target screen
          // We need to handle this case here, by selecting either the index screen or the first screen of the group
          // IMPORTANT: This does not affect groups that use _layout files with initialRouteNames
          // Layout files create a new route config. This only affects groups without layouts that have their screens
          // hoisted.
          // Example:
          // - /home/_layout
          // - /home/(a|b|c)/index          --> Hoisted to /home/_layout navigator
          // - /home/(a|b|c)/other          --> Hoisted to /home/_layout navigator
          // - /home/(profile)/me           --> Hoisted to /home/_layout navigator
          //
          // route.push('/home/(a)')        --> This should navigate to /home/(a)/index
          // route.push('/home/(profile)')  --> This should navigate to /home/(profile)/me
          const screens = currentOptions[route.name].screens;
          // Determine what screen the user wants to navigate to. If no screen is specified, assume there is an index screen
          // In the examples above, this ensures that /home/(a) navigates to /home/(a)/index
          const targetScreen =
          // This is typed as unknown, so we need to add these extra assertions
          route.params && 'screen' in route.params && typeof route.params.screen === 'string' ? route.params.screen : 'index';
          // If the target screen is not in the screens object, default to the first screen
          // In the examples above, this ensures that /home/(profile) navigates to /home/(profile)/me
          // As there is no index screen in the group
          const screen = screens ? screens[targetScreen] ? targetScreen : Object.keys(screens)[0] : undefined;
          if (screen && screens && currentOptions[route.name].screens?.[screen]) {
            const nestedParams = route.params?.params;
            route = Object.assign({}, screens[screen], {
              name: screen,
              key: screen,
              params: nestedParams
            });
            currentOptions = screens;
          } else {
            hasNext = false;
          }
          // hasNext = false;
          // END FORK
        } else {
          index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;
          const nextRoute = route.state.routes[index];
          const nestedConfig = currentOptions[route.name].screens;
          // if there is config for next route name, we go deeper
          if (nestedConfig && nextRoute.name in nestedConfig) {
            route = nextRoute;
            currentOptions = nestedConfig;
          } else {
            // If not, there is no sense in going deeper in config
            hasNext = false;
          }
        }
      }
      if (pattern === undefined) {
        pattern = nestedRouteNames.join('/');
      }
      if (currentOptions[route.name] !== undefined) {
        // START FORK
        path += expo.getPathWithConventionsCollapsed(Object.assign({}, options, {
          pattern,
          route,
          params: allParams,
          initialRouteName: configs[route.name]?.initialRouteName
        }));
        // path += pattern
        //   .split('/')
        //   .map((p) => {
        //     const name = getParamName(p);
        //     // We don't know what to show for wildcard patterns
        //     // Showing the route name seems ok, though whatever we show here will be incorrect
        //     // Since the page doesn't actually exist
        //     if (p === '*') {
        //       return route.name;
        //     }
        //     // If the path has a pattern for a param, put the param in the path
        //     if (p.startsWith(':')) {
        //       const value = allParams[name];
        //       if (value === undefined && p.endsWith('?')) {
        //         // Optional params without value assigned in route.params should be ignored
        //         return '';
        //       }
        //       // Valid characters according to
        //       // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)
        //       return String(value).replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]/g, (char) =>
        //         encodeURIComponent(char)
        //       );
        //     }
        //     return encodeURIComponent(p);
        //   })
        //   .join('/');
        // } else {
      } else if (!route.name.startsWith('+')) {
        path += encodeURIComponent(route.name);
      }
      // END FORK
      if (!focusedParams) {
        focusedParams = focusedRoute.params;
      }
      if (route.state) {
        path += '/';
      } else if (focusedParams) {
        for (const param in focusedParams) {
          if (focusedParams[param] === 'undefined') {
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete focusedParams[param];
          }
        }
        // START FORK
        delete focusedParams['#'];
        focusedParams = (0, navigationParams_1.removeInternalExpoRouterParams)(focusedParams);
        // END FORK
        const query = queryString.stringify(focusedParams, {
          sort: false
        });
        if (query) {
          path += `?${query}`;
        }
      }
      current = route.state;
    }
    // Remove multiple as well as trailing slashes
    path = path.replace(/\/+/g, '/');
    path = path.length > 1 ? path.replace(/\/$/, '') : path;
    // Include the root path if specified
    if (options?.path) {
      path = joinPaths(options.path, path);
    }
    // START FORK
    path = expo.appendBaseUrl(path);
    if (allParams['#']) {
      path += `#${allParams['#']}`;
    }
    // END FORK
    // START FORK
    return {
      path,
      params: allParams
    };
    // END FORK
  }
  // const getParamName = (pattern: string) => pattern.replace(/^:/, '').replace(/\?$/, '');
  const joinPaths = (...paths) => [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');
  const createConfigItem = (config, parentPattern) => {
    if (typeof config === 'string') {
      // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
      const pattern = parentPattern ? joinPaths(parentPattern, config) : config;
      return {
        pattern
      };
    }
    if (config.exact && config.path === undefined) {
      throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
    }
    // If an object is specified as the value (e.g. Foo: { ... }),
    // It can have `path` property and `screens` prop which has nested configs
    const pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';
    const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;
    return {
      // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.
      pattern: pattern?.split('/').filter(Boolean).join('/'),
      stringify: config.stringify,
      screens
    };
  };
  const createNormalizedConfigs = (options, pattern) => Object.fromEntries(Object.entries(options).map(([name, c]) => {
    const result = createConfigItem(c, pattern);
    return [name, result];
  }));
  function appendBaseUrl(path, baseUrl = "") {
    if (process.env.NODE_ENV !== 'development') {
      if (baseUrl) {
        return `/${baseUrl.replace(/^\/+/, '').replace(/\/$/, '')}${path}`;
      }
    }
    return path;
  }
},681,[300,658,648],"node_modules/expo-router/build/fork/getPathFromState.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["path"];
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getStateFromPath = getStateFromPath;
  const native_1 = require(_dependencyMap[1], "@react-navigation/native");
  const escape_string_regexp_1 = __importDefault(require(_dependencyMap[2], "escape-string-regexp"));
  const findFocusedRoute_1 = require(_dependencyMap[3], "./findFocusedRoute");
  const expo = __importStar(require(_dependencyMap[4], "./getStateFromPath-forks"));
  const constants_1 = require(_dependencyMap[5], "../constants");
  /**
   * Utility to parse a path string to initial state object accepted by the container.
   * This is useful for deep linking when we need to handle the incoming URL.
   *
   * @example
   * ```js
   * getStateFromPath(
   *   '/chat/jane/42',
   *   {
   *     screens: {
   *       Chat: {
   *         path: 'chat/:author/:id',
   *         parse: { id: Number }
   *       }
   *     }
   *   }
   * )
   * ```
   * @param path Path string to parse and convert, e.g. /foo/bar?count=42.
   * @param options Extra options to fine-tune how to parse the path.
   */
  function getStateFromPath(path, options,
  // START FORK
  segments = []
  // END FORK
  ) {
    const {
      initialRoutes,
      configs,
      configWithRegexes
    } = getConfigResources(options,
    // START FORK
    segments
    // END FORK
    );
    const screens = options?.screens;
    // START FORK
    const expoPath = expo.getUrlWithReactNavigationConcessions(path);
    // END FORK
    // START FORK
    let remaining = expo.cleanPath(expoPath.nonstandardPathname);
    // let remaining = path
    //   .replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
    //   .replace(/^\//, '') // Remove extra leading slash
    //   .replace(/\?.*$/, ''); // Remove query params which we will handle later
    // // Make sure there is a trailing slash
    // remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;
    // END FORK
    const prefix = options?.path?.replace(/^\//, ''); // Remove extra leading slash
    if (prefix) {
      // Make sure there is a trailing slash
      const normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;
      // If the path doesn't start with the prefix, it's not a match
      if (!remaining.startsWith(normalizedPrefix)) {
        return undefined;
      }
      // Remove the prefix from the path
      remaining = remaining.replace(normalizedPrefix, '');
    }
    if (screens === undefined) {
      // When no config is specified, use the path segments as route names
      const routes = remaining.split('/').filter(Boolean).map(segment => {
        const name = decodeURIComponent(segment);
        return {
          name
        };
      });
      if (routes.length) {
        return createNestedStateObject(expoPath, routes, initialRoutes, [], expoPath.hash);
      }
      return undefined;
    }
    if (remaining === '/') {
      // We need to add special handling of empty path so navigation to empty path also works
      // When handling empty path, we should only look at the root level config
      // START FORK
      const match = expo.matchForEmptyPath(configWithRegexes);
      // const match = configs.find(
      //   (config) =>
      //     config.path === '' &&
      //     config.routeNames.every(
      //       // Make sure that none of the parent configs have a non-empty path defined
      //       (name) => !configs.find((c) => c.screen === name)?.path
      //     )
      // );
      // END FORK
      if (match) {
        return createNestedStateObject(expoPath, match.routeNames.map(name => ({
          name
        })), initialRoutes, configs, expoPath.hash);
      }
      return undefined;
    }
    let result;
    let current;
    // We match the whole path against the regex instead of segments
    // This makes sure matches such as wildcard will catch any unmatched routes, even if nested
    const {
      routes,
      remainingPath
    } = matchAgainstConfigs(remaining, configWithRegexes);
    if (routes !== undefined) {
      // This will always be empty if full path matched
      current = createNestedStateObject(expoPath, routes, initialRoutes, configs, expoPath.hash);
      remaining = remainingPath;
      result = current;
    }
    if (current == null || result == null) {
      return undefined;
    }
    return result;
  }
  /**
   * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.
   */
  let cachedConfigResources = [undefined, prepareConfigResources()];
  function getConfigResources(options,
  // START FORK
  previousSegments
  // END FORK
  ) {
    // START FORK - We need to disable this caching as our configs can change based upon the current state
    // if (cachedConfigResources[0] !== options) {
    cachedConfigResources = [options, prepareConfigResources(options, previousSegments)];
    // }
    // END FORK FORK
    return cachedConfigResources[1];
  }
  function prepareConfigResources(options, previousSegments) {
    if (options) {
      (0, native_1.validatePathConfig)(options);
    }
    const initialRoutes = getInitialRoutes(options);
    const configs = getNormalizedConfigs(initialRoutes, options?.screens, previousSegments);
    checkForDuplicatedConfigs(configs);
    const configWithRegexes = getConfigsWithRegexes(configs);
    return {
      initialRoutes,
      configs,
      configWithRegexes
    };
  }
  function getInitialRoutes(options) {
    const initialRoutes = [];
    if (options?.initialRouteName) {
      initialRoutes.push({
        initialRouteName: options.initialRouteName,
        parentScreens: []
      });
    }
    return initialRoutes;
  }
  function getNormalizedConfigs(initialRoutes, screens = {},
  // START FORK
  previousSegments
  // END FORK
  ) {
    // Create a normalized configs array which will be easier to use
    return [].concat(...Object.keys(screens).map(key => createNormalizedConfigs(key, screens, [], initialRoutes, []))).map(expo.appendIsInitial(initialRoutes)).sort(expo.getRouteConfigSorter(previousSegments));
    // .sort((a, b) => {
    //   // Sort config so that:
    //   // - the most exhaustive ones are always at the beginning
    //   // - patterns with wildcard are always at the end
    //   // If 2 patterns are same, move the one with less route names up
    //   // This is an error state, so it's only useful for consistent error messages
    //   if (a.pattern === b.pattern) {
    //     return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));
    //   }
    //   // If one of the patterns starts with the other, it's more exhaustive
    //   // So move it up
    //   if (a.pattern.startsWith(b.pattern)) {
    //     return -1;
    //   }
    //   if (b.pattern.startsWith(a.pattern)) {
    //     return 1;
    //   }
    //   const aParts = a.pattern.split('/');
    //   const bParts = b.pattern.split('/');
    //   for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
    //     // if b is longer, b get higher priority
    //     if (aParts[i] == null) {
    //       return 1;
    //     }
    //     // if a is longer, a get higher priority
    //     if (bParts[i] == null) {
    //       return -1;
    //     }
    //     const aWildCard = aParts[i] === '*' || aParts[i].startsWith(':');
    //     const bWildCard = bParts[i] === '*' || bParts[i].startsWith(':');
    //     // if both are wildcard we compare next component
    //     if (aWildCard && bWildCard) {
    //       continue;
    //     }
    //     // if only a is wild card, b get higher priority
    //     if (aWildCard) {
    //       return 1;
    //     }
    //     // if only b is wild card, a get higher priority
    //     if (bWildCard) {
    //       return -1;
    //     }
    //   }
    //   return bParts.length - aParts.length;
    // });
  }
  function checkForDuplicatedConfigs(configs) {
    // Check for duplicate patterns in the config
    configs.reduce((acc, config) => {
      if (acc[config.pattern]) {
        const a = acc[config.pattern].routeNames;
        const b = config.routeNames;
        // It's not a problem if the path string omitted from a inner most screen
        // For example, it's ok if a path resolves to `A > B > C` or `A > B`
        const intersects = a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);
        if (!intersects) {
          throw new Error(`Found conflicting screens with the same pattern. The pattern '${config.pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);
        }
      }
      return Object.assign(acc, {
        [config.pattern]: config
      });
    }, {});
  }
  function getConfigsWithRegexes(configs) {
    return configs.map(c => Object.assign({}, c, {
      // Add `$` to the regex to make sure it matches till end of the path and not just beginning
      // START FORK
      // regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,
      regex: expo.configRegExp(c)
      // END FORK
    }));
  }
  const joinPaths = (...paths) => [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');
  const matchAgainstConfigs = (remaining, configs) => {
    let routes;
    let remainingPath = remaining;
    // START FORK
    const allParams = Object.create(null);
    // END FORK
    // Go through all configs, and see if the next path segment matches our regex
    for (const config of configs) {
      if (!config.regex) {
        continue;
      }
      const match = remainingPath.match(config.regex);
      // If our regex matches, we need to extract params from the path
      if (match) {
        const matchResult = config.pattern?.split('/').reduce((acc, p, index) => {
          if (!expo.isDynamicPart(p)) {
            return acc;
          }
          acc.pos += 1;
          // START FORK
          const decodedParamSegment = expo.safelyDecodeURIComponent(
          // const decodedParamSegment = decodeURIComponent(
          // The param segments appear every second item starting from 2 in the regex match result
          match[(acc.pos + 1) * 2]
          // Remove trailing slash
          .replace(/\/$/, ''));
          // END FORK
          Object.assign(acc.matchedParams, {
            [p]: Object.assign(acc.matchedParams[p] || {}, {
              [index]: decodedParamSegment
            })
          });
          return acc;
        }, {
          pos: -1,
          matchedParams: {}
        });
        const matchedParams = matchResult.matchedParams || {};
        routes = config.routeNames.map(name => {
          const routeConfig = configs.find(c => {
            // Check matching name AND pattern in case same screen is used at different levels in config
            return c.screen === name && config.pattern.startsWith(c.pattern);
          });
          // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.
          const normalizedPath = routeConfig?.path.split('/').filter(Boolean).join('/');
          // Get the number of segments in the initial pattern
          const numInitialSegments = routeConfig?.pattern
          // Extract the prefix from the pattern by removing the ending path pattern (e.g pattern=`a/b/c/d` and normalizedPath=`c/d` becomes `a/b`)
          .replace(new RegExp(`${(0, escape_string_regexp_1.default)(normalizedPath)}$`), '')?.split('/').length;
          const params = normalizedPath?.split('/').reduce((acc, p, index) => {
            if (!expo.isDynamicPart(p)) {
              return acc;
            }
            // Get the real index of the path parameter in the matched path
            // by offsetting by the number of segments in the initial pattern
            const offset = numInitialSegments ? numInitialSegments - 1 : 0;
            // START FORK
            // const value = matchedParams[p]?.[index + offset];
            const value = expo.getParamValue(p, matchedParams[p]?.[index + offset]);
            // END FORK
            if (value) {
              // START FORK
              // const key = p.replace(/^:/, '').replace(/\?$/, '');
              const key = expo.replacePart(p);
              // END FORK
              acc[key] = routeConfig?.parse?.[key] ? routeConfig.parse[key](value) : value;
            }
            return acc;
          }, {});
          if (params && Object.keys(params).length) {
            Object.assign(allParams, params);
            return {
              name,
              params
            };
          }
          return {
            name
          };
        });
        remainingPath = remainingPath.replace(match[1], '');
        break;
      }
    }
    // START FORK
    expo.populateParams(routes, allParams);
    // END FORK
    return {
      routes,
      remainingPath
    };
  };
  const createNormalizedConfigs = (screen, routeConfig, routeNames = [], initials, parentScreens, parentPattern) => {
    const configs = [];
    routeNames.push(screen);
    parentScreens.push(screen);
    // @ts-expect-error: TODO(@kitten): This is entirely untyped. The index access just flags this, but we're not typing the config properly here
    const config = routeConfig[screen];
    if (typeof config === 'string') {
      // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
      const pattern = parentPattern ? joinPaths(parentPattern, config) : config;
      configs.push(createConfigItem(screen, routeNames, pattern, config));
    } else if (typeof config === 'object') {
      let pattern;
      // if an object is specified as the value (e.g. Foo: { ... }),
      // it can have `path` property and
      // it could have `screens` prop which has nested configs
      if (typeof config.path === 'string') {
        if (config.exact && config.path === undefined) {
          throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
        }
        pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';
        if (screen !== constants_1.INTERNAL_SLOT_NAME) {
          configs.push(createConfigItem(screen, routeNames, pattern, config.path, config.parse, config));
        }
      }
      if (config.screens) {
        // property `initialRouteName` without `screens` has no purpose
        if (config.initialRouteName) {
          initials.push({
            initialRouteName: config.initialRouteName,
            parentScreens
          });
        }
        Object.keys(config.screens).forEach(nestedConfig => {
          const result = createNormalizedConfigs(nestedConfig, config.screens, routeNames, initials, [...parentScreens], pattern ?? parentPattern);
          configs.push(...result);
        });
      }
    }
    routeNames.pop();
    return configs;
  };
  const createConfigItem = (screen, routeNames, pattern, path, parse = undefined, config = {}) => {
    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.
    pattern = pattern.split('/').filter(Boolean).join('/');
    // START FORK
    const regex = pattern ? expo.routePatternToRegex(pattern) : undefined;
    // const regex = pattern
    //   ? new RegExp(
    //       `^(${pattern
    //         .split('/')
    //         .map((it) => {
    //           if (it.startsWith(':')) {
    //             return `(([^/]+\\/)${it.endsWith('?') ? '?' : ''})`;
    //           }
    //           return `${it === '*' ? '.*' : escape(it)}\\/`;
    //         })
    //         .join('')})`
    //     )
    //   : undefined;
    // END FORK
    return Object.assign({
      screen,
      regex,
      pattern,
      path,
      // The routeNames array is mutated, so copy it to keep the current state
      routeNames: [...routeNames],
      parse
    }, expo.createConfig(screen, pattern, routeNames, config));
  };
  const findParseConfigForRoute = (routeName, flatConfig) => {
    for (const config of flatConfig) {
      if (routeName === config.routeNames[config.routeNames.length - 1]) {
        return config.parse;
      }
    }
    return undefined;
  };
  // Try to find an initial route connected with the one passed
  const findInitialRoute = (routeName, parentScreens, initialRoutes) => {
    for (const config of initialRoutes) {
      if (parentScreens.length === config.parentScreens.length) {
        let sameParents = true;
        for (let i = 0; i < parentScreens.length; i++) {
          if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {
            sameParents = false;
            break;
          }
        }
        if (sameParents) {
          return routeName !== config.initialRouteName ? config.initialRouteName : undefined;
        }
      }
    }
    return undefined;
  };
  // returns state object with values depending on whether
  // it is the end of state and if there is initialRoute for this level
  const createStateObject = (initialRoute, route, isEmpty) => {
    if (isEmpty) {
      if (initialRoute) {
        return {
          index: 1,
          routes: [{
            name: initialRoute,
            params: route.params
          }, route]
        };
      } else {
        return {
          routes: [route]
        };
      }
    } else {
      if (initialRoute) {
        return {
          index: 1,
          routes: [{
            name: initialRoute,
            params: route.params
          }, Object.assign({}, route, {
            state: {
              routes: []
            }
          })]
        };
      } else {
        return {
          routes: [Object.assign({}, route, {
            state: {
              routes: []
            }
          })]
        };
      }
    }
  };
  const createNestedStateObject = (_ref, routes, initialRoutes, flatConfig, hash) => {
    let {
        path
      } = _ref,
      expoURL = _objectWithoutPropertiesLoose(_ref, _excluded);
    let route = routes.shift();
    const parentScreens = [];
    let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
    parentScreens.push(route.name);
    const state = createStateObject(initialRoute, route, routes.length === 0);
    if (routes.length > 0) {
      let nestedState = state;
      while (route = routes.shift()) {
        initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
        const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;
        nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);
        if (routes.length > 0) {
          nestedState = nestedState.routes[nestedStateIndex].state;
        }
        parentScreens.push(route.name);
      }
    }
    route = (0, findFocusedRoute_1.findFocusedRoute)(state);
    // START FORK
    route.path = expoURL.pathWithoutGroups;
    // route.path = path;
    // END FORK
    // START FORK
    // const params = parseQueryParams(
    const params = expo.parseQueryParams(path, route, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined, hash);
    // END FORK
    // START FORK
    // expo.handleUrlParams(route, params, hash);
    if (params) {
      route.params = Object.assign({}, route.params, params);
    }
    // END FORK
    return state;
  };
  // START FORK
  // const parseQueryParams = (path: string, parseConfig?: Record<string, (value: string) => any>) => {
  //   const query = path.split('?')[1];
  //   const params = queryString.parse(query);
  //   if (parseConfig) {
  //     Object.keys(params).forEach((name) => {
  //       if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {
  //         params[name] = parseConfig[name](params[name] as string);
  //       }
  //     });
  //   }
  //   return Object.keys(params).length ? params : undefined;
  // };
  // END FORK
},682,[759,253,308,683,673,639],"node_modules/expo-router/build/fork/getStateFromPath.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // Forked so we can access without importing any React Native code in Node.js environments.
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.findFocusedRoute = findFocusedRoute;
  function findFocusedRoute(state) {
    let current = state;
    while (current?.routes[current.index ?? 0].state != null) {
      current = current.routes[current.index ?? 0].state;
    }
    const route = current?.routes[current?.index ?? 0];
    return route;
  }
},683,[],"node_modules/expo-router/build/fork/findFocusedRoute.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.series = void 0;
  exports.useLinking = useLinking;
  exports.getInitialURLWithTimeout = getInitialURLWithTimeout;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const fast_deep_equal_1 = __importDefault(require(_dependencyMap[1], "fast-deep-equal"));
  const React = __importStar(require(_dependencyMap[2], "react"));
  const createMemoryHistory_1 = require(_dependencyMap[3], "./createMemoryHistory");
  const getPathFromState_1 = require(_dependencyMap[4], "./getPathFromState");
  const serverLocationContext_1 = require(_dependencyMap[5], "../global-state/serverLocationContext");
  const storeContext_1 = require(_dependencyMap[6], "../global-state/storeContext");
  const utils_1 = require(_dependencyMap[7], "../global-state/utils");
  /**
   * Find the matching navigation state that changed between 2 navigation states
   * e.g.: a -> b -> c -> d and a -> b -> c -> e -> f, if history in b changed, b is the matching state
   */
  const findMatchingState = (a, b) => {
    if (a === undefined || b === undefined || a.key !== b.key) {
      return [undefined, undefined];
    }
    // Tab and drawer will have `history` property, but stack will have history in `routes`
    const aHistoryLength = a.history ? a.history.length : a.routes.length;
    const bHistoryLength = b.history ? b.history.length : b.routes.length;
    const aRoute = a.routes[a.index];
    const bRoute = b.routes[b.index];
    const aChildState = aRoute.state;
    const bChildState = bRoute.state;
    // Stop here if this is the state object that changed:
    // - history length is different
    // - focused routes are different
    // - one of them doesn't have child state
    // - child state keys are different
    if (aHistoryLength !== bHistoryLength || aRoute.key !== bRoute.key || aChildState === undefined || bChildState === undefined || aChildState.key !== bChildState.key) {
      return [a, b];
    }
    return findMatchingState(aChildState, bChildState);
  };
  /**
   * Run async function in series as it's called.
   */
  const series = cb => {
    let queue = Promise.resolve();
    const callback = () => {
      queue = queue.then(cb);
    };
    return callback;
  };
  exports.series = series;
  const linkingHandlers = [];
  function useLinking(ref, {
    enabled = true,
    config,
    getStateFromPath = native_1.getStateFromPath,
    getPathFromState = native_1.getPathFromState,
    getActionFromState = native_1.getActionFromState
  }, onUnhandledLinking) {
    const independent = (0, native_1.useNavigationIndependentTree)();
    const store = (0, storeContext_1.useExpoRouterStore)();
    React.useEffect(() => {
      if (process.env.NODE_ENV === 'production') {
        return undefined;
      }
      if (independent) {
        return undefined;
      }
      if (enabled !== false && linkingHandlers.length) {
        console.error(['Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:', "- You don't have multiple NavigationContainers in the app each with 'linking' enabled", '- Only a single instance of the root component is rendered'].join('\n').trim());
      }
      const handler = Symbol();
      if (enabled !== false) {
        linkingHandlers.push(handler);
      }
      return () => {
        const index = linkingHandlers.indexOf(handler);
        if (index > -1) {
          linkingHandlers.splice(index, 1);
        }
      };
    }, [enabled, independent]);
    const [history] = React.useState(createMemoryHistory_1.createMemoryHistory);
    // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners
    // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`
    // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect
    const enabledRef = React.useRef(enabled);
    const configRef = React.useRef(config);
    const getStateFromPathRef = React.useRef(getStateFromPath);
    const getPathFromStateRef = React.useRef(getPathFromState);
    const getActionFromStateRef = React.useRef(getActionFromState);
    React.useEffect(() => {
      enabledRef.current = enabled;
      configRef.current = config;
      getStateFromPathRef.current = getStateFromPath;
      getPathFromStateRef.current = getPathFromState;
      getActionFromStateRef.current = getActionFromState;
    });
    const validateRoutesNotExistInRootState = React.useCallback(state => {
      // START FORK
      // Instead of using the rootState, we use INTERNAL_SLOT_NAME, which is the only route in the root navigator in Expo Router
      // const navigation = ref.current;
      // const rootState = navigation?.getRootState();
      const routeNames = (0, utils_1.getRootStackRouteNames)();
      // END FORK
      // Make sure that the routes in the state exist in the root navigator
      // Otherwise there's an error in the linking configuration
      // START FORK
      // return state?.routes.some((r) => !rootState?.routeNames?.includes(r.name));
      return state?.routes.some(r => !routeNames.includes(r.name));
      // END FORK
    }, [ref]);
    const server = React.use(serverLocationContext_1.ServerContext);
    const getInitialState = React.useCallback(() => {
      let value;
      if (enabledRef.current) {
        const location = server?.location ?? (typeof window !== 'undefined' ? window.location : undefined);
        const path = location ? location.pathname + location.search : undefined;
        if (path) {
          value = getStateFromPathRef.current(path, configRef.current);
        }
        // If the link were handled, it gets cleared in NavigationContainer
        onUnhandledLinking(path);
      }
      const thenable = {
        then(onfulfilled) {
          return Promise.resolve(onfulfilled ? onfulfilled(value) : value);
        },
        catch() {
          return thenable;
        }
      };
      return thenable;
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const previousIndexRef = React.useRef(undefined);
    const previousStateRef = React.useRef(undefined);
    const pendingPopStatePathRef = React.useRef(undefined);
    React.useEffect(() => {
      previousIndexRef.current = history.index;
      return history.listen(() => {
        const navigation = ref.current;
        if (!navigation || !enabled) {
          return;
        }
        const {
          location
        } = window;
        const path = location.pathname + location.search + location.hash;
        const index = history.index;
        const previousIndex = previousIndexRef.current ?? 0;
        previousIndexRef.current = index;
        pendingPopStatePathRef.current = path;
        // When browser back/forward is clicked, we first need to check if state object for this index exists
        // If it does we'll reset to that state object
        // Otherwise, we'll handle it like a regular deep link
        const record = history.get(index);
        if (record?.path === path && record?.state) {
          navigation.resetRoot(record.state);
          return;
        }
        const state = getStateFromPathRef.current(path, configRef.current);
        // We should only dispatch an action when going forward
        // Otherwise the action will likely add items to history, which would mess things up
        if (state) {
          // If the link were handled, it gets cleared in NavigationContainer
          onUnhandledLinking(path);
          // Make sure that the routes in the state exist in the root navigator
          // Otherwise there's an error in the linking configuration
          if (validateRoutesNotExistInRootState(state)) {
            return;
          }
          if (index > previousIndex || (
          /* START FORK
           *
           * This is a workaround for React Navigation's handling of hashes (it doesn't handle them)
           * When you click on <a href="#hash">, the browser will first fire a popstate event
           * and this callback will be called.
           *
           * From React Navigation's perspective, it's treating the new hash change like a back/forward
           * button press, so it thinks it should reset the state. When we should
           * be to be pushing the new state
           *
           * Our fix is to check if the index is the same as the previous index
           * and if the incoming path is the same as the old path but with the hash added,
           * then treat it as a push instead of a reset
           *
           * This also works for subsequent hash changes, as internally RN
           * doesn't store the hash in the history state.
           *
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/popstate_event#when_popstate_is_sent
           */
          index === previousIndex && (!record || `${record?.path}${location.hash}` === path))
          // END FORK
          ) {
            const action = getActionFromStateRef.current(state, configRef.current);
            if (action !== undefined) {
              try {
                navigation.dispatch(action);
              } catch (e) {
                // Ignore any errors from deep linking.
                // This could happen in case of malformed links, navigation object not being initialized etc.
                console.warn(`An error occurred when trying to handle the link '${path}': ${typeof e === 'object' && e != null && 'message' in e ? e.message : e}`);
              }
            } else {
              navigation.resetRoot(state);
            }
          } else {
            navigation.resetRoot(state);
          }
        } else {
          // if current path didn't return any state, we should revert to initial state
          navigation.resetRoot(state);
        }
      });
    }, [enabled, history, onUnhandledLinking, ref, validateRoutesNotExistInRootState]);
    React.useEffect(() => {
      if (!enabled) {
        return;
      }
      const getPathForRoute = (route, state) => {
        let path;
        // If the `route` object contains a `path`, use that path as long as `route.name` and `params` still match
        // This makes sure that we preserve the original URL for wildcard routes
        if (route?.path) {
          const stateForPath = getStateFromPathRef.current(route.path, configRef.current);
          if (stateForPath) {
            const focusedRoute = (0, native_1.findFocusedRoute)(stateForPath);
            if (focusedRoute && focusedRoute.name === route.name && (0, fast_deep_equal_1.default)(Object.assign({}, focusedRoute.params), Object.assign({}, route.params))) {
              // START FORK - Ensure paths coming from events (e.g refresh) have the base URL
              // path = route.path;
              path = (0, getPathFromState_1.appendBaseUrl)(route.path);
              // END FORK
            }
          }
        }
        if (path == null) {
          path = getPathFromStateRef.current(state, configRef.current);
        }
        // START FORK - ExpoRouter manually handles hashes. This code is intentionally removed
        // const previousRoute = previousStateRef.current
        //   ? findFocusedRoute(previousStateRef.current)
        //   : undefined;
        // Preserve the hash if the route didn't change
        // if (
        //   previousRoute &&
        //   route &&
        //   'key' in previousRoute &&
        //   'key' in route &&
        //   previousRoute.key === route.key
        // ) {
        //   path = path + location.hash;
        // }
        // END FORK
        return path;
      };
      if (ref.current) {
        // We need to record the current metadata on the first render if they aren't set
        // This will allow the initial state to be in the history entry
        // START FORK
        // Instead of using the rootState (which might be stale) we should use the focused state
        // const state = ref.current.getRootState();
        const rootState = ref.current.getRootState();
        const state = store.state;
        // END FORK
        if (state) {
          const route = (0, native_1.findFocusedRoute)(state);
          const path = getPathForRoute(route, state);
          if (previousStateRef.current === undefined) {
            // START FORK
            // previousStateRef.current = state;
            previousStateRef.current = rootState;
            // END FORK
          }
          history.replace({
            path,
            state
          });
        }
      }
      const onStateChange = async () => {
        const navigation = ref.current;
        if (!navigation || !enabled) {
          return;
        }
        const previousState = previousStateRef.current;
        // START FORK
        // Instead of using the rootState (which might be stale) we should use the focused state
        // const state = navigation.getRootState();
        const rootState = navigation.getRootState();
        const state = store.state;
        // END FORK
        // root state may not available, for example when root navigators switch inside the container
        if (!state) {
          return;
        }
        const pendingPath = pendingPopStatePathRef.current;
        const route = (0, native_1.findFocusedRoute)(state);
        const path = getPathForRoute(route, state);
        // START FORK
        // previousStateRef.current = state;
        previousStateRef.current = rootState;
        // END FORK
        pendingPopStatePathRef.current = undefined;
        // To detect the kind of state change, we need to:
        // - Find the common focused navigation state in previous and current state
        // - If only the route keys changed, compare history/routes.length to check if we go back/forward/replace
        // - If no common focused navigation state found, it's a replace
        const [previousFocusedState, focusedState] = findMatchingState(previousState, state);
        if (previousFocusedState && focusedState &&
        // We should only handle push/pop if path changed from what was in last `popstate`
        // Otherwise it's likely a change triggered by `popstate`
        path !== pendingPath) {
          const historyDelta = (focusedState.history ? focusedState.history.length : focusedState.routes.length) - (previousFocusedState.history ? previousFocusedState.history.length : previousFocusedState.routes.length);
          if (historyDelta > 0) {
            // If history length is increased, we should pushState
            // Note that path might not actually change here, for example, drawer open should pushState
            history.push({
              path,
              state
            });
          } else if (historyDelta < 0) {
            // If history length is decreased, i.e. entries were removed, we want to go back
            const nextIndex = history.backIndex({
              path
            });
            const currentIndex = history.index;
            try {
              if (nextIndex !== -1 && nextIndex < currentIndex &&
              // We should only go back if the entry exists and it's less than current index
              history.get(nextIndex - currentIndex)) {
                // An existing entry for this path exists and it's less than current index, go back to that
                await history.go(nextIndex - currentIndex);
              } else {
                // We couldn't find an existing entry to go back to, so we'll go back by the delta
                // This won't be correct if multiple routes were pushed in one go before
                // Usually this shouldn't happen and this is a fallback for that
                await history.go(historyDelta);
              }
              // Store the updated state as well as fix the path if incorrect
              history.replace({
                path,
                state
              });
            } catch {
              // The navigation was interrupted
            }
          } else {
            // If history length is unchanged, we want to replaceState
            history.replace({
              path,
              state
            });
          }
        } else {
          // If no common navigation state was found, assume it's a replace
          // This would happen if the user did a reset/conditionally changed navigators
          history.replace({
            path,
            state
          });
        }
      };
      // We debounce onStateChange coz we don't want multiple state changes to be handled at one time
      // This could happen since `history.go(n)` is asynchronous
      // If `pushState` or `replaceState` were called before `history.go(n)` completes, it'll mess stuff up
      return ref.current?.addListener('state', (0, exports.series)(onStateChange));
    }, [enabled, history, ref]);
    return {
      getInitialState
    };
  }
  function getInitialURLWithTimeout() {
    return typeof window === 'undefined' ? '' : window.location.href;
  }
},684,[253,328,9,685,681,686,389,635],"node_modules/expo-router/build/fork/useLinking.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createMemoryHistory = createMemoryHistory;
  const non_secure_1 = require(_dependencyMap[0], "nanoid/non-secure");
  function createMemoryHistory() {
    let index = 0;
    let items = [];
    // Pending callbacks for `history.go(n)`
    // We might modify the callback stored if it was interrupted, so we have a ref to identify it
    const pending = [];
    const interrupt = () => {
      // If another history operation was performed we need to interrupt existing ones
      // This makes sure that calls such as `history.replace` after `history.go` don't happen
      // Since otherwise it won't be correct if something else has changed
      pending.forEach(it => {
        const cb = it.cb;
        it.cb = () => cb(true);
      });
    };
    const history = {
      get index() {
        // We store an id in the state instead of an index
        // Index could get out of sync with in-memory values if page reloads
        const id = window.history.state?.id;
        if (id) {
          const index = items.findIndex(item => item.id === id);
          return index > -1 ? index : 0;
        }
        return 0;
      },
      get(index) {
        return items[index];
      },
      backIndex({
        path
      }) {
        // We need to find the index from the element before current to get closest path to go back to
        for (let i = index - 1; i >= 0; i--) {
          const item = items[i];
          if (item.path === path) {
            return i;
          }
        }
        return -1;
      },
      push({
        path,
        state
      }) {
        interrupt();
        const id = (0, non_secure_1.nanoid)();
        // When a new entry is pushed, all the existing entries after index will be inaccessible
        // So we remove any existing entries after the current index to clean them up
        items = items.slice(0, index + 1);
        items.push({
          path,
          state,
          id
        });
        index = items.length - 1;
        // We pass empty string for title because it's ignored in all browsers except safari
        // We don't store state object in history.state because:
        // - browsers have limits on how big it can be, and we don't control the size
        // - while not recommended, there could be non-serializable data in state
        window.history.pushState({
          id
        }, '', path);
      },
      replace({
        path,
        state
      }) {
        interrupt();
        const id = window.history.state?.id ?? (0, non_secure_1.nanoid)();
        // Need to keep the hash part of the path if there was no previous history entry
        // or the previous history entry had the same path
        let pathWithHash = path;
        const hash = pathWithHash.includes('#') ? '' : location.hash;
        if (!items.length || items.findIndex(item => item.id === id) < 0) {
          // There are two scenarios for creating an array with only one history record:
          // - When loaded id not found in the items array, this function by default will replace
          //   the first item. We need to keep only the new updated object, otherwise it will break
          //   the page when navigating forward in history.
          // - This is the first time any state modifications are done
          //   So we need to push the entry as there's nothing to replace
          pathWithHash = pathWithHash + hash;
          items = [{
            path: pathWithHash,
            state,
            id
          }];
          index = 0;
        } else {
          if (items[index].path === path) {
            pathWithHash = pathWithHash + hash;
          }
          items[index] = {
            path,
            state,
            id
          };
        }
        window.history.replaceState({
          id
        }, '', pathWithHash);
      },
      // `history.go(n)` is asynchronous, there are couple of things to keep in mind:
      // - it won't do anything if we can't go `n` steps, the `popstate` event won't fire.
      // - each `history.go(n)` call will trigger a separate `popstate` event with correct location.
      // - the `popstate` event fires before the next frame after calling `history.go(n)`.
      // This method differs from `history.go(n)` in the sense that it'll go back as many steps it can.
      go(n) {
        interrupt();
        // To guard against unexpected navigation out of the app we will assume that browser history is only as deep as the length of our memory
        // history. If we don't have an item to navigate to then update our index and navigate as far as we can without taking the user out of the app.
        const nextIndex = index + n;
        const lastItemIndex = items.length - 1;
        if (n < 0 && !items[nextIndex]) {
          // Attempted to navigate beyond the first index. Negating the current index will align the browser history with the first item.
          n = -index;
          index = 0;
        } else if (n > 0 && nextIndex > lastItemIndex) {
          // Attempted to navigate past the last index. Calculate how many indices away from the last index and go there.
          n = lastItemIndex - index;
          index = lastItemIndex;
        } else {
          index = nextIndex;
        }
        if (n === 0) {
          return;
        }
        // When we call `history.go`, `popstate` will fire when there's history to go back to
        // So we need to somehow handle following cases:
        // - There's history to go back, `history.go` is called, and `popstate` fires
        // - `history.go` is called multiple times, we need to resolve on respective `popstate`
        // - No history to go back, but `history.go` was called, browser has no API to detect it
        return new Promise((resolve, reject) => {
          const done = interrupted => {
            clearTimeout(timer);
            if (interrupted) {
              reject(new Error('History was changed during navigation.'));
              return;
            }
            // There seems to be a bug in Chrome regarding updating the title
            // If we set a title just before calling `history.go`, the title gets lost
            // However the value of `document.title` is still what we set it to
            // It's just not displayed in the tab bar
            // To update the tab bar, we need to reset the title to something else first (e.g. '')
            // And set the title to what it was before so it gets applied
            // It won't work without setting it to empty string coz otherwise title isn't changing
            // Which means that the browser won't do anything after setting the title
            const {
              title
            } = window.document;
            window.document.title = '';
            window.document.title = title;
            resolve();
          };
          pending.push({
            ref: done,
            cb: done
          });
          // If navigation didn't happen within 100ms, assume that it won't happen
          // This may not be accurate, but hopefully it won't take so much time
          // In Chrome, navigation seems to happen instantly in next microtask
          // But on Firefox, it seems to take much longer, around 50ms from our testing
          // We're using a hacky timeout since there doesn't seem to be way to know for sure
          const timer = setTimeout(() => {
            const index = pending.findIndex(it => it.ref === done);
            if (index > -1) {
              pending[index].cb();
              pending.splice(index, 1);
            }
          }, 100);
          const onPopState = () => {
            const id = window.history.state?.id;
            const currentIndex = items.findIndex(item => item.id === id);
            // Fix createMemoryHistory.index variable's value
            // as it may go out of sync when navigating in the browser.
            index = Math.max(currentIndex, 0);
            const last = pending.pop();
            window.removeEventListener('popstate', onPopState);
            last?.cb();
          };
          window.addEventListener('popstate', onPopState);
          window.history.go(n);
        });
      },
      // The `popstate` event is triggered when history changes, except `pushState` and `replaceState`
      // If we call `history.go(n)` ourselves, we don't want it to trigger the listener
      // Here we normalize it so that only external changes (e.g. user pressing back/forward) trigger the listener
      listen(listener) {
        const onPopState = () => {
          if (pending.length) {
            // This was triggered by `history.go(n)`, we shouldn't call the listener
            return;
          }
          listener();
        };
        window.addEventListener('popstate', onPopState);
        return () => window.removeEventListener('popstate', onPopState);
      }
    };
    return history;
  }
},685,[260],"node_modules/expo-router/build/fork/createMemoryHistory.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ServerContext = void 0;
  // This is file should mirror https://github.com/react-navigation/react-navigation/blob/6.x/packages/native/src/ServerContext.tsx
  const react_1 = require(_dependencyMap[0], "react");
  exports.ServerContext = (0, react_1.createContext)(undefined);
},686,[9],"node_modules/expo-router/build/global-state/serverLocationContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.extrapolateGroups = exports.generateDynamic = void 0;
  exports.getRoutes = getRoutes;
  exports.getExactRoutes = getExactRoutes;
  const getRoutesCore_1 = require(_dependencyMap[0], "./getRoutesCore");
  /**
   * Given a Metro context module, return an array of nested routes.
   *
   * This is a two step process:
   *  1. Convert the RequireContext keys (file paths) into a directory tree.
   *      - This should extrapolate array syntax into multiple routes
   *      - Routes are given a specificity score
   *  2. Flatten the directory tree into routes
   *      - Routes in directories without _layout files are hoisted to the nearest _layout
   *      - The name of the route is relative to the nearest _layout
   *      - If multiple routes have the same name, the most specific route is used
   */
  function getRoutes(contextModule, options = {}) {
    return (0, getRoutesCore_1.getRoutes)(contextModule, Object.assign({
      getSystemRoute({
        route,
        type,
        defaults,
        redirectConfig,
        rewriteConfig
      }) {
        if (route === '' && type === 'layout') {
          // Root layout when no layout is defined.
          return {
            type: 'layout',
            loadRoute: () => ({
              default: require(_dependencyMap[1], "./views/Navigator").DefaultNavigator
            }),
            // Generate a fake file name for the directory
            contextKey: 'expo-router/build/views/Navigator.js',
            route: '',
            generated: true,
            dynamic: null,
            children: []
          };
        } else if (route === '_sitemap' && type === 'route') {
          return {
            loadRoute() {
              const {
                Sitemap,
                getNavOptions
              } = require(_dependencyMap[2], "./views/Sitemap");
              return {
                default: Sitemap,
                getNavOptions
              };
            },
            route: '_sitemap',
            type: 'route',
            contextKey: 'expo-router/build/views/Sitemap.js',
            generated: true,
            internal: true,
            dynamic: null,
            children: []
          };
        } else if (route === '+not-found' && type === 'route') {
          return {
            loadRoute() {
              return {
                default: require(_dependencyMap[3], "./views/Unmatched").Unmatched
              };
            },
            type: 'route',
            route: '+not-found',
            contextKey: 'expo-router/build/views/Unmatched.js',
            generated: true,
            internal: true,
            dynamic: [{
              name: '+not-found',
              deep: true,
              notFound: true
            }],
            children: []
          };
        } else if (type === 'redirect' && redirectConfig && defaults) {
          return Object.assign({}, defaults, {
            loadRoute() {
              return require(_dependencyMap[4], "./getRoutesRedirects").getRedirectModule(redirectConfig);
            }
          });
        } else if (type === 'rewrite' && rewriteConfig && defaults) {
          // Rewrite routes only work in a server context and have no equivalent on native or
          // static exports
          return Object.assign({}, defaults, {
            loadRoute() {
              return {
                default: contextModule(rewriteConfig.destinationContextKey).default
              };
            }
          });
        }
        throw new Error(`Unknown system route: ${route} and type: ${type} and redirectConfig: ${redirectConfig} and rewriteConfig: ${rewriteConfig}`);
      }
    }, options));
  }
  function getExactRoutes(contextModule, options = {}) {
    return getRoutes(contextModule, Object.assign({}, options, {
      skipGenerated: true
    }));
  }
  var getRoutesCore_2 = require(_dependencyMap[0], "./getRoutesCore");
  Object.defineProperty(exports, "generateDynamic", {
    enumerable: true,
    get: function () {
      return getRoutesCore_2.generateDynamic;
    }
  });
  Object.defineProperty(exports, "extrapolateGroups", {
    enumerable: true,
    get: function () {
      return getRoutesCore_2.extrapolateGroups;
    }
  });
},687,[688,689,691,701,676],"node_modules/expo-router/build/getRoutes.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getRoutes = getRoutes;
  exports.extrapolateGroups = extrapolateGroups;
  exports.generateDynamic = generateDynamic;
  const matchers_1 = require(_dependencyMap[0], "./matchers");
  const url_1 = require(_dependencyMap[1], "./utils/url");
  const validPlatforms = new Set(['android', 'ios', 'native', 'web']);
  /**
   * Given a Metro context module, return an array of nested routes.
   *
   * This is a two step process:
   *  1. Convert the RequireContext keys (file paths) into a directory tree.
   *      - This should extrapolate array syntax into multiple routes
   *      - Routes are given a specificity score
   *  2. Flatten the directory tree into routes
   *      - Routes in directories without _layout files are hoisted to the nearest _layout
   *      - The name of the route is relative to the nearest _layout
   *      - If multiple routes have the same name, the most specific route is used
   */
  function getRoutes(contextModule, options) {
    const middleware = getMiddleware(contextModule, options);
    const directoryTree = getDirectoryTree(contextModule, options);
    // If there are no routes
    if (!directoryTree) {
      return null;
    }
    const rootNode = flattenDirectoryTreeToRoutes(directoryTree, options);
    if (middleware) {
      rootNode.middleware = middleware;
    }
    if (!options.ignoreEntryPoints) {
      crawlAndAppendInitialRoutesAndEntryFiles(rootNode, options);
    }
    return rootNode;
  }
  /**
   * Given a RequireContext, return the middleware node if one is found. If more than one middleware file is found, an error is thrown.
   */
  function getMiddleware(contextModule, options) {
    const allMiddlewareFiles = contextModule.keys().filter(key => key.includes('+middleware'));
    // Check if middleware is enabled via plugin config
    if (!options.unstable_useServerMiddleware) {
      if (allMiddlewareFiles.length > 0) {
        console.warn('Server middleware is not enabled. Add unstable_useServerMiddleware: true to your `expo-router` plugin config.\n\n' + JSON.stringify({
          expo: {
            plugins: [['expo-router', {
              unstable_useServerMiddleware: true
            }]]
          }
        }, null, 2));
      }
      return null;
    }
    const isValidMiddleware = key => /^\.\/\+middleware\.[tj]sx?$/.test(key);
    const rootMiddlewareFiles = allMiddlewareFiles.filter(isValidMiddleware);
    const nonRootMiddleware = allMiddlewareFiles.filter(file => !rootMiddlewareFiles.includes(file));
    if (nonRootMiddleware.length > 0) {
      throw new Error(`The middleware file can only be placed at the root level. Remove the following files: ${nonRootMiddleware.join(', ')}`);
    }
    if (rootMiddlewareFiles.length === 0) {
      return null;
    }
    // In development, throw an error if there are multiple root-level middleware files
    if (rootMiddlewareFiles.length > 1) {
      if (process.env.NODE_ENV !== 'production') {
        throw new Error(`Only one middleware file is allowed. Keep one of the conflicting files: ${rootMiddlewareFiles.map(p => `"${p}"`).join(' or ')}`);
      }
    }
    const middlewareFilePath = rootMiddlewareFiles[0];
    const middleware = {
      loadRoute() {
        if (options.ignoreRequireErrors) {
          try {
            return contextModule(middlewareFilePath);
          } catch {
            return {};
          }
        } else {
          return contextModule(middlewareFilePath);
        }
      },
      contextKey: middlewareFilePath
    };
    if (options.internal_stripLoadRoute) {
      delete middleware.loadRoute;
    }
    return middleware;
  }
  /**
   * Converts the RequireContext keys (file paths) into a directory tree.
   */
  function getDirectoryTree(contextModule, options) {
    const importMode = options.importMode || "sync";
    const ignoreList = [/^\.\/\+(html|native-intent)\.[tj]sx?$/]; // Ignore the top level ./+html file
    if (options.ignore) {
      ignoreList.push(...options.ignore);
    }
    if (!options.preserveApiRoutes) {
      ignoreList.push(/\+api$/, /\+api\.[tj]sx?$/);
    }
    // Always ignore middleware files in regular route processing
    ignoreList.push(/\+middleware$/, /\+middleware\.[tj]sx?$/);
    const rootDirectory = {
      files: new Map(),
      subdirectories: new Map()
    };
    let hasRoutes = false;
    let isValid = false;
    const contextKeys = contextModule.keys();
    const redirects = {};
    const rewrites = {};
    let validRedirectDestinations;
    const getValidDestinations = () => {
      // Loop over contexts once and cache the valid destinations
      validRedirectDestinations ??= contextKeys.map(key => {
        return {
          contextKey: key,
          nameWithoutInvisible: getNameWithoutInvisibleSegmentsFromRedirectPath((0, matchers_1.removeSupportedExtensions)(key))
        };
      });
      return validRedirectDestinations;
    };
    // If we are keeping redirects as valid routes, then we need to add them to the contextKeys
    // This is useful for generating a sitemap with redirects, or static site generation that includes redirects
    if (options.preserveRedirectAndRewrites) {
      if (options.redirects) {
        for (const redirect of options.redirects) {
          const sourceContextKey = getSourceContextKeyFromRedirectSource(redirect.source);
          const sourceName = getNameFromRedirectPath(redirect.source);
          const isExternalRedirect = (0, url_1.shouldLinkExternally)(redirect.destination);
          const targetDestinationName = isExternalRedirect ? redirect.destination : getNameWithoutInvisibleSegmentsFromRedirectPath(redirect.destination);
          if (ignoreList.some(regex => regex.test(sourceContextKey))) {
            continue;
          }
          const validDestination = isExternalRedirect ? undefined : getValidDestinations().find(key => key.nameWithoutInvisible === targetDestinationName);
          const destination = isExternalRedirect ? targetDestinationName : validDestination?.nameWithoutInvisible;
          const destinationContextKey = isExternalRedirect ? targetDestinationName : validDestination?.contextKey;
          if (!destinationContextKey || destination === undefined) {
            /*
             * Only throw the error when we are preserving the api routes
             * When doing a static export, API routes will not exist so the redirect destination may not exist.
             * The desired behavior for this error is to warn the user when running `expo start`, so its ok if
             * `expo export` swallows this error.
             */
            if (options.preserveApiRoutes) {
              throw new Error(`Redirect destination "${redirect.destination}" does not exist.`);
            }
            continue;
          }
          contextKeys.push(sourceContextKey);
          redirects[sourceName] = {
            source: sourceName,
            destination,
            destinationContextKey,
            permanent: Boolean(redirect.permanent),
            external: isExternalRedirect,
            methods: redirect.methods
          };
        }
      }
      if (options.rewrites) {
        for (const rewrite of options.rewrites) {
          const sourceContextKey = getSourceContextKeyFromRedirectSource(rewrite.source);
          const sourceName = getNameFromRedirectPath(rewrite.source);
          // We check to see if the context key is already known so that we don't create a rewrite for
          // a route that already exists on disk
          const isSourceContextKeyAlreadyKnown = contextKeys.includes(sourceContextKey);
          const targetDestinationName = isSourceContextKeyAlreadyKnown ? getNameFromRedirectPath(rewrite.destination) : getNameWithoutInvisibleSegmentsFromRedirectPath(rewrite.destination);
          if (ignoreList.some(regex => regex.test(sourceContextKey))) {
            continue;
          }
          const validDestination = getValidDestinations().find(key => key.nameWithoutInvisible === targetDestinationName);
          const destination = validDestination?.nameWithoutInvisible;
          const destinationContextKey = validDestination?.contextKey;
          if (!destinationContextKey || destination === undefined) {
            /*
             * Only throw the error when we are preserving the api routes
             * When doing a static export, API routes will not exist so the redirect destination may not exist.
             * The desired behavior for this error is to warn the user when running `expo start`, so its ok if
             * `expo export` swallows this error.
             */
            if (options.preserveApiRoutes) {
              throw new Error(`Rewrite destination "${rewrite.destination}" does not exist.`);
            }
            continue;
          }
          contextKeys.push(sourceContextKey);
          rewrites[sourceName] = {
            source: sourceName,
            destination,
            destinationContextKey,
            methods: rewrite.methods
          };
        }
      }
    }
    const processedRedirectsRewrites = new Set();
    for (const filePath of contextKeys) {
      if (ignoreList.some(regex => regex.test(filePath))) {
        continue;
      }
      isValid = true;
      const meta = getFileMeta(filePath, options, redirects, rewrites);
      // This is a file that should be ignored. e.g maybe it has an invalid platform?
      if (meta.specificity < 0) {
        continue;
      }
      let node = {
        type: meta.isApi ? 'api' : meta.isLayout ? 'layout' : 'route',
        loadRoute() {
          let routeModule;
          if (options.ignoreRequireErrors) {
            try {
              routeModule = contextModule(filePath);
            } catch {
              routeModule = {};
            }
          } else {
            routeModule = contextModule(filePath);
          }
          if (process.env.NODE_ENV === 'development' && importMode === 'sync') {
            // In development mode, when async routes are disabled, add some extra error handling to improve the developer experience.
            // This can be useful when you accidentally use an async function in a route file for the default export.
            if (routeModule instanceof Promise) {
              throw new Error(`Route "${filePath}" cannot be a promise when async routes is disabled.`);
            }
            const defaultExport = routeModule?.default;
            if (defaultExport instanceof Promise) {
              throw new Error(`The default export from route "${filePath}" is a promise. Ensure the React Component does not use async or promises.`);
            }
            // check if default is an async function without invoking it
            if (defaultExport instanceof Function &&
            // This only works on web because Hermes support async functions so we have to transform them out.
            defaultExport.constructor.name === 'AsyncFunction') {
              throw new Error(`The default export from route "${filePath}" is an async function. Ensure the React Component does not use async or promises.`);
            }
          }
          return routeModule;
        },
        contextKey: filePath,
        route: '',
        // This is overwritten during hoisting based upon the _layout
        dynamic: null,
        children: [] // While we are building the directory tree, we don't know the node's children just yet. This is added during hoisting
      };
      if (meta.isRedirect) {
        if (processedRedirectsRewrites.has(meta.route)) {
          continue;
        }
        const redirect = redirects[meta.route];
        node.destinationContextKey = redirect.destinationContextKey;
        node.permanent = redirect.permanent;
        node.generated = true;
        if (node.type === 'route') {
          node = options.getSystemRoute({
            type: 'redirect',
            route: redirect.destination,
            defaults: node,
            redirectConfig: redirect
          });
        }
        if (redirect.methods) {
          node.methods = redirect.methods;
        }
        node.type = 'redirect';
        processedRedirectsRewrites.add(meta.route);
      }
      if (meta.isRewrite) {
        if (processedRedirectsRewrites.has(meta.route)) {
          continue;
        }
        const rewrite = rewrites[meta.route];
        node.destinationContextKey = rewrite.destinationContextKey;
        node.generated = true;
        if (node.type === 'route') {
          node = options.getSystemRoute({
            type: 'rewrite',
            route: rewrite.destination,
            defaults: node,
            rewriteConfig: rewrite
          });
        }
        if (rewrite.methods) {
          node.methods = rewrite.methods;
        }
        node.type = 'rewrite';
        processedRedirectsRewrites.add(meta.route);
      }
      if (process.env.NODE_ENV === 'development') {
        // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should
        // filter the missing routes.
        if (node.type !== 'api' && importMode === 'sync') {
          const routeItem = node.loadRoute();
          // Have a warning for nullish ex
          const route = routeItem?.default;
          if (route == null) {
            // Do not throw an error since a user may just be creating a new route.
            console.warn(`Route "${filePath}" is missing the required default export. Ensure a React component is exported as default.`);
            continue;
          }
          if (['boolean', 'number', 'string'].includes(typeof route)) {
            throw new Error(`The default export from route "${filePath}" is an unsupported type: "${typeof route}". Only React Components are supported as default exports from route files.`);
          }
        }
      }
      /**
       * A single filepath may be extrapolated into multiple routes if it contains array syntax.
       * Another way to thinking about is that a filepath node is present in multiple leaves of the directory tree.
       */
      for (const route of extrapolateGroups(meta.route)) {
        // Traverse the directory tree to its leaf node, creating any missing directories along the way
        const subdirectoryParts = route.split('/').slice(0, -1);
        // Start at the root directory and traverse the path to the leaf directory
        let directory = rootDirectory;
        for (const part of subdirectoryParts) {
          let subDirectory = directory.subdirectories.get(part);
          // Create any missing subdirectories
          if (!subDirectory) {
            subDirectory = {
              files: new Map(),
              subdirectories: new Map()
            };
            directory.subdirectories.set(part, subDirectory);
          }
          directory = subDirectory;
        }
        // Clone the node for this route
        node = Object.assign({}, node, {
          route
        });
        if (meta.isLayout) {
          directory.layout ??= [];
          const existing = directory.layout[meta.specificity];
          if (existing) {
            // In production, use the first route found
            if (process.env.NODE_ENV !== 'production') {
              throw new Error(`The layouts "${filePath}" and "${existing.contextKey}" conflict on the route "/${route}". Remove or rename one of these files.`);
            }
          } else {
            node = getLayoutNode(node, options);
            directory.layout[meta.specificity] = node;
          }
        } else if (meta.isApi) {
          const fileKey = `${route}+api`;
          let nodes = directory.files.get(fileKey);
          if (!nodes) {
            nodes = [];
            directory.files.set(fileKey, nodes);
          }
          // API Routes have no specificity, they are always the first node
          const existing = nodes[0];
          if (existing) {
            // In production, use the first route found
            if (process.env.NODE_ENV !== 'production') {
              throw new Error(`The API route file "${filePath}" and "${existing.contextKey}" conflict on the route "/${route}". Remove or rename one of these files.`);
            }
          } else {
            nodes[0] = node;
          }
        } else {
          let nodes = directory.files.get(route);
          if (!nodes) {
            nodes = [];
            directory.files.set(route, nodes);
          }
          /**
           * If there is an existing node with the same specificity, then we have a conflict.
           * NOTE(Platform Routes):
           *    We cannot check for specificity conflicts here, as we haven't processed all the context keys yet!
           *    This will be checked during hoisting, as well as enforcing that all routes have a non-platform route.
           */
          const existing = nodes[meta.specificity];
          if (existing) {
            // In production, use the first route found
            if (process.env.NODE_ENV !== 'production') {
              throw new Error(`The route files "${filePath}" and "${existing.contextKey}" conflict on the route "/${route}". Remove or rename one of these files.`);
            }
          } else {
            hasRoutes ||= true;
            nodes[meta.specificity] = node;
          }
        }
      }
    }
    // If there are no routes/layouts then we should display the tutorial.
    if (!isValid) {
      return null;
    }
    /**
     * If there are no top-level _layout, add a default _layout
     * While this is a generated route, it will still be generated even if skipGenerated is true.
     */
    if (!rootDirectory.layout) {
      rootDirectory.layout = [options.getSystemRoute({
        type: 'layout',
        route: ''
      })];
    }
    // Only include the sitemap if there are routes.
    if (!options.skipGenerated) {
      if (hasRoutes && options.sitemap !== false) {
        appendSitemapRoute(rootDirectory, options);
      }
      if (options.notFound !== false) {
        appendNotFoundRoute(rootDirectory, options);
      }
    }
    return rootDirectory;
  }
  function getNameFromRedirectPath(path) {
    // Removing only the filesystem extensions, to be able to handle +api, +html
    return (0, matchers_1.removeFileSystemExtensions)((0, matchers_1.removeFileSystemDots)(path))
    // Remove the leading `/`
    .replace(/^\//, '');
  }
  function getNameWithoutInvisibleSegmentsFromRedirectPath(path) {
    return (0, matchers_1.stripInvisibleSegmentsFromPath)(getNameFromRedirectPath(path));
  }
  // Creates fake context key for redirects and rewrites
  function getSourceContextKeyFromRedirectSource(source) {
    const name = getNameFromRedirectPath(source);
    const prefix = './';
    const suffix = /\.[tj]sx?$/.test(name) ? '' : '.js'; // Ensure it has a file extension
    return `${prefix}${name}${suffix}`;
  }
  /**
   * Flatten the directory tree into routes, hoisting routes to the nearest _layout.
   */
  function flattenDirectoryTreeToRoutes(directory, options, /* The nearest _layout file in the directory tree */
  layout, /* Route names are relative to their layout */
  pathToRemove = '') {
    /**
     * This directory has a _layout file so it becomes the new target for hoisting routes.
     */
    if (directory.layout) {
      const previousLayout = layout;
      layout = getMostSpecific(directory.layout);
      // Add the new layout as a child of its parent
      if (previousLayout) {
        previousLayout.children.push(layout);
      }
      if (options.internal_stripLoadRoute) {
        delete layout.loadRoute;
      }
      // `route` is the absolute pathname. We need to make this relative to the last _layout
      const newRoute = layout.route.replace(pathToRemove, '');
      pathToRemove = layout.route ? `${layout.route}/` : '';
      // Now update this layout with the new relative route and dynamic conventions
      layout.route = newRoute;
      layout.dynamic = generateDynamic(layout.contextKey.slice(0));
    }
    // This should never occur as there will always be a root layout, but it makes the type system happy
    if (!layout) throw new Error('Expo Router Internal Error: No nearest layout');
    for (const routes of directory.files.values()) {
      const routeNode = getMostSpecific(routes);
      // `route` is the absolute pathname. We need to make this relative to the nearest layout
      routeNode.route = routeNode.route.replace(pathToRemove, '');
      routeNode.dynamic = generateDynamic(routeNode.route);
      if (options.internal_stripLoadRoute) {
        delete routeNode.loadRoute;
      }
      layout.children.push(routeNode);
    }
    // Recursively flatten the subdirectories
    for (const child of directory.subdirectories.values()) {
      flattenDirectoryTreeToRoutes(child, options, layout, pathToRemove);
    }
    return layout;
  }
  function getFileMeta(originalKey, options, redirects, rewrites) {
    // Remove the leading `./`
    const key = (0, matchers_1.removeSupportedExtensions)((0, matchers_1.removeFileSystemDots)(originalKey));
    let route = key;
    const parts = (0, matchers_1.removeFileSystemDots)(originalKey).split('/');
    const filename = parts[parts.length - 1];
    const [filenameWithoutExtensions, platformExtension] = (0, matchers_1.removeSupportedExtensions)(filename).split('.');
    const isLayout = filenameWithoutExtensions === '_layout';
    const isApi = originalKey.match(/\+api\.(\w+\.)?[jt]sx?$/);
    if (filenameWithoutExtensions.startsWith('(') && filenameWithoutExtensions.endsWith(')')) {
      throw new Error(`Invalid route ${originalKey}. Routes cannot end with '(group)' syntax`);
    }
    // Nested routes cannot start with the '+' character, except for the '+not-found' route
    if (!isApi && filename.startsWith('+') && filenameWithoutExtensions !== '+not-found') {
      const renamedRoute = [...parts.slice(0, -1), filename.slice(1)].join('/');
      throw new Error(`Invalid route ${originalKey}. Route nodes cannot start with the '+' character. "Rename it to ${renamedRoute}"`);
    }
    let specificity = 0;
    const hasPlatformExtension = validPlatforms.has(platformExtension);
    const usePlatformRoutes = options.platformRoutes ?? true;
    if (hasPlatformExtension) {
      if (!usePlatformRoutes) {
        // If the user has disabled platform routes, then we should ignore this file
        specificity = -1;
      } else if (!options.platform) {
        // If we don't have a platform, then we should ignore this file
        // This used by typed routes, sitemap, etc
        specificity = -1;
      } else if (platformExtension === options.platform) {
        // If the platform extension is the same as the options.platform, then it is the most specific
        specificity = 2;
      } else if (platformExtension === 'native' && options.platform !== 'web') {
        // `native` is allow but isn't as specific as the platform
        specificity = 1;
      } else if (platformExtension !== options.platform) {
        // Somehow we have a platform extension that doesn't match the options.platform and it isn't native
        // This is an invalid file and we will ignore it
        specificity = -1;
      }
      if (isApi && specificity !== 0) {
        throw new Error(`API routes cannot have platform extensions. Remove '.${platformExtension}' from '${originalKey}'`);
      }
      route = route.replace(new RegExp(`.${platformExtension}$`), '');
    }
    return {
      route,
      specificity,
      isLayout,
      isApi,
      isRedirect: key in redirects,
      isRewrite: key in rewrites
    };
  }
  /**
   * Generates a set of strings which have the router array syntax extrapolated.
   *
   * /(a,b)/(c,d)/e.tsx => new Set(['a/c/e.tsx', 'a/d/e.tsx', 'b/c/e.tsx', 'b/d/e.tsx'])
   */
  function extrapolateGroups(key, keys = new Set()) {
    const match = (0, matchers_1.matchArrayGroupName)(key);
    if (!match) {
      keys.add(key);
      return keys;
    }
    const groups = match.split(',');
    const groupsSet = new Set(groups);
    if (groupsSet.size !== groups.length) {
      throw new Error(`Array syntax cannot contain duplicate group name "${groups}" in "${key}".`);
    }
    if (groups.length === 1) {
      keys.add(key);
      return keys;
    }
    for (const group of groups) {
      extrapolateGroups(key.replace(match, group.trim()), keys);
    }
    return keys;
  }
  function generateDynamic(path) {
    const dynamic = path.split('/').map(part => {
      if (part === '+not-found') {
        return {
          name: '+not-found',
          deep: true,
          notFound: true
        };
      }
      return (0, matchers_1.matchDynamicName)(part) ?? null;
    }).filter(part => !!part);
    return dynamic.length === 0 ? null : dynamic;
  }
  function appendSitemapRoute(directory, options) {
    if (!directory.files.has('_sitemap') && options.getSystemRoute) {
      directory.files.set('_sitemap', [options.getSystemRoute({
        type: 'route',
        route: '_sitemap'
      })]);
    }
  }
  function appendNotFoundRoute(directory, options) {
    if (!directory.files.has('+not-found') && options.getSystemRoute) {
      directory.files.set('+not-found', [options.getSystemRoute({
        type: 'route',
        route: '+not-found'
      })]);
    }
  }
  function getLayoutNode(node, options) {
    /**
     * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.
     * Each of these layouts will have a different anchor based upon the first group name.
     */
    // We may strip loadRoute during testing
    const groupName = (0, matchers_1.matchLastGroupName)(node.route);
    const childMatchingGroup = node.children.find(child => {
      return child.route.replace(/\/index$/, '') === groupName;
    });
    let anchor = childMatchingGroup?.route;
    const loaded = node.loadRoute();
    if (loaded?.unstable_settings) {
      try {
        // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.
        anchor = loaded.unstable_settings.anchor ?? loaded.unstable_settings.initialRouteName ?? anchor;
      } catch (error) {
        if (error instanceof Error) {
          if (!error.message.match(/You cannot dot into a client module/)) {
            throw error;
          }
        }
      }
      if (groupName) {
        // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.
        const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.anchor ?? loaded.unstable_settings?.[groupName]?.initialRouteName;
        anchor = groupSpecificInitialRouteName ?? anchor;
      }
    }
    return Object.assign({}, node, {
      route: node.route.replace(/\/?_layout$/, ''),
      children: [],
      // Each layout should have its own children
      initialRouteName: anchor
    });
  }
  function crawlAndAppendInitialRoutesAndEntryFiles(node, options, entryPoints = []) {
    if (node.type === 'route') {
      node.entryPoints = [...new Set([...entryPoints, node.contextKey])];
    } else if (node.type === 'redirect') {
      node.entryPoints = [...new Set([...entryPoints, node.destinationContextKey])];
    } else if (node.type === 'layout') {
      if (!node.children) {
        throw new Error(`Layout "${node.contextKey}" does not contain any child routes`);
      }
      // Every node below this layout will have it as an entryPoint
      entryPoints = [...entryPoints, node.contextKey];
      /**
       * Calculate the initialRouteNode
       *
       * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.
       * Each of these layouts will have a different anchor based upon the first group.
       */
      const groupName = (0, matchers_1.matchGroupName)(node.route);
      const childMatchingGroup = node.children.find(child => {
        return child.route.replace(/\/index$/, '') === groupName;
      });
      let anchor = childMatchingGroup?.route;
      // We may strip loadRoute during testing
      if (!options.internal_stripLoadRoute) {
        const loaded = node.loadRoute();
        if (loaded?.unstable_settings) {
          try {
            // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.
            anchor = loaded.unstable_settings.anchor ?? loaded.unstable_settings.initialRouteName ?? anchor;
          } catch (error) {
            if (error instanceof Error) {
              if (!error.message.match(/You cannot dot into a client module/)) {
                throw error;
              }
            }
          }
          if (groupName) {
            // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.
            const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.anchor ?? loaded.unstable_settings?.[groupName]?.initialRouteName;
            anchor = groupSpecificInitialRouteName ?? anchor;
          }
        }
      }
      if (anchor) {
        const anchorRoute = node.children.find(child => child.route === anchor);
        if (!anchorRoute) {
          const validAnchorRoutes = node.children.filter(child => !child.generated).map(child => `'${child.route}'`).join(', ');
          if (groupName) {
            throw new Error(`Layout ${node.contextKey} has invalid anchor '${anchor}' for group '(${groupName})'. Valid options are: ${validAnchorRoutes}`);
          } else {
            throw new Error(`Layout ${node.contextKey} has invalid anchor '${anchor}'. Valid options are: ${validAnchorRoutes}`);
          }
        }
        // Navigators can add initialsRoutes into the history, so they need to be to be included in the entryPoints
        node.initialRouteName = anchor;
        entryPoints.push(anchorRoute.contextKey);
      }
      for (const child of node.children) {
        crawlAndAppendInitialRoutesAndEntryFiles(child, options, entryPoints);
      }
    }
  }
  function getMostSpecific(routes) {
    const route = routes[routes.length - 1];
    if (!routes[0]) {
      throw new Error(`The file ${route.contextKey} does not have a fallback sibling file without a platform extension.`);
    }
    // This works even tho routes is holey array (e.g it might have index 0 and 2 but not 1)
    // `.length` includes the holes in its count
    return routes[routes.length - 1];
  }
},688,[380,677],"node_modules/expo-router/build/getRoutesCore.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // Copyright © 2024 650 Industries.
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\views\\Navigator.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigatorContext = void 0;
  exports.Navigator = Navigator;
  exports.useNavigatorContext = useNavigatorContext;
  exports.Slot = Slot;
  exports.DefaultNavigator = DefaultNavigator;
  const native_1 = require(_dependencyMap[1], "@react-navigation/native");
  const React = __importStar(require(_dependencyMap[2], "react"));
  const react_native_is_edge_to_edge_1 = require(_dependencyMap[3], "react-native-is-edge-to-edge");
  const react_native_safe_area_context_1 = require(_dependencyMap[4], "react-native-safe-area-context");
  const Screen_1 = require(_dependencyMap[5], "./Screen");
  const Route_1 = require(_dependencyMap[6], "../Route");
  const StackClient_1 = require(_dependencyMap[7], "../layouts/StackClient");
  const withLayoutContext_1 = require(_dependencyMap[8], "../layouts/withLayoutContext");
  const useScreens_1 = require(_dependencyMap[9], "../useScreens");
  exports.NavigatorContext = React.createContext(null);
  if (process.env.NODE_ENV !== 'production') {
    exports.NavigatorContext.displayName = 'NavigatorContext';
  }
  /**
   * An unstyled custom navigator. Good for basic web layouts.
   *
   * @hidden
   */
  function Navigator({
    initialRouteName,
    screenOptions,
    children,
    router,
    routerOptions
  }) {
    const contextKey = (0, Route_1.useContextKey)();
    // A custom navigator can have a mix of Screen and other components (like a Slot inside a View)
    const {
      screens,
      children: nonScreenChildren,
      protectedScreens
    } = (0, withLayoutContext_1.useFilterScreenChildren)(children, {
      isCustomNavigator: true,
      contextKey
    });
    const sortedScreens = (0, useScreens_1.useSortedScreens)(screens ?? [], protectedScreens);
    router ||= StackClient_1.StackRouter;
    const navigation = (0, native_1.useNavigationBuilder)(router, Object.assign({}, routerOptions, {
      id: contextKey,
      children: sortedScreens || [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Screen_1.Screen, {}, "default", false, {
        fileName: _jsxFileName,
        lineNumber: 74,
        columnNumber: 37
      }, this)],
      screenOptions,
      initialRouteName
    }));
    // useNavigationBuilder requires at least one screen to be defined otherwise it will throw.
    if (!sortedScreens.length) {
      console.warn(`Navigator at "${contextKey}" has no children.`);
      return null;
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(exports.NavigatorContext.Provider, {
      value: Object.assign({}, navigation, {
        contextKey,
        router
      }),
      children: nonScreenChildren
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 83,
      columnNumber: 13
    }, this);
  }
  /**
   * @hidden
   */
  function useNavigatorContext() {
    const context = React.use(exports.NavigatorContext);
    if (!context) {
      throw new Error('useNavigatorContext must be used within a <Navigator />');
    }
    return context;
  }
  function SlotNavigator(props) {
    const contextKey = (0, Route_1.useContextKey)();
    // Allows adding Screen components as children to configure routes.
    const {
      screens,
      protectedScreens
    } = (0, withLayoutContext_1.useFilterScreenChildren)([], {
      contextKey
    });
    const {
      state,
      descriptors,
      NavigationContent
    } = (0, native_1.useNavigationBuilder)(StackClient_1.StackRouter, Object.assign({}, props, {
      id: contextKey,
      children: (0, useScreens_1.useSortedScreens)(screens ?? [], protectedScreens)
    }));
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(NavigationContent, {
      children: descriptors[state.routes[state.index].key].render()
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 112,
      columnNumber: 13
    }, this);
  }
  /**
   * Renders the currently selected content.
   *
   * There are actually two different implementations of `<Slot/>`:
   *  - Used inside a `_layout` as the `Navigator`
   *  - Used inside a `Navigator` as the content
   *
   * Since a custom `Navigator` will set the `NavigatorContext.contextKey` to
   * the current `_layout`, you can use this to determine if you are inside
   * a custom navigator or not.
   */
  function Slot(props) {
    const contextKey = (0, Route_1.useContextKey)();
    const context = React.use(exports.NavigatorContext);
    if (context?.contextKey !== contextKey) {
      // The _layout has changed since the last navigator
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(SlotNavigator, Object.assign({}, props), void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 130,
        columnNumber: 16
      }, this);
    }
    /*
     * The user has defined a custom navigator
     * <Navigator><Slot /></Navigator>
     */
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(NavigatorSlot, {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 136,
      columnNumber: 12
    }, this);
  }
  /**
   * Render the current navigator content.
   */
  function NavigatorSlot() {
    const context = useNavigatorContext();
    const {
      state,
      descriptors
    } = context;
    return descriptors[state.routes[state.index].key]?.render() ?? null;
  }
  /**
   * The default navigator for the app when no root _layout is provided.
   */
  function DefaultNavigator() {
    if (false && (0, react_native_is_edge_to_edge_1.isEdgeToEdge)()) {
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(SlotNavigator, {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 151,
        columnNumber: 16
      }, this);
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_safe_area_context_1.SafeAreaView, {
      style: {
        flex: 1
      },
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(SlotNavigator, {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 154,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 153,
      columnNumber: 13
    }, this);
  }
  Navigator.Slot = NavigatorSlot;
  Navigator.useContext = useNavigatorContext;
  /** Used to configure route settings. */
  Navigator.Screen = Screen_1.Screen;
},689,[33,253,9,690,423,633,379,252,378,388],"node_modules/expo-router/build/views/Navigator.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "controlEdgeToEdgeValues", {
    enumerable: true,
    get: function () {
      return controlEdgeToEdgeValues;
    }
  });
  Object.defineProperty(exports, "isEdgeToEdge", {
    enumerable: true,
    get: function () {
      return isEdgeToEdge;
    }
  });
  // src/index.ts
  var isEdgeToEdge = () => true;
  var controlEdgeToEdgeValues = values => {};
},690,[],"node_modules/react-native-is-edge-to-edge/dist/index.mjs");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // Copyright © 2024 650 Industries.
  'use client';

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _reactJsxDevRuntime = require(_dependencyMap[1], "react/jsx-dev-runtime");
  const _excluded = ["style", "leftIcon", "rightIcon", "filename", "level", "info"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\views\\Sitemap.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getNavOptions = getNavOptions;
  exports.Sitemap = Sitemap;
  const expo_constants_1 = __importDefault(require(_dependencyMap[2], "expo-constants"));
  const react_1 = __importDefault(require(_dependencyMap[3], "react"));
  const react_native_1 = require(_dependencyMap[4], "react-native-web/dist/index");
  const react_native_safe_area_context_1 = require(_dependencyMap[5], "react-native-safe-area-context");
  const NoSSR_1 = require(_dependencyMap[6], "./NoSSR");
  const Pressable_1 = require(_dependencyMap[7], "./Pressable");
  const useSitemap_1 = require(_dependencyMap[8], "./useSitemap");
  const Link_1 = require(_dependencyMap[9], "../link/Link");
  const statusbar_1 = require(_dependencyMap[10], "../utils/statusbar");
  const INDENT = 20;
  function getNavOptions() {
    return {
      title: 'sitemap',
      presentation: 'modal',
      headerLargeTitle: false,
      headerTitleStyle: {
        color: 'white'
      },
      headerShown: true,
      headerTintColor: 'white',
      headerLargeTitleStyle: {
        color: 'white'
      },
      headerStyle: {
        backgroundColor: 'black',
        // @ts-expect-error: mistyped
        borderBottomColor: '#323232'
      },
      header: () => {
        const WrapperElement = react_native_1.Platform.OS === 'android' ? react_native_safe_area_context_1.SafeAreaView : react_native_1.View;
        return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(WrapperElement, {
          style: styles.header,
          children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
            style: styles.headerContent,
            children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
              style: styles.headerIcon,
              children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(SitemapIcon, {}, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 43,
                columnNumber: 15
              }, this)
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 42,
              columnNumber: 13
            }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
              role: "heading",
              "aria-level": 1,
              style: styles.title,
              children: "Sitemap"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 45,
              columnNumber: 13
            }, this)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 41,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 40,
          columnNumber: 21
        }, this);
      }
    };
  }
  function Sitemap() {
    // Following the https://github.com/expo/expo/blob/ubax/router/move-404-and-sitemap-to-root/packages/expo-router/src/getRoutesSSR.ts#L38
    // we need to ensure that the Sitemap component is not rendered on the server.
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(NoSSR_1.NoSSR, {
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(SitemapInner, {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 57,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 56,
      columnNumber: 13
    }, this);
  }
  function SitemapInner() {
    const sitemap = (0, useSitemap_1.useSitemap)();
    const children = react_1.default.useMemo(() => sitemap?.children.filter(({
      isInternal
    }) => !isInternal) ?? [], [sitemap]);
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
      style: styles.container,
      testID: "expo-router-sitemap",
      children: [statusbar_1.canOverrideStatusBarBehavior && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.StatusBar, {
        barStyle: "light-content"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 64,
        columnNumber: 52
      }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.ScrollView, {
        contentContainerStyle: styles.scroll,
        automaticallyAdjustContentInsets: true,
        contentInsetAdjustmentBehavior: "automatic",
        children: [children.map(child => /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
          testID: "sitemap-item-container",
          style: styles.itemContainer,
          children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(SitemapItem, {
            node: child
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 67,
            columnNumber: 13
          }, this)
        }, child.contextKey, false, {
          fileName: _jsxFileName,
          lineNumber: 66,
          columnNumber: 35
        }, this)), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(SystemInfo, {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 69,
          columnNumber: 9
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 65,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 63,
      columnNumber: 13
    }, this);
  }
  function SitemapItem({
    node,
    level = 0
  }) {
    const isLayout = react_1.default.useMemo(() => node.children.length > 0 || node.contextKey.match(/_layout\.[jt]sx?$/), [node]);
    const info = node.isInitial ? 'Initial' : node.isGenerated ? 'Generated' : '';
    if (isLayout) {
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(LayoutSitemapItem, {
        node: node,
        level: level,
        info: info
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 77,
        columnNumber: 16
      }, this);
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(StandardSitemapItem, {
      node: node,
      level: level,
      info: info
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 79,
      columnNumber: 12
    }, this);
  }
  function LayoutSitemapItem({
    node,
    level,
    info
  }) {
    const [isCollapsed, setIsCollapsed] = react_1.default.useState(true);
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
      style: styles.itemInnerContainer,
      children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(SitemapItemPressable, {
        style: {
          opacity: 0.4
        },
        leftIcon: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(PkgIcon, {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 84,
          columnNumber: 64
        }, this),
        rightIcon: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(ArrowIcon, {
          rotation: isCollapsed ? 0 : 180
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 84,
          columnNumber: 88
        }, this),
        filename: node.filename,
        level: level,
        info: info,
        onPress: () => setIsCollapsed(prev => !prev)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 84,
        columnNumber: 7
      }, this), !isCollapsed && node.children.map(child => /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(SitemapItem, {
        node: child,
        level: level + (node.isGenerated ? 0 : 1)
      }, child.contextKey, false, {
        fileName: _jsxFileName,
        lineNumber: 86,
        columnNumber: 43
      }, this))]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 83,
      columnNumber: 13
    }, this);
  }
  function StandardSitemapItem({
    node,
    info,
    level
  }) {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Link_1.Link, {
      accessibilityLabel: node.contextKey,
      href: node.href,
      asChild: true,
      replace: true,
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(SitemapItemPressable, {
        leftIcon: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(FileIcon, {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 91,
          columnNumber: 39
        }, this),
        rightIcon: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(ForwardIcon, {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 91,
          columnNumber: 64
        }, this),
        filename: node.filename,
        level: level,
        info: info
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 91,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 90,
      columnNumber: 13
    }, this);
  }
  function SitemapItemPressable(_ref) {
    let {
        style,
        leftIcon,
        rightIcon,
        filename,
        level,
        info
      } = _ref,
      pressableProps = _objectWithoutPropertiesLoose(_ref, _excluded);
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Pressable_1.Pressable, Object.assign({}, pressableProps, {
      children: ({
        pressed,
        hovered
      }) => /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
        testID: "sitemap-item",
        style: [styles.itemInnerContainer, styles.itemPressable, {
          paddingLeft: INDENT + level * INDENT,
          backgroundColor: hovered ? '#202425' : '#151718'
        }, pressed && {
          backgroundColor: '#26292b'
        }, style],
        children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
          style: {
            flexDirection: 'row',
            alignItems: 'center'
          },
          children: [leftIcon, /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
            style: styles.filename,
            children: filename
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 108,
            columnNumber: 13
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 106,
          columnNumber: 11
        }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
          style: {
            flexDirection: 'row',
            alignItems: 'center'
          },
          children: [!!info && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
            style: [styles.virtual, {
              marginRight: 8
            }],
            children: info
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 112,
            columnNumber: 24
          }, this), rightIcon]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 111,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 96,
        columnNumber: 35
      }, this)
    }), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 95,
      columnNumber: 13
    }, this);
  }
  function FileIcon() {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Image, {
      style: styles.image,
      source: require(_dependencyMap[11], "expo-router/assets/file.png")
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 119,
      columnNumber: 12
    }, this);
  }
  function PkgIcon() {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Image, {
      style: styles.image,
      source: require(_dependencyMap[12], "expo-router/assets/pkg.png")
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 122,
      columnNumber: 12
    }, this);
  }
  function ForwardIcon() {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Image, {
      style: styles.image,
      source: require(_dependencyMap[13], "expo-router/assets/forward.png")
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 125,
      columnNumber: 12
    }, this);
  }
  function SitemapIcon() {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Image, {
      style: styles.image,
      source: require(_dependencyMap[14], "expo-router/assets/sitemap.png")
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 128,
      columnNumber: 12
    }, this);
  }
  function ArrowIcon({
    rotation = 0
  }) {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Image, {
      style: [styles.image, {
        transform: [{
          rotate: `${rotation}deg`
        }]
      }],
      source: require(_dependencyMap[15], "expo-router/assets/arrow_down.png")
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 131,
      columnNumber: 13
    }, this);
  }
  function SystemInfo() {
    const getHermesVersion = () => {
      if (!global.HermesInternal) {
        return null;
      }
      const HERMES_RUNTIME = global.HermesInternal?.getRuntimeProperties?.() ?? {};
      const HERMES_VERSION = HERMES_RUNTIME['OSS Release Version'];
      const isStaticHermes = HERMES_RUNTIME['Static Hermes'];
      if (!HERMES_RUNTIME) {
        return null;
      }
      if (isStaticHermes) {
        return `${HERMES_VERSION} (shermes)`;
      }
      return HERMES_VERSION;
    };
    const locationOrigin = window.location.origin;
    const expoSdkVersion = expo_constants_1.default.expoConfig?.sdkVersion || 'Unknown';
    const hermesVersion = getHermesVersion();
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
      testID: "sitemap-system-info",
      style: {
        gap: 8,
        marginTop: 16
      },
      children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        style: styles.systemInfoTitle,
        children: "System Information"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 161,
        columnNumber: 7
      }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
        style: styles.systemInfoContainer,
        children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(FormText, {
          right: process.env.NODE_ENV,
          children: "Mode"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 163,
          columnNumber: 9
        }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(FormText, {
          right: expoSdkVersion,
          children: "Expo SDK"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 164,
          columnNumber: 9
        }, this), hermesVersion && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(FormText, {
          right: hermesVersion,
          children: "Hermes version"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 165,
          columnNumber: 27
        }, this), locationOrigin && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(FormText, {
          right: locationOrigin,
          children: "Location origin"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 166,
          columnNumber: 28
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 162,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 157,
      columnNumber: 13
    }, this);
  }
  function FormText({
    children,
    right
  }) {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
      style: styles.systemInfoItem,
      children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        style: styles.systemInfoLabel,
        numberOfLines: 1,
        ellipsizeMode: "tail",
        children: children
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 172,
        columnNumber: 7
      }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
        style: {
          flex: 1
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 175,
        columnNumber: 7
      }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        selectable: true,
        style: [styles.systemInfoValue, styles.code],
        numberOfLines: 1,
        ellipsizeMode: "tail",
        children: right
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 177,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 171,
      columnNumber: 13
    }, this);
  }
  const styles = react_native_1.StyleSheet.create({
    container: {
      backgroundColor: 'black',
      flex: 1,
      alignItems: 'stretch'
    },
    header: {
      backgroundColor: '#151718',
      paddingVertical: 16,
      borderBottomWidth: 1,
      borderColor: '#313538',
      boxShadow: '0px 3px 3px rgba(0, 0, 0, 0.33)'
    },
    headerContent: Object.assign({
      flexDirection: 'row',
      alignItems: 'center',
      gap: 14,
      paddingHorizontal: '5%'
    }, react_native_1.Platform.select({
      web: {
        width: '100%',
        maxWidth: 960,
        marginHorizontal: 'auto'
      }
    })),
    title: {
      color: 'white',
      fontSize: 28,
      fontWeight: 'bold'
    },
    scroll: Object.assign({
      gap: 12,
      paddingHorizontal: '5%',
      paddingVertical: 16
    }, react_native_1.Platform.select({
      ios: {
        paddingBottom: 24
      },
      web: {
        width: '100%',
        maxWidth: 960,
        marginHorizontal: 'auto',
        paddingBottom: 24
      },
      default: {
        paddingBottom: 12
      }
    })),
    itemContainer: {
      borderWidth: 1,
      borderColor: '#313538',
      backgroundColor: '#151718',
      borderRadius: 12,
      borderCurve: 'continuous'
    },
    itemInnerContainer: {
      backgroundColor: '#151718',
      borderRadius: 12,
      borderCurve: 'continuous',
      gap: 12
    },
    itemPressable: Object.assign({
      paddingHorizontal: INDENT,
      paddingVertical: 16,
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center'
    }, react_native_1.Platform.select({
      web: {
        transitionDuration: '100ms'
      }
    })),
    filename: {
      color: 'white',
      fontSize: 20,
      marginLeft: 12
    },
    virtual: {
      textAlign: 'right',
      color: 'white'
    },
    image: {
      width: 24,
      height: 24,
      resizeMode: 'contain',
      opacity: 0.6
    },
    headerIcon: {
      width: 40,
      height: 40,
      backgroundColor: '#202425',
      borderRadius: 8,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center'
    },
    systemInfoContainer: {
      borderWidth: 1,
      borderColor: '#313538',
      backgroundColor: '#151718',
      borderRadius: 12,
      gap: 8,
      borderCurve: 'continuous',
      padding: INDENT
    },
    systemInfoTitle: {
      color: 'white',
      fontSize: 18,
      fontWeight: '600',
      marginBottom: 12,
      paddingHorizontal: INDENT
    },
    systemInfoItem: {
      flexDirection: 'row',
      gap: 8,
      alignItems: 'center',
      flexWrap: 'wrap'
    },
    systemInfoLabel: {
      color: 'white',
      fontSize: 16,
      lineHeight: 24
    },
    systemInfoValue: {
      color: 'white',
      fontSize: 16,
      opacity: 0.7,
      flexShrink: 1,
      letterSpacing: 0.5
    },
    code: {
      fontVariant: ['tabular-nums'],
      fontFamily: react_native_1.Platform.select({
        default: `SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`,
        ios: 'ui-monospace',
        android: 'monospace'
      }),
      fontWeight: '500'
    }
  });
},691,[759,33,636,9,492,423,692,693,694,651,695,696,697,698,699,700],"node_modules/expo-router/build/views/Sitemap.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NoSSR = NoSSR;
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  function NoSSR({
    children
  }) {
    const [mounted, setMounted] = react_1.default.useState(false);
    react_1.default.useEffect(() => {
      setMounted(true);
    }, []);
    if (!mounted) {
      // If the component is not mounted, return null to prevent server-side rendering.
      return null;
    }
    // This component is used to prevent server-side rendering of its children.
    // It can be useful for components that rely on browser-specific APIs or
    // need to be rendered only on the client side.
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(_reactJsxDevRuntime.Fragment, {
      children: children
    }, void 0, false);
  }
},692,[33,9],"node_modules/expo-router/build/views/NoSSR.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Pressable = void 0;
  const react_native_1 = require(_dependencyMap[0], "react-native-web/dist/index");
  exports.Pressable = react_native_1.Pressable;
},693,[492],"node_modules/expo-router/build/views/Pressable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useSitemap = useSitemap;
  const react_1 = require(_dependencyMap[0], "react");
  const Route_1 = require(_dependencyMap[1], "../Route");
  const router_store_1 = require(_dependencyMap[2], "../global-state/router-store");
  const matchers_1 = require(_dependencyMap[3], "../matchers");
  const routeSegments = (route, parents) => [...parents, ...route.route.split('/')];
  const routeHref = (route, parents) => '/' + routeSegments(route, parents).map(segment => {
    // add an extra layer of entropy to the url for deep dynamic routes
    if ((0, matchers_1.matchDynamicName)(segment)?.deep) {
      return segment + '/' + Date.now();
    }
    // index must be erased but groups can be preserved.
    return segment === 'index' ? '' : segment;
  }).filter(Boolean).join('/');
  const routeFilename = route => {
    const segments = route.contextKey.split('/');
    // join last two segments for layout routes
    if (route.contextKey.match(/_layout\.[jt]sx?$/)) {
      return segments[segments.length - 2] + '/' + segments[segments.length - 1];
    }
    const routeSegmentsCount = route.route.split('/').length;
    // Join the segment count in reverse order
    // This presents files without layout routes as children with all relevant segments.
    return segments.slice(-routeSegmentsCount).join('/');
  };
  const mapForRoute = (route, parents) => ({
    contextKey: route.contextKey,
    filename: routeFilename(route),
    href: routeHref(route, parents),
    isInitial: route.initialRouteName === route.route,
    isInternal: route.internal ?? false,
    isGenerated: route.generated ?? false,
    children: [...route.children].sort(Route_1.sortRoutes).map(child => mapForRoute(child, routeSegments(route, parents)))
  });
  function useSitemap() {
    const sitemap = (0, react_1.useMemo)(() => router_store_1.store.routeNode ? mapForRoute(router_store_1.store.routeNode, []) : null, [router_store_1.store.routeNode]);
    return sitemap;
  }
},694,[9,379,671,380],"node_modules/expo-router/build/views/useSitemap.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.canOverrideStatusBarBehavior = void 0;
  const expo_constants_1 = __importDefault(require(_dependencyMap[0], "expo-constants"));
  const react_native_1 = require(_dependencyMap[1], "react-native-web/dist/index");
  const react_native_is_edge_to_edge_1 = require(_dependencyMap[2], "react-native-is-edge-to-edge");
  const hasViewControllerBasedStatusBarAppearance = react_native_1.Platform.OS === 'ios' && !!expo_constants_1.default.expoConfig?.ios?.infoPlist?.UIViewControllerBasedStatusBarAppearance;
  exports.canOverrideStatusBarBehavior = !(0, react_native_is_edge_to_edge_1.isEdgeToEdge)() && !hasViewControllerBasedStatusBarAppearance;
},695,[636,492,690],"node_modules/expo-router/build/utils/statusbar.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/file.png",
    width: 48,
    height: 48
  };
},696,[],"node_modules/expo-router/assets/file.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/pkg.png",
    width: 48,
    height: 48
  };
},697,[],"node_modules/expo-router/assets/pkg.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/forward.png",
    width: 48,
    height: 48
  };
},698,[],"node_modules/expo-router/assets/forward.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/sitemap.png",
    width: 48,
    height: 48
  };
},699,[],"node_modules/expo-router/assets/sitemap.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/arrow_down.png",
    width: 48,
    height: 48
  };
},700,[],"node_modules/expo-router/assets/arrow_down.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // Copyright © 2024 650 Industries.
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\views\\Unmatched.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Unmatched = Unmatched;
  const native_1 = require(_dependencyMap[1], "@react-navigation/native");
  const expo_linking_1 = require(_dependencyMap[2], "expo-linking");
  const react_1 = __importDefault(require(_dependencyMap[3], "react"));
  const react_native_1 = require(_dependencyMap[4], "react-native-web/dist/index");
  const hooks_1 = require(_dependencyMap[5], "../hooks");
  const NoSSR_1 = require(_dependencyMap[6], "./NoSSR");
  const Link_1 = require(_dependencyMap[7], "../link/Link");
  const useNavigation_1 = require(_dependencyMap[8], "../useNavigation");
  const useSafeLayoutEffect_1 = require(_dependencyMap[9], "./useSafeLayoutEffect");
  const stack_1 = require(_dependencyMap[10], "../utils/stack");
  const Pressable_1 = require(_dependencyMap[11], "../views/Pressable");
  /**
   * Default screen for unmatched routes.
   *
   * @hidden
   */
  function Unmatched() {
    // Following the https://github.com/expo/expo/blob/ubax/router/move-404-and-sitemap-to-root/packages/expo-router/src/getRoutesSSR.ts#L51
    // we need to ensure that the Unmatched component is not rendered on the server.
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(NoSSR_1.NoSSR, {
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(UnmatchedInner, {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 29,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 13
    }, this);
  }
  function UnmatchedInner() {
    const [render, setRender] = react_1.default.useState(false);
    const router = (0, hooks_1.useRouter)();
    const route = (0, native_1.useRoute)();
    const navigation = (0, useNavigation_1.useNavigation)();
    const pathname = (0, hooks_1.usePathname)();
    const url = (0, expo_linking_1.createURL)(pathname);
    react_1.default.useEffect(() => {
      setRender(true);
    }, []);
    const isFocused = navigation.isFocused();
    const isPreloaded = (0, stack_1.isRoutePreloadedInStack)(navigation.getState(), route);
    /** This route may be prefetched if a <Link prefetch href="/<unmatched>" /> is used */
    (0, useSafeLayoutEffect_1.useSafeLayoutEffect)(() => {
      if (!isPreloaded || isPreloaded && isFocused) {
        navigation.setOptions({
          title: 'Not Found'
        });
      }
    }, [isFocused, isPreloaded, navigation]);
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
      testID: "expo-router-unmatched",
      style: styles.container,
      children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(NotFoundAsset, {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 53,
        columnNumber: 7
      }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        role: "heading",
        "aria-level": 1,
        style: styles.title,
        children: "Unmatched Route"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 54,
        columnNumber: 7
      }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        role: "heading",
        "aria-level": 2,
        style: [styles.subtitle, styles.secondaryText],
        children: "Page could not be found."
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 57,
        columnNumber: 7
      }, this), render ? /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Link_1.Link, Object.assign({
        href: pathname,
        replace: true
      }, react_native_1.Platform.select({
        native: {
          asChild: true
        }
      }), {
        children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Pressable_1.Pressable, {
          children: ({
            hovered,
            pressed
          }) => /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
            style: [styles.pageLink, styles.secondaryText, react_native_1.Platform.select({
              web: {
                transitionDuration: '200ms',
                opacity: 1
              }
            }), hovered && {
              opacity: 0.8,
              textDecorationLine: 'underline'
            }, pressed && {
              opacity: 0.8
            }],
            children: url
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 62,
            columnNumber: 41
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 61,
          columnNumber: 11
        }, this)
      }), void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 60,
        columnNumber: 18
      }, this) : /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
        style: [styles.pageLink, styles.placeholder]
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 82,
        columnNumber: 28
      }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
        style: styles.linkContainer,
        children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Pressable_1.Pressable, {
          children: ({
            hovered,
            pressed
          }) => /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
            onPress: () => {
              if (router.canGoBack()) {
                router.back();
              } else {
                router.replace('/');
              }
            },
            style: [styles.link, react_native_1.Platform.select({
              web: {
                transitionDuration: '200ms',
                opacity: 1
              }
            }), hovered && {
              opacity: 0.8,
              textDecorationLine: 'underline'
            }, pressed && {
              opacity: 0.8
            }],
            children: "Go back"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 85,
            columnNumber: 39
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 84,
          columnNumber: 9
        }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
          style: [styles.linkSeparator, styles.secondaryText],
          children: "\u2022"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 111,
          columnNumber: 9
        }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Link_1.Link, Object.assign({
          href: "/_sitemap",
          replace: true
        }, react_native_1.Platform.select({
          native: {
            asChild: true
          }
        }), {
          children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Pressable_1.Pressable, {
            children: ({
              hovered,
              pressed
            }) => /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
              style: [styles.link, react_native_1.Platform.select({
                web: {
                  transitionDuration: '200ms',
                  opacity: 1
                }
              }), hovered && {
                opacity: 0.8,
                textDecorationLine: 'underline'
              }, pressed && {
                opacity: 0.8
              }],
              children: "Sitemap"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 114,
              columnNumber: 41
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 113,
            columnNumber: 11
          }, this)
        }), void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 112,
          columnNumber: 9
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 83,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 52,
      columnNumber: 13
    }, this);
  }
  function NotFoundAsset() {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Image, {
      source: require(_dependencyMap[12], "expo-router/assets/unmatched.png"),
      style: styles.image
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 138,
      columnNumber: 12
    }, this);
  }
  const styles = react_native_1.StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: 'black',
      padding: 24,
      paddingBottom: 64,
      alignItems: 'center',
      justifyContent: 'center'
    },
    image: {
      width: 270,
      height: 168,
      resizeMode: 'contain',
      marginBottom: 28
    },
    title: Object.assign({}, react_native_1.Platform.select({
      web: {
        fontSize: 64,
        lineHeight: 64
      },
      default: {
        fontSize: 56,
        lineHeight: 56
      }
    }), {
      color: '#fff',
      fontWeight: '800',
      textAlign: 'center'
    }),
    subtitle: {
      fontSize: 34,
      marginTop: 4,
      marginBottom: 12,
      fontWeight: '200',
      textAlign: 'center'
    },
    pageLink: {
      minHeight: 20
    },
    secondaryText: {
      color: '#9ba1a6'
    },
    placeholder: {
      backgroundColor: '#9ba1a644',
      minWidth: 180,
      borderRadius: 5
    },
    linkContainer: {
      marginTop: 28,
      flexDirection: 'row',
      gap: 12
    },
    link: {
      fontSize: 20,
      textAlign: 'center',
      color: '#52a9ff'
    },
    linkSeparator: {
      fontSize: 20
    }
  });
},701,[33,253,664,9,492,678,692,651,634,386,641,693,702],"node_modules/expo-router/build/views/Unmatched.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/unmatched.png",
    width: 436,
    height: 266
  };
},702,[],"node_modules/expo-router/assets/unmatched.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.defaultRouteInfo = void 0;
  exports.getRouteInfoFromState = getRouteInfoFromState;
  const constants_1 = require(_dependencyMap[0], "../constants");
  const getPathFromState_forks_1 = require(_dependencyMap[1], "../fork/getPathFromState-forks");
  exports.defaultRouteInfo = {
    unstable_globalHref: '',
    searchParams: new URLSearchParams(),
    pathname: '/',
    params: {},
    segments: [],
    pathnameWithParams: '/',
    // TODO: Remove this, it is not used anywhere
    isIndex: false
  };
  function getRouteInfoFromState(state) {
    if (!state) return exports.defaultRouteInfo;
    const index = 'index' in state ? state.index ?? 0 : 0;
    let route = state.routes[index];
    if (route.name === constants_1.NOT_FOUND_ROUTE_NAME || route.name === constants_1.SITEMAP_ROUTE_NAME) {
      const path = route.path || (route.name === constants_1.NOT_FOUND_ROUTE_NAME ? '/' : `/${route.name}`);
      return Object.assign({}, exports.defaultRouteInfo, {
        unstable_globalHref: (0, getPathFromState_forks_1.appendBaseUrl)(path),
        pathname: path,
        pathnameWithParams: path,
        segments: [route.name]
      });
    }
    if (route.name !== constants_1.INTERNAL_SLOT_NAME) {
      throw new Error(`Expected the first route to be ${constants_1.INTERNAL_SLOT_NAME}, but got ${route.name}`);
    }
    state = route.state;
    const segments = [];
    let params = Object.create(null);
    while (state) {
      route = state.routes['index' in state && state.index ? state.index : 0];
      Object.assign(params, route.params);
      let routeName = route.name;
      if (routeName.startsWith('/')) {
        routeName = routeName.slice(1);
      }
      segments.push(...routeName.split('/'));
      state = route.state;
    }
    params = Object.fromEntries(Object.entries(params).map(([key, value]) => {
      if (typeof value === 'string') {
        return [key, safeDecodeURIComponent(value)];
      } else if (Array.isArray(value)) {
        return [key, value.map(v => safeDecodeURIComponent(v))];
      } else {
        return [key, value];
      }
    }));
    /**
     * If React Navigation didn't render the entire tree (e.g it was interrupted in a layout)
     * then the state maybe incomplete. The reset of the path is in the params, instead of being a route
     */
    let routeParams = route.params;
    while (routeParams && 'screen' in routeParams) {
      if (typeof routeParams.screen === 'string') {
        const screen = routeParams.screen.startsWith('/') ? routeParams.screen.slice(1) : routeParams.screen;
        segments.push(...screen.split('/'));
      }
      if (typeof routeParams.params === 'object' && !Array.isArray(routeParams.params)) {
        routeParams = routeParams.params;
      } else {
        routeParams = undefined;
      }
    }
    if (route.params && 'screen' in route.params && route.params.screen === 'string') {
      const screen = route.params.screen.startsWith('/') ? route.params.screen.slice(1) : route.params.screen;
      segments.push(...screen.split('/'));
    }
    if (segments[segments.length - 1] === 'index') {
      segments.pop();
    }
    delete params['screen'];
    delete params['params'];
    const pathParams = new Set();
    const pathname = '/' + segments.filter(segment => {
      return !(segment.startsWith('(') && segment.endsWith(')'));
    }).flatMap(segment => {
      if (segment === '+not-found') {
        const notFoundPath = params['not-found'];
        pathParams.add('not-found');
        if (typeof notFoundPath === 'undefined') {
          // Not founds are optional, do nothing if its not present
          return [];
        } else if (Array.isArray(notFoundPath)) {
          return notFoundPath;
        } else {
          return [notFoundPath];
        }
      } else if (segment.startsWith('[...') && segment.endsWith(']')) {
        let paramName = segment.slice(4, -1);
        // Legacy for React Navigation optional params
        if (paramName.endsWith('?')) {
          paramName = paramName.slice(0, -1);
        }
        const values = params[paramName];
        pathParams.add(paramName);
        // Catchall params are optional
        return values || [];
      } else if (segment.startsWith('[') && segment.endsWith(']')) {
        const paramName = segment.slice(1, -1);
        const value = params[paramName];
        pathParams.add(paramName);
        // Optional params are optional
        return value ? [value] : [];
      } else {
        return [segment];
      }
    }).join('/');
    const searchParams = new URLSearchParams(Object.entries(params).flatMap(([key, value]) => {
      // Search params should not include path params
      if (pathParams.has(key)) {
        return [];
      } else if (Array.isArray(value)) {
        return value.map(v => [key, v]);
      }
      return [[key, value]];
    }));
    let hash;
    if (searchParams.has('#')) {
      hash = searchParams.get('#') || undefined;
      searchParams.delete('#');
    }
    // We cannot use searchParams.size because it is not included in the React Native polyfill
    const searchParamString = searchParams.toString();
    let pathnameWithParams = searchParamString ? pathname + '?' + searchParamString : pathname;
    pathnameWithParams = hash ? pathnameWithParams + '#' + hash : pathnameWithParams;
    return {
      segments,
      pathname,
      params,
      unstable_globalHref: (0, getPathFromState_forks_1.appendBaseUrl)(pathnameWithParams),
      searchParams,
      pathnameWithParams,
      // TODO: Remove this, it is not used anywhere
      isIndex: false
    };
  }
  function safeDecodeURIComponent(value) {
    try {
      return typeof value === 'string' ? decodeURIComponent(value) : value;
    } catch {
      // If the value is not a valid URI component, return it as is
      return value;
    }
  }
},703,[639,658],"node_modules/expo-router/build/global-state/routeInfo.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Prefetch = Prefetch;
  const react_1 = require(_dependencyMap[0], "react");
  const imperative_api_1 = require(_dependencyMap[1], "./imperative-api");
  const useLoadedNavigation_1 = require(_dependencyMap[2], "./link/useLoadedNavigation");
  /**
   * When rendered on a focused screen, this component will preload the specified route.
   */
  function Prefetch(props) {
    const navigation = (0, useLoadedNavigation_1.useOptionalNavigation)();
    (0, react_1.useLayoutEffect)(() => {
      if (navigation?.isFocused()) {
        imperative_api_1.router.prefetch(props.href);
      }
    }, [navigation, props.href]);
    return null;
  }
},704,[9,679,705],"node_modules/expo-router/build/Prefetch.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useLoadedNavigation = useLoadedNavigation;
  exports.useOptionalNavigation = useOptionalNavigation;
  const native_1 = require(_dependencyMap[0], "@react-navigation/native");
  const react_1 = require(_dependencyMap[1], "react");
  const router_store_1 = require(_dependencyMap[2], "../global-state/router-store");
  /** Returns a callback which is invoked when the navigation state has loaded. */
  function useLoadedNavigation() {
    const navigation = (0, native_1.useNavigation)();
    const isMounted = (0, react_1.useRef)(true);
    const pending = (0, react_1.useRef)([]);
    (0, react_1.useEffect)(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    const flush = (0, react_1.useCallback)(() => {
      if (isMounted.current) {
        const pendingCallbacks = pending.current;
        pending.current = [];
        pendingCallbacks.forEach(callback => {
          callback(navigation);
        });
      }
    }, [navigation]);
    (0, react_1.useEffect)(() => {
      if (router_store_1.store.navigationRef.current) {
        flush();
      }
    }, [flush]);
    const push = (0, react_1.useCallback)(fn => {
      pending.current.push(fn);
      if (router_store_1.store.navigationRef.current) {
        flush();
      }
    }, [flush]);
    return push;
  }
  function useOptionalNavigation() {
    const [navigation, setNavigation] = (0, react_1.useState)(null);
    const loadNavigation = useLoadedNavigation();
    (0, react_1.useEffect)(() => {
      loadNavigation(nav => setNavigation(nav));
    }, []);
    return navigation;
  }
},705,[253,9,671],"node_modules/expo-router/build/link/useLoadedNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["style"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\ui\\Slot.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Slot = void 0;
  const react_slot_1 = require(_dependencyMap[2], "@radix-ui/react-slot");
  const react_1 = require(_dependencyMap[3], "react");
  const react_native_1 = require(_dependencyMap[4], "react-native-web/dist/index");
  /**
   * RadixUI has special logic to handle the merging of `style` and `className` props.
   * On the web styles are not allowed so Radix does not handle this scenario.
   * This could be fixed upstream (PR open), but it may not as RN is not their target
   * platform.
   *
   * This shim calls `StyleSheet.flatten` on the styles before we render the <Slot />
   *
   * @see https://github.com/expo/expo/issues/31352
   * @see https://github.com/radix-ui/primitives/issues/3107
   * @param Component
   * @returns
   */
  function ShimSlotForReactNative(Component) {
    return (0, react_1.forwardRef)(function RNSlotHOC(_ref, ref) {
      let {
          style
        } = _ref,
        props = _objectWithoutPropertiesLoose(_ref, _excluded);
      style = (0, react_1.useMemo)(() => react_native_1.StyleSheet.flatten(style), [style]);
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Component, Object.assign({
        ref: ref
      }, props, {
        style: style
      }), void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 23,
        columnNumber: 16
      }, this);
    });
  }
  exports.Slot = ShimSlotForReactNative(react_slot_1.Slot);
},706,[33,759,707,9,492],"node_modules/expo-router/build/ui/Slot.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["children"],
    _excluded2 = ["children"];
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
        get: () => from[key],
        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
      });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod));
  var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
    value: true
  }), mod);

  // packages/react/slot/src/index.ts
  var index_exports = {};
  __export(index_exports, {
    Root: () => Slot,
    Slot: () => Slot,
    Slottable: () => Slottable,
    createSlot: () => createSlot,
    createSlottable: () => createSlottable
  });
  module.exports = __toCommonJS(index_exports);

  // packages/react/slot/src/slot.tsx
  var React = __toESM(require(_dependencyMap[1], "react"));
  var import_react_compose_refs = require(_dependencyMap[2], "@radix-ui/react-compose-refs");
  var import_jsx_runtime = require(_dependencyMap[3], "react/jsx-runtime");
  // @__NO_SIDE_EFFECTS__
  function createSlot(ownerName) {
    const SlotClone = /* @__PURE__ */createSlotClone(ownerName);
    const Slot2 = React.forwardRef((props, forwardedRef) => {
      const {
          children
        } = props,
        slotProps = _objectWithoutPropertiesLoose(props, _excluded);
      const childrenArray = React.Children.toArray(children);
      const slottable = childrenArray.find(isSlottable);
      if (slottable) {
        const newElement = slottable.props.children;
        const newChildren = childrenArray.map(child => {
          if (child === slottable) {
            if (React.Children.count(newElement) > 1) return React.Children.only(null);
            return React.isValidElement(newElement) ? newElement.props.children : null;
          } else {
            return child;
          }
        });
        return /* @__PURE__ */(0, import_jsx_runtime.jsx)(SlotClone, Object.assign({}, slotProps, {
          ref: forwardedRef,
          children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null
        }));
      }
      return /* @__PURE__ */(0, import_jsx_runtime.jsx)(SlotClone, Object.assign({}, slotProps, {
        ref: forwardedRef,
        children
      }));
    });
    Slot2.displayName = `${ownerName}.Slot`;
    return Slot2;
  }
  var Slot = /* @__PURE__ */createSlot("Slot");
  // @__NO_SIDE_EFFECTS__
  function createSlotClone(ownerName) {
    const SlotClone = React.forwardRef((props, forwardedRef) => {
      const {
          children
        } = props,
        slotProps = _objectWithoutPropertiesLoose(props, _excluded2);
      if (React.isValidElement(children)) {
        const childrenRef = getElementRef(children);
        const props2 = mergeProps(slotProps, children.props);
        if (children.type !== React.Fragment) {
          props2.ref = forwardedRef ? (0, import_react_compose_refs.composeRefs)(forwardedRef, childrenRef) : childrenRef;
        }
        return React.cloneElement(children, props2);
      }
      return React.Children.count(children) > 1 ? React.Children.only(null) : null;
    });
    SlotClone.displayName = `${ownerName}.SlotClone`;
    return SlotClone;
  }
  var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
  // @__NO_SIDE_EFFECTS__
  function createSlottable(ownerName) {
    const Slottable2 = ({
      children
    }) => {
      return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
        children
      });
    };
    Slottable2.displayName = `${ownerName}.Slottable`;
    Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
    return Slottable2;
  }
  var Slottable = /* @__PURE__ */createSlottable("Slottable");
  function isSlottable(child) {
    return React.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
  }
  function mergeProps(slotProps, childProps) {
    const overrideProps = Object.assign({}, childProps);
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue) {
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        } else if (slotPropValue) {
          overrideProps[propName] = slotPropValue;
        }
      } else if (propName === "style") {
        overrideProps[propName] = Object.assign({}, slotPropValue, childPropValue);
      } else if (propName === "className") {
        overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
      }
    }
    return Object.assign({}, slotProps, overrideProps);
  }
  function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }
},707,[759,9,708,274],"node_modules/@radix-ui/react-slot/dist/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
        get: () => from[key],
        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
      });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod));
  var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
    value: true
  }), mod);

  // packages/react/compose-refs/src/index.ts
  var index_exports = {};
  __export(index_exports, {
    composeRefs: () => composeRefs,
    useComposedRefs: () => useComposedRefs
  });
  module.exports = __toCommonJS(index_exports);

  // packages/react/compose-refs/src/compose-refs.tsx
  var React = __toESM(require(_dependencyMap[0], "react"));
  function setRef(ref, value) {
    if (typeof ref === "function") {
      return ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs(...refs) {
    return node => {
      let hasCleanup = false;
      const cleanups = refs.map(ref => {
        const cleanup = setRef(ref, node);
        if (!hasCleanup && typeof cleanup == "function") {
          hasCleanup = true;
        }
        return cleanup;
      });
      if (hasCleanup) {
        return () => {
          for (let i = 0; i < cleanups.length; i++) {
            const cleanup = cleanups[i];
            if (typeof cleanup == "function") {
              cleanup();
            } else {
              setRef(refs[i], null);
            }
          }
        };
      }
    };
  }
  function useComposedRefs(...refs) {
    return React.useCallback(composeRefs(...refs), refs);
  }
},708,[9],"node_modules/@radix-ui/react-compose-refs/dist/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["children"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\link\\LinkWithPreview.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LinkWithPreview = LinkWithPreview;
  const react_1 = __importStar(require(_dependencyMap[2], "react"));
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const hooks_1 = require(_dependencyMap[4], "../hooks");
  const BaseExpoRouterLink_1 = require(_dependencyMap[5], "./BaseExpoRouterLink");
  const InternalLinkPreviewContext_1 = require(_dependencyMap[6], "./InternalLinkPreviewContext");
  const elements_1 = require(_dependencyMap[7], "./elements");
  const LinkPreviewContext_1 = require(_dependencyMap[8], "./preview/LinkPreviewContext");
  const native_1 = require(_dependencyMap[9], "./preview/native");
  const useNextScreenId_1 = require(_dependencyMap[10], "./preview/useNextScreenId");
  const url_1 = require(_dependencyMap[11], "../utils/url");
  const isPad = react_native_1.Platform.OS === 'ios' && react_native_1.Platform.isPad;
  function LinkWithPreview(_ref) {
    let {
        children
      } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);
    const router = (0, hooks_1.useRouter)();
    const {
      setOpenPreviewKey
    } = (0, LinkPreviewContext_1.useLinkPreviewContext)();
    const [isCurrentPreviewOpen, setIsCurrenPreviewOpen] = (0, react_1.useState)(false);
    const hrefWithoutQuery = String(rest.href).split('?')[0];
    const prevHrefWithoutQuery = (0, react_1.useRef)(hrefWithoutQuery);
    (0, react_1.useEffect)(() => {
      if (isCurrentPreviewOpen) {
        if (prevHrefWithoutQuery.current !== hrefWithoutQuery) {
          throw new Error('Link does not support changing the href prop after the preview has been opened. Please ensure that the href prop is stable and does not change between renders.');
        }
      } else {
        prevHrefWithoutQuery.current = hrefWithoutQuery;
      }
    }, [hrefWithoutQuery]);
    const [{
      nextScreenId,
      tabPath
    }, prefetch] = (0, useNextScreenId_1.useNextScreenId)();
    (0, react_1.useEffect)(() => {
      if (rest.replace) {
        if (process.env.NODE_ENV !== 'production') {
          throw new Error('Using replace links with preview is not supported');
        } else {
          console.warn('Using replace links with preview is not supported');
        }
      }
    }, [rest.href, rest.replace]);
    const triggerElement = react_1.default.useMemo(() => getFirstChildOfType(children, elements_1.LinkTrigger), [children]);
    const menuElement = react_1.default.useMemo(() => getFirstChildOfType(children, elements_1.LinkMenu), [children]);
    const previewElement = react_1.default.useMemo(() => getFirstChildOfType(children, elements_1.LinkPreview), [children]);
    if ((previewElement || menuElement) && !triggerElement) {
      if (process.env.NODE_ENV !== 'production') {
        throw new Error('When you use Link.Preview, you must use Link.Trigger to specify the trigger element.');
      } else {
        console.warn('When you use Link.Preview, you must use Link.Trigger to specify the trigger element.');
      }
    }
    const trigger = react_1.default.useMemo(() => triggerElement ?? /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(elements_1.LinkTrigger, {
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 87,
      columnNumber: 69
    }, this), [triggerElement, children]);
    const preview = react_1.default.useMemo(() => (0, url_1.shouldLinkExternally)(String(rest.href)) || !previewElement ? null : previewElement, [previewElement, rest.href]);
    const isPreviewTapped = (0, react_1.useRef)(false);
    const tabPathValue = (0, react_1.useMemo)(() => ({
      path: tabPath
    }), [tabPath]);
    const hasPreview = !!previewElement;
    if (rest.replace) {
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(BaseExpoRouterLink_1.BaseExpoRouterLink, Object.assign({
        children: children
      }, rest), void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 95,
        columnNumber: 16
      }, this);
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(native_1.NativeLinkPreview, {
      nextScreenId: isPad ? undefined : nextScreenId,
      tabPath: isPad ? undefined : tabPathValue,
      onWillPreviewOpen: () => {
        if (hasPreview) {
          isPreviewTapped.current = false;
          prefetch(rest.href);
          setIsCurrenPreviewOpen(true);
        }
      },
      onPreviewWillClose: () => {
        if (hasPreview) {
          setIsCurrenPreviewOpen(false);
          // When preview was not tapped, then we need to enable the screen stack animation
          // Otherwise this will happen in StackNavigator, when new screen is opened
          if (!isPreviewTapped.current || isPad) {
            setOpenPreviewKey(undefined);
          }
        }
      },
      onPreviewDidClose: () => {
        if (hasPreview && isPreviewTapped.current && isPad) {
          router.navigate(rest.href, {
            __internal__PreviewKey: nextScreenId
          });
        }
      },
      onPreviewTapped: () => {
        isPreviewTapped.current = true;
        if (!isPad) {
          router.navigate(rest.href, {
            __internal__PreviewKey: nextScreenId
          });
        }
      },
      style: {
        display: 'contents'
      },
      disableForceFlatten: true,
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(InternalLinkPreviewContext_1.InternalLinkPreviewContext, {
        value: {
          isVisible: isCurrentPreviewOpen,
          href: rest.href
        },
        children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(BaseExpoRouterLink_1.BaseExpoRouterLink, Object.assign({}, rest, {
          children: trigger,
          ref: rest.ref
        }), void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 123,
          columnNumber: 9
        }, this), preview, menuElement]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 122,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 97,
      columnNumber: 13
    }, this);
  }
  function getFirstChildOfType(children, type) {
    return react_1.default.Children.toArray(children).find(child => (0, react_1.isValidElement)(child) && child.type === type);
  }
},709,[33,759,9,492,678,653,710,711,647,713,714,677],"node_modules/expo-router/build/link/LinkWithPreview.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.InternalLinkPreviewContext = void 0;
  const react_1 = require(_dependencyMap[0], "react");
  exports.InternalLinkPreviewContext = (0, react_1.createContext)(undefined);
},710,[9],"node_modules/expo-router/build/link/InternalLinkPreviewContext.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["unstable_keepPresented", "onPress"],
    _excluded2 = ["width", "height"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\link\\elements.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LinkMenu = void 0;
  exports.LinkMenuAction = LinkMenuAction;
  exports.LinkPreview = LinkPreview;
  exports.LinkTrigger = LinkTrigger;
  const react_1 = __importStar(require(_dependencyMap[2], "react"));
  const InternalLinkPreviewContext_1 = require(_dependencyMap[3], "./InternalLinkPreviewContext");
  const HrefPreview_1 = require(_dependencyMap[4], "./preview/HrefPreview");
  const PreviewRouteContext_1 = require(_dependencyMap[5], "./preview/PreviewRouteContext");
  const native_1 = require(_dependencyMap[6], "./preview/native");
  const Slot_1 = require(_dependencyMap[7], "../ui/Slot");
  /**
   * This component renders a context menu action for a link.
   * It should only be used as a child of `Link.Menu` or `LinkMenu`.
   *
   * > **Note**: You can use the alias `Link.MenuAction` for this component.
   *
   * @platform ios
   */
  function LinkMenuAction(props) {
    if ((0, PreviewRouteContext_1.useIsPreview)() || true || !(0, react_1.use)(InternalLinkPreviewContext_1.InternalLinkPreviewContext)) {
      return null;
    }
    const {
        unstable_keepPresented,
        onPress
      } = props,
      rest = _objectWithoutPropertiesLoose(props, _excluded);
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(native_1.NativeLinkPreviewAction, Object.assign({}, rest, {
      onSelected: onPress,
      keepPresented: unstable_keepPresented
    }), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 60,
      columnNumber: 13
    }, this);
  }
  /**
   * Groups context menu actions for a link.
   *
   * If multiple `Link.Menu` components are used within a single `Link`, only the first will be rendered.
   * Only `Link.MenuAction` and `LinkMenuAction` components are allowed as children.
   *
   * @example
   * ```tsx
   * <Link.Menu>
   *   <Link.MenuAction title="Action 1" onPress={() => {}} />
   *   <Link.MenuAction title="Action 2" onPress={() => {}} />
   * </Link.Menu>
   * ```
   *
   * > **Note**: You can use the alias `Link.Menu` for this component.
   *
   * @platform ios
   */
  const LinkMenu = props => {
    if ((0, PreviewRouteContext_1.useIsPreview)() || true || !(0, react_1.use)(InternalLinkPreviewContext_1.InternalLinkPreviewContext)) {
      return null;
    }
    const children = react_1.default.Children.toArray(props.children).filter(child => (0, react_1.isValidElement)(child) && (child.type === LinkMenuAction || child.type === exports.LinkMenu));
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(native_1.NativeLinkPreviewAction, Object.assign({}, props, {
      title: props.title ?? '',
      onSelected: () => {},
      children: children
    }), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 85,
      columnNumber: 13
    }, this);
  };
  exports.LinkMenu = LinkMenu;
  /**
   * A component used to render and customize the link preview.
   *
   * If `Link.Preview` is used without any props, it will render a preview of the `href` passed to the `Link`.
   *
   * If multiple `Link.Preview` components are used within a single `Link`, only the first one will be rendered.
   *
   * To customize the preview, you can pass custom content as children.
   *
   * @example
   * ```tsx
   * <Link href="/about">
   *   <Link.Preview>
   *     <Text>Custom Preview Content</Text>
   *   </Link.Preview>
   * </Link>
   * ```
   *
   * @example
   * ```tsx
   * <Link href="/about">
   *   <Link.Preview />
   * </Link>
   * ```
   *
   * > **Note**: You can use the alias `Link.Preview` for this component.
   *
   * @platform ios
   */
  function LinkPreview(props) {
    const {
      children,
      style
    } = props;
    const internalPreviewContext = (0, react_1.use)(InternalLinkPreviewContext_1.InternalLinkPreviewContext);
    if ((0, PreviewRouteContext_1.useIsPreview)() || true || !internalPreviewContext) {
      return null;
    }
    const {
      isVisible,
      href
    } = internalPreviewContext;
    const _ref = style ?? {},
      {
        width,
        height
      } = _ref,
      restOfStyle = _objectWithoutPropertiesLoose(_ref, _excluded2);
    const contentSize = {
      width: width ?? 0,
      height: height ?? 0
    };
    let content;
    if (children) {
      content = isVisible ? children : null;
    } else {
      content = isVisible ? /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(HrefPreview_1.HrefPreview, {
        href: href
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 134,
        columnNumber: 31
      }, this) : null;
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(native_1.NativeLinkPreviewContent, {
      style: restOfStyle,
      preferredContentSize: contentSize,
      children: content
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 136,
      columnNumber: 13
    }, this);
  }
  /**
   * Serves as the trigger for a link.
   * The content inside this component will be rendered as part of the base link.
   *
   * If multiple `Link.Trigger` components are used within a single `Link`, only the first will be rendered.
   *
   * @example
   * ```tsx
   * <Link href="/about">
   *   <Link.Trigger>
   *     Trigger
   *   </Link.Trigger>
   * </Link>
   * ```
   *
   * > **Note**: You can use the alias `Link.Trigger` for this component.
   *
   * @platform ios
   */
  function LinkTrigger(props) {
    if (react_1.default.Children.count(props.children) > 1 || !(0, react_1.isValidElement)(props.children)) {
      // If onPress is passed, this means that Link passed props to this component.
      // We can assume that asChild is used, so we throw an error, because link will not work in this case.
      if (props && typeof props === 'object' && 'onPress' in props) {
        throw new Error('When using Link.Trigger in an asChild Link, you must pass a single child element that will emit onPress event.');
      }
      return props.children;
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Slot_1.Slot, Object.assign({}, props), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 168,
      columnNumber: 12
    }, this);
  }
},711,[33,759,9,710,712,385,713,706],"node_modules/expo-router/build/link/elements.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\link\\preview\\HrefPreview.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.HrefPreview = HrefPreview;
  const native_1 = require(_dependencyMap[1], "@react-navigation/native");
  const react_1 = require(_dependencyMap[2], "react");
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const PreviewRouteContext_1 = require(_dependencyMap[4], "./PreviewRouteContext");
  const constants_1 = require(_dependencyMap[5], "../../constants");
  const router_store_1 = require(_dependencyMap[6], "../../global-state/router-store");
  const utils_1 = require(_dependencyMap[7], "../../global-state/utils");
  const hooks_1 = require(_dependencyMap[8], "../../hooks");
  const useNavigation_1 = require(_dependencyMap[9], "../../useNavigation");
  const useScreens_1 = require(_dependencyMap[10], "../../useScreens");
  const linking_1 = require(_dependencyMap[11], "../linking");
  function HrefPreview({
    href
  }) {
    const hrefState = (0, react_1.useMemo)(() => getHrefState(href), [href]);
    const index = hrefState?.index ?? 0;
    let isProtected = false;
    if (hrefState?.routes[index]?.name === constants_1.INTERNAL_SLOT_NAME) {
      let routerState = hrefState;
      let rnState = router_store_1.store.state;
      while (routerState && rnState) {
        const routerRoute = routerState.routes[0];
        // When the route we want to show is not present in react-navigation state
        // Then most likely it is a protected route
        if (rnState.stale === false && !rnState.routeNames?.includes(routerRoute.name)) {
          isProtected = true;
          break;
        }
        const rnIndex = rnState.routes.findIndex(route => route.name === routerRoute.name);
        if (rnIndex === -1) {
          break;
        }
        routerState = routerRoute.state;
        rnState = rnState.routes[rnIndex]?.state;
      }
      if (!isProtected) {
        return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(PreviewForRootHrefState, {
          hrefState: hrefState,
          href: href
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 39,
          columnNumber: 20
        }, this);
      }
    }
    const pathname = href.toString();
    const segments = pathname.split('/').filter(Boolean);
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(PreviewRouteContext_1.PreviewRouteContext.Provider, {
      value: {
        params: {},
        pathname,
        segments
      },
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(PreviewForInternalRoutes, {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 49,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 44,
      columnNumber: 13
    }, this);
  }
  function PreviewForRootHrefState({
    hrefState,
    href
  }) {
    const navigation = (0, useNavigation_1.useNavigation)();
    const {
      routeNode,
      params,
      state
    } = getParamsAndNodeFromHref(hrefState);
    const path = state ? (0, linking_1.getPathFromState)(state) : undefined;
    const value = (0, react_1.useMemo)(() => ({
      params,
      pathname: href.toString(),
      segments: path?.split('/').filter(Boolean) || []
    }), [params, href]);
    // This can happen in a theoretical case where the state is not yet initialized or is incorrectly initialized.
    // This check ensures TypeScript type safety as well.
    if (!routeNode) {
      return null;
    }
    const Component = (0, useScreens_1.getQualifiedRouteComponent)(routeNode);
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(PreviewRouteContext_1.PreviewRouteContext, {
      value: value,
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(native_1.NavigationContext, {
        value: navigationPropWithWarnings,
        children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Component, {
          navigation: navigation
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 70,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 69,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 67,
      columnNumber: 13
    }, this);
  }
  function PreviewForInternalRoutes() {
    const pathname = (0, hooks_1.usePathname)();
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
      style: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        gap: 8,
        backgroundColor: 'white'
      },
      children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        style: {
          fontWeight: '600',
          fontSize: 24
        },
        children: "Invalid preview"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 83,
        columnNumber: 7
      }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        style: {
          fontWeight: '200',
          fontSize: 14
        },
        children: pathname
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 84,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 76,
      columnNumber: 13
    }, this);
  }
  function getHrefState(href) {
    const hrefState = router_store_1.store.getStateForHref(href);
    return hrefState;
  }
  function getParamsAndNodeFromHref(hrefState) {
    const index = hrefState?.index ?? 0;
    if (hrefState?.routes[index] && hrefState.routes[index].name !== constants_1.INTERNAL_SLOT_NAME) {
      const name = hrefState.routes[index].name;
      if (name === constants_1.SITEMAP_ROUTE_NAME || name === constants_1.NOT_FOUND_ROUTE_NAME) {
        console.log(router_store_1.store.routeNode);
        console.log(hrefState);
      }
      const error = `Expo Router Error: Expected navigation state to begin with one of [${(0, utils_1.getRootStackRouteNames)().join(', ')}] routes`;
      if (process.env.NODE_ENV !== 'production') {
        throw new Error(error);
      } else {
        console.warn(error);
      }
    }
    const initialState = hrefState?.routes[index]?.state;
    let state = initialState;
    let routeNode = router_store_1.store.routeNode;
    const params = {};
    while (state && routeNode) {
      const route = state.routes[state.index || state.routes.length - 1];
      Object.assign(params, route.params);
      state = route.state;
      routeNode = routeNode.children.find(child => child.route === route.name);
    }
    return {
      params,
      routeNode,
      state: initialState
    };
  }
  const displayWarningForProp = prop => {
    if (process.env.NODE_ENV !== 'production') {
      console.warn(`navigation.${prop} should not be used in a previewed screen. To fix this issue, wrap navigation calls with 'if (!isPreview) { ... }'.`);
    }
  };
  const createNOOPWithWarning = prop => () => displayWarningForProp(prop);
  const navigationPropWithWarnings = {
    setParams: createNOOPWithWarning('setParams'),
    setOptions: createNOOPWithWarning('setOptions'),
    addListener: () => () => {},
    removeListener: () => {},
    isFocused: () => true,
    canGoBack: () => false,
    dispatch: createNOOPWithWarning('dispatch'),
    navigate: createNOOPWithWarning('navigate'),
    goBack: createNOOPWithWarning('goBack'),
    reset: createNOOPWithWarning('reset'),
    push: createNOOPWithWarning('push'),
    pop: createNOOPWithWarning('pop'),
    popToTop: createNOOPWithWarning('popToTop'),
    navigateDeprecated: createNOOPWithWarning('navigateDeprecated'),
    preload: createNOOPWithWarning('preload'),
    getId: () => {
      displayWarningForProp('getId');
      return '';
    },
    // @ts-expect-error
    getParent: createNOOPWithWarning('getParent'),
    getState: () => {
      displayWarningForProp('getState');
      return {
        key: '',
        index: 0,
        routeNames: [],
        routes: [],
        type: '',
        stale: false
      };
    }
  };
},712,[33,253,9,492,385,639,671,635,678,634,388,680],"node_modules/expo-router/build/link/preview/HrefPreview.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\link\\preview\\native.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NativeLinkPreviewAction = NativeLinkPreviewAction;
  exports.NativeLinkPreview = NativeLinkPreview;
  exports.NativeLinkPreviewContent = NativeLinkPreviewContent;
  const expo_1 = require(_dependencyMap[1], "expo");
  const react_native_1 = require(_dependencyMap[2], "react-native-web/dist/index");
  const areNativeViewsAvailable = false && !react_native_1.Platform.isTV && global.RN$Bridgeless === true;
  const LinkPreviewNativeActionView = areNativeViewsAvailable ? (0, expo_1.requireNativeView)('ExpoRouterNativeLinkPreview', 'LinkPreviewNativeActionView') : null;
  function NativeLinkPreviewAction(props) {
    if (!LinkPreviewNativeActionView) {
      return null;
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(LinkPreviewNativeActionView, Object.assign({}, props), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 17,
      columnNumber: 12
    }, this);
  }
  const NativeLinkPreviewView = areNativeViewsAvailable ? (0, expo_1.requireNativeView)('ExpoRouterNativeLinkPreview', 'NativeLinkPreviewView') : null;
  function NativeLinkPreview(props) {
    if (!NativeLinkPreviewView) {
      return null;
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(NativeLinkPreviewView, Object.assign({}, props), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 26,
      columnNumber: 12
    }, this);
  }
  const NativeLinkPreviewContentView = areNativeViewsAvailable ? (0, expo_1.requireNativeView)('ExpoRouterNativeLinkPreview', 'NativeLinkPreviewContentView') : null;
  function NativeLinkPreviewContent(props) {
    if (!NativeLinkPreviewContentView) {
      return null;
    }
    const style = react_native_1.StyleSheet.flatten([props.style, {
      position: 'absolute',
      top: 0,
      left: 0
    }]);
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(NativeLinkPreviewContentView, Object.assign({}, props, {
      style: style
    }), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 12
    }, this);
  }
  // #endregion
},713,[33,550,492],"node_modules/expo-router/build/link/preview/native.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useNextScreenId = useNextScreenId;
  const react_1 = require(_dependencyMap[0], "react");
  const LinkPreviewContext_1 = require(_dependencyMap[1], "./LinkPreviewContext");
  const utils_1 = require(_dependencyMap[2], "./utils");
  const router_store_1 = require(_dependencyMap[3], "../../global-state/router-store");
  const hooks_1 = require(_dependencyMap[4], "../../hooks");
  function useNextScreenId() {
    const router = (0, hooks_1.useRouter)();
    const {
      setOpenPreviewKey
    } = (0, LinkPreviewContext_1.useLinkPreviewContext)();
    const [internalNextScreenId, internalSetNextScreenId] = (0, react_1.useState)();
    const currentHref = (0, react_1.useRef)(undefined);
    const [tabPath, setTabPath] = (0, react_1.useState)([]);
    (0, react_1.useEffect)(() => {
      // When screen is prefetched, then the root state is updated with the preloaded route.
      return router_store_1.store.navigationRef.addListener('state', ({
        data: {
          state
        }
      }) => {
        // If we have the current href, it means that we prefetched the route
        if (currentHref.current && state) {
          const preloadedRoute = (0, utils_1.getPreloadedRouteFromRootStateByHref)(currentHref.current, state);
          const routeKey = preloadedRoute?.key;
          const tabPathFromRootState = (0, utils_1.getTabPathFromRootStateByHref)(currentHref.current, state);
          // Without this timeout react-native does not have enough time to mount the new screen
          // and thus it will not be found on the native side
          if (routeKey || tabPathFromRootState.length) {
            setTimeout(() => {
              internalSetNextScreenId(routeKey);
              setOpenPreviewKey(routeKey);
              setTabPath(tabPathFromRootState);
            });
          }
          // We got the preloaded state, so we can reset the currentHref
          // to prevent unnecessary processing
          currentHref.current = undefined;
        }
      });
    }, []);
    const prefetch = (0, react_1.useCallback)(href => {
      // Resetting the nextScreenId to undefined
      internalSetNextScreenId(undefined);
      router.prefetch(href);
      currentHref.current = href;
    }, [router.prefetch]);
    return [{
      nextScreenId: internalNextScreenId,
      tabPath
    }, prefetch];
  }
},714,[9,647,715,671,678],"node_modules/expo-router/build/link/preview/useNextScreenId.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getTabPathFromRootStateByHref = getTabPathFromRootStateByHref;
  exports.getPreloadedRouteFromRootStateByHref = getPreloadedRouteFromRootStateByHref;
  exports.deepEqual = deepEqual;
  const router_store_1 = require(_dependencyMap[0], "../../global-state/router-store");
  const routing_1 = require(_dependencyMap[1], "../../global-state/routing");
  const href_1 = require(_dependencyMap[2], "../href");
  const navigationParams_1 = require(_dependencyMap[3], "../../navigationParams");
  function getTabPathFromRootStateByHref(href, rootState) {
    const hrefState = router_store_1.store.getStateForHref((0, href_1.resolveHref)(href));
    const state = rootState;
    if (!hrefState || !state) {
      return [];
    }
    // Replicating the logic from `linkTo`
    const {
      navigationRoutes
    } = (0, routing_1.findDivergentState)(hrefState, state, true);
    if (!navigationRoutes.length) {
      return [];
    }
    const tabPath = [];
    navigationRoutes.forEach((route, i, arr) => {
      if (route.state?.type === 'tab') {
        const tabState = route.state;
        const oldTabKey = tabState.routes[tabState.index].key;
        // The next route will be either stack inside a tab or a new tab key
        if (!arr[i + 1]) {
          throw new Error(`New tab route is missing for ${route.key}. This is likely an internal Expo Router bug.`);
        }
        const newTabKey = arr[i + 1].key;
        tabPath.push({
          oldTabKey,
          newTabKey
        });
      }
    });
    return tabPath;
  }
  function getPreloadedRouteFromRootStateByHref(href, rootState) {
    const hrefState = router_store_1.store.getStateForHref((0, href_1.resolveHref)(href));
    const state = rootState;
    if (!hrefState || !state) {
      return undefined;
    }
    // Replicating the logic from `linkTo`
    const {
      navigationState,
      actionStateRoute
    } = (0, routing_1.findDivergentState)(hrefState, state, true);
    if (!navigationState || !actionStateRoute) {
      return undefined;
    }
    if (navigationState.type === 'stack') {
      const stackState = navigationState;
      const payload = (0, routing_1.getPayloadFromStateRoute)(actionStateRoute);
      const preloadedRoute = stackState.preloadedRoutes.find(route => route.name === actionStateRoute.name && deepEqual((0, navigationParams_1.removeInternalExpoRouterParams)(route.params), (0, navigationParams_1.removeInternalExpoRouterParams)(payload.params)));
      const activeRoute = stackState.routes[stackState.index];
      // When the active route is the same as the preloaded route,
      // then we should not navigate. It aligns with base link behavior.
      if (activeRoute.name === preloadedRoute?.name && deepEqual(
      // using ?? {}, because from our perspective undefined === {}, as both mean no params
      (0, navigationParams_1.removeInternalExpoRouterParams)(activeRoute.params ?? {}), (0, navigationParams_1.removeInternalExpoRouterParams)(payload.params ?? {}))) {
        return undefined;
      }
      return preloadedRoute;
    }
    return undefined;
  }
  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
      return false;
    }
    const keys = Object.keys(a);
    return keys.length === Object.keys(b).length && keys.every(key => deepEqual(a[key], b[key]));
  }
},715,[671,659,640,648],"node_modules/expo-router/build/link/preview/utils.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Redirect = Redirect;
  const hooks_1 = require(_dependencyMap[0], "../hooks");
  const useFocusEffect_1 = require(_dependencyMap[1], "../useFocusEffect");
  const PreviewRouteContext_1 = require(_dependencyMap[2], "./preview/PreviewRouteContext");
  /**
   * Redirects to the `href` as soon as the component is mounted.
   *
   * @example
   * ```tsx
   * import { View, Text } from 'react-native';
   * import { Redirect } from 'expo-router';
   *
   * export default function Page() {
   *  const { user } = useAuth();
   *
   *  if (!user) {
   *    return <Redirect href="/login" />;
   *  }
   *
   *  return (
   *    <View>
   *      <Text>Welcome Back!</Text>
   *    </View>
   *  );
   * }
   * ```
   */
  function Redirect({
    href,
    relativeToDirectory,
    withAnchor
  }) {
    const router = (0, hooks_1.useRouter)();
    const isPreview = (0, PreviewRouteContext_1.useIsPreview)();
    (0, useFocusEffect_1.useFocusEffect)(() => {
      if (!isPreview) {
        try {
          router.replace(href, {
            relativeToDirectory,
            withAnchor
          });
        } catch (error) {
          console.error(error);
        }
      }
    });
    return null;
  }
},716,[678,717,385],"node_modules/expo-router/build/link/Redirect.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useFocusEffect = useFocusEffect;
  // A fork of `useFocusEffect` that waits for the navigation state to load before
  // running the effect. This is especially useful for native redirects.
  const React = __importStar(require(_dependencyMap[0], "react"));
  const useLoadedNavigation_1 = require(_dependencyMap[1], "./link/useLoadedNavigation");
  const useNavigation_1 = require(_dependencyMap[2], "./useNavigation");
  /**
   * Hook to run an effect whenever a route is **focused**. Similar to
   * [`React.useEffect`](https://react.dev/reference/react/useEffect).
   *
   * This can be used to perform side-effects such as fetching data or subscribing to events.
   * The passed callback should be wrapped in [`React.useCallback`](https://react.dev/reference/react/useCallback)
   * to avoid running the effect too often.
   *
   * @example
   * ```tsx
   * import { useFocusEffect } from 'expo-router';
   * import { useCallback } from 'react';
   *
   * export default function Route() {
   *   useFocusEffect(
   *     // Callback should be wrapped in `React.useCallback` to avoid running the effect too often.
   *     useCallback(() => {
   *       // Invoked whenever the route is focused.
   *       console.log("Hello, I'm focused!");
   *
   *       // Return function is invoked whenever the route gets out of focus.
   *       return () => {
   *         console.log('This route is now unfocused.');
   *       };
   *     }, []),
   *    );
   *
   *  return </>;
   * }
   *```
   *
   * @param effect Memoized callback containing the effect, should optionally return a cleanup function.
   * @param do_not_pass_a_second_prop
   */
  function useFocusEffect(effect, do_not_pass_a_second_prop) {
    const optionalNavigation = (0, useLoadedNavigation_1.useOptionalNavigation)();
    const navigation = (0, useNavigation_1.useNavigation)();
    if (do_not_pass_a_second_prop !== undefined) {
      const message = "You passed a second argument to 'useFocusEffect', but it only accepts one argument. " + "If you want to pass a dependency array, you can use 'React.useCallback':\n\n" + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    // Your code here\n' + '  }, [depA, depB])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
      console.error(message);
    }
    React.useEffect(() => {
      if (!navigation || !optionalNavigation) {
        return;
      }
      let isFocused = false;
      let cleanup;
      const callback = () => {
        const destroy = effect();
        if (destroy === undefined || typeof destroy === 'function') {
          return destroy;
        }
        if (process.env.NODE_ENV !== 'production') {
          let message = 'An effect function must not return anything besides a function, which is used for clean-up.';
          if (destroy === null) {
            message += " You returned 'null'. If your effect does not require clean-up, return 'undefined' (or nothing).";
          } else if (typeof destroy.then === 'function') {
            message += "\n\nIt looks like you wrote 'useFocusEffect(async () => ...)' or returned a Promise. " + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    async function fetchData() {\n' + '      // You can await here\n' + '      const response = await MyAPI.getData(someId);\n' + '      // ...\n' + '    }\n\n' + '    fetchData();\n' + '  }, [someId])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
          } else {
            message += ` You returned '${JSON.stringify(destroy)}'.`;
          }
          console.error(message);
        }
      };
      // We need to run the effect on initial render/dep changes if the screen is focused
      if (navigation.isFocused()) {
        cleanup = callback();
        isFocused = true;
      }
      const unsubscribeFocus = navigation.addListener('focus', () => {
        // If callback was already called for focus, avoid calling it again
        // The focus event may also fire on initial render, so we guard against running the effect twice
        if (isFocused) {
          return;
        }
        if (cleanup !== undefined) {
          cleanup();
        }
        cleanup = callback();
        isFocused = true;
      });
      const unsubscribeBlur = navigation.addListener('blur', () => {
        if (cleanup !== undefined) {
          cleanup();
        }
        cleanup = undefined;
        isFocused = false;
      });
      return () => {
        if (cleanup !== undefined) {
          cleanup();
        }
        unsubscribeFocus();
        unsubscribeBlur();
      };
    }, [effect, navigation, optionalNavigation]);
  }
},717,[9,705,634],"node_modules/expo-router/build/useFocusEffect.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.tabRouterOverride = void 0;
  const tabRouterOverride = original => {
    return Object.assign({}, original, {
      getStateForAction: (state, action, options) => {
        if (action.target && action.target !== state.key) {
          return null;
        }
        if (isReplaceAction(action)) {
          // Generate the state as if we were using JUMP_TO
          let nextState = original.getStateForAction(state, Object.assign({}, action, {
            type: 'JUMP_TO'
          }), options);
          if (!nextState || nextState.index === undefined || !Array.isArray(nextState.history)) {
            return null;
          }
          // If the state is valid and we didn't JUMP_TO a single history state,
          // then remove the previous state.
          if (nextState.index !== 0) {
            const previousIndex = nextState.index - 1;
            nextState = Object.assign({}, nextState, {
              key: `${nextState.key}-replace`,
              // Omit the previous history entry that we are replacing
              history: [...nextState.history.slice(0, previousIndex), ...nextState.history.splice(nextState.index)]
            });
          }
          return nextState;
        }
        return original.getStateForAction(state, action, options);
      }
    });
  };
  exports.tabRouterOverride = tabRouterOverride;
  function isReplaceAction(action) {
    return action.type === 'REPLACE';
  }
},718,[],"node_modules/expo-router/build/layouts/TabRouter.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __exportStar = this && this.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useFocusEffect = exports.useNavigation = exports.SplashScreen = exports.ErrorBoundary = exports.useSitemap = exports.Sitemap = exports.Unmatched = exports.ExpoRoot = exports.Slot = exports.Navigator = exports.withLayoutContext = exports.useIsPreview = exports.router = exports.useRootNavigationState = exports.useRootNavigation = exports.useSegments = exports.useLocalSearchParams = exports.useGlobalSearchParams = exports.useNavigationContainerRef = exports.usePathname = exports.useUnstableGlobalHref = exports.useRouter = void 0;
  // Expo Router API
  const Navigator_1 = require(_dependencyMap[0], "./views/Navigator");
  Object.defineProperty(exports, "Navigator", {
    enumerable: true,
    get: function () {
      return Navigator_1.Navigator;
    }
  });
  Object.defineProperty(exports, "Slot", {
    enumerable: true,
    get: function () {
      return Navigator_1.Slot;
    }
  });
  var hooks_1 = require(_dependencyMap[1], "./hooks");
  Object.defineProperty(exports, "useRouter", {
    enumerable: true,
    get: function () {
      return hooks_1.useRouter;
    }
  });
  Object.defineProperty(exports, "useUnstableGlobalHref", {
    enumerable: true,
    get: function () {
      return hooks_1.useUnstableGlobalHref;
    }
  });
  Object.defineProperty(exports, "usePathname", {
    enumerable: true,
    get: function () {
      return hooks_1.usePathname;
    }
  });
  Object.defineProperty(exports, "useNavigationContainerRef", {
    enumerable: true,
    get: function () {
      return hooks_1.useNavigationContainerRef;
    }
  });
  Object.defineProperty(exports, "useGlobalSearchParams", {
    enumerable: true,
    get: function () {
      return hooks_1.useGlobalSearchParams;
    }
  });
  Object.defineProperty(exports, "useLocalSearchParams", {
    enumerable: true,
    get: function () {
      return hooks_1.useLocalSearchParams;
    }
  });
  Object.defineProperty(exports, "useSegments", {
    enumerable: true,
    get: function () {
      return hooks_1.useSegments;
    }
  });
  Object.defineProperty(exports, "useRootNavigation", {
    enumerable: true,
    get: function () {
      return hooks_1.useRootNavigation;
    }
  });
  Object.defineProperty(exports, "useRootNavigationState", {
    enumerable: true,
    get: function () {
      return hooks_1.useRootNavigationState;
    }
  });
  var imperative_api_1 = require(_dependencyMap[2], "./imperative-api");
  Object.defineProperty(exports, "router", {
    enumerable: true,
    get: function () {
      return imperative_api_1.router;
    }
  });
  __exportStar(require(_dependencyMap[3], "./link/Link"), exports);
  __exportStar(require(_dependencyMap[4], "./link/elements"), exports);
  var PreviewRouteContext_1 = require(_dependencyMap[5], "./link/preview/PreviewRouteContext");
  Object.defineProperty(exports, "useIsPreview", {
    enumerable: true,
    get: function () {
      return PreviewRouteContext_1.useIsPreview;
    }
  });
  var withLayoutContext_1 = require(_dependencyMap[6], "./layouts/withLayoutContext");
  Object.defineProperty(exports, "withLayoutContext", {
    enumerable: true,
    get: function () {
      return withLayoutContext_1.withLayoutContext;
    }
  });
  // Expo Router Views
  var ExpoRoot_1 = require(_dependencyMap[7], "./ExpoRoot");
  Object.defineProperty(exports, "ExpoRoot", {
    enumerable: true,
    get: function () {
      return ExpoRoot_1.ExpoRoot;
    }
  });
  var Unmatched_1 = require(_dependencyMap[8], "./views/Unmatched");
  Object.defineProperty(exports, "Unmatched", {
    enumerable: true,
    get: function () {
      return Unmatched_1.Unmatched;
    }
  });
  var Sitemap_1 = require(_dependencyMap[9], "./views/Sitemap");
  Object.defineProperty(exports, "Sitemap", {
    enumerable: true,
    get: function () {
      return Sitemap_1.Sitemap;
    }
  });
  var useSitemap_1 = require(_dependencyMap[10], "./views/useSitemap");
  Object.defineProperty(exports, "useSitemap", {
    enumerable: true,
    get: function () {
      return useSitemap_1.useSitemap;
    }
  });
  var ErrorBoundary_1 = require(_dependencyMap[11], "./views/ErrorBoundary");
  Object.defineProperty(exports, "ErrorBoundary", {
    enumerable: true,
    get: function () {
      return ErrorBoundary_1.ErrorBoundary;
    }
  });
  // Platform
  /**
   * @hidden
   */
  exports.SplashScreen = __importStar(require(_dependencyMap[12], "./views/Splash"));
  // React Navigation
  var useNavigation_1 = require(_dependencyMap[13], "./useNavigation");
  Object.defineProperty(exports, "useNavigation", {
    enumerable: true,
    get: function () {
      return useNavigation_1.useNavigation;
    }
  });
  var useFocusEffect_1 = require(_dependencyMap[14], "./useFocusEffect");
  Object.defineProperty(exports, "useFocusEffect", {
    enumerable: true,
    get: function () {
      return useFocusEffect_1.useFocusEffect;
    }
  });
},719,[689,678,679,651,711,385,378,720,701,691,694,731,548,634,717],"node_modules/expo-router/build/exports.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["wrapper"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\ExpoRoot.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ExpoRoot = ExpoRoot;
  const native_1 = require(_dependencyMap[2], "@react-navigation/native");
  const react_1 = __importStar(require(_dependencyMap[3], "react"));
  const react_native_1 = require(_dependencyMap[4], "react-native-web/dist/index");
  const react_native_safe_area_context_1 = require(_dependencyMap[5], "react-native-safe-area-context");
  const constants_1 = require(_dependencyMap[6], "./constants");
  const useDomComponentNavigation_1 = require(_dependencyMap[7], "./domComponents/useDomComponentNavigation");
  const NavigationContainer_1 = require(_dependencyMap[8], "./fork/NavigationContainer");
  const router_store_1 = require(_dependencyMap[9], "./global-state/router-store");
  const serverLocationContext_1 = require(_dependencyMap[10], "./global-state/serverLocationContext");
  const storeContext_1 = require(_dependencyMap[11], "./global-state/storeContext");
  const utils_1 = require(_dependencyMap[12], "./global-state/utils");
  const LinkPreviewContext_1 = require(_dependencyMap[13], "./link/preview/LinkPreviewContext");
  const primitives_1 = require(_dependencyMap[14], "./primitives");
  const statusbar_1 = require(_dependencyMap[15], "./utils/statusbar");
  const Sitemap_1 = require(_dependencyMap[16], "./views/Sitemap");
  const SplashScreen = __importStar(require(_dependencyMap[17], "./views/Splash"));
  const Unmatched_1 = require(_dependencyMap[18], "./views/Unmatched");
  const isTestEnv = process.env.NODE_ENV === 'test';
  const INITIAL_METRICS = react_native_1.Platform.OS === 'web' || isTestEnv ? {
    frame: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    insets: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }
  } : undefined;
  const documentTitle = {
    enabled: false
  };
  /**
   * @hidden
   */
  function ExpoRoot(_ref) {
    let {
        wrapper: ParentWrapper = react_1.Fragment
      } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, _excluded);
    /*
     * Due to static rendering we need to wrap these top level views in second wrapper
     * View's like <SafeAreaProvider /> generate a <div> so if the parent wrapper
     * is a HTML document, we need to ensure its inside the <body>
     */
    const wrapper = (0, react_1.useMemo)(() => ({
      children
    }) => {
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(ParentWrapper, {
        children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(LinkPreviewContext_1.LinkPreviewContextProvider, {
          children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_safe_area_context_1.SafeAreaProvider, {
            // SSR support
            initialMetrics: INITIAL_METRICS,
            children: [statusbar_1.canOverrideStatusBarBehavior && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(AutoStatusBar, {}, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 81,
              columnNumber: 62
            }, this), children]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 77,
            columnNumber: 15
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 76,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 75,
        columnNumber: 17
      }, this);
    }, [ParentWrapper]);
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(ContextNavigator, Object.assign({}, props, {
      wrapper: wrapper
    }), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 87,
      columnNumber: 12
    }, this);
  }
  function AutoStatusBar() {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.StatusBar, {
      barStyle: (0, react_native_1.useColorScheme)() === 'light' ? 'dark-content' : 'light-content'
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 90,
      columnNumber: 12
    }, this);
  }
  const initialUrl = react_native_1.Platform.OS === 'web' && typeof window !== 'undefined' ? new URL(window.location.href) : undefined;
  function ContextNavigator({
    context,
    location: initialLocation = initialUrl,
    wrapper: WrapperComponent = react_1.Fragment,
    linking = {}
  }) {
    // location and linking.getInitialURL are both used to initialize the router state
    //  - location is used on web and during static rendering
    //  - linking.getInitialURL is used on native
    const serverContext = (0, react_1.useMemo)(() => {
      let contextType = {};
      if (initialLocation instanceof URL) {
        contextType = {
          location: {
            pathname: initialLocation.pathname + initialLocation.hash,
            search: initialLocation.search
          }
        };
      } else if (typeof initialLocation === 'string') {
        // The initial location is a string, so we need to parse it into a URL.
        const url = new URL(initialLocation, 'http://placeholder.base');
        contextType = {
          location: {
            pathname: url.pathname,
            search: url.search
          }
        };
      }
      return contextType;
    }, []);
    /*
     * The serverUrl is an initial URL used in server rendering environments.
     * e.g Static renders, units tests, etc
     */
    const serverUrl = serverContext.location ? `${serverContext.location.pathname}${serverContext.location.search}` : undefined;
    const store = (0, router_store_1.useStore)(context, linking, serverUrl);
    (0, useDomComponentNavigation_1.useDomComponentNavigation)();
    if (store.shouldShowTutorial()) {
      SplashScreen.hideAsync();
      if (process.env.NODE_ENV === 'development') {
        const Tutorial = require(_dependencyMap[19], "./onboard/Tutorial").Tutorial;
        return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(WrapperComponent, {
          children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Tutorial, {}, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 135,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 134,
          columnNumber: 21
        }, this);
      } else {
        // Ensure tutorial styles are stripped in production.
        return null;
      }
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(storeContext_1.StoreContext.Provider, {
      value: store,
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(NavigationContainer_1.NavigationContainer, {
        ref: store.navigationRef,
        initialState: store.state,
        linking: store.linking,
        onUnhandledAction: onUnhandledAction,
        documentTitle: documentTitle,
        onReady: store.onReady,
        children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(serverLocationContext_1.ServerContext.Provider, {
          value: serverContext,
          children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(WrapperComponent, {
            children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Content, {}, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 147,
              columnNumber: 13
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 146,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 145,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 144,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 143,
      columnNumber: 13
    }, this);
  }
  function Content() {
    const children = [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(primitives_1.Screen, {
      name: constants_1.INTERNAL_SLOT_NAME,
      component: router_store_1.store.rootComponent
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 154,
      columnNumber: 23
    }, this)];
    if ((0, utils_1.shouldAppendNotFound)()) {
      children.push(/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(primitives_1.Screen, {
        name: constants_1.NOT_FOUND_ROUTE_NAME,
        component: Unmatched_1.Unmatched
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 156,
        columnNumber: 23
      }, this));
    }
    if ((0, utils_1.shouldAppendSitemap)()) {
      children.push(/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(primitives_1.Screen, {
        name: constants_1.SITEMAP_ROUTE_NAME,
        component: Sitemap_1.Sitemap
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 159,
        columnNumber: 23
      }, this));
    }
    const {
      state,
      descriptors,
      NavigationContent
    } = (0, native_1.useNavigationBuilder)(native_1.StackRouter, {
      children,
      id: constants_1.INTERNAL_SLOT_NAME
    });
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(NavigationContent, {
      children: descriptors[state.routes[state.index].key].render()
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 165,
      columnNumber: 13
    }, this);
  }
  let onUnhandledAction;
  if (process.env.NODE_ENV !== 'production') {
    onUnhandledAction = action => {
      const payload = action.payload;
      let message = `The action '${action.type}'${payload ? ` with payload ${JSON.stringify(action.payload)}` : ''} was not handled by any navigator.`;
      switch (action.type) {
        case 'NAVIGATE':
        case 'PUSH':
        case 'REPLACE':
        case 'JUMP_TO':
          if (payload?.name) {
            message += `\n\nDo you have a route named '${payload.name}'?`;
          } else {
            message += `\n\nYou need to pass the name of the screen to navigate to. This may be a bug.`;
          }
          break;
        case 'GO_BACK':
        case 'POP':
        case 'POP_TO_TOP':
          message += `\n\nIs there any screen to go back to?`;
          break;
        case 'OPEN_DRAWER':
        case 'CLOSE_DRAWER':
        case 'TOGGLE_DRAWER':
          message += `\n\nIs your screen inside a Drawer navigator?`;
          break;
      }
      message += `\n\nThis is a development-only warning and won't be shown in production.`;
      if (process.env.NODE_ENV === 'test') {
        throw new Error(message);
      }
      console.error(message);
    };
  } else {
    onUnhandledAction = function () {};
  }
},720,[33,759,253,9,492,423,639,721,724,671,686,389,635,647,391,695,691,548,701,728],"node_modules/expo-router/build/ExpoRoot.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useDomComponentNavigation = useDomComponentNavigation;
  const global_1 = require(_dependencyMap[0], "expo/dom/global");
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  const events_1 = require(_dependencyMap[2], "./events");
  const routing_1 = require(_dependencyMap[3], "../global-state/routing");
  function useDomComponentNavigation() {
    react_1.default.useEffect(() => {
      if (true) {
        return () => {};
      }
      return (0, global_1.addGlobalDomEventListener)(({
        type,
        data
      }) => {
        switch (type) {
          case events_1.ROUTER_LINK_TYPE:
            (0, routing_1.linkTo)(data.href, data.options);
            break;
          case events_1.ROUTER_DISMISS_ALL_TYPE:
            (0, routing_1.dismissAll)();
            break;
          case events_1.ROUTER_DISMISS_TYPE:
            (0, routing_1.dismiss)(data.count);
            break;
          case events_1.ROUTER_BACK_TYPE:
            (0, routing_1.goBack)();
            break;
          case events_1.ROUTER_SET_PARAMS_TYPE:
            (0, routing_1.setParams)(data.params);
            break;
        }
      });
    }, []);
  }
},721,[722,9,657,659],"node_modules/expo-router/build/domComponents/useDomComponentNavigation.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  var _srcDomGlobalEvents = require(_dependencyMap[0], "../src/dom/global-events");
  Object.keys(_srcDomGlobalEvents).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _srcDomGlobalEvents[k];
        }
      });
    }
  });
},722,[723],"node_modules/expo/dom/global.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports._emitGlobalEvent = _emitGlobalEvent;
  Object.defineProperty(exports, "addGlobalDomEventListener", {
    enumerable: true,
    get: function () {
      return addGlobalDomEventListener;
    }
  });
  const globalListeners = new Set();
  function _emitGlobalEvent(message) {
    globalListeners.forEach(listener => listener(message));
  }
  const addGlobalDomEventListener = onSubscribe => {
    globalListeners.add(onSubscribe);
    return () => {
      globalListeners.delete(onSubscribe);
    };
  };
},723,[],"node_modules/expo/src/dom/global-events.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _objectWithoutPropertiesLoose = require(_dependencyMap[1], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["direction", "theme", "linking", "fallback", "documentTitle", "onReady", "onStateChange"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\fork\\NavigationContainer.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NavigationContainer = void 0;
  const native_1 = require(_dependencyMap[2], "@react-navigation/native");
  const react_1 = __importDefault(require(_dependencyMap[3], "react"));
  const react_native_1 = require(_dependencyMap[4], "react-native-web/dist/index");
  const use_latest_callback_1 = __importDefault(require(_dependencyMap[5], "use-latest-callback"));
  const useBackButton_1 = require(_dependencyMap[6], "./useBackButton");
  const useDocumentTitle_1 = require(_dependencyMap[7], "./useDocumentTitle");
  const useLinking_1 = require(_dependencyMap[8], "./useLinking");
  const useThenable_1 = require(_dependencyMap[9], "./useThenable");
  const imperative_api_1 = require(_dependencyMap[10], "../imperative-api");
  globalThis.REACT_NAVIGATION_DEVTOOLS = new WeakMap();
  /**
   * Container component which holds the navigation state designed for React Native apps.
   * This should be rendered at the root wrapping the whole app.
   *
   * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).
   * @param props.onReady Callback which is called after the navigation tree mounts.
   * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
   * @param props.onUnhandledAction Callback which is called when an action is not handled.
   * @param props.direction Text direction of the components. Defaults to `'ltr'`.
   * @param props.theme Theme object for the UI elements.
   * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.
   * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.
   * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.
   * @param props.children Child elements to render the content.
   * @param props.ref Ref object which refers to the navigation object containing helper methods.
   */
  function NavigationContainerInner(_ref, ref) {
    let {
        direction = react_native_1.I18nManager.getConstants().isRTL ? 'rtl' : 'ltr',
        theme = native_1.DefaultTheme,
        linking,
        fallback = null,
        documentTitle,
        onReady,
        onStateChange
      } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);
    const isLinkingEnabled = linking ? linking.enabled !== false : false;
    if (linking?.config) {
      (0, native_1.validatePathConfig)(linking.config);
    }
    const refContainer = react_1.default.useRef(null);
    (0, useBackButton_1.useBackButton)(refContainer);
    (0, useDocumentTitle_1.useDocumentTitle)(refContainer, documentTitle);
    (0, imperative_api_1.useImperativeApiEmitter)(refContainer);
    const [lastUnhandledLink, setLastUnhandledLink] = react_1.default.useState();
    const {
      getInitialState
    } = (0, useLinking_1.useLinking)(refContainer, Object.assign({
      enabled: isLinkingEnabled,
      prefixes: []
    }, linking), setLastUnhandledLink);
    const linkingContext = react_1.default.useMemo(() => ({
      options: linking
    }), [linking]);
    const unhandledLinkingContext = react_1.default.useMemo(() => ({
      lastUnhandledLink,
      setLastUnhandledLink
    }), [lastUnhandledLink, setLastUnhandledLink]);
    const onReadyForLinkingHandling = (0, use_latest_callback_1.default)(() => {
      // If the screen path matches lastUnhandledLink, we do not track it
      const path = refContainer.current?.getCurrentRoute()?.path;
      setLastUnhandledLink(previousLastUnhandledLink => {
        if (previousLastUnhandledLink === path) {
          return undefined;
        }
        return previousLastUnhandledLink;
      });
      onReady?.();
    });
    const onStateChangeForLinkingHandling = (0, use_latest_callback_1.default)(state => {
      // If the screen path matches lastUnhandledLink, we do not track it
      const path = refContainer.current?.getCurrentRoute()?.path;
      setLastUnhandledLink(previousLastUnhandledLink => {
        if (previousLastUnhandledLink === path) {
          return undefined;
        }
        return previousLastUnhandledLink;
      });
      onStateChange?.(state);
    });
    // Add additional linking related info to the ref
    // This will be used by the devtools
    react_1.default.useEffect(() => {
      if (refContainer.current) {
        REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {
          get linking() {
            return Object.assign({}, linking, {
              enabled: isLinkingEnabled,
              prefixes: linking?.prefixes ?? [],
              getStateFromPath: linking?.getStateFromPath ?? native_1.getStateFromPath,
              getPathFromState: linking?.getPathFromState ?? native_1.getPathFromState,
              getActionFromState: linking?.getActionFromState ?? native_1.getActionFromState
            });
          }
        });
      }
    });
    const [isResolved, initialState] = (0, useThenable_1.useThenable)(getInitialState);
    react_1.default.useImperativeHandle(ref, () => refContainer.current);
    const isLinkingReady = rest.initialState != null || !isLinkingEnabled || isResolved;
    if (!isLinkingReady) {
      // This is temporary until we have Suspense for data-fetching
      // Then the fallback will be handled by a parent `Suspense` component
      return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(native_1.ThemeProvider, {
        value: theme,
        children: fallback
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 96,
        columnNumber: 16
      }, this);
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(native_1.LocaleDirContext.Provider, {
      value: direction,
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(native_1.UNSTABLE_UnhandledLinkingContext.Provider, {
        value: unhandledLinkingContext,
        children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(native_1.LinkingContext.Provider, {
          value: linkingContext,
          children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(native_1.BaseNavigationContainer, Object.assign({}, rest, {
            theme: theme,
            onReady: onReadyForLinkingHandling,
            onStateChange: onStateChangeForLinkingHandling,
            initialState: rest.initialState == null ? initialState : rest.initialState,
            ref: refContainer
          }), void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 101,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 100,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 99,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 98,
      columnNumber: 13
    }, this);
  }
  exports.NavigationContainer = react_1.default.forwardRef(NavigationContainerInner);
},724,[33,759,253,9,492,268,725,726,684,727,679],"node_modules/expo-router/build/fork/NavigationContainer.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useBackButton = useBackButton;
  function useBackButton(_) {
    // No-op
    // BackHandler is not available on web
  }
},725,[],"node_modules/expo-router/build/fork/useBackButton.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useDocumentTitle = useDocumentTitle;
  const React = __importStar(require(_dependencyMap[0], "react"));
  // import type { DocumentTitleOptions } from './types';
  /**
   * Set the document title for the active screen
   */
  function useDocumentTitle(ref, {
    enabled = true,
    formatter = (options, route) => options?.title ?? route?.name
  } = {}) {
    React.useEffect(() => {
      if (!enabled) {
        return;
      }
      const navigation = ref.current;
      if (navigation) {
        const title = formatter(navigation.getCurrentOptions(), navigation.getCurrentRoute());
        document.title = title;
      }
      return navigation?.addListener('options', e => {
        const title = formatter(e.data.options, navigation?.getCurrentRoute());
        document.title = title;
      });
    });
  }
},726,[9],"node_modules/expo-router/build/fork/useDocumentTitle.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.useThenable = useThenable;
  /*
   * This file is unchanged, except for moving eslint comments
   */
  const React = __importStar(require(_dependencyMap[0], "react"));
  function useThenable(create) {
    const [promise] = React.useState(create);
    let initialState = [false, undefined];
    // Check if our thenable is synchronous
    promise.then(result => {
      initialState = [true, result];
    });
    const [state, setState] = React.useState(initialState);
    const [resolved] = state;
    React.useEffect(() => {
      let cancelled = false;
      const resolve = async () => {
        let result;
        try {
          result = await promise;
        } finally {
          if (!cancelled) {
            setState([true, result]);
          }
        }
      };
      if (!resolved) {
        resolve();
      }
      return () => {
        cancelled = true;
      };
    }, [promise, resolved]);
    return state;
  }
},727,[9],"node_modules/expo-router/build/fork/useThenable.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\onboard\\Tutorial.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Tutorial = Tutorial;
  const react_1 = __importDefault(require(_dependencyMap[1], "react"));
  const react_native_1 = require(_dependencyMap[2], "react-native-web/dist/index");
  const react_native_safe_area_context_1 = require(_dependencyMap[3], "react-native-safe-area-context");
  const exports_1 = require(_dependencyMap[4], "../exports");
  const getDevServer_1 = require(_dependencyMap[5], "../getDevServer");
  const Pressable_1 = require(_dependencyMap[6], "../views/Pressable");
  const canAutoTouchFile = "..\\..\\..\\..\\app" != null;
  function createEntryFileAsync() {
    if (process.env.NODE_ENV === 'production') {
      // No dev server
      console.warn('createEntryFile() cannot be used in production');
      return;
    }
    // Pings middleware in the Expo CLI dev server.
    return fetch((0, getDevServer_1.getDevServer)().url + '_expo/touch', {
      method: 'POST',
      body: JSON.stringify({
        type: 'router_index'
      })
    });
  }
  function Tutorial() {
    react_1.default.useEffect(() => {
      if (react_native_1.Platform.OS === 'web') {
        // Reset the route on web so the initial route isn't a 404 after
        // the user has created the entry file.
        // This is useful for cases where you are testing the tutorial.
        // To test: touch the new file, then navigate to a missing route `/foobar`, then delete the app folder.
        // you should see the tutorial again and be able to create the entry file once more.
        if (typeof location !== 'undefined' && location.pathname !== '/') {
          location.replace('/');
        }
        if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {
          window.document.title = 'Welcome to Expo';
        }
      }
    }, []);
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_safe_area_context_1.SafeAreaView, {
      style: styles.background,
      children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.StatusBar, {
        barStyle: "light-content"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 43,
        columnNumber: 7
      }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
        style: styles.container,
        children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
          style: styles.logotypeWrapper,
          children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Image, {
            style: styles.logotype,
            source: require(_dependencyMap[7], "expo-router/assets/logotype.png")
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 46,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 45,
          columnNumber: 9
        }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
          role: "heading",
          "aria-level": 1,
          style: styles.title,
          children: "Welcome to Expo"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 48,
          columnNumber: 9
        }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
          role: "heading",
          "aria-level": 2,
          style: [styles.subtitle, styles.textSecondary],
          children: ["Start by creating a file", react_native_1.Platform.OS !== 'web' ? '\n' : ' ', "in the", ' ', /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
            style: {
              fontWeight: '600'
            },
            children: getRootDir()
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 53,
            columnNumber: 11
          }, this), " directory."]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 51,
          columnNumber: 9
        }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
          children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(exports_1.Link, Object.assign({
            href: "https://docs.expo.dev/router/introduction/"
          }, react_native_1.Platform.select({
            web: {
              target: '_blank'
            },
            native: {
              asChild: true
            }
          }), {
            children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Pressable_1.Pressable, {
              children: ({
                hovered,
                pressed
              }) => /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
                style: [styles.link, react_native_1.Platform.select({
                  web: {
                    transitionDuration: '200ms',
                    marginBottom: 12
                  }
                }), hovered && {
                  opacity: 0.8,
                  textDecorationLine: 'underline'
                }, pressed && {
                  opacity: 0.8
                }],
                children: "Learn more about Expo Router in the documentation."
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 58,
                columnNumber: 43
              }, this)
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 57,
              columnNumber: 13
            }, this)
          }), void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 56,
            columnNumber: 11
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 55,
          columnNumber: 9
        }, this), canAutoTouchFile && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Button, {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 79,
          columnNumber: 30
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 44,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 13
    }, this);
  }
  function getRootDir() {
    const dir = "..\\..\\..\\..\\app" ?? '';
    if (/[\\/]src[\\/]app$/.test(dir)) {
      return 'src/app';
    } else if (/[\\/]app$/.test(dir)) {
      return 'app';
    }
    return dir.split(/[\\/]/).pop() ?? '';
  }
  function Button() {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Pressable_1.Pressable, {
      onPress: () => {
        createEntryFileAsync();
      },
      style: styles.button,
      children: ({
        pressed,
        hovered
      }) => /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
        style: [styles.buttonContainer, hovered && {
          backgroundColor: '#fff'
        }, pressed && react_native_1.Platform.select({
          web: {
            transform: 'scale(0.98)',
            transitionDuration: '200ms'
          },
          default: {
            backgroundColor: '#fff'
          }
        })],
        children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
          style: [styles.code, hovered && {
            color: '#000'
          }, pressed && react_native_1.Platform.select({
            native: {
              color: '#000'
            }
          })],
          children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
            style: styles.textSecondary,
            children: "$"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 121,
            columnNumber: 13
          }, this), " touch ", `${getRootDir()}/index.tsx`]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 113,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 97,
        columnNumber: 35
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 94,
      columnNumber: 13
    }, this);
  }
  const styles = react_native_1.StyleSheet.create({
    background: {
      backgroundColor: '#000',
      flex: 1
    },
    container: Object.assign({
      flex: 1,
      padding: 24,
      paddingBottom: 64,
      alignItems: 'center',
      justifyContent: 'center',
      marginHorizontal: 'auto',
      gap: 16
    }, react_native_1.Platform.select({
      web: {
        maxWidth: 960
      },
      native: {
        width: '100%'
      }
    })),
    logotypeWrapper: {
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: '#151718',
      borderRadius: 12,
      borderWidth: 1,
      borderStyle: 'solid',
      borderColor: '#313538',
      width: 78,
      height: 78,
      marginBottom: 8
    },
    logotype: {
      width: 48,
      height: 44
    },
    title: Object.assign({}, react_native_1.Platform.select({
      web: {
        fontSize: 64,
        lineHeight: 64
      },
      default: {
        fontSize: 56,
        lineHeight: 56
      }
    }), {
      color: '#fff',
      fontWeight: '800',
      textAlign: 'center'
    }),
    buttonContainer: Object.assign({}, react_native_1.Platform.select({
      web: {
        transitionDuration: '200ms'
      }
    }), {
      backgroundColor: 'transparent',
      borderColor: '#fff',
      borderWidth: 2,
      paddingVertical: 12,
      paddingHorizontal: 24,
      borderRadius: 8
    }),
    button: Object.assign({}, react_native_1.Platform.select({
      web: {
        marginTop: 12
      },
      native: {
        position: 'absolute',
        bottom: 24,
        left: 32,
        right: 32,
        overflow: 'hidden'
      }
    })),
    code: Object.assign({}, react_native_1.Platform.select({
      web: {
        transitionDuration: '200ms',
        fontFamily: 'Courier, monospace'
      },
      default: {
        fontFamily: react_native_1.Platform.select({
          ios: 'Courier New',
          android: 'monospace'
        })
      }
    }), {
      color: '#fff',
      textAlign: 'center',
      userSelect: 'none',
      fontSize: 18,
      fontWeight: 'bold'
    }),
    subtitle: {
      fontSize: 34,
      fontWeight: '200',
      textAlign: 'center'
    },
    link: Object.assign({
      fontSize: 20,
      lineHeight: 26,
      textAlign: 'center',
      color: '#52a9ff',
      marginTop: 12
    }, react_native_1.Platform.select({
      web: {
        marginBottom: 24
      }
    })),
    textSecondary: {
      color: '#9ba1a6'
    }
  });
},728,[33,9,492,423,719,729,693,730],"node_modules/expo-router/build/onboard/Tutorial.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getDevServer = void 0;
  const getDevServer = () => {
    // Disable for SSR
    if (typeof window === 'undefined') {
      return {
        bundleLoadedFromServer: true,
        fullBundleUrl: '',
        url: ''
      };
    }
    return {
      // The bundle is always loaded from a server in the browser.
      bundleLoadedFromServer: true,
      /** URL but ensures that platform query param is added. */
      get fullBundleUrl() {
        if (document?.currentScript && 'src' in document.currentScript) {
          return document.currentScript.src;
        }
        const bundleUrl = new URL(location.href);
        bundleUrl.searchParams.set('platform', 'web');
        return bundleUrl.toString();
      },
      url: location.origin + '/'
    };
  };
  exports.getDevServer = getDevServer;
},729,[],"node_modules/expo-router/build/getDevServer/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2Fexpo-router%2Fassets/logotype.png",
    width: 96,
    height: 88
  };
},730,[],"node_modules/expo-router/assets/logotype.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
  'use client';

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\views\\ErrorBoundary.js";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ErrorBoundary = ErrorBoundary;
  const bottom_tabs_1 = require(_dependencyMap[1], "@react-navigation/bottom-tabs");
  const react_1 = require(_dependencyMap[2], "react");
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const react_native_safe_area_context_1 = require(_dependencyMap[4], "react-native-safe-area-context");
  const Pressable_1 = require(_dependencyMap[5], "./Pressable");
  const Link_1 = require(_dependencyMap[6], "../link/Link");
  const errors_1 = require(_dependencyMap[7], "../rsc/router/errors");
  function StandardErrorView({
    error
  }) {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
      style: {
        marginBottom: 12,
        gap: 4,
        flexWrap: true ? 'wrap' : 'nowrap'
      },
      children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        role: "heading",
        "aria-level": 1,
        style: styles.title,
        children: "Something went wrong"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 18,
        columnNumber: 7
      }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        testID: "router_error_message",
        role: "heading",
        "aria-level": 2,
        style: styles.errorMessage,
        children: ["Error: ", error.message]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 21,
        columnNumber: 7
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 13
    }, this);
  }
  function ErrorBoundary({
    error,
    retry
  }) {
    const inTabBar = (0, react_1.use)(bottom_tabs_1.BottomTabBarHeightContext);
    const Wrapper = inTabBar ? react_native_1.View : react_native_safe_area_context_1.SafeAreaView;
    const isServerError = error instanceof errors_1.ReactServerError;
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
      style: styles.container,
      children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Wrapper, {
        style: {
          flex: 1,
          gap: 8,
          maxWidth: 720,
          marginHorizontal: 'auto'
        },
        children: [isServerError ? /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(ReactServerErrorView, {
          error: error
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 32,
          columnNumber: 27
        }, this) : /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(StandardErrorView, {
          error: error
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 32,
          columnNumber: 69
        }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
          style: {
            flex: 1
          }
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 33,
          columnNumber: 9
        }, this), process.env.NODE_ENV === 'development' && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Link_1.Link, {
          testID: "router_error_sitemap",
          href: "/_sitemap",
          style: styles.link,
          children: "Sitemap"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 35,
          columnNumber: 53
        }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(Pressable_1.Pressable, {
          testID: "router_error_retry",
          onPress: retry,
          children: ({
            hovered,
            pressed
          }) => /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
            style: [styles.buttonInner, (hovered || pressed) && {
              backgroundColor: 'white'
            }],
            children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
              style: [styles.buttonText, {
                color: hovered || pressed ? 'black' : 'white'
              }],
              children: "Retry"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 40,
              columnNumber: 15
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 39,
            columnNumber: 39
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 38,
          columnNumber: 9
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 31,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 13
    }, this);
  }
  const COMMON_ERROR_STATUS = {
    404: 'NOT_FOUND',
    500: 'INTERNAL_SERVER_ERROR',
    503: 'SERVICE_UNAVAILABLE',
    504: 'GATEWAY_TIMEOUT'
  };
  // TODO: This should probably be replaced by a DOM component that loads server errors in the future.
  function ReactServerErrorView({
    error
  }) {
    let title = String(error.statusCode);
    title += ': ' + (COMMON_ERROR_STATUS[error.statusCode] ?? 'Server Error');
    const errorId = error.headers.get('cf-ray');
    const date = error.headers.get('Date');
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
      style: {
        padding: 12,
        gap: 8
      },
      children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        selectable: true,
        allowFontScaling: true,
        style: {
          fontSize: react_native_1.Platform.select({
            web: 24,
            default: 16
          }),
          fontWeight: 'bold',
          marginBottom: 4,
          color: 'white'
        },
        children: title
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 69,
        columnNumber: 7
      }, this), true ? /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.ScrollView, {
        style: {
          borderColor: 'rgba(255,255,255,0.5)',
          borderTopWidth: react_native_1.StyleSheet.hairlineWidth,
          borderBottomWidth: react_native_1.StyleSheet.hairlineWidth,
          maxHeight: 150
        },
        contentContainerStyle: {
          paddingVertical: 4
        },
        children: /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
          testID: "router_error_message",
          selectable: true,
          allowFontScaling: true,
          style: {
            color: 'white'
          },
          children: error.message
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 84,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 78,
        columnNumber: 41
      }, this) : /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.TextInput, {
        testID: "router_error_message",
        scrollEnabled: true,
        multiline: true,
        editable: false,
        allowFontScaling: true,
        value: error.message,
        style: {
          borderColor: 'rgba(255,255,255,0.5)',
          borderTopWidth: react_native_1.StyleSheet.hairlineWidth,
          borderBottomWidth: react_native_1.StyleSheet.hairlineWidth,
          paddingVertical: 4,
          maxHeight: 150,
          color: 'white'
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 89,
        columnNumber: 42
      }, this), /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(InfoRow, {
        title: "Code",
        right: error.statusCode
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 98,
        columnNumber: 7
      }, this), errorId && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(InfoRow, {
        title: "ID",
        right: errorId
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 99,
        columnNumber: 19
      }, this), date && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(InfoRow, {
        title: "Date",
        right: date
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 100,
        columnNumber: 16
      }, this), error.url && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        selectable: true,
        allowFontScaling: true,
        style: {
          fontSize: 14,
          opacity: 0.5,
          color: 'white'
        },
        children: error.url
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 102,
        columnNumber: 22
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 65,
      columnNumber: 13
    }, this);
  }
  function InfoRow({
    title,
    right
  }) {
    const style = {
      fontSize: 16,
      color: 'white'
    };
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {
      style: {
        flexDirection: 'row',
        justifyContent: 'space-between'
      },
      children: [/*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        selectable: true,
        allowFontScaling: true,
        style: style,
        children: title
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 113,
        columnNumber: 7
      }, this), right && /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.Text, {
        selectable: true,
        allowFontScaling: true,
        style: [style, styles.code],
        children: right
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 116,
        columnNumber: 18
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 112,
      columnNumber: 13
    }, this);
  }
  const styles = react_native_1.StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: 'black',
      padding: 24,
      alignItems: 'stretch',
      justifyContent: 'center'
    },
    title: {
      color: 'white',
      fontSize: react_native_1.Platform.select({
        web: 32,
        default: 24
      }),
      fontWeight: 'bold'
    },
    buttonText: Object.assign({
      fontSize: 18,
      fontWeight: 'bold',
      color: 'black'
    }, react_native_1.Platform.select({
      web: {
        transitionDuration: '100ms'
      }
    })),
    buttonInner: Object.assign({}, react_native_1.Platform.select({
      web: {
        transitionDuration: '100ms'
      }
    }), {
      paddingVertical: 12,
      paddingHorizontal: 24,
      borderColor: 'white',
      borderWidth: 2,
      marginLeft: 8,
      justifyContent: 'center',
      alignItems: 'center'
    }),
    code: {
      fontFamily: react_native_1.Platform.select({
        default: 'Courier',
        ios: 'Courier New',
        android: 'monospace'
      }),
      fontWeight: '500'
    },
    errorMessage: {
      color: 'white',
      fontSize: 16
    },
    subtitle: {
      color: 'white',
      fontSize: 14,
      marginBottom: 12
    },
    link: {
      color: 'rgba(255,255,255,0.4)',
      textDecorationStyle: 'solid',
      textDecorationLine: 'underline',
      fontSize: 14,
      textAlign: 'center'
    }
  });
},731,[33,394,9,492,423,693,651,631],"node_modules/expo-router/build/views/ErrorBoundary.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\ApiNoExpo\\app\\index.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return Inicial;
    }
  });
  var _reactCompilerRuntime = require(_dependencyMap[0], "react/compiler-runtime");
  var _expoRouter = require(_dependencyMap[1], "expo-router");
  var _reactNativeWebDistExportsImage = require(_dependencyMap[2], "react-native-web/dist/exports/Image");
  var Image = _interopDefault(_reactNativeWebDistExportsImage);
  var _reactNativeWebDistExportsImageBackground = require(_dependencyMap[3], "react-native-web/dist/exports/ImageBackground");
  var ImageBackground = _interopDefault(_reactNativeWebDistExportsImageBackground);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[5], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsTouchableOpacity = require(_dependencyMap[6], "react-native-web/dist/exports/TouchableOpacity");
  var TouchableOpacity = _interopDefault(_reactNativeWebDistExportsTouchableOpacity);
  var _reactNativeWebDistExportsView = require(_dependencyMap[7], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactJsxDevRuntime = require(_dependencyMap[8], "react/jsx-dev-runtime");
  function Inicial() {
    const $ = (0, _reactCompilerRuntime.c)(5);
    if ($[0] !== "21189f224f2d2d6625ed640fba0e93f74325fb001cf87d112e140b3cc9e4019b") {
      for (let $i = 0; $i < 5; $i += 1) {
        $[$i] = Symbol.for("react.memo_cache_sentinel");
      }
      $[0] = "21189f224f2d2d6625ed640fba0e93f74325fb001cf87d112e140b3cc9e4019b";
    }
    let t0;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = require(_dependencyMap[9], "../assets/gohan.gif");
      $[1] = t0;
    } else {
      t0 = $[1];
    }
    let t1;
    if ($[2] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: s.wrapInicial,
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
          style: s.title,
          children: "Dragon Ball API"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 18,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 17,
        columnNumber: 7
      }, this);
      $[2] = t1;
    } else {
      t1 = $[2];
    }
    let t2;
    if ($[3] === Symbol.for("react.memo_cache_sentinel")) {
      t2 = /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: s.wrapInicial,
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Image.default, {
          style: s.img,
          source: require(_dependencyMap[10], "../assets/logo.png"),
          alt: "logo"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 21,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 20,
        columnNumber: 7
      }, this);
      $[3] = t2;
    } else {
      t2 = $[3];
    }
    let t3;
    if ($[4] === Symbol.for("react.memo_cache_sentinel")) {
      t3 = /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ImageBackground.default, {
        source: t0,
        style: s.container,
        children: [t1, t2, /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
          style: s.wrapInicial,
          children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(TouchableOpacity.default, {
            style: s.btn,
            onPress: _temp,
            children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
              style: s.btnText,
              children: "Visitar personagens"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 34,
              columnNumber: 11
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 28,
            columnNumber: 9
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 27,
          columnNumber: 7
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 13,
        columnNumber: 5
      }, this);
      $[4] = t3;
    } else {
      t3 = $[4];
    }
    return t3;
  }
  _c2 = Inicial;
  function _temp() {
    _expoRouter.router.push("/list");
  }
  const s = StyleSheet.default.create({
    wrapInicial: {
      flex: 1,
      alignItems: "center",
      paddingVertical: 20
    },
    title: {
      fontSize: 25,
      fontWeight: "bold",
      alignSelf: "center",
      textShadowColor: "#181818",
      textShadowOffset: {
        width: 10,
        height: 10
      },
      textShadowRadius: 10,
      color: "#ffd000"
    },
    img: {
      width: "80%",
      height: "60%",
      top: -10
    },
    btn: {
      backgroundColor: "#ff990000",
      borderColor: "#090909",
      borderRadius: 100,
      paddingHorizontal: 30,
      paddingVertical: 10,
      shadowColor: "#000",
      shadowOffset: {
        width: 6,
        height: 10
      },
      shadowOpacity: 0.37,
      shadowRadius: 7.49,
      elevation: 12
    },
    btnText: {
      color: "#ffffff",
      fontSize: 22
    },
    container: {
      flex: 1,
      width: "100%",
      height: "100%",
      justifyContent: "center",
      alignItems: "center"
    }
  });
  var _c2;
  $RefreshReg$(_c2, "Inicial");
},732,[246,248,155,517,55,138,515,110,33,857,733],"app/index.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets/logo.png",
    width: 1080,
    height: 518
  };
},733,[],"assets/logo.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\ApiNoExpo\\app\\list.tsx",
    _s = $RefreshSig$();
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return List;
    }
  });
  var _expoImage = require(_dependencyMap[0], "expo-image");
  var _react = require(_dependencyMap[1], "react");
  var _reactNativeWebDistExportsFlatList = require(_dependencyMap[2], "react-native-web/dist/exports/FlatList");
  var FlatList = _interopDefault(_reactNativeWebDistExportsFlatList);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[4], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsTextInput = require(_dependencyMap[5], "react-native-web/dist/exports/TextInput");
  var TextInput = _interopDefault(_reactNativeWebDistExportsTextInput);
  var _reactNativeWebDistExportsView = require(_dependencyMap[6], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactJsxDevRuntime = require(_dependencyMap[7], "react/jsx-dev-runtime");
  function List() {
    _s();
    const [personagens, setPersonagens] = (0, _react.useState)();
    const [loading, setLoading] = (0, _react.useState)(true);
    const fechtCharacters = async () => {
      try {
        const response = await fetch("https://dragonball-api.com/api/characters");
        const data = await response.json();
        setPersonagens(data.items);
      } catch (error) {
        console.error(error);
      } finally {
        setLoading(false);
      }
    };
    (0, _react.useEffect)(() => {
      fechtCharacters();
    }, []);
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: s.screen,
      children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
        style: s.titulo,
        children: "Lista de personagens"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 27,
        columnNumber: 7
      }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(TextInput.default, {
        style: s.input,
        placeholder: "Digite o valor(1/58)"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 28,
        columnNumber: 7
      }, this), loading ? /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: s.wrapImage,
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_expoImage.Image, {
          style: s.loading,
          source: require(_dependencyMap[8], "../assets/loading2.gif")
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 31,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 30,
        columnNumber: 9
      }, this) : /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(FlatList.default, {
        data: personagens,
        renderItem: ({
          item
        }) => {
          return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
            style: s.wrap2,
            children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
              style: s.content,
              children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
                style: s.name,
                children: item.name
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 40,
                columnNumber: 19
              }, this)
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 39,
              columnNumber: 17
            }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
              style: s.imageContainer,
              children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_expoImage.Image, {
                source: {
                  uri: item.image
                },
                style: s.image
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 43,
                columnNumber: 19
              }, this)
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 42,
              columnNumber: 17
            }, this)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 38,
            columnNumber: 15
          }, this);
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 34,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 26,
      columnNumber: 5
    }, this);
  }
  _s(List, "9XIdNP8kSj0m3trzggE7mKrS4RE=");
  _c = List;
  const s = StyleSheet.default.create({
    titulo: {
      fontSize: 32,
      alignSelf: "center",
      textAlign: "center",
      fontWeight: "bold",
      textShadowColor: "#181818",
      textShadowOffset: {
        width: 10,
        height: 10
      },
      textShadowRadius: 10,
      color: "#ffd000"
    },
    wrap2: {
      alignItems: "center",
      justifyContent: "center",
      padding: 100,
      borderRadius: 20,
      borderWidth: 2,
      top: 50,
      margin: 10,
      backgroundColor: "#bdbdbd3d"
    },
    name: {
      top: -20,
      zIndex: 500,
      padding: 5,
      borderWidth: 1,
      borderRadius: 10,
      backgroundColor: "#bdbdbd7e"
    },
    image: {
      width: 150,
      height: 330,
      flex: 1
    },
    content: {},
    loading: {
      width: 100,
      height: 100
    },
    screen: {
      flex: 1,
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "#e8ecec"
    },
    wrapImage: {
      flex: 1,
      alignItems: "center",
      justifyContent: "center",
      width: 200,
      height: 200
    },
    imageContainer: {
      width: 150,
      height: 330
    },
    input: {}
  });
  var _c;
  $RefreshReg$(_c, "List");
},734,[862,9,169,55,138,436,110,33,856],"app/list.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = this && this.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  __exportStar(require(_dependencyMap[0], "./ExpoHead"), exports);
},736,[737],"node_modules/expo-router/build/head/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\head\\ExpoHead.js";
  var __importDefault = this && this.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Head = void 0;
  const native_1 = require(_dependencyMap[1], "@react-navigation/native");
  const react_1 = __importDefault(require(_dependencyMap[2], "react"));
  const lib_1 = require(_dependencyMap[3], "../../vendor/react-helmet-async/lib");
  function FocusedHelmet({
    children
  }) {
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(lib_1.Helmet, {
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 11,
      columnNumber: 12
    }, this);
  }
  const Head = ({
    children
  }) => {
    const isFocused = (0, native_1.useIsFocused)();
    if (!isFocused) {
      return null;
    }
    return /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(FocusedHelmet, {
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 12
    }, this);
  };
  exports.Head = Head;
  exports.Head.Provider = lib_1.HelmetProvider;
},737,[33,253,9,738],"node_modules/expo-router/build/head/ExpoHead.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _objectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  const _excluded = ["children"],
    _excluded2 = ["children"];
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
        get: () => from[key],
        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
      });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod));
  var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
    value: true
  }), mod);

  // src/index.tsx
  var src_exports = {};
  __export(src_exports, {
    Helmet: () => Helmet,
    HelmetData: () => HelmetData,
    HelmetProvider: () => HelmetProvider
  });
  module.exports = __toCommonJS(src_exports);
  var import_react4 = __toESM(require(_dependencyMap[1], "react"));
  var import_react_fast_compare = __toESM(require(_dependencyMap[2], "react-fast-compare"));
  var import_invariant = __toESM(require(_dependencyMap[3], "invariant"));

  // src/Provider.tsx
  var import_react2 = __toESM(require(_dependencyMap[1], "react"));

  // src/server.ts
  var import_react = __toESM(require(_dependencyMap[1], "react"));

  // src/constants.ts
  var TAG_NAMES = /* @__PURE__ */(TAG_NAMES2 => {
    TAG_NAMES2["BASE"] = "base";
    TAG_NAMES2["BODY"] = "body";
    TAG_NAMES2["HEAD"] = "head";
    TAG_NAMES2["HTML"] = "html";
    TAG_NAMES2["LINK"] = "link";
    TAG_NAMES2["META"] = "meta";
    TAG_NAMES2["NOSCRIPT"] = "noscript";
    TAG_NAMES2["SCRIPT"] = "script";
    TAG_NAMES2["STYLE"] = "style";
    TAG_NAMES2["TITLE"] = "title";
    TAG_NAMES2["FRAGMENT"] = "Symbol(react.fragment)";
    return TAG_NAMES2;
  })(TAG_NAMES || {});
  var SEO_PRIORITY_TAGS = {
    link: {
      rel: ["amphtml", "canonical", "alternate"]
    },
    script: {
      type: ["application/ld+json"]
    },
    meta: {
      charset: "",
      name: ["generator", "robots", "description"],
      property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"]
    }
  };
  var VALID_TAG_NAMES = Object.values(TAG_NAMES);
  var REACT_TAG_MAP = {
    accesskey: "accessKey",
    charset: "charSet",
    class: "className",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    "http-equiv": "httpEquiv",
    itemprop: "itemProp",
    tabindex: "tabIndex"
  };
  var HTML_TAG_MAP = Object.entries(REACT_TAG_MAP).reduce((carry, [key, value]) => {
    carry[value] = key;
    return carry;
  }, {});
  var HELMET_ATTRIBUTE = "data-rh";

  // src/utils.ts
  var HELMET_PROPS = {
    DEFAULT_TITLE: "defaultTitle",
    DEFER: "defer",
    ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
    ON_CHANGE_CLIENT_STATE: "onChangeClientState",
    TITLE_TEMPLATE: "titleTemplate",
    PRIORITIZE_SEO_TAGS: "prioritizeSeoTags"
  };
  var getInnermostProperty = (propsList, property) => {
    for (let i = propsList.length - 1; i >= 0; i -= 1) {
      const props = propsList[i];
      if (Object.prototype.hasOwnProperty.call(props, property)) {
        return props[property];
      }
    }
    return null;
  };
  var getTitleFromPropsList = propsList => {
    let innermostTitle = getInnermostProperty(propsList, "title" /* TITLE */);
    const innermostTemplate = getInnermostProperty(propsList, HELMET_PROPS.TITLE_TEMPLATE);
    if (Array.isArray(innermostTitle)) {
      innermostTitle = innermostTitle.join("");
    }
    if (innermostTemplate && innermostTitle) {
      return innermostTemplate.replace(/%s/g, () => innermostTitle);
    }
    const innermostDefaultTitle = getInnermostProperty(propsList, HELMET_PROPS.DEFAULT_TITLE);
    return innermostTitle || innermostDefaultTitle || void 0;
  };
  var getOnChangeClientState = propsList => getInnermostProperty(propsList, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || (() => {});
  var getAttributesFromPropsList = (tagType, propsList) => propsList.filter(props => typeof props[tagType] !== "undefined").map(props => props[tagType]).reduce((tagAttrs, current) => Object.assign({}, tagAttrs, current), {});
  var getBaseTagFromPropsList = (primaryAttributes, propsList) => propsList.filter(props => typeof props["base" /* BASE */] !== "undefined").map(props => props["base" /* BASE */]).reverse().reduce((innermostBaseTag, tag) => {
    if (!innermostBaseTag.length) {
      const keys = Object.keys(tag);
      for (let i = 0; i < keys.length; i += 1) {
        const attributeKey = keys[i];
        const lowerCaseAttributeKey = attributeKey.toLowerCase();
        if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
          return innermostBaseTag.concat(tag);
        }
      }
    }
    return innermostBaseTag;
  }, []);
  var warn = msg => console && typeof console.warn === "function" && console.warn(msg);
  var getTagsFromPropsList = (tagName, primaryAttributes, propsList) => {
    const approvedSeenTags = {};
    return propsList.filter(props => {
      if (Array.isArray(props[tagName])) {
        return true;
      }
      if (typeof props[tagName] !== "undefined") {
        warn(`Helmet: ${tagName} should be of type "Array". Instead found type "${typeof props[tagName]}"`);
      }
      return false;
    }).map(props => props[tagName]).reverse().reduce((approvedTags, instanceTags) => {
      const instanceSeenTags = {};
      instanceTags.filter(tag => {
        let primaryAttributeKey;
        const keys2 = Object.keys(tag);
        for (let i = 0; i < keys2.length; i += 1) {
          const attributeKey = keys2[i];
          const lowerCaseAttributeKey = attributeKey.toLowerCase();
          if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === "rel" /* REL */ && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === "rel" /* REL */ && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
            primaryAttributeKey = lowerCaseAttributeKey;
          }
          if (primaryAttributes.indexOf(attributeKey) !== -1 && (attributeKey === "innerHTML" /* INNER_HTML */ || attributeKey === "cssText" /* CSS_TEXT */ || attributeKey === "itemprop" /* ITEM_PROP */)) {
            primaryAttributeKey = attributeKey;
          }
        }
        if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
          return false;
        }
        const value = tag[primaryAttributeKey].toLowerCase();
        if (!approvedSeenTags[primaryAttributeKey]) {
          approvedSeenTags[primaryAttributeKey] = {};
        }
        if (!instanceSeenTags[primaryAttributeKey]) {
          instanceSeenTags[primaryAttributeKey] = {};
        }
        if (!approvedSeenTags[primaryAttributeKey][value]) {
          instanceSeenTags[primaryAttributeKey][value] = true;
          return true;
        }
        return false;
      }).reverse().forEach(tag => approvedTags.push(tag));
      const keys = Object.keys(instanceSeenTags);
      for (let i = 0; i < keys.length; i += 1) {
        const attributeKey = keys[i];
        const tagUnion = Object.assign({}, approvedSeenTags[attributeKey], instanceSeenTags[attributeKey]);
        approvedSeenTags[attributeKey] = tagUnion;
      }
      return approvedTags;
    }, []).reverse();
  };
  var getAnyTrueFromPropsList = (propsList, checkedTag) => {
    if (Array.isArray(propsList) && propsList.length) {
      for (let index = 0; index < propsList.length; index += 1) {
        const prop = propsList[index];
        if (prop[checkedTag]) {
          return true;
        }
      }
    }
    return false;
  };
  var reducePropsToState = propsList => ({
    baseTag: getBaseTagFromPropsList(["href" /* HREF */], propsList),
    bodyAttributes: getAttributesFromPropsList("bodyAttributes" /* BODY */, propsList),
    defer: getInnermostProperty(propsList, HELMET_PROPS.DEFER),
    encode: getInnermostProperty(propsList, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
    htmlAttributes: getAttributesFromPropsList("htmlAttributes" /* HTML */, propsList),
    linkTags: getTagsFromPropsList("link" /* LINK */, ["rel" /* REL */, "href" /* HREF */], propsList),
    metaTags: getTagsFromPropsList("meta" /* META */, ["name" /* NAME */, "charset" /* CHARSET */, "http-equiv" /* HTTPEQUIV */, "property" /* PROPERTY */, "itemprop" /* ITEM_PROP */], propsList),
    noscriptTags: getTagsFromPropsList("noscript" /* NOSCRIPT */, ["innerHTML" /* INNER_HTML */], propsList),
    onChangeClientState: getOnChangeClientState(propsList),
    scriptTags: getTagsFromPropsList("script" /* SCRIPT */, ["src" /* SRC */, "innerHTML" /* INNER_HTML */], propsList),
    styleTags: getTagsFromPropsList("style" /* STYLE */, ["cssText" /* CSS_TEXT */], propsList),
    title: getTitleFromPropsList(propsList),
    titleAttributes: getAttributesFromPropsList("titleAttributes" /* TITLE */, propsList),
    prioritizeSeoTags: getAnyTrueFromPropsList(propsList, HELMET_PROPS.PRIORITIZE_SEO_TAGS)
  });
  var flattenArray = possibleArray => Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
  var checkIfPropsMatch = (props, toMatch) => {
    const keys = Object.keys(props);
    for (let i = 0; i < keys.length; i += 1) {
      if (toMatch[keys[i]] && toMatch[keys[i]].includes(props[keys[i]])) {
        return true;
      }
    }
    return false;
  };
  var prioritizer = (elementsList, propsToMatch) => {
    if (Array.isArray(elementsList)) {
      return elementsList.reduce((acc, elementAttrs) => {
        if (checkIfPropsMatch(elementAttrs, propsToMatch)) {
          acc.priority.push(elementAttrs);
        } else {
          acc.default.push(elementAttrs);
        }
        return acc;
      }, {
        priority: [],
        default: []
      });
    }
    return {
      default: elementsList,
      priority: []
    };
  };
  var without = (obj, key) => {
    return Object.assign({}, obj, {
      [key]: void 0
    });
  };

  // src/server.ts
  var SELF_CLOSING_TAGS = ["noscript" /* NOSCRIPT */, "script" /* SCRIPT */, "style" /* STYLE */];
  var encodeSpecialCharacters = (str, encode = true) => {
    if (encode === false) {
      return String(str);
    }
    return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  };
  var generateElementAttributesAsString = attributes => Object.keys(attributes).reduce((str, key) => {
    const attr = typeof attributes[key] !== "undefined" ? `${key}="${attributes[key]}"` : `${key}`;
    return str ? `${str} ${attr}` : attr;
  }, "");
  var generateTitleAsString = (type, title, attributes, encode) => {
    const attributeString = generateElementAttributesAsString(attributes);
    const flattenedTitle = flattenArray(title);
    return attributeString ? `<${type} ${HELMET_ATTRIBUTE}="true" ${attributeString}>${encodeSpecialCharacters(flattenedTitle, encode)}</${type}>` : `<${type} ${HELMET_ATTRIBUTE}="true">${encodeSpecialCharacters(flattenedTitle, encode)}</${type}>`;
  };
  var generateTagsAsString = (type, tags, encode = true) => tags.reduce((str, t) => {
    const tag = t;
    const attributeHtml = Object.keys(tag).filter(attribute => !(attribute === "innerHTML" /* INNER_HTML */ || attribute === "cssText" /* CSS_TEXT */)).reduce((string, attribute) => {
      const attr = typeof tag[attribute] === "undefined" ? attribute : `${attribute}="${encodeSpecialCharacters(tag[attribute], encode)}"`;
      return string ? `${string} ${attr}` : attr;
    }, "");
    const tagContent = tag.innerHTML || tag.cssText || "";
    const isSelfClosing = SELF_CLOSING_TAGS.indexOf(type) === -1;
    return `${str}<${type} ${HELMET_ATTRIBUTE}="true" ${attributeHtml}${isSelfClosing ? `/>` : `>${tagContent}</${type}>`}`;
  }, "");
  var convertElementAttributesToReactProps = (attributes, initProps = {}) => Object.keys(attributes).reduce((obj, key) => {
    const mapped = REACT_TAG_MAP[key];
    obj[mapped || key] = attributes[key];
    return obj;
  }, initProps);
  var generateTitleAsReactComponent = (_type, title, attributes) => {
    const initProps = {
      key: title,
      [HELMET_ATTRIBUTE]: true
    };
    const props = convertElementAttributesToReactProps(attributes, initProps);
    return [import_react.default.createElement("title" /* TITLE */, props, title)];
  };
  var generateTagsAsReactComponent = (type, tags) => tags.map((tag, i) => {
    const mappedTag = {
      key: i,
      [HELMET_ATTRIBUTE]: true
    };
    Object.keys(tag).forEach(attribute => {
      const mapped = REACT_TAG_MAP[attribute];
      const mappedAttribute = mapped || attribute;
      if (mappedAttribute === "innerHTML" /* INNER_HTML */ || mappedAttribute === "cssText" /* CSS_TEXT */) {
        const content = tag.innerHTML || tag.cssText;
        mappedTag.dangerouslySetInnerHTML = {
          __html: content
        };
      } else {
        mappedTag[mappedAttribute] = tag[attribute];
      }
    });
    return import_react.default.createElement(type, mappedTag);
  });
  var getMethodsForTag = (type, tags, encode = true) => {
    switch (type) {
      case "title" /* TITLE */:
        return {
          toComponent: () => generateTitleAsReactComponent(type, tags.title, tags.titleAttributes),
          toString: () => generateTitleAsString(type, tags.title, tags.titleAttributes, encode)
        };
      case "bodyAttributes" /* BODY */:
      case "htmlAttributes" /* HTML */:
        return {
          toComponent: () => convertElementAttributesToReactProps(tags),
          toString: () => generateElementAttributesAsString(tags)
        };
      default:
        return {
          toComponent: () => generateTagsAsReactComponent(type, tags),
          toString: () => generateTagsAsString(type, tags, encode)
        };
    }
  };
  var getPriorityMethods = ({
    metaTags,
    linkTags,
    scriptTags,
    encode
  }) => {
    const meta = prioritizer(metaTags, SEO_PRIORITY_TAGS.meta);
    const link = prioritizer(linkTags, SEO_PRIORITY_TAGS.link);
    const script = prioritizer(scriptTags, SEO_PRIORITY_TAGS.script);
    const priorityMethods = {
      toComponent: () => [...generateTagsAsReactComponent("meta" /* META */, meta.priority), ...generateTagsAsReactComponent("link" /* LINK */, link.priority), ...generateTagsAsReactComponent("script" /* SCRIPT */, script.priority)],
      toString: () =>
      // generate all the tags as strings and concatenate them
      `${getMethodsForTag("meta" /* META */, meta.priority, encode)} ${getMethodsForTag("link" /* LINK */, link.priority, encode)} ${getMethodsForTag("script" /* SCRIPT */, script.priority, encode)}`
    };
    return {
      priorityMethods,
      metaTags: meta.default,
      linkTags: link.default,
      scriptTags: script.default
    };
  };
  var mapStateOnServer = props => {
    const {
      baseTag,
      bodyAttributes,
      encode = true,
      htmlAttributes,
      noscriptTags,
      styleTags,
      title = "",
      titleAttributes,
      prioritizeSeoTags
    } = props;
    let {
      linkTags,
      metaTags,
      scriptTags
    } = props;
    let priorityMethods = {
      toComponent: () => {},
      toString: () => ""
    };
    if (prioritizeSeoTags) {
      ({
        priorityMethods,
        linkTags,
        metaTags,
        scriptTags
      } = getPriorityMethods(props));
    }
    return {
      priority: priorityMethods,
      base: getMethodsForTag("base" /* BASE */, baseTag, encode),
      bodyAttributes: getMethodsForTag("bodyAttributes" /* BODY */, bodyAttributes, encode),
      htmlAttributes: getMethodsForTag("htmlAttributes" /* HTML */, htmlAttributes, encode),
      link: getMethodsForTag("link" /* LINK */, linkTags, encode),
      meta: getMethodsForTag("meta" /* META */, metaTags, encode),
      noscript: getMethodsForTag("noscript" /* NOSCRIPT */, noscriptTags, encode),
      script: getMethodsForTag("script" /* SCRIPT */, scriptTags, encode),
      style: getMethodsForTag("style" /* STYLE */, styleTags, encode),
      title: getMethodsForTag("title" /* TITLE */, {
        title,
        titleAttributes
      }, encode)
    };
  };
  var server_default = mapStateOnServer;

  // src/HelmetData.ts
  var instances = [];
  var isDocument = !!(typeof window !== "undefined" && window.document && window.document.createElement);
  var HelmetData = class {
    instances = [];
    canUseDOM = isDocument;
    value = {
      setHelmet: serverState => {
        this.context.helmet = serverState;
      },
      helmetInstances: {
        get: () => this.canUseDOM ? instances : this.instances,
        add: instance => {
          (this.canUseDOM ? instances : this.instances).push(instance);
        },
        remove: instance => {
          const index = (this.canUseDOM ? instances : this.instances).indexOf(instance);
          (this.canUseDOM ? instances : this.instances).splice(index, 1);
        }
      }
    };
    constructor(context, canUseDOM) {
      this.context = context;
      this.canUseDOM = canUseDOM || false;
      if (!canUseDOM) {
        context.helmet = server_default({
          baseTag: [],
          bodyAttributes: {},
          encodeSpecialCharacters: true,
          htmlAttributes: {},
          linkTags: [],
          metaTags: [],
          noscriptTags: [],
          scriptTags: [],
          styleTags: [],
          title: "",
          titleAttributes: {}
        });
      }
    }
  };

  // src/Provider.tsx
  var defaultValue = {};
  var Context = import_react2.default.createContext(defaultValue);
  var HelmetProvider = class _HelmetProvider extends import_react2.Component {
    static canUseDOM = isDocument;
    constructor(props) {
      super(props);
      this.helmetData = new HelmetData(this.props.context || {}, _HelmetProvider.canUseDOM);
    }
    render() {
      return /* @__PURE__ */import_react2.default.createElement(Context.Provider, {
        value: this.helmetData.value
      }, this.props.children);
    }
  };

  // src/Dispatcher.tsx
  var import_react3 = require(_dependencyMap[1], "react");
  var import_shallowequal = __toESM(require(_dependencyMap[4], "shallowequal"));

  // src/client.ts
  var updateTags = (type, tags) => {
    const headElement = document.head || document.querySelector("head" /* HEAD */);
    const tagNodes = headElement.querySelectorAll(`${type}[${HELMET_ATTRIBUTE}]`);
    const oldTags = [].slice.call(tagNodes);
    const newTags = [];
    let indexToDelete;
    if (tags && tags.length) {
      tags.forEach(tag => {
        const newElement = document.createElement(type);
        for (const attribute in tag) {
          if (Object.prototype.hasOwnProperty.call(tag, attribute)) {
            if (attribute === "innerHTML" /* INNER_HTML */) {
              newElement.innerHTML = tag.innerHTML;
            } else if (attribute === "cssText" /* CSS_TEXT */) {
              if (newElement.styleSheet) {
                newElement.styleSheet.cssText = tag.cssText;
              } else {
                newElement.appendChild(document.createTextNode(tag.cssText));
              }
            } else {
              const attr = attribute;
              const value = typeof tag[attr] === "undefined" ? "" : tag[attr];
              newElement.setAttribute(attribute, value);
            }
          }
        }
        newElement.setAttribute(HELMET_ATTRIBUTE, "true");
        if (oldTags.some((existingTag, index) => {
          indexToDelete = index;
          return newElement.isEqualNode(existingTag);
        })) {
          oldTags.splice(indexToDelete, 1);
        } else {
          newTags.push(newElement);
        }
      });
    }
    oldTags.forEach(tag => tag.parentNode?.removeChild(tag));
    newTags.forEach(tag => headElement.appendChild(tag));
    return {
      oldTags,
      newTags
    };
  };
  var updateAttributes = (tagName, attributes) => {
    const elementTag = document.getElementsByTagName(tagName)[0];
    if (!elementTag) {
      return;
    }
    const helmetAttributeString = elementTag.getAttribute(HELMET_ATTRIBUTE);
    const helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
    const attributesToRemove = [...helmetAttributes];
    const attributeKeys = Object.keys(attributes);
    for (const attribute of attributeKeys) {
      const value = attributes[attribute] || "";
      if (elementTag.getAttribute(attribute) !== value) {
        elementTag.setAttribute(attribute, value);
      }
      if (helmetAttributes.indexOf(attribute) === -1) {
        helmetAttributes.push(attribute);
      }
      const indexToSave = attributesToRemove.indexOf(attribute);
      if (indexToSave !== -1) {
        attributesToRemove.splice(indexToSave, 1);
      }
    }
    for (let i = attributesToRemove.length - 1; i >= 0; i -= 1) {
      elementTag.removeAttribute(attributesToRemove[i]);
    }
    if (helmetAttributes.length === attributesToRemove.length) {
      elementTag.removeAttribute(HELMET_ATTRIBUTE);
    } else if (elementTag.getAttribute(HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
      elementTag.setAttribute(HELMET_ATTRIBUTE, attributeKeys.join(","));
    }
  };
  var updateTitle = (title, attributes) => {
    if (typeof title !== "undefined" && document.title !== title) {
      document.title = flattenArray(title);
    }
    updateAttributes("title" /* TITLE */, attributes);
  };
  var commitTagChanges = (newState, cb) => {
    const {
      baseTag,
      bodyAttributes,
      htmlAttributes,
      linkTags,
      metaTags,
      noscriptTags,
      onChangeClientState,
      scriptTags,
      styleTags,
      title,
      titleAttributes
    } = newState;
    updateAttributes("body" /* BODY */, bodyAttributes);
    updateAttributes("html" /* HTML */, htmlAttributes);
    updateTitle(title, titleAttributes);
    const tagUpdates = {
      baseTag: updateTags("base" /* BASE */, baseTag),
      linkTags: updateTags("link" /* LINK */, linkTags),
      metaTags: updateTags("meta" /* META */, metaTags),
      noscriptTags: updateTags("noscript" /* NOSCRIPT */, noscriptTags),
      scriptTags: updateTags("script" /* SCRIPT */, scriptTags),
      styleTags: updateTags("style" /* STYLE */, styleTags)
    };
    const addedTags = {};
    const removedTags = {};
    Object.keys(tagUpdates).forEach(tagType => {
      const {
        newTags,
        oldTags
      } = tagUpdates[tagType];
      if (newTags.length) {
        addedTags[tagType] = newTags;
      }
      if (oldTags.length) {
        removedTags[tagType] = tagUpdates[tagType].oldTags;
      }
    });
    if (cb) {
      cb();
    }
    onChangeClientState(newState, addedTags, removedTags);
  };
  var _helmetCallback = null;
  var handleStateChangeOnClient = newState => {
    if (_helmetCallback) {
      cancelAnimationFrame(_helmetCallback);
    }
    if (newState.defer) {
      _helmetCallback = requestAnimationFrame(() => {
        commitTagChanges(newState, () => {
          _helmetCallback = null;
        });
      });
    } else {
      commitTagChanges(newState);
      _helmetCallback = null;
    }
  };
  var client_default = handleStateChangeOnClient;

  // src/Dispatcher.tsx
  var HelmetDispatcher = class extends import_react3.Component {
    rendered = false;
    shouldComponentUpdate(nextProps) {
      return !(0, import_shallowequal.default)(nextProps, this.props);
    }
    componentDidUpdate() {
      this.emitChange();
    }
    componentWillUnmount() {
      const {
        helmetInstances
      } = this.props.context;
      helmetInstances.remove(this);
      this.emitChange();
    }
    emitChange() {
      const {
        helmetInstances,
        setHelmet
      } = this.props.context;
      let serverState = null;
      const state = reducePropsToState(helmetInstances.get().map(instance => {
        const props = Object.assign({}, instance.props);
        delete props.context;
        return props;
      }));
      if (HelmetProvider.canUseDOM) {
        client_default(state);
      } else if (server_default) {
        serverState = server_default(state);
      }
      setHelmet(serverState);
    }
    // componentWillMount will be deprecated
    // for SSR, initialize on first render
    // constructor is also unsafe in StrictMode
    init() {
      if (this.rendered) {
        return;
      }
      this.rendered = true;
      const {
        helmetInstances
      } = this.props.context;
      helmetInstances.add(this);
      this.emitChange();
    }
    render() {
      this.init();
      return null;
    }
  };

  // src/index.tsx
  var Helmet = class extends import_react4.Component {
    static defaultProps = {
      defer: true,
      encodeSpecialCharacters: true,
      prioritizeSeoTags: false
    };
    shouldComponentUpdate(nextProps) {
      return !(0, import_react_fast_compare.default)(without(this.props, "helmetData"), without(nextProps, "helmetData"));
    }
    mapNestedChildrenToProps(child, nestedChildren) {
      if (!nestedChildren) {
        return null;
      }
      switch (child.type) {
        case "script" /* SCRIPT */:
        case "noscript" /* NOSCRIPT */:
          return {
            innerHTML: nestedChildren
          };
        case "style" /* STYLE */:
          return {
            cssText: nestedChildren
          };
        default:
          throw new Error(`<${child.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`);
      }
    }
    flattenArrayTypeChildren(child, arrayTypeChildren, newChildProps, nestedChildren) {
      return Object.assign({}, arrayTypeChildren, {
        [child.type]: [...(arrayTypeChildren[child.type] || []), Object.assign({}, newChildProps, this.mapNestedChildrenToProps(child, nestedChildren))]
      });
    }
    mapObjectTypeChildren(child, newProps, newChildProps, nestedChildren) {
      switch (child.type) {
        case "title" /* TITLE */:
          return Object.assign({}, newProps, {
            [child.type]: nestedChildren,
            titleAttributes: Object.assign({}, newChildProps)
          });
        case "body" /* BODY */:
          return Object.assign({}, newProps, {
            bodyAttributes: Object.assign({}, newChildProps)
          });
        case "html" /* HTML */:
          return Object.assign({}, newProps, {
            htmlAttributes: Object.assign({}, newChildProps)
          });
        default:
          return Object.assign({}, newProps, {
            [child.type]: Object.assign({}, newChildProps)
          });
      }
    }
    mapArrayTypeChildrenToProps(arrayTypeChildren, newProps) {
      let newFlattenedProps = Object.assign({}, newProps);
      Object.keys(arrayTypeChildren).forEach(arrayChildName => {
        newFlattenedProps = Object.assign({}, newFlattenedProps, {
          [arrayChildName]: arrayTypeChildren[arrayChildName]
        });
      });
      return newFlattenedProps;
    }
    warnOnInvalidChildren(child, nestedChildren) {
      (0, import_invariant.default)(VALID_TAG_NAMES.some(name => child.type === name), typeof child.type === "function" ? `You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.` : `Only elements types ${VALID_TAG_NAMES.join(", ")} are allowed. Helmet does not support rendering <${child.type}> elements. Refer to our API for more information.`);
      (0, import_invariant.default)(!nestedChildren || typeof nestedChildren === "string" || Array.isArray(nestedChildren) && !nestedChildren.some(nestedChild => typeof nestedChild !== "string"), `Helmet expects a string as a child of <${child.type}>. Did you forget to wrap your children in braces? ( <${child.type}>{\`\`}</${child.type}> ) Refer to our API for more information.`);
      return true;
    }
    mapChildrenToProps(children, newProps) {
      let arrayTypeChildren = {};
      import_react4.default.Children.forEach(children, child => {
        if (!child || !child.props) {
          return;
        }
        const _child$props = child.props,
          {
            children: nestedChildren
          } = _child$props,
          childProps = _objectWithoutPropertiesLoose(_child$props, _excluded);
        const newChildProps = Object.keys(childProps).reduce((obj, key) => {
          obj[HTML_TAG_MAP[key] || key] = childProps[key];
          return obj;
        }, {});
        let {
          type
        } = child;
        if (typeof type === "symbol") {
          type = type.toString();
        } else {
          this.warnOnInvalidChildren(child, nestedChildren);
        }
        switch (type) {
          case "Symbol(react.fragment)" /* FRAGMENT */:
            newProps = this.mapChildrenToProps(nestedChildren, newProps);
            break;
          case "link" /* LINK */:
          case "meta" /* META */:
          case "noscript" /* NOSCRIPT */:
          case "script" /* SCRIPT */:
          case "style" /* STYLE */:
            arrayTypeChildren = this.flattenArrayTypeChildren(child, arrayTypeChildren, newChildProps, nestedChildren);
            break;
          default:
            newProps = this.mapObjectTypeChildren(child, newProps, newChildProps, nestedChildren);
            break;
        }
      });
      return this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);
    }
    render() {
      const _this$props = this.props,
        {
          children
        } = _this$props,
        props = _objectWithoutPropertiesLoose(_this$props, _excluded2);
      let newProps = Object.assign({}, props);
      let {
        helmetData
      } = props;
      if (children) {
        newProps = this.mapChildrenToProps(children, newProps);
      }
      if (helmetData && !(helmetData instanceof HelmetData)) {
        const data = helmetData;
        helmetData = new HelmetData(data.context, true);
        delete newProps.helmetData;
      }
      return helmetData ? /* @__PURE__ */import_react4.default.createElement(HelmetDispatcher, Object.assign({}, newProps, {
        context: helmetData.value
      })) : /* @__PURE__ */import_react4.default.createElement(Context.Consumer, null, context => /* @__PURE__ */import_react4.default.createElement(HelmetDispatcher, Object.assign({}, newProps, {
        context
      })));
    }
  };
},738,[759,9,739,628,740],"node_modules/expo-router/vendor/react-helmet-async/lib/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /* global Map:readonly, Set:readonly, ArrayBuffer:readonly */

  var hasElementType = typeof Element !== 'undefined';
  var hasMap = typeof Map === 'function';
  var hasSet = typeof Set === 'function';
  var hasArrayBuffer = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView;

  // Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js

  function equal(a, b) {
    // START: fast-deep-equal es6/index.js 3.1.3
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
        return true;
      }

      // START: Modifications:
      // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code
      //    to co-exist with es5.
      // 2. Replace `for of` with es5 compliant iteration using `for`.
      //    Basically, take:
      //
      //    ```js
      //    for (i of a.entries())
      //      if (!b.has(i[0])) return false;
      //    ```
      //
      //    ... and convert to:
      //
      //    ```js
      //    it = a.entries();
      //    while (!(i = it.next()).done)
      //      if (!b.has(i.value[0])) return false;
      //    ```
      //
      //    **Note**: `i` access switches to `i.value`.
      var it;
      if (hasMap && a instanceof Map && b instanceof Map) {
        if (a.size !== b.size) return false;
        it = a.entries();
        while (!(i = it.next()).done) if (!b.has(i.value[0])) return false;
        it = a.entries();
        while (!(i = it.next()).done) if (!equal(i.value[1], b.get(i.value[0]))) return false;
        return true;
      }
      if (hasSet && a instanceof Set && b instanceof Set) {
        if (a.size !== b.size) return false;
        it = a.entries();
        while (!(i = it.next()).done) if (!b.has(i.value[0])) return false;
        return true;
      }
      // END: Modifications

      if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0;) if (a[i] !== b[i]) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      // START: Modifications:
      // Apply guards for `Object.create(null)` handling. See:
      // - https://github.com/FormidableLabs/react-fast-compare/issues/64
      // - https://github.com/epoberezkin/fast-deep-equal/issues/49
      if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === 'function' && typeof b.valueOf === 'function') return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString && typeof a.toString === 'function' && typeof b.toString === 'function') return a.toString() === b.toString();
      // END: Modifications

      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      // END: fast-deep-equal

      // START: react-fast-compare
      // custom handling for DOM elements
      if (hasElementType && a instanceof Element) return false;

      // custom handling for React/Preact
      for (i = length; i-- !== 0;) {
        if ((keys[i] === '_owner' || keys[i] === '__v' || keys[i] === '__o') && a.$$typeof) {
          // React-specific: avoid traversing React elements' _owner
          // Preact-specific: avoid traversing Preact elements' __v and __o
          //    __v = $_original / $_vnode
          //    __o = $_owner
          // These properties contain circular references and are not needed when
          // comparing the actual elements (and not their owners)
          // .$$typeof and ._store on just reasonable markers of elements

          continue;
        }

        // all other properties should be traversed as usual
        if (!equal(a[keys[i]], b[keys[i]])) return false;
      }
      // END: react-fast-compare

      // START: fast-deep-equal
      return true;
    }
    return a !== a && b !== b;
  }
  // end fast-deep-equal

  module.exports = function isEqual(a, b) {
    try {
      return equal(a, b);
    } catch (error) {
      if ((error.message || '').match(/stack|recursion/i)) {
        // warn on circular references, don't crash
        // browsers give this different errors name and messages:
        // chrome/safari: "RangeError", "Maximum call stack size exceeded"
        // firefox: "InternalError", too much recursion"
        // edge: "Error", "Out of stack space"
        console.warn('react-fast-compare cannot handle circular refs');
        return false;
      }
      // some other error. we should definitely know about these
      throw error;
    }
  };
},739,[],"node_modules/react-fast-compare/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  //

  module.exports = function shallowEqual(objA, objB, compare, compareContext) {
    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
    if (ret !== void 0) {
      return !!ret;
    }
    if (objA === objB) {
      return true;
    }
    if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
      return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

    // Test for A's keys different from B.
    for (var idx = 0; idx < keysA.length; idx++) {
      var key = keysA[idx];
      if (!bHasOwnProperty(key)) {
        return false;
      }
      var valueA = objA[key];
      var valueB = objB[key];
      ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
      if (ret === false || ret === void 0 && valueA !== valueB) {
        return false;
      }
    }
    return true;
  };
},740,[],"node_modules/shallowequal/index.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * This is a hack for Expo Router to support Fast Refresh on _layout files
   *
   * Fast Refresh only works when:
   *  - Files only export React Components
   *  - All inverse dependencies only export React Components
   *
   * Expo Router's _layout files support exporting both 'unstable_settings' and 'ErrorBoundary'
   *
   * 'unstable_settings':
   *  - This is a plain object, so it will break Fast Refresh
   *
   * 'ErrorBoundary'
   *  - While this is a React component, it is imported from 'expo-router'
   *  - 'expo-router' has an inverse dependency on _ctx, which is a require.context object
   *
   * 'generateStaticParams'
   *  - This is a function that is not a React Component, so it will break Fast Refresh
   *
   *
   * To resolve this issue, we extend ReactRefresh to flag these exports as React components
   *
   * @see https://reactnative.dev/docs/fast-refresh
   */
  if (process.env.NODE_ENV === 'development') {
    if (
    // Should be a string at runtime
    typeof __METRO_GLOBAL_PREFIX__ !== 'undefined' &&
    // Should be set by Metro's require polyfill
    global[__METRO_GLOBAL_PREFIX__ + '__ReactRefresh']) {
      // source: https://github.com/facebook/metro/blob/main/packages/metro-runtime/src/polyfills/require.js
      // TODO(@kitten): Add type for this and use `globalThis` over `global`
      const Refresh = global[__METRO_GLOBAL_PREFIX__ + '__ReactRefresh'];
      // Keep a reference to the original
      const isLikelyComponentType = Refresh.isLikelyComponentType;
      // Modules can be dereferenced at any time
      const expoRouterExports = new WeakSet();
      Object.assign(Refresh, {
        /*
         * isLikelyComponentType is called twice.
         *   1. Initially with a modules export object
         *   2. With each individual export of a module
         */
        isLikelyComponentType(value) {
          try {
            if (typeof value === 'object') {
              if ('unstable_settings' in value) {
                expoRouterExports.add(value.unstable_settings);
              }
              if ('ErrorBoundary' in value) {
                expoRouterExports.add(value.ErrorBoundary);
              }
              if ('generateStaticParams' in value) {
                expoRouterExports.add(value.generateStaticParams);
              }
            }
          } catch {
            // Ignore - we're just trying to avoid breaking Fast Refresh by using exports
            // that aren't JS objects valid as keys for the WeakSet - like we've seen with
            // some JSI::HostObject instances that are exported in a module - see #33670
            // https://github.com/expo/expo/issues/33670
          }
          return expoRouterExports.has(value) || isLikelyComponentType(value);
        }
      });
    }
  }
},741,[],"node_modules/expo-router/build/fast-refresh.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _reactJsxDevRuntime = require(_dependencyMap[0], "react/jsx-dev-runtime");
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-router\\build\\renderRootComponent.js";
  var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function () {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });
  var __importStar = this && this.__importStar || function () {
    var ownKeys = function (o) {
      ownKeys = Object.getOwnPropertyNames || function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  }();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.renderRootComponent = renderRootComponent;
  const expo_1 = require(_dependencyMap[1], "expo");
  const React = __importStar(require(_dependencyMap[2], "react"));
  const react_native_1 = require(_dependencyMap[3], "react-native-web/dist/index");
  const SplashScreen = __importStar(require(_dependencyMap[4], "./utils/splash"));
  function isBaseObject(obj) {
    if (Object.prototype.toString.call(obj) !== '[object Object]') {
      return false;
    }
    const proto = Object.getPrototypeOf(obj);
    if (proto === null) {
      return true;
    }
    return proto === Object.prototype;
  }
  function isErrorShaped(error) {
    return error && typeof error === 'object' && typeof error.name === 'string' && typeof error.message === 'string';
  }
  /**
   * After we throw this error, any number of tools could handle it.
   * This check ensures the error is always in a reason state before surfacing it to the runtime.
   */
  function convertError(error) {
    if (isErrorShaped(error)) {
      return error;
    }
    if (process.env.NODE_ENV === 'development') {
      if (error == null) {
        return new Error('A null/undefined error was thrown.');
      }
    }
    if (isBaseObject(error)) {
      return new Error(JSON.stringify(error));
    }
    return new Error(String(error));
  }
  /**
   * Register and mount the root component using the predefined rendering
   * method. This function ensures the Splash Screen and errors are handled correctly.
   */
  function renderRootComponent(Component) {
    try {
      // This must be delayed so the user has a chance to call it first.
      setTimeout(() => {
        SplashScreen._internal_preventAutoHideAsync?.();
      });
      React.startTransition(() => {
        if (process.env.NODE_ENV !== 'production') {
          const {
            withErrorOverlay
          } = require(_dependencyMap[5], "@expo/metro-runtime/error-overlay");
          (0, expo_1.registerRootComponent)(withErrorOverlay(Component));
        } else {
          (0, expo_1.registerRootComponent)(Component);
        }
      });
    } catch (e) {
      // Hide the splash screen if there was an error so the user can see it.
      SplashScreen.hideAsync();
      const error = convertError(e);
      // Prevent the app from throwing confusing:
      //  ERROR  Invariant Violation: "main" has not been registered. This can happen if:
      // * Metro (the local dev server) is run from the wrong folder. Check if Metro is running, stop it and restart it in the current project.
      // * A module failed to load due to an error and `AppRegistry.registerComponent` wasn't called.
      (0, expo_1.registerRootComponent)(() => /*#__PURE__*/_reactJsxDevRuntime.jsxDEV(react_native_1.View, {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 103,
        columnNumber: 49
      }, this));
      // Console is pretty useless on native, on web you get interactive stack traces.
      if (true) {
        console.error(error);
        console.error(`A runtime error has occurred while rendering the root component.`);
      }
      // Give React a tick to render before throwing.
      setTimeout(() => {
        throw error;
      });
      // TODO: Render a production-only error screen.
    }
  }
},742,[33,550,9,492,549,743],"node_modules/expo-router/build/renderRootComponent.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  var _srcErrorOverlay = require(_dependencyMap[0], "./src/error-overlay");
  Object.keys(_srcErrorOverlay).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _srcErrorOverlay[k];
        }
      });
    }
  });
},743,[744],"node_modules/@expo/metro-runtime/error-overlay.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\index.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.withErrorOverlay = withErrorOverlay;
  require(_dependencyMap[0], "react");
  var _reactJsxDevRuntime = require(_dependencyMap[1], "react/jsx-dev-runtime");
  if (process.env.NODE_ENV === 'development' && true) {
    // Stack traces are big with React Navigation
    require(_dependencyMap[2], "./LogBox").default.install();
  }
  function withErrorOverlay(Comp) {
    if (process.env.NODE_ENV === 'production') {
      return Comp;
    }
    const {
      default: ErrorToastContainer
    } = require(_dependencyMap[3], "./toast/ErrorToastContainer");
    return function ErrorOverlay(props) {
      return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ErrorToastContainer, {
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Comp, Object.assign({}, props), void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 19,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 18,
        columnNumber: 7
      }, this);
    };
  }
},744,[9,33,7,745],"node_modules/@expo/metro-runtime/src/error-overlay/index.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\toast\\ErrorToastContainer.web.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  exports.ErrorToastContainer = ErrorToastContainer;
  var _react = require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[1], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsView = require(_dependencyMap[2], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _ErrorToast = require(_dependencyMap[3], "./ErrorToast");
  var _DataLogBoxData = require(_dependencyMap[4], "../Data/LogBoxData");
  var LogBoxData = _interopNamespace(_DataLogBoxData);
  var _DataLogContext = require(_dependencyMap[5], "../Data/LogContext");
  var _useRejectionHandler = require(_dependencyMap[6], "../useRejectionHandler");
  var _reactJsxDevRuntime = require(_dependencyMap[7], "react/jsx-dev-runtime");
  function ErrorToastContainer() {
    (0, _useRejectionHandler.useRejectionHandler)();
    const {
      logs,
      isDisabled
    } = (0, _DataLogContext.useLogs)();
    if (!logs.length || isDisabled) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ErrorToastStack, {
      logs: logs
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 23,
      columnNumber: 10
    }, this);
  }
  function ErrorToastStack({
    logs
  }) {
    const onDismissWarns = (0, _react.useCallback)(() => {
      LogBoxData.clearWarnings();
    }, []);
    const onDismissErrors = (0, _react.useCallback)(() => {
      LogBoxData.clearErrors();
    }, []);
    const setSelectedLog = (0, _react.useCallback)(index => {
      LogBoxData.setSelectedLog(index);
    }, []);
    function openLog(log) {
      let index = logs.length - 1;

      // Stop at zero because if we don't find any log, we'll open the first log.
      while (index > 0 && logs[index] !== log) {
        index -= 1;
      }
      setSelectedLog(index);
    }
    const warnings = (0, _react.useMemo)(() => logs.filter(log => log.level === 'warn'), [logs]);
    const errors = (0, _react.useMemo)(() => logs.filter(log => log.level === 'error' || log.level === 'fatal'), [logs]);
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: styles.list,
      children: [warnings.length > 0 && /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_ErrorToast.ErrorToast, {
        log: warnings[warnings.length - 1],
        level: "warn",
        totalLogCount: warnings.length,
        onPressOpen: () => openLog(warnings[warnings.length - 1]),
        onPressDismiss: onDismissWarns
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 59,
        columnNumber: 9
      }, this), errors.length > 0 && /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_ErrorToast.ErrorToast, {
        log: errors[errors.length - 1],
        level: "error",
        totalLogCount: errors.length,
        onPressOpen: () => openLog(errors[errors.length - 1]),
        onPressDismiss: onDismissErrors
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 69,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 57,
      columnNumber: 5
    }, this);
  }
  const styles = StyleSheet.default.create({
    list: {
      bottom: 6,
      left: 10,
      right: 10,
      maxWidth: 320,
      // @ts-expect-error
      position: 'fixed'
    }
  });
  var _default = LogBoxData.withSubscription(ErrorToastContainer);
},745,[9,55,110,746,8,21,749,33],"node_modules/@expo/metro-runtime/src/error-overlay/toast/ErrorToastContainer.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\toast\\ErrorToast.tsx";
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.ErrorToast = ErrorToast;
  var _react = require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsImage = require(_dependencyMap[1], "react-native-web/dist/exports/Image");
  var Image = _interopDefault(_reactNativeWebDistExportsImage);
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[2], "react-native-web/dist/exports/Platform");
  var Platform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _reactNativeWebDistExportsPressable = require(_dependencyMap[3], "react-native-web/dist/exports/Pressable");
  var Pressable = _interopDefault(_reactNativeWebDistExportsPressable);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[4], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[5], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsView = require(_dependencyMap[6], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _ErrorToastMessage = require(_dependencyMap[7], "./ErrorToastMessage");
  var _DataLogBoxData = require(_dependencyMap[8], "../Data/LogBoxData");
  var LogBoxData = _interopNamespace(_DataLogBoxData);
  var _UILogBoxStyle = require(_dependencyMap[9], "../UI/LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_UILogBoxStyle);
  var _reactJsxDevRuntime = require(_dependencyMap[10], "react/jsx-dev-runtime");
  function useSymbolicatedLog(log) {
    // Eagerly symbolicate so the stack is available when pressing to inspect.
    (0, _react.useEffect)(() => {
      LogBoxData.symbolicateLogLazy('stack', log);
      LogBoxData.symbolicateLogLazy('component', log);
    }, [log]);
  }
  function ErrorToast(props) {
    const {
      totalLogCount,
      level,
      log
    } = props;
    useSymbolicatedLog(log);
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: toastStyles.container,
      children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Pressable.default, {
        style: {
          flex: 1
        },
        onPress: props.onPressOpen,
        children: ({
          /** @ts-expect-error: react-native types are broken. */
          hovered,
          pressed
        }) => /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
          style: [toastStyles.press, {
            // @ts-expect-error: web-only type
            transitionDuration: '150ms',
            backgroundColor: pressed ? '#323232' : hovered ? '#111111' : LogBoxStyle.getBackgroundColor()
          }],
          children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Count, {
            count: totalLogCount,
            level: level
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 58,
            columnNumber: 13
          }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_ErrorToastMessage.ErrorToastMessage, {
            message: log.message
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 59,
            columnNumber: 13
          }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Dismiss, {
            onPress: props.onPressDismiss
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 60,
            columnNumber: 13
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 45,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 39,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 38,
      columnNumber: 5
    }, this);
  }
  function Count({
    count,
    level
  }) {
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: [countStyles.inside, countStyles[level]],
      children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
        style: countStyles.text,
        children: count <= 1 ? '!' : count
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 71,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 70,
      columnNumber: 5
    }, this);
  }
  function Dismiss({
    onPress
  }) {
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Pressable.default, {
      style: {
        marginLeft: 5
      },
      hitSlop: {
        top: 12,
        right: 10,
        bottom: 12,
        left: 10
      },
      onPress: onPress,
      children: ({
        /** @ts-expect-error: react-native types are broken. */
        hovered,
        pressed
      }) => /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
        style: [dismissStyles.press, hovered && {
          opacity: 0.8
        }, pressed && {
          opacity: 0.5
        }],
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Image.default, {
          source: require(_dependencyMap[11], "@expo/metro-runtime/assets/close.png"),
          style: dismissStyles.image
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 96,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 94,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 78,
      columnNumber: 5
    }, this);
  }
  const countStyles = StyleSheet.default.create({
    warn: {
      backgroundColor: LogBoxStyle.getWarningColor(1)
    },
    error: {
      backgroundColor: LogBoxStyle.getErrorColor(1)
    },
    log: {
      backgroundColor: LogBoxStyle.getLogColor(1)
    },
    inside: {
      marginRight: 8,
      minWidth: 22,
      aspectRatio: 1,
      paddingHorizontal: 4,
      borderRadius: 11,
      justifyContent: 'center',
      alignItems: 'center'
    },
    text: Object.assign({
      color: LogBoxStyle.getTextColor(1),
      fontSize: 14,
      lineHeight: 18,
      textAlign: 'center',
      fontWeight: '600'
    }, Platform.default.select({
      web: {
        textShadow: `0px 0px 3px ${LogBoxStyle.getBackgroundColor(0.8)}`
      }
    }))
  });
  const dismissStyles = StyleSheet.default.create({
    press: {
      backgroundColor: '#323232',
      height: 20,
      width: 20,
      borderRadius: 25,
      alignItems: 'center',
      justifyContent: 'center'
    },
    image: {
      height: 8,
      width: 8
    }
  });
  const toastStyles = StyleSheet.default.create({
    container: {
      height: 48,
      justifyContent: 'center',
      marginBottom: 4
    },
    press: {
      borderWidth: 1,
      borderRadius: 8,
      overflow: 'hidden',
      flexDirection: 'row',
      alignItems: 'center',
      borderColor: '#323232',
      backgroundColor: LogBoxStyle.getBackgroundColor(),
      flex: 1,
      paddingHorizontal: 12
    }
  });
},746,[9,155,14,143,55,138,110,747,8,136,33,748],"node_modules/@expo/metro-runtime/src/error-overlay/toast/ErrorToast.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\@expo\\metro-runtime\\src\\error-overlay\\toast\\ErrorToastMessage.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.ErrorToastMessage = ErrorToastMessage;
  require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[1], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[2], "react-native-web/dist/exports/Text");
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _UILogBoxMessage = require(_dependencyMap[3], "../UI/LogBoxMessage");
  var _UILogBoxStyle = require(_dependencyMap[4], "../UI/LogBoxStyle");
  var LogBoxStyle = _interopNamespace(_UILogBoxStyle);
  var _reactJsxDevRuntime = require(_dependencyMap[5], "react/jsx-dev-runtime");
  function ErrorToastMessage({
    message
  }) {
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(Text.default, {
      numberOfLines: 1,
      style: styles.text,
      children: message && /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_UILogBoxMessage.LogBoxMessage, {
        plaintext: true,
        message: message,
        style: styles.substitutionText
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 11,
        columnNumber: 19
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 10,
      columnNumber: 5
    }, this);
  }
  const styles = StyleSheet.default.create({
    text: {
      userSelect: 'none',
      paddingLeft: 8,
      color: LogBoxStyle.getTextColor(1),
      flex: 1,
      fontSize: 14,
      lineHeight: 22
    },
    substitutionText: {
      color: LogBoxStyle.getTextColor(0.6)
    }
  });
},747,[9,55,138,163,136,33],"node_modules/@expo/metro-runtime/src/error-overlay/toast/ErrorToastMessage.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fnode_modules%2F%40expo%2Fmetro-runtime%2Fassets/close.png",
    width: 28,
    height: 28
  };
},748,[],"node_modules/@expo/metro-runtime/assets/close.png");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.useRejectionHandler = useRejectionHandler;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopDefault(_react);
  var _modulesExceptionsManager = require(_dependencyMap[1], "./modules/ExceptionsManager");
  var ExceptionsManager = _interopDefault(_modulesExceptionsManager);
  function useStackTraceLimit(limit) {
    const current = React.default.useRef(0);
    React.default.useEffect(() => {
      try {
        // @ts-expect-error: StackTraceLimit is not defined in the Error type
        const currentLimit = Error.stackTraceLimit;
        // @ts-expect-error: StackTraceLimit is not defined in the Error type
        Error.stackTraceLimit = limit;
        current.current = currentLimit;
      } catch {}
      return () => {
        try {
          // @ts-expect-error: StackTraceLimit is not defined in the Error type
          Error.stackTraceLimit = current.current;
        } catch {}
      };
    }, [limit]);
  }
  function useRejectionHandler() {
    const hasError = React.default.useRef(false);
    useStackTraceLimit(35);
    React.default.useEffect(() => {
      function onUnhandledError(ev) {
        hasError.current = true;
        const error = ev?.error;
        if (!error || !(error instanceof Error) || typeof error.stack !== 'string') {
          return;
        }
        ExceptionsManager.default.handleException(error);
      }
      function onUnhandledRejection(ev) {
        hasError.current = true;
        const reason = ev?.reason;
        if (!reason || !(reason instanceof Error) || typeof reason.stack !== 'string') {
          return;
        }
        ExceptionsManager.default.handleException(reason);
      }
      window.addEventListener('unhandledrejection', onUnhandledRejection);
      window.addEventListener('error', onUnhandledError);
      return () => {
        window.removeEventListener('error', onUnhandledError);
        window.removeEventListener('unhandledrejection', onUnhandledRejection);
      };
    }, []);
    return hasError;
  }
},749,[9,241],"node_modules/@expo/metro-runtime/src/error-overlay/useRejectionHandler.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
},759,[],"node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets/loading2.gif",
    width: 400,
    height: 400
  };
},856,[],"assets/loading2.gif");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "/assets/?unstable_path=.%2Fassets/gohan.gif",
    width: 799,
    height: 1465
  };
},857,[],"assets/gohan.gif");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "Image", {
    enumerable: true,
    get: function () {
      return _Image.Image;
    }
  });
  Object.defineProperty(exports, "ImageBackground", {
    enumerable: true,
    get: function () {
      return _ImageBackground.ImageBackground;
    }
  });
  Object.defineProperty(exports, "useImage", {
    enumerable: true,
    get: function () {
      return _useImage.useImage;
    }
  });
  var _ImageTypes = require(_dependencyMap[0], "./Image.types");
  Object.keys(_ImageTypes).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _ImageTypes[k];
        }
      });
    }
  });
  var _Image = require(_dependencyMap[1], "./Image");
  var _ImageBackground = require(_dependencyMap[2], "./ImageBackground");
  var _useImage = require(_dependencyMap[3], "./useImage");
},862,[863,864,865,866],"node_modules/expo-image/src/index.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},863,[],"node_modules/expo-image/src/Image.types.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  const _excluded = ["style", "source", "placeholder", "contentFit", "contentPosition", "transition", "fadeDuration", "resizeMode", "defaultSource", "loadingIndicatorSource"],
    _excluded2 = ["resizeMode"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-image\\src\\Image.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "Image", {
    enumerable: true,
    get: function () {
      return Image;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _react = require(_dependencyMap[2], "react");
  var React = _interopDefault(_react);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _ExpoImage = require(_dependencyMap[4], "./ExpoImage");
  var ExpoImage = _interopDefault(_ExpoImage);
  var _ImageModule = require(_dependencyMap[5], "./ImageModule");
  var ImageModule = _interopDefault(_ImageModule);
  var _utils = require(_dependencyMap[6], "./utils");
  var _utilsResolveSources = require(_dependencyMap[7], "./utils/resolveSources");
  var _reactJsxDevRuntime = require(_dependencyMap[8], "react/jsx-dev-runtime");
  let loggedDefaultSourceDeprecationWarning = false;
  let loggedRenderingChildrenWarning = false;
  class Image extends React.default.PureComponent {
    constructor(props) {
      super(props);
      this.nativeViewRef = (0, _expoModulesCore.createSnapshotFriendlyRef)();
      this.containerViewRef = (0, _expoModulesCore.createSnapshotFriendlyRef)();
    }

    // Reanimated support on web
    getAnimatableRef = () => {
      if (_expoModulesCore.Platform.OS === 'web') {
        return this.containerViewRef.current;
      } else {
        return this;
      }
    };

    /**
     * @hidden
     */
    static Image = ImageModule.default.Image;

    /**
     * Preloads images at the given URLs that can be later used in the image view.
     * Preloaded images are cached to the memory and disk by default, so make sure
     * to use `disk` (default) or `memory-disk` [cache policy](#cachepolicy).
     * @param urls - A URL string or an array of URLs of images to prefetch.
     * @param {ImagePrefetchOptions['cachePolicy']} cachePolicy - The cache policy for prefetched images.
     * @return A promise resolving to `true` as soon as all images have been
     * successfully prefetched. If an image fails to be prefetched, the promise
     * will immediately resolve to `false` regardless of whether other images have
     * finished prefetching.
     */

    /**
     * Preloads images at the given URLs that can be later used in the image view.
     * Preloaded images are cached to the memory and disk by default, so make sure
     * to use `disk` (default) or `memory-disk` [cache policy](#cachepolicy).
     * @param urls - A URL string or an array of URLs of images to prefetch.
     * @param options - Options for prefetching images.
     * @return A promise resolving to `true` as soon as all images have been
     * successfully prefetched. If an image fails to be prefetched, the promise
     * will immediately resolve to `false` regardless of whether other images have
     * finished prefetching.
     */

    static async prefetch(urls, options) {
      let cachePolicy = 'memory-disk';
      let headers;
      switch (typeof options) {
        case 'string':
          cachePolicy = options;
          break;
        case 'object':
          cachePolicy = options.cachePolicy ?? cachePolicy;
          headers = options.headers;
          break;
      }
      return ImageModule.default.prefetch(Array.isArray(urls) ? urls : [urls], cachePolicy, headers);
    }

    /**
     * Asynchronously clears all images stored in memory.
     * @platform android
     * @platform ios
     * @return A promise resolving to `true` when the operation succeeds.
     * It may resolve to `false` on Android when the activity is no longer available.
     * Resolves to `false` on Web.
     */
    static async clearMemoryCache() {
      return await ImageModule.default.clearMemoryCache();
    }

    /**
     * Asynchronously clears all images from the disk cache.
     * @platform android
     * @platform ios
     * @return A promise resolving to `true` when the operation succeeds.
     * It may resolve to `false` on Android when the activity is no longer available.
     * Resolves to `false` on Web.
     */
    static async clearDiskCache() {
      return await ImageModule.default.clearDiskCache();
    }

    /**
     * Asynchronously checks if an image exists in the disk cache and resolves to
     * the path of the cached image if it does.
     * @param cacheKey - The cache key for the requested image. Unless you have set
     * a custom cache key, this will be the source URL of the image.
     * @platform android
     * @platform ios
     * @return A promise resolving to the path of the cached image. It will resolve
     * to `null` if the image does not exist in the cache.
     */
    static async getCachePathAsync(cacheKey) {
      return await ImageModule.default.getCachePathAsync(cacheKey);
    }

    /**
     * Asynchronously generates a [Blurhash](https://blurha.sh) from an image.
     * @param source - The image source, either a URL (string) or an ImageRef
     * @param numberOfComponents - The number of components to encode the blurhash with.
     * Must be between 1 and 9. Defaults to `[4, 3]`.
     * @platform android
     * @platform ios
     * @return A promise resolving to the blurhash string.
     */
    static async generateBlurhashAsync(source, numberOfComponents) {
      return ImageModule.default.generateBlurhashAsync(source, numberOfComponents);
    }

    /**
     * Asynchronously generates a [Thumbhash](https://evanw.github.io/thumbhash/) from an image.
     * @param source - The image source, either a URL (string) or an ImageRef
     * @platform android
     * @platform ios
     * @return A promise resolving to the thumbhash string.
     */
    static async generateThumbhashAsync(source) {
      return ImageModule.default.generateThumbhashAsync(source);
    }

    /**
     * Asynchronously starts playback of the view's image if it is animated.
     * @platform android
     * @platform ios
     */
    async startAnimating() {
      await this.nativeViewRef.current?.startAnimating();
    }

    /**
     * Asynchronously stops the playback of the view's image if it is animated.
     * @platform android
     * @platform ios
     */
    async stopAnimating() {
      await this.nativeViewRef.current?.stopAnimating();
    }

    /**
     * Prevents the resource from being reloaded by locking it.
     * @platform android
     * @platform ios
     */
    async lockResourceAsync() {
      await this.nativeViewRef.current?.lockResourceAsync();
    }

    /**
     * Releases the lock on the resource, allowing it to be reloaded.
     * @platform android
     * @platform ios
     */
    async unlockResourceAsync() {
      await this.nativeViewRef.current?.unlockResourceAsync();
    }

    /**
     * Reloads the resource, ignoring lock.
     * @platform android
     * @platform ios
     */
    async reloadAsync() {
      await this.nativeViewRef.current?.reloadAsync();
    }

    /**
     * Loads an image from the given source to memory and resolves to
     * an object that references the native image instance.
     * @platform android
     * @platform ios
     * @platform web
     */
    static async loadAsync(source, options) {
      const resolvedSource = (0, _utilsResolveSources.resolveSource)(source);
      return await ImageModule.default.loadAsync(resolvedSource, options);
    }
    render() {
      const _this$props = this.props,
        {
          style,
          source,
          placeholder,
          contentFit,
          contentPosition,
          transition,
          fadeDuration,
          resizeMode: resizeModeProp,
          defaultSource,
          loadingIndicatorSource
        } = _this$props,
        restProps = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      const _ref = StyleSheet.default.flatten(style) || {},
        {
          resizeMode: resizeModeStyle
        } = _ref,
        restStyle = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded2);
      const resizeMode = resizeModeProp ?? resizeModeStyle;
      if ((defaultSource || loadingIndicatorSource) && !loggedDefaultSourceDeprecationWarning) {
        console.warn('[expo-image]: `defaultSource` and `loadingIndicatorSource` props are deprecated, use `placeholder` instead');
        loggedDefaultSourceDeprecationWarning = true;
      }
      // @ts-expect-error
      if (restProps.children && !loggedRenderingChildrenWarning) {
        console.warn('The <Image> component does not support children. If you want to render content on top of the image, consider using the <ImageBackground> component or absolute positioning.');
        loggedRenderingChildrenWarning = true;
      }
      return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ExpoImage.default, Object.assign({}, restProps, {
        style: restStyle,
        source: (0, _utilsResolveSources.resolveSources)(source),
        placeholder: (0, _utilsResolveSources.resolveSources)(placeholder ?? defaultSource ?? loadingIndicatorSource),
        contentFit: (0, _utils.resolveContentFit)(contentFit, resizeMode),
        contentPosition: (0, _utils.resolveContentPosition)(contentPosition),
        transition: (0, _utils.resolveTransition)(transition, fadeDuration),
        nativeViewRef: this.nativeViewRef,
        containerViewRef: this.containerViewRef
      }), void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 249,
        columnNumber: 7
      }, this);
    }
  }
},864,[759,594,9,55,867,868,869,870,33],"node_modules/expo-image/src/Image.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  const _excluded = ["style", "imageStyle", "children"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-image\\src\\ImageBackground.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.ImageBackground = ImageBackground;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  require(_dependencyMap[1], "react");
  var _reactNativeWebDistExportsView = require(_dependencyMap[2], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[3], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _Image = require(_dependencyMap[4], "./Image");
  var _reactJsxDevRuntime = require(_dependencyMap[5], "react/jsx-dev-runtime");
  function ImageBackground(_ref) {
    let {
        style,
        imageStyle,
        children
      } = _ref,
      props = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, {
      style: style,
      children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_Image.Image, Object.assign({}, props, {
        style: [StyleSheet.default.absoluteFill, imageStyle]
      }), void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 12,
        columnNumber: 7
      }, this), children]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 11,
      columnNumber: 5
    }, this);
  }
},865,[759,9,110,55,864,33],"node_modules/expo-image/src/ImageBackground.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.useImage = useImage;
  var _react = require(_dependencyMap[0], "react");
  var _Image = require(_dependencyMap[1], "./Image");
  var _utilsResolveSources = require(_dependencyMap[2], "./utils/resolveSources");
  /**
   * A hook that loads an image from the given source and returns a reference
   * to the native image instance, or `null` until the first image is successfully loaded.
   *
   * It loads a new image every time the `uri` of the provided source changes.
   * To trigger reloads in some other scenarios, you can provide an additional dependency list.
   * @platform android
   * @platform ios
   * @platform web
   *
   * @example
   * ```ts
   * import { useImage, Image } from 'expo-image';
   * import { Text } from 'react-native';
   *
   * export default function MyImage() {
   *   const image = useImage('https://picsum.photos/1000/800', {
   *     maxWidth: 800,
   *     onError(error, retry) {
   *       console.error('Loading failed:', error.message);
   *     }
   *   });
   *
   *   if (!image) {
   *     return <Text>Image is loading...</Text>;
   *   }
   *
   *   return <Image source={image} style={{ width: image.width / 2, height: image.height / 2 }} />;
   * }
   * ```
   */
  function useImage(source, options = {}, dependencies = []) {
    const resolvedSource = (0, _utilsResolveSources.resolveSource)(source);
    const [image, setImage] = (0, _react.useState)(null);

    // Since options are not dependencies of the below effect, we store them in a ref.
    // Once the image is asynchronously loaded, the effect will use the most recent options,
    // instead of the captured ones (especially important for callbacks that may change in subsequent renders).
    const optionsRef = (0, _react.useRef)(options);
    optionsRef.current = options;
    (0, _react.useEffect)(() => {
      // We're doing some asynchronous action in this effect, so we should keep track
      // if the effect was already cleaned up. In that case, the async action shouldn't change the state.
      let isEffectValid = true;
      function loadImage() {
        _Image.Image.loadAsync(resolvedSource, options).then(image => {
          if (isEffectValid) {
            setImage(image);
          }
        }).catch(error => {
          if (!isEffectValid) {
            return;
          }
          if (optionsRef.current.onError) {
            optionsRef.current.onError(error, loadImage);
          } else {
            // Print unhandled errors to the console.
            console.error(`Loading an image from '${resolvedSource.uri}' failed, use 'onError' option to handle errors and suppress this message`);
            console.error(error);
          }
        });
      }
      loadImage();
      return () => {
        // Invalidate the effect and release the shared object to free up memory.
        isEffectValid = false;
        image?.release();
      };
    }, [resolvedSource.uri, ...dependencies]);
    return image;
  }
},866,[9,864,870],"node_modules/expo-image/src/useImage.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["source", "placeholder", "contentFit", "contentPosition", "placeholderContentFit", "cachePolicy", "onLoad", "transition", "onError", "responsivePolicy", "onLoadEnd", "onDisplay", "priority", "blurRadius", "recyclingKey", "style", "nativeViewRef", "accessibilityLabel", "alt", "tintColor", "containerViewRef"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-image\\src\\ExpoImage.web.tsx"; // TODO(@kitten): We shouldn't be importing all of react-native-web or rely on it for a web module in this way optimally
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return ExpoImage;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  require(_dependencyMap[1], "react");
  var _reactNativeWebDistExportsView = require(_dependencyMap[2], "react-native-web/dist/exports/View");
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _webAnimationManager = require(_dependencyMap[3], "./web/AnimationManager");
  var AnimationManager = _interopDefault(_webAnimationManager);
  var _webImageWrapper = require(_dependencyMap[4], "./web/ImageWrapper");
  var ImageWrapper = _interopDefault(_webImageWrapper);
  var _webImageStyles = require(_dependencyMap[5], "./web/imageStyles");
  var loadStyle = _interopDefault(_webImageStyles);
  var _webUseSourceSelection = require(_dependencyMap[6], "./web/useSourceSelection");
  var useSourceSelection = _interopDefault(_webUseSourceSelection);
  var _reactJsxDevRuntime = require(_dependencyMap[7], "react/jsx-dev-runtime");
  (0, loadStyle.default)();
  function onLoadAdapter(onLoad) {
    return event => {
      const target = event.target;
      onLoad?.({
        source: {
          url: target.currentSrc,
          width: target.naturalWidth,
          height: target.naturalHeight,
          mediaType: null
        },
        cacheType: 'none'
      });
    };
  }
  function onErrorAdapter(onError) {
    return ({
      source
    }) => {
      onError?.({
        error: `Failed to load image from url: ${source?.uri}`
      });
    };
  }

  // Used for flip transitions to mimic native animations
  function setCssVariablesForFlipTransitions(element, size) {
    element?.style.setProperty('--expo-image-width', `${size.width}px`);
    element?.style.setProperty('--expo-image-height', `${size.height}px`);
  }
  function isFlipTransition(transition) {
    return transition?.effect === 'flip-from-bottom' || transition?.effect === 'flip-from-top' || transition?.effect === 'flip-from-left' || transition?.effect === 'flip-from-right';
  }
  function getAnimationKey(source, recyclingKey) {
    const uri = source && 'uri' in source && source.uri || '';
    return recyclingKey ? [recyclingKey, uri].join('-') : uri;
  }
  function ExpoImage(_ref) {
    let {
        source,
        placeholder,
        contentFit,
        contentPosition,
        placeholderContentFit,
        cachePolicy,
        onLoad,
        transition,
        onError,
        responsivePolicy,
        onLoadEnd,
        onDisplay,
        priority,
        blurRadius,
        recyclingKey,
        style,
        nativeViewRef,
        accessibilityLabel,
        alt,
        tintColor,
        containerViewRef
      } = _ref,
      props = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const imagePlaceholderContentFit = placeholderContentFit || 'scale-down';
    const imageHashStyle = {
      objectFit: placeholderContentFit || contentFit
    };
    const selectedSource = (0, useSourceSelection.default)(source, responsivePolicy,
    // TODO(@vonovak): this cast is a workaround
    containerViewRef, isFlipTransition(transition) ? setCssVariablesForFlipTransitions : null);

    // TODO(@kitten): This should narrow before accessing `placeholder?.[0]`
    const firstPlaceholder = placeholder?.[0];
    const initialNodeAnimationKey = getAnimationKey(firstPlaceholder, recyclingKey);
    const initialNode = firstPlaceholder?.uri ? [initialNodeAnimationKey, ({
      onAnimationFinished
    }) => (className, style) => /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ImageWrapper.default, {
      ref: nativeViewRef,
      source: firstPlaceholder,
      style: Object.assign({
        objectFit: imagePlaceholderContentFit
      }, blurRadius ? {
        filter: `blur(${blurRadius}px)`
      } : {}, style),
      className: className,
      events: {
        onTransitionEnd: [onAnimationFinished]
      },
      contentPosition: {
        left: '50%',
        top: '50%'
      },
      hashPlaceholderContentPosition: contentPosition,
      hashPlaceholderStyle: imageHashStyle,
      accessibilityLabel: accessibilityLabel ?? alt,
      cachePolicy: cachePolicy,
      priority: priority,
      tintColor: tintColor
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 103,
      columnNumber: 13
    }, this)] : null;

    // @ts-expect-error: TODO(@kitten): This was implicitly cast to `any`, but with correct types this is now a mismatch
    const currentNodeAnimationKey = getAnimationKey(selectedSource ?? firstPlaceholder, recyclingKey);
    const currentNode = [currentNodeAnimationKey, ({
      onAnimationFinished,
      onReady,
      onMount,
      onError: onErrorInner
    }) => (className, style) => /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ImageWrapper.default, {
      ref: nativeViewRef
      // @ts-expect-error: TODO(@kitten): This was implicitly cast to `any`, but with correct types this is now a mismatch
      ,
      source: selectedSource || firstPlaceholder,
      events: {
        onError: [onErrorAdapter(onError), onLoadEnd, onErrorInner],
        onLoad: [onLoadAdapter(onLoad), onLoadEnd, onReady],
        onMount: [onMount],
        onTransitionEnd: [onAnimationFinished],
        onDisplay: [onDisplay]
      },
      style: Object.assign({
        objectFit: selectedSource ? contentFit : imagePlaceholderContentFit
      }, blurRadius ? {
        filter: `blur(${blurRadius}px)`
      } : {}, style),
      className: className,
      cachePolicy: cachePolicy,
      priority: priority,
      contentPosition: selectedSource ? contentPosition : {
        top: '50%',
        left: '50%'
      },
      hashPlaceholderContentPosition: contentPosition,
      hashPlaceholderStyle: imageHashStyle,
      accessibilityLabel: accessibilityLabel,
      tintColor: tintColor
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 133,
      columnNumber: 9
    }, this)];
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(View.default, Object.assign({
      ref: containerViewRef
      // @ts-expect-error: TODO(@kitten): This is related to react-native-web presumably
      ,
      dataSet: {
        expoimage: true
      },
      style: [{
        overflow: 'hidden'
      }, style]
    }, props, {
      children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(AnimationManager.default, {
        transition: transition,
        recyclingKey: recyclingKey,
        initial: initialNode,
        children: currentNode
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 167,
        columnNumber: 7
      }, this)
    }), void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 161,
      columnNumber: 5
    }, this);
  }
},867,[759,9,110,871,872,873,874,33],"node_modules/expo-image/src/ExpoImage.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _expoModulesCore = require(_dependencyMap[0], "expo-modules-core");
  var _webImageRef = require(_dependencyMap[1], "./web/ImageRef");
  var ImageRefWeb = _interopDefault(_webImageRef);
  class ImageModule extends _expoModulesCore.NativeModule {
    Image = ImageRefWeb.default;
    async prefetch(urls, _, __) {
      const urlsArray = Array.isArray(urls) ? urls : [urls];
      return new Promise(resolve => {
        let imagesLoaded = 0;
        urlsArray.forEach(url => {
          const img = new Image();
          img.src = url;
          img.onload = () => {
            imagesLoaded++;
            if (imagesLoaded === urlsArray.length) {
              resolve(true);
            }
          };
          img.onerror = () => resolve(false);
        });
      });
    }
    async clearMemoryCache() {
      return false;
    }
    async clearDiskCache() {
      return false;
    }
    async loadAsync(source) {
      if (!source.uri) {
        // TODO: Add support for sources without the uri, e.g. blurhash and thumbhash.
        throw new Error('The image source must have the "uri" property defined');
      }
      const response = await fetch(source.uri, {
        headers: source.headers
      });
      if (!response.ok) {
        throw new Error(`Image request failed with the status code: ${response.status}`);
      }
      const blob = await response.blob();
      const imageObjectUrl = URL.createObjectURL(blob);
      const image = await loadImageElementAsync(imageObjectUrl);
      return ImageRefWeb.default.init(imageObjectUrl, image.width, image.height, response.headers.get('Content-Type'));
    }
  }

  /**
   * Helper that resolves to an `<img />` element once it finishes loading the given source.
   */
  async function loadImageElementAsync(src) {
    return new Promise((resolve, reject) => {
      const image = document.createElement('img');
      image.onload = () => resolve(image);
      image.onerror = () => reject(new Error(`Unable to load the image from '${src}'`));
      image.src = src;
    });
  }
  var _default = (0, _expoModulesCore.registerWebModule)(ImageModule, 'ExpoImage');
},868,[594,888],"node_modules/expo-image/src/ImageModule.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.resolveContentFit = resolveContentFit;
  exports.resolveContentPosition = resolveContentPosition;
  exports.resolveTransition = resolveTransition;
  exports.isImageRef = isImageRef;
  var _expo = require(_dependencyMap[0], "expo");
  let loggedResizeModeDeprecationWarning = false;
  let loggedRepeatDeprecationWarning = false;
  let loggedFadeDurationDeprecationWarning = false;

  /**
   * If the `contentFit` is not provided, it's resolved from the equivalent `resizeMode` prop
   * that we support to provide compatibility with React Native Image.
   */
  function resolveContentFit(contentFit, resizeMode) {
    if (contentFit) {
      return contentFit;
    }
    if (resizeMode) {
      if (!loggedResizeModeDeprecationWarning) {
        console.log('[expo-image]: Prop "resizeMode" is deprecated, use "contentFit" instead');
        loggedResizeModeDeprecationWarning = true;
      }
      switch (resizeMode) {
        case 'contain':
        case 'cover':
        case 'none':
          return resizeMode;
        case 'stretch':
          return 'fill';
        case 'center':
          return 'scale-down';
        case 'repeat':
          if (!loggedRepeatDeprecationWarning) {
            console.log('[expo-image]: Resize mode "repeat" is no longer supported');
            loggedRepeatDeprecationWarning = true;
          }
          return 'cover';
        default:
          {
            const exhaustiveCheck = resizeMode;
            throw new Error(`Unhandled resizeMode case: ${exhaustiveCheck}`);
          }
      }
    }
    return 'cover';
  }

  /**
   * It resolves a stringified form of the `contentPosition` prop to an object,
   * which is the only form supported in the native code.
   */
  function resolveContentPosition(contentPosition) {
    if (typeof contentPosition === 'string') {
      const contentPositionStringMappings = {
        center: {
          top: '50%',
          left: '50%'
        },
        top: {
          top: 0,
          left: '50%'
        },
        right: {
          top: '50%',
          right: 0
        },
        bottom: {
          bottom: 0,
          left: '50%'
        },
        left: {
          top: '50%',
          left: 0
        },
        'top center': {
          top: 0,
          left: '50%'
        },
        'top right': {
          top: 0,
          right: 0
        },
        'top left': {
          top: 0,
          left: 0
        },
        'right center': {
          top: '50%',
          right: 0
        },
        'right top': {
          top: 0,
          right: 0
        },
        'right bottom': {
          bottom: 0,
          right: 0
        },
        'bottom center': {
          bottom: 0,
          left: '50%'
        },
        'bottom right': {
          bottom: 0,
          right: 0
        },
        'bottom left': {
          bottom: 0,
          left: 0
        },
        'left center': {
          top: '50%',
          left: 0
        },
        'left top': {
          top: 0,
          left: 0
        },
        'left bottom': {
          bottom: 0,
          left: 0
        }
      };
      const contentPositionObject = contentPositionStringMappings[contentPosition];
      if (!contentPositionObject) {
        console.warn(`[expo-image]: Content position "${contentPosition}" is invalid`);
        return contentPositionStringMappings.center;
      }
      return contentPositionObject;
    }
    return contentPosition ?? {
      top: '50%',
      left: '50%'
    };
  }

  /**
   * If `transition` or `fadeDuration` is a number, it's resolved to a cross dissolve transition with the given duration.
   * When `fadeDuration` is used, it logs an appropriate deprecation warning.
   */
  function resolveTransition(transition, fadeDuration) {
    if (typeof transition === 'number') {
      return {
        duration: transition
      };
    }
    if (!transition && typeof fadeDuration === 'number') {
      if (!loggedFadeDurationDeprecationWarning) {
        console.warn('[expo-image]: Prop "fadeDuration" is deprecated, use "transition" instead');
        loggedFadeDurationDeprecationWarning = true;
      }
      return {
        duration: fadeDuration
      };
    }
    return transition ?? null;
  }

  /**
   * Checks whether the given value is an instance of the `SharedRef<'image'>` class.
   */
  function isImageRef(value) {
    return value instanceof _expo.SharedRef && value.nativeRefType === 'image';
  }
},869,[550],"node_modules/expo-image/src/utils.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["blurhash", "thumbhash"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.isBlurhashString = isBlurhashString;
  exports.isThumbhashString = isThumbhashString;
  exports.resolveSource = resolveSource;
  exports.resolveSources = resolveSources;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _expoModulesCore = require(_dependencyMap[1], "expo-modules-core");
  var _resolveAssetSource = require(_dependencyMap[2], "./resolveAssetSource");
  var resolveAssetSource = _interopDefault(_resolveAssetSource);
  var _resolveHashString = require(_dependencyMap[3], "./resolveHashString");
  var _utils = require(_dependencyMap[4], "../utils");
  function isBlurhashString(str) {
    return /^(blurhash:\/)+[\w#$%*+,\-.:;=?@[\]^_{}|~]+(\/[\d.]+)*$/.test(str);
  }

  // Base64 strings will be recognized as blurhash by default (to keep compatibility),
  // interpret as thumbhash only if correct uri scheme is provided
  function isThumbhashString(str) {
    return str.startsWith('thumbhash:/');
  }
  function resolveSource(source) {
    if (typeof source === 'string') {
      if (isBlurhashString(source)) {
        return (0, _resolveHashString.resolveBlurhashString)(source);
      } else if (isThumbhashString(source)) {
        return (0, _resolveHashString.resolveThumbhashString)(source);
      }
      return {
        uri: source
      };
    }
    if (typeof source === 'number') {
      return (0, resolveAssetSource.default)(source);
    }
    if (typeof source === 'object' && (source?.blurhash || source?.thumbhash)) {
      const {
          blurhash,
          thumbhash
        } = source,
        restSource = (0, _objectWithoutPropertiesLoose.default)(source, _excluded);
      const resolved = thumbhash ? (0, _resolveHashString.resolveThumbhashString)(thumbhash) : (0, _resolveHashString.resolveBlurhashString)(blurhash);
      return Object.assign({}, resolved, restSource);
    }
    return source ?? null;
  }

  /**
   * Resolves provided `source` prop to an array of objects expected by the native implementation.
   */
  function resolveSources(sources) {
    if (Array.isArray(sources)) {
      return sources.map(resolveSource).filter(Boolean);
    }
    if ((0, _utils.isImageRef)(sources)) {
      if (_expoModulesCore.Platform.OS === 'web') {
        return sources;
      }
      // @ts-expect-error
      return sources.__expo_shared_object_id__;
    }
    return [resolveSource(sources)].filter(Boolean);
  }
},870,[759,594,879,880,869],"node_modules/expo-image/src/utils/resolveSources.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-image\\src\\web\\AnimationManager.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return AnimationManager;
    }
  });
  exports.getAnimatorFromTransition = getAnimatorFromTransition;
  var _react = require(_dependencyMap[0], "react");
  var React = _interopDefault(_react);
  var _reactJsxDevRuntime = require(_dependencyMap[1], "react/jsx-dev-runtime");
  const SUPPORTED_ANIMATIONS = ['cross-dissolve', 'flip-from-left', 'flip-from-right', 'flip-from-top', 'flip-from-bottom'];
  function useAnimationManagerNode(node, initialStatus) {
    const newNode = React.default.useMemo(() => {
      if (!node) {
        return null;
      }
      const [animationKey, renderFunction] = node;
      // key, ReactElement, ref, callbacks
      return {
        animationKey,
        persistedElement: renderFunction,
        status: initialStatus || 'mounted'
      };
    }, [node?.[0]]);
    return newNode;
  }
  function validateTimingFunctionForAnimation(animationClass, timingFunction) {
    if (animationClass?.includes('flip')) {
      if (timingFunction?.includes('ease')) {
        return 'ease-in-out';
      }
      return 'linear';
    }
    return timingFunction || null;
  }
  function validateAnimationClass(effect) {
    if (SUPPORTED_ANIMATIONS.includes(effect)) {
      return effect;
    }
    return 'cross-dissolve';
  }
  function getAnimatorFromTransition(transition) {
    if (!transition?.duration) {
      return null;
    }
    const animationClass = validateAnimationClass(transition.effect);
    if (!animationClass) {
      return {
        startingClass: '',
        animateInClass: '',
        animateOutClass: '',
        containerClass: '',
        timingFunction: 'linear',
        animationClass: '',
        duration: 0
      };
    }
    const timingFunction = validateTimingFunctionForAnimation(animationClass, transition.timing);
    const timingClass = `image-timing-${timingFunction}`;
    return {
      startingClass: `${animationClass}-start`,
      animateInClass: [animationClass, 'transitioning', `${animationClass}-active`, timingClass].join(' '),
      animateOutClass: [animationClass, `${animationClass}-end`, timingClass].join(' '),
      containerClass: `${animationClass}-container`,
      timingFunction,
      animationClass,
      duration: transition?.duration || 0
    };
  }
  function AnimationManager({
    children: renderFunction,
    initial,
    transition,
    recyclingKey
  }) {
    const animation = getAnimatorFromTransition(transition);
    const initialNode = useAnimationManagerNode(initial, 'active');
    const [nodes, setNodes] = React.default.useState(initialNode ? [initialNode] : []);
    const [prevRecyclingKey, setPrevRecyclingKey] = React.default.useState(recyclingKey ?? '');
    if (prevRecyclingKey !== (recyclingKey ?? '')) {
      setPrevRecyclingKey(recyclingKey ?? '');
      setNodes(initialNode ? [initialNode] : []);
    }
    const removeAllNodesOfKeyExceptShowing = key => {
      setNodes(n => n.filter(node => (key ? node.animationKey !== key : false) || node.status === 'in' || node.status === 'active'));
    };
    const newNode = useAnimationManagerNode(renderFunction);
    React.default.useEffect(() => {
      setNodes(n => {
        if (!newNode) {
          return n;
        }
        const existingNodeIndex = n.findIndex(node => node.animationKey === newNode.animationKey);
        if (existingNodeIndex >= 0) {
          if (animation) {
            return n.map(n2 => n2.animationKey === newNode.animationKey ? Object.assign({}, newNode, {
              status: 'in'
            }) : Object.assign({}, n2, {
              status: 'out'
            }));
          } else {
            return [Object.assign({}, newNode, {
              status: 'in'
            })];
          }
        }
        return [...n, newNode];
      });
    }, [newNode]);
    function wrapNodeWithCallbacks(node) {
      if (renderFunction[0] === node.animationKey) {
        return renderFunction[1]({
          onReady: () => {
            if (animation) {
              setNodes(nodes => nodes.map(n => n === newNode ? Object.assign({}, n, {
                status: 'in'
              }) : Object.assign({}, n, {
                status: 'out'
              })));
            } else {
              setNodes([Object.assign({}, node, {
                status: 'in'
              })]);
            }
          },
          onAnimationFinished: () => {
            setNodes([Object.assign({}, node, {
              status: 'in'
            })]);
          },
          onError: () => {
            setNodes(nodes => nodes.map(n => n === node ? Object.assign({}, n, {
              status: 'errored'
            }) : n));
          }
        });
      }
      if (initial?.[0] === node.animationKey) {
        return initial[1]({
          onAnimationFinished: () => {
            if (node.status === 'out') {
              removeAllNodesOfKeyExceptShowing(node.animationKey);
            }
          },
          onError: () => {
            setNodes(nodes => nodes.map(n => n === node ? Object.assign({}, n, {
              status: 'errored'
            }) : n));
          }
        });
      }
      return node.persistedElement({
        onAnimationFinished: () => {
          removeAllNodesOfKeyExceptShowing(node.animationKey);
        }
      });
    }
    const styles = {
      transitionDuration: `${animation?.duration || 0}ms`,
      transitionTimingFunction: animation?.timingFunction || 'linear'
    };
    const classes = {
      in: animation?.animateInClass,
      out: animation?.animateOutClass,
      mounted: animation?.startingClass
    };
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_reactJsxDevRuntime.Fragment, {
      children: [...nodes].filter(n => n.status !== 'errored').map(n => {
        const status = n.status;
        // TODO(@kitten): This creates impossible states!
        // Ensure that the above type is either exhaustively reflected in this `map` so `className` sheds `undefined`,
        // or retype the `MountedAnimationNode` function to accept `className: string | undefined`
        const className = classes[status];
        return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)("div", {
          className: animation?.containerClass,
          children: wrapNodeWithCallbacks(n)(className, styles)
        }, n.animationKey, false, {
          fileName: _jsxFileName,
          lineNumber: 224,
          columnNumber: 13
        }, this);
      })
    }, void 0, false);
  }
},871,[9,33],"node_modules/expo-image/src/web/AnimationManager.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["source", "events", "contentPosition", "hashPlaceholderContentPosition", "priority", "style", "hashPlaceholderStyle", "tintColor", "className", "accessibilityLabel", "cachePolicy"];
  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-image\\src\\web\\ImageWrapper.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0], "@babel/runtime/helpers/objectWithoutPropertiesLoose");
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1], "react");
  var React = _interopDefault(_react);
  var _ColorTintFilter = require(_dependencyMap[2], "./ColorTintFilter");
  var ColorTintFilter = _interopDefault(_ColorTintFilter);
  var _getImageWrapperEventHandler = require(_dependencyMap[3], "./getImageWrapperEventHandler");
  var _hooks = require(_dependencyMap[4], "./hooks");
  var _positioning = require(_dependencyMap[5], "./positioning");
  var _reactJsxDevRuntime = require(_dependencyMap[6], "react/jsx-dev-runtime");
  function getFetchPriorityFromImagePriority(priority = 'normal') {
    return priority && ['low', 'high'].includes(priority) ? priority : 'auto';
  }
  function getImgPropsFromSource(source) {
    if (source && 'srcset' in source) {
      return {
        srcSet: source.srcset,
        sizes: source.sizes
      };
    }
    return {};
  }
  const ImageWrapper = /*#__PURE__*/React.default.forwardRef((_ref, ref) => {
    let {
        source,
        events,
        contentPosition,
        hashPlaceholderContentPosition,
        priority,
        style,
        hashPlaceholderStyle,
        tintColor,
        className,
        accessibilityLabel,
        cachePolicy
      } = _ref,
      props = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    (0, _react.useEffect)(() => {
      events?.onMount?.forEach(e => e?.());
    }, []);

    // Use a unique ID for the SVG filter so that multiple <Image> can be used
    // on the same page with different tint colors without conflicts.
    const tintId = (0, _react.useId)()
    // Make it safe for use as an SVG ID. SVG IDs are most strict than HTML
    // IDs. They must be compliant with https://www.w3.org/TR/xml/#NT-Name.
    // React 19 changed useId() to include « and ». These must be removed or
    // the SVG filter will not work (e.g. in Safari which enforces the spec).
    .replace(/[«»]/g, '_');

    // Thumbhash uri always has to start with 'thumbhash:/'
    const {
      resolvedSource,
      isImageHash
    } = (0, _hooks.useImageHashes)(source);
    const objectPosition = (0, _positioning.getObjectPositionFromContentPositionObject)(isImageHash ? hashPlaceholderContentPosition : contentPosition);
    const sourceWithHeaders = (0, _hooks.useHeaders)(resolvedSource, cachePolicy, events?.onError);
    if (!sourceWithHeaders) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(_reactJsxDevRuntime.Fragment, {
      children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)(ColorTintFilter.default, {
        id: tintId,
        tintColor: tintColor
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 68,
        columnNumber: 9
      }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)("img", Object.assign({
        ref: ref,
        alt: accessibilityLabel,
        className: className,
        src: sourceWithHeaders?.uri || undefined,
        style: Object.assign({
          objectPosition
        }, _positioning.absoluteFilledPosition, (0, _ColorTintFilter.getTintColorStyle)(tintId, tintColor), style, isImageHash ? hashPlaceholderStyle : {})
        // @ts-ignore
        // eslint-disable-next-line react/no-unknown-property
        ,
        fetchPriority: getFetchPriorityFromImagePriority(priority || 'normal')
      }, (0, _getImageWrapperEventHandler.getImageWrapperEventHandler)(events, sourceWithHeaders), getImgPropsFromSource(source), props), source?.uri, false, {
        fileName: _jsxFileName,
        lineNumber: 69,
        columnNumber: 9
      }, this)]
    }, void 0, true);
  });
  var _default = ImageWrapper;
},872,[759,9,875,876,877,878,33],"node_modules/expo-image/src/web/ImageWrapper.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return loadStyle;
    }
  });
  const style = `
[data-expoimage] .cross-dissolve {
  transition-property: opacity;
  animation-fill-mode: forwards;
}
[data-expoimage] .cross-dissolve-start:not(.transitioning) {
  opacity: 0;
}
[data-expoimage] .cross-dissolve-active {
  opacity: 1;
}
[data-expoimage] .cross-dissolve-end {
  opacity: 0;
}
[data-expoimage] .flip-from-left {
  transition-property: transform, opacity;
  transition-timing-function: var(--expo-image-timing,linear), steps(2, jump-none) !important;
  transform-origin: center;

}
[data-expoimage] .flip-from-left-container {
  width: 100%;
  height: 100%;
  position: absolute;
  left: 0;
  top: 0;
  perspective: 1000px;
}
[data-expoimage] .flip-from-left-start:not(.transitioning) {
  transform:  translateZ(calc(var(--expo-image-width,1000px) * -1.25)) rotateY(-180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-left-active {
  transform: translateZ(0px) rotateY(0) ;
  opacity:1;
}
[data-expoimage] .flip-from-left-end {
  transform:  translateZ(calc(var(--expo-image-width,1000px) * -1.25)) rotateY(180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-right {
  transition-property: transform, opacity;
  transition-timing-function: var(--expo-image-timing,linear), steps(2, jump-none) !important;
  transform-origin: center;
}
[data-expoimage] .flip-from-right-container {
  width: 100%;
  height: 100%;
  position: absolute;
  left: 0;
  top: 0;
  perspective: 1000px;
}
[data-expoimage] .flip-from-right-start:not(.transitioning) {
  transform:  translateZ(calc(var(--expo-image-width,1000px) * -1.25)) rotateY(180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-right-active {
  transform: translateZ(0px) rotateY(0) ;
  opacity:1;
}
[data-expoimage] .flip-from-right-end {
  transform:  translateZ(calc(var(--expo-image-width,1000px) * -1.25)) rotateY(-180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-top {
  transition-property: transform, opacity;
  transition-timing-function: var(--expo-image-timing,linear), steps(2, jump-none) !important;
  transform-origin: center;
}
[data-expoimage] .flip-from-top-container {
  width: 100%;
  height: 100%;
  position: absolute;
  left: 0;
  top: 0;
  perspective: 1000px;
}
[data-expoimage] .flip-from-top-start:not(.transitioning) {
  transform:  translateZ(calc(var(--expo-image-height,1000px) * -1.5)) rotateX(180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-top-active {
  transform: translateZ(0px) rotateX(0) ;
  opacity:1;
}
[data-expoimage] .flip-from-top-end {
  transform:  translateZ(calc(var(--expo-image-height,1000px) * -1.5)) rotateX(-180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-bottom {
  transition-property: transform, opacity;
  transition-timing-function: var(--expo-image-timing,linear), steps(2, jump-none) !important;
  transform-origin: center;
}
[data-expoimage] .flip-from-bottom-container {
  width: 100%;
  height: 100%;
  position: absolute;
  left: 0;
  top: 0;
  perspective: 1000px;
}
[data-expoimage] .flip-from-bottom-start:not(.transitioning) {
  transform:  translateZ(calc(var(--expo-image-height,1000px) * -1.25)) rotateX(-180deg);
  opacity: 0;
}
[data-expoimage] .flip-from-bottom-active {
  transform: translateZ(0px) rotateX(0) ;
  opacity:1;
}
[data-expoimage] .flip-from-bottom-end {
  transform:  translateZ(calc(var(--expo-image-height,1000px) * -1.25)) rotateX(180deg);
  opacity: 0;
}
[data-expoimage] .image-timing-linear {
  --expo-image-timing: linear;
}
[data-expoimage] .image-timing-ease-in {
  --expo-image-timing: ease-in;
}
[data-expoimage] .image-timing-ease-out {
  --expo-image-timing: ease-out;
}
[data-expoimage] .image-timing-ease-in-out {
  --expo-image-timing: ease-in-out;
}
`;
  function loadStyle() {
    if (typeof window !== 'undefined') {
      const styleTag = document.createElement('style');
      styleTag.innerHTML = style;
      styleTag.id = 'expo-image-styles';
      document.head.appendChild(styleTag);
    }
  }
},873,[],"node_modules/expo-image/src/web/imageStyles.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useSourceSelection;
    }
  });
  var _react = require(_dependencyMap[0], "react");
  var React = _interopDefault(_react);
  var _utils = require(_dependencyMap[1], "../utils");
  var _utilsResolveSources = require(_dependencyMap[2], "../utils/resolveSources");
  function findBestSourceForSize(sources, size) {
    if (sources?.length === 1) {
      return sources[0];
    }
    return [...(sources || [])]
    // look for the smallest image that's still larger then a container
    ?.map(source => {
      if (!size) {
        return {
          source,
          penalty: 0,
          covers: false
        };
      }
      const {
        width,
        height
      } = typeof source === 'object' ? source : {
        width: null,
        height: null
      };
      if (width == null || height == null) {
        return {
          source,
          penalty: 0,
          covers: false
        };
      }
      if (width < size.width || height < size.height) {
        return {
          source,
          penalty: Math.max(size.width - width, size.height - height),
          covers: false
        };
      }
      return {
        source,
        penalty: (width - size.width) * (height - size.height),
        covers: true
      };
    }).sort((a, b) => a.penalty - b.penalty).sort((a, b) => Number(b.covers) - Number(a.covers))[0]?.source ?? null;
  }
  function getCSSMediaQueryForSource(source) {
    return `(max-width: ${source.webMaxViewportWidth ?? source.width}px) ${source.width}px`;
  }
  function selectSource(sources, size, responsivePolicy) {
    if (sources == null || sources.length === 0) {
      return null;
    }
    if (sources.length === 1) {
      return sources[0];
    }
    if (responsivePolicy !== 'static') {
      return findBestSourceForSize(sources, size);
    }
    const staticSupportedSources = sources.filter(s => s.uri && s.width != null && !(0, _utilsResolveSources.isBlurhashString)(s.uri) && !(0, _utilsResolveSources.isThumbhashString)(s.uri)).sort((a, b) => (a.webMaxViewportWidth ?? a.width ?? 0) - (b.webMaxViewportWidth ?? b.width ?? 0));
    if (staticSupportedSources.length === 0) {
      console.warn("You've set the `static` responsivePolicy but none of the sources have the `width` properties set. Make sure you set both `width` and `webMaxViewportWidth` for best results when using static responsiveness. Falling back to the `initial` policy.");
      return findBestSourceForSize(sources, size);
    }
    const srcset = staticSupportedSources?.map(source => `${source.uri} ${source.width}w`).join(', ');
    const sizes = `${staticSupportedSources?.map(getCSSMediaQueryForSource).join(', ')}, ${staticSupportedSources[staticSupportedSources.length - 1]?.width}px`;
    return {
      srcset,
      sizes,
      uri: staticSupportedSources[staticSupportedSources.length - 1]?.uri ?? '',
      type: 'srcset'
    };
  }
  function useSourceSelection(sources, responsivePolicy = 'static', containerRef, measurementCallback = null) {
    const hasMoreThanOneSource = (Array.isArray(sources) ? sources.length : 0) > 1;
    const [size, setSize] = (0, _react.useState)(containerRef.current?.getBoundingClientRect() ?? null);
    if (size && containerRef.current) {
      measurementCallback?.(containerRef.current, size);
    }
    React.default.useEffect(() => {
      if (!hasMoreThanOneSource && !measurementCallback || !containerRef.current) {
        return () => {};
      }
      if (responsivePolicy === 'live') {
        const resizeObserver = new ResizeObserver(entries => {
          setSize(entries[0].contentRect);
          measurementCallback?.(entries[0].target, entries[0].contentRect);
        });
        resizeObserver.observe(containerRef.current);
        return () => {
          resizeObserver.disconnect();
        };
      }
      return () => {};
    }, [responsivePolicy, hasMoreThanOneSource, containerRef.current, measurementCallback]);
    if ((0, _utils.isImageRef)(sources)) {
      // There is always only one image ref, so there is nothing else to select from.
      return sources;
    }
    return selectSource(sources, size, responsivePolicy);
  }
},874,[9,869,870],"node_modules/expo-image/src/web/useSourceSelection.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _jsxFileName = "C:\\Users\\kauan math\\Desktop\\pedro-kauan-iot\\node_modules\\expo-image\\src\\web\\ColorTintFilter.tsx";
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return TintColorFilter;
    }
  });
  exports.getTintColorStyle = getTintColorStyle;
  require(_dependencyMap[0], "react");
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[1], "react-native-web/dist/exports/StyleSheet");
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactJsxDevRuntime = require(_dependencyMap[2], "react/jsx-dev-runtime");
  function getTintColorStyle(tintId, tintColor) {
    if (!tintColor) {
      return {};
    }
    return {
      filter: `url(#expo-image-tint-${tintId})`
    };
  }
  function TintColorFilter({
    id,
    tintColor
  }) {
    if (!tintColor) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)("svg", {
      style: styles.svg,
      children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)("defs", {
        children: /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)("filter", {
          id: `expo-image-tint-${id}`,
          children: [/*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)("feFlood", {
            floodColor: tintColor
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 23,
            columnNumber: 11
          }, this), /*#__PURE__*/(0, _reactJsxDevRuntime.jsxDEV)("feComposite", {
            in2: "SourceAlpha",
            operator: "atop"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 24,
            columnNumber: 11
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 22,
          columnNumber: 9
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 21,
        columnNumber: 7
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 5
    }, this);
  }
  const styles = StyleSheet.default.create({
    svg: {
      width: 0,
      height: 0
    }
  });
},875,[9,55,33],"node_modules/expo-image/src/web/ColorTintFilter.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.getImageWrapperEventHandler = getImageWrapperEventHandler;
  var _utilsResolveSources = require(_dependencyMap[0], "../utils/resolveSources");
  function getImageWrapperEventHandler(events, source) {
    return {
      onLoad: event => {
        events?.onLoad?.forEach(e => e?.(event));
        if (typeof window !== 'undefined') {
          // On Web there is no way to detect when the image gets displayed, but we can assume it happens on the repaint right after the image is successfully loaded.
          window.requestAnimationFrame(() => {
            events?.onDisplay?.forEach(e => e?.());
          });
        }
      },
      onTransitionEnd: () => events?.onTransitionEnd?.forEach(e => e?.()),
      onError: () => {
        // A temporary workaround for blurhash blobs throwing opaque errors when used in an img tag.
        if (source?.uri && (0, _utilsResolveSources.isBlurhashString)(source?.uri)) {
          return;
        }
        events?.onError?.forEach(e => e?.({
          source: source || null
        }));
      }
    };
  }
},876,[870],"node_modules/expo-image/src/web/getImageWrapperEventHandler.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.useThumbhash = useThumbhash;
  exports.useImageHashes = useImageHashes;
  exports.useHeaders = useHeaders;
  var _react = require(_dependencyMap[0], "react");
  var _utilsBlurhashUseBlurhash = require(_dependencyMap[1], "../utils/blurhash/useBlurhash");
  var _utilsResolveSources = require(_dependencyMap[2], "../utils/resolveSources");
  var _utilsThumbhashThumbhash = require(_dependencyMap[3], "../utils/thumbhash/thumbhash");
  function useThumbhash(source) {
    const isThumbhash = (0, _utilsResolveSources.isThumbhashString)(source?.uri || '');
    const strippedThumbhashString = source?.uri?.replace(/thumbhash:\//, '') ?? '';
    const thumbhashSource = (0, _react.useMemo)(() => isThumbhash ? {
      uri: (0, _utilsThumbhashThumbhash.thumbHashStringToDataURL)(strippedThumbhashString)
    } : null, [strippedThumbhashString, isThumbhash]);
    return [thumbhashSource, isThumbhash];
  }
  function useImageHashes(source) {
    const [thumbhash, isThumbhashString] = useThumbhash(source);
    const [blurhash, isBlurhashString] = (0, _utilsBlurhashUseBlurhash.useBlurhash)(source);
    return (0, _react.useMemo)(() => {
      if (!isThumbhashString && !isBlurhashString) {
        return {
          resolvedSource: source,
          isImageHash: false
        };
      }
      if (!blurhash && !thumbhash) {
        return {
          resolvedSource: null,
          isImageHash: true
        };
      }
      return {
        resolvedSource: blurhash ?? thumbhash,
        isImageHash: true
      };
    }, [blurhash, thumbhash, isThumbhashString, isBlurhashString, source]);
  }
  function useHeaders(source, cachePolicy, onError) {
    const [objectURL, setObjectURL] = (0, _react.useState)(null);
    (0, _react.useEffect)(() => {
      (async () => {
        if (!source?.headers || !source.uri) {
          return;
        }
        try {
          const result = await fetch(source.uri, {
            headers: source.headers,
            cache: cachePolicy === 'none' ? 'no-cache' : 'default',
            redirect: 'follow'
          });
          if (!result.ok) {
            throw new Error(`Failed to fetch image: ${result.status} ${result.statusText}`);
          }
          const blob = await result.blob();
          setObjectURL(prevObjURL => {
            if (prevObjURL) {
              URL.revokeObjectURL(prevObjURL);
            }
            return URL.createObjectURL(blob);
          });
        } catch {
          onError?.forEach(e => e?.({
            source
          }));
        }
      })();
    }, [source]);
    if (!source?.headers) {
      return source;
    }
    if (!objectURL) {
      // Avoid fetching a URL without headers if we have headers
      return null;
    }
    return Object.assign({}, source, {
      uri: objectURL
    });
  }
},877,[9,881,870,883],"node_modules/expo-image/src/web/hooks.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.ensureValueIsWebUnits = ensureValueIsWebUnits;
  Object.defineProperty(exports, "absoluteFilledPosition", {
    enumerable: true,
    get: function () {
      return absoluteFilledPosition;
    }
  });
  exports.getObjectPositionFromContentPositionObject = getObjectPositionFromContentPositionObject;
  function ensureValueIsWebUnits(value) {
    const trimmedValue = String(value).trim();
    if (trimmedValue.endsWith('%')) {
      return trimmedValue;
    }
    return `${trimmedValue}px`;
  }
  const absoluteFilledPosition = {
    width: '100%',
    height: '100%',
    position: 'absolute',
    left: 0,
    top: 0
  };
  function getObjectPositionFromContentPositionObject(contentPosition) {
    const resolvedPosition = Object.assign({}, contentPosition);
    if (!resolvedPosition) {
      return '50% 50%';
    }
    if (resolvedPosition.top == null && resolvedPosition.bottom == null) {
      resolvedPosition.top = '50%';
    }
    if (resolvedPosition.left == null && resolvedPosition.right == null) {
      resolvedPosition.left = '50%';
    }
    return ['top', 'bottom', 'left', 'right'].map(key => {
      if (key in resolvedPosition) {
        return `${key} ${ensureValueIsWebUnits(resolvedPosition[key])}`;
      }
      return '';
    }).join(' ') || '50% 50%';
  }
},878,[],"node_modules/expo-image/src/web/positioning.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return resolveAssetSource;
    }
  });
  exports.setCustomSourceTransformer = setCustomSourceTransformer;
  Object.defineProperty(exports, "pickScale", {
    enumerable: true,
    get: function () {
      return pickScale;
    }
  });
  var _reactNativeAssetsRegistryRegistry = require(_dependencyMap[0], "@react-native/assets-registry/registry");
  var _AssetSourceResolverWeb = require(_dependencyMap[1], "./AssetSourceResolver.web");
  var AssetSourceResolver = _interopDefault(_AssetSourceResolverWeb);
  let _customSourceTransformer;
  function setCustomSourceTransformer(transformer) {
    _customSourceTransformer = transformer;
  }

  /**
   * `source` is either a number (opaque type returned by require('./foo.png'))
   * or an `ImageSource` like { uri: '<http location || file path>' }
   */
  function resolveAssetSource(source) {
    if (typeof source === 'object') {
      return source;
    }
    const asset = (0, _reactNativeAssetsRegistryRegistry.getAssetByID)(source);
    if (!asset) {
      return undefined;
    }
    const resolver = new AssetSourceResolver.default('https://expo.dev', null, asset);
    if (_customSourceTransformer) {
      return _customSourceTransformer(resolver);
    }
    return resolver.defaultAsset();
  }
  Object.defineProperty(resolveAssetSource, 'setCustomSourceTransformer', {
    get() {
      return setCustomSourceTransformer;
    }
  });
  const {
    pickScale
  } = AssetSourceResolver.default;
},879,[156,882],"node_modules/expo-image/src/utils/resolveAssetSource.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.resolveBlurhashString = resolveBlurhashString;
  exports.resolveThumbhashString = resolveThumbhashString;
  /**
   * Converts a string in blurhash format (`blurhash:/<hash>/<width>/<height>`
   * or <hash>/<width>/<height>) into an `ImageSource`.
   *
   * @return An ImageSource representing the provided blurhash.
   * */
  function resolveBlurhashString(str) {
    const [hash, width, height] = str.replace(/^blurhash:\//, '').split('/');
    return {
      uri: 'blurhash:/' + hash,
      width: parseInt(width, 10) || 16,
      height: parseInt(height, 10) || 16
    };
  }

  /**
   * Converts a string in thumbhash format (`thumbhash:/<hash>` or `<hash>`)
   * into an `ImageSource`.
   * Note: Unlike the `resolveBlurhashString` the `thumbhash:/` scheme has to be present,
   * as the scheme has to be explicitly stated to be interpreted a `thumbhash` source.
   *
   * @return An ImageSource representing the provided thumbhash.
   * */
  function resolveThumbhashString(str) {
    const hash = str.replace(/^thumbhash:\//, '');
    return {
      uri: 'thumbhash:/' + hash
    };
  }
},880,[],"node_modules/expo-image/src/utils/resolveHashString.web.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.useBlurhash = useBlurhash;
  var _react = require(_dependencyMap[0], "react");
  var _decode = require(_dependencyMap[1], "./decode");
  var decode = _interopDefault(_decode);
  var _resolveSources = require(_dependencyMap[2], "../resolveSources");
  // adapted from https://gist.github.com/ngbrown/d62eb518753378eb0a9bf02bb4723235
  // modified from https://gist.github.com/WorldMaker/a3cbe0059acd827edee568198376b95a
  // https://github.com/woltapp/react-blurhash/issues/3

  const DEFAULT_SIZE = {
    width: 32,
    height: 32
  };

  // We scale up the canvas to avoid an irritating visual glitch when animating in Chrome.
  const scaleRatio = 10;
  function useBlurhash(blurhash, punch = 1) {
    punch = punch || 1;
    const [uri, setUri] = (0, _react.useState)(null);
    const isBlurhash = (blurhash?.uri && (0, _resolveSources.isBlurhashString)(blurhash.uri)) ?? false;
    (0, _react.useEffect)(() => {
      let isCanceled = false;
      if (!blurhash || !blurhash.uri || !isBlurhash) {
        return;
      }
      const strippedBlurhashString = blurhash.uri.replace(/blurhash:\//, '');
      const pixels = (0, decode.default)(strippedBlurhashString, blurhash.width ?? DEFAULT_SIZE.width, blurhash.height ?? DEFAULT_SIZE.height, punch);
      const canvas = document.createElement('canvas');
      const upscaledCanvas = document.createElement('canvas');
      canvas.width = blurhash.width ?? DEFAULT_SIZE.width;
      canvas.height = blurhash.height ?? DEFAULT_SIZE.height;
      upscaledCanvas.width = (blurhash.width ?? DEFAULT_SIZE.width) * scaleRatio;
      upscaledCanvas.height = (blurhash.height ?? DEFAULT_SIZE.height) * scaleRatio;
      const context = canvas.getContext('2d');
      if (!context) {
        console.warn('Failed to decode blurhash');
        return;
      }
      const imageData = context.createImageData(canvas.width, canvas.height);
      imageData.data.set(pixels);
      context.putImageData(imageData, 0, 0);
      const upscaledContext = upscaledCanvas.getContext('2d');
      if (!upscaledContext) {
        console.warn('Failed to decode blurhash');
        return;
      }
      upscaledContext.scale(scaleRatio, scaleRatio);
      upscaledContext.drawImage(canvas, 0, 0);
      upscaledCanvas.toBlob(blob => {
        if (!isCanceled) {
          setUri(oldUrl => {
            if (oldUrl) {
              URL.revokeObjectURL(oldUrl);
            }
            return blob ? URL.createObjectURL(blob) : oldUrl;
          });
        }
      });
      return function cleanupBlurhash() {
        isCanceled = true;
        setUri(oldUrl => {
          if (oldUrl) {
            URL.revokeObjectURL(oldUrl);
          }
          return null;
        });
      };
    }, [blurhash?.uri, blurhash?.height, blurhash?.width, punch, isBlurhash]);
    const source = (0, _react.useMemo)(() => uri ? {
      uri
    } : null, [uri]);
    return [source, isBlurhash];
  }
},881,[9,884,870],"node_modules/expo-image/src/utils/blurhash/useBlurhash.tsx");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return AssetSourceResolver;
    }
  });
  var _expoModulesCore = require(_dependencyMap[0], "expo-modules-core");
  var _reactNativeWebDistExportsPixelRatio = require(_dependencyMap[1], "react-native-web/dist/exports/PixelRatio");
  var PixelRatio = _interopDefault(_reactNativeWebDistExportsPixelRatio);
  // Returns the Metro dev server-specific asset location.
  function getScaledAssetPath(asset) {
    const scale = AssetSourceResolver.pickScale(asset.scales, PixelRatio.default.get());
    const scaleSuffix = scale === 1 ? '' : '@' + scale + 'x';
    const type = !asset.type ? '' : `.${asset.type}`;
    if (__DEV__) {
      return asset.httpServerLocation + '/' + asset.name + scaleSuffix + type;
    } else {
      return asset.httpServerLocation.replace(/\.\.\//g, '_') + '/' + asset.name + scaleSuffix + type;
    }
  }
  class AssetSourceResolver {
    // where the jsbundle is being run from
    // NOTE(EvanBacon): Never defined on web.

    // the asset to resolve

    constructor(serverUrl, jsbundleUrl, asset) {
      this.serverUrl = serverUrl || 'https://expo.dev';
      this.jsbundleUrl = null;
      this.asset = asset;
    }

    // Always true for web runtimes
    isLoadedFromServer() {
      return true;
    }

    // Always false for web runtimes
    isLoadedFromFileSystem() {
      return false;
    }
    defaultAsset() {
      return this.assetServerURL();
    }

    /**
     * @returns absolute remote URL for the hosted asset.
     */
    assetServerURL() {
      const fromUrl = new URL(getScaledAssetPath(this.asset), this.serverUrl);
      fromUrl.searchParams.set('platform', _expoModulesCore.Platform.OS);
      fromUrl.searchParams.set('hash', this.asset.hash);
      return this.fromSource(
      // Relative on web
      fromUrl.toString().replace(fromUrl.origin, ''));
    }
    fromSource(source) {
      return {
        __packager_asset: true,
        width: this.asset.width ?? undefined,
        height: this.asset.height ?? undefined,
        uri: source,
        scale: AssetSourceResolver.pickScale(this.asset.scales, PixelRatio.default.get())
      };
    }
    static pickScale(scales, deviceScale) {
      for (let i = 0; i < scales.length; i++) {
        if (scales[i] >= deviceScale) {
          return scales[i];
        }
      }
      return scales[scales.length - 1] || 1;
    }
  }
},882,[594,158],"node_modules/expo-image/src/utils/AssetSourceResolver.web.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.rgbaToThumbHash = rgbaToThumbHash;
  exports.thumbHashToRGBA = thumbHashToRGBA;
  exports.thumbHashToAverageRGBA = thumbHashToAverageRGBA;
  exports.thumbHashToApproximateAspectRatio = thumbHashToApproximateAspectRatio;
  exports.rgbaToDataURL = rgbaToDataURL;
  exports.thumbHashToDataURL = thumbHashToDataURL;
  exports.thumbHashStringToDataURL = thumbHashStringToDataURL;
  // Code copied and slightly modified from https://github.com/evanw/thumbhash

  /**
   * Encodes an RGBA image to a ThumbHash. RGB should not be premultiplied by A.
   *
   * @param w The width of the input image. Must be ≤100px.
   * @param h The height of the input image. Must be ≤100px.
   * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.
   * @returns The ThumbHash as a Uint8Array.
   */

  function rgbaToThumbHash(w, h, rgba) {
    // Encoding an image larger than 100x100 is slow with no benefit
    if (w > 100 || h > 100) throw new Error(`${w}x${h} doesn't fit in 100x100`);
    const {
      PI,
      round,
      max,
      cos,
      abs
    } = Math;

    // Determine the average color
    let avg_r = 0,
      avg_g = 0,
      avg_b = 0,
      avg_a = 0;
    for (let i = 0, j = 0; i < w * h; i++, j += 4) {
      const alpha = rgba[j + 3] / 255;
      avg_r += alpha / 255 * rgba[j];
      avg_g += alpha / 255 * rgba[j + 1];
      avg_b += alpha / 255 * rgba[j + 2];
      avg_a += alpha;
    }
    if (avg_a) {
      avg_r /= avg_a;
      avg_g /= avg_a;
      avg_b /= avg_a;
    }
    const hasAlpha = avg_a < w * h;
    const l_limit = hasAlpha ? 5 : 7; // Use fewer luminance bits if there's alpha
    const lx = max(1, round(l_limit * w / max(w, h)));
    const ly = max(1, round(l_limit * h / max(w, h)));
    const l = []; // luminance
    const p = []; // yellow - blue
    const q = []; // red - green
    const a = []; // alpha

    // Convert the image from RGBA to LPQA (composite atop the average color)
    for (let i = 0, j = 0; i < w * h; i++, j += 4) {
      const alpha = rgba[j + 3] / 255;
      const r = avg_r * (1 - alpha) + alpha / 255 * rgba[j];
      const g = avg_g * (1 - alpha) + alpha / 255 * rgba[j + 1];
      const b = avg_b * (1 - alpha) + alpha / 255 * rgba[j + 2];
      l[i] = (r + g + b) / 3;
      p[i] = (r + g) / 2 - b;
      q[i] = r - g;
      a[i] = alpha;
    }

    // Encode using the DCT into DC (constant) and normalized AC (varying) terms
    const encodeChannel = (channel, nx, ny) => {
      let dc = 0;
      const ac = [];
      let scale = 0;
      const fx = [];
      for (let cy = 0; cy < ny; cy++) {
        for (let cx = 0; cx * ny < nx * (ny - cy); cx++) {
          let f = 0;
          for (let x = 0; x < w; x++) fx[x] = cos(PI / w * cx * (x + 0.5));
          for (let y = 0; y < h; y++) for (let x = 0, fy = cos(PI / h * cy * (y + 0.5)); x < w; x++) f += channel[x + y * w] * fx[x] * fy;
          f /= w * h;
          if (cx || cy) {
            ac.push(f);
            scale = max(scale, abs(f));
          } else {
            dc = f;
          }
        }
      }
      if (scale) for (let i = 0; i < ac.length; i++) ac[i] = 0.5 + 0.5 / scale * ac[i];
      return [dc, ac, scale];
    };
    const [l_dc, l_ac, l_scale] = encodeChannel(l, max(3, lx), max(3, ly));
    const [p_dc, p_ac, p_scale] = encodeChannel(p, 3, 3);
    const [q_dc, q_ac, q_scale] = encodeChannel(q, 3, 3);
    const [a_dc, a_ac, a_scale] = hasAlpha ? encodeChannel(a, 5, 5) : [];

    // Write the constants
    const isLandscape = w > h;
    const header24 = round(63 * l_dc) | round(31.5 + 31.5 * p_dc) << 6 | round(31.5 + 31.5 * q_dc) << 12 | round(31 * l_scale) << 18 | (hasAlpha ? 1 : 0) << 23;
    const header16 = (isLandscape ? ly : lx) | round(63 * p_scale) << 3 | round(63 * q_scale) << 9 | (isLandscape ? 1 : 0) << 15;
    const hash = [header24 & 255, header24 >> 8 & 255, header24 >> 16, header16 & 255, header16 >> 8];
    const ac_start = hasAlpha ? 6 : 5;
    let ac_index = 0;
    if (hasAlpha) hash.push(round(15 * a_dc) | round(15 * a_scale) << 4);

    // Write the varying factors
    for (const ac of hasAlpha ? [l_ac, p_ac, q_ac, a_ac] : [l_ac, p_ac, q_ac]) for (const f of ac) hash[ac_start + (ac_index >> 1)] |= round(15 * f) << ((ac_index++ & 1) << 2);
    return new Uint8Array(hash);
  }

  /**
   * Decodes a ThumbHash to an RGBA image. RGB is not be premultiplied by A.
   *
   * @param hash The bytes of the ThumbHash.
   * @returns The width, height, and pixels of the rendered placeholder image.
   */
  function thumbHashToRGBA(hash) {
    const {
      PI,
      min,
      max,
      cos,
      round
    } = Math;

    // Read the constants
    const header24 = hash[0] | hash[1] << 8 | hash[2] << 16;
    const header16 = hash[3] | hash[4] << 8;
    const l_dc = (header24 & 63) / 63;
    const p_dc = (header24 >> 6 & 63) / 31.5 - 1;
    const q_dc = (header24 >> 12 & 63) / 31.5 - 1;
    const l_scale = (header24 >> 18 & 31) / 31;
    const hasAlpha = header24 >> 23;
    const p_scale = (header16 >> 3 & 63) / 63;
    const q_scale = (header16 >> 9 & 63) / 63;
    const isLandscape = header16 >> 15;
    const lx = max(3, isLandscape ? hasAlpha ? 5 : 7 : header16 & 7);
    const ly = max(3, isLandscape ? header16 & 7 : hasAlpha ? 5 : 7);
    const a_dc = hasAlpha ? (hash[5] & 15) / 15 : 1;
    const a_scale = (hash[5] >> 4) / 15;

    // Read the varying factors (boost saturation by 1.25x to compensate for quantization)
    const ac_start = hasAlpha ? 6 : 5;
    let ac_index = 0;
    const decodeChannel = (nx, ny, scale) => {
      const ac = [];
      for (let cy = 0; cy < ny; cy++) for (let cx = cy ? 0 : 1; cx * ny < nx * (ny - cy); cx++) ac.push(((hash[ac_start + (ac_index >> 1)] >> ((ac_index++ & 1) << 2) & 15) / 7.5 - 1) * scale);
      return ac;
    };
    const l_ac = decodeChannel(lx, ly, l_scale);
    const p_ac = decodeChannel(3, 3, p_scale * 1.25);
    const q_ac = decodeChannel(3, 3, q_scale * 1.25);
    const a_ac = hasAlpha ? decodeChannel(5, 5, a_scale) : null;

    // Decode using the DCT into RGB
    const ratio = thumbHashToApproximateAspectRatio(hash);
    const w = round(ratio > 1 ? 32 : 32 * ratio);
    const h = round(ratio > 1 ? 32 / ratio : 32);
    const rgba = new Uint8Array(w * h * 4),
      fx = [],
      fy = [];
    for (let y = 0, i = 0; y < h; y++) {
      for (let x = 0; x < w; x++, i += 4) {
        let l = l_dc,
          p = p_dc,
          q = q_dc,
          a = a_dc;

        // Precompute the coefficients
        for (let cx = 0, n = max(lx, hasAlpha ? 5 : 3); cx < n; cx++) fx[cx] = cos(PI / w * (x + 0.5) * cx);
        for (let cy = 0, n = max(ly, hasAlpha ? 5 : 3); cy < n; cy++) fy[cy] = cos(PI / h * (y + 0.5) * cy);

        // Decode L
        for (let cy = 0, j = 0; cy < ly; cy++) for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx * ly < lx * (ly - cy); cx++, j++) l += l_ac[j] * fx[cx] * fy2;

        // Decode P and Q
        for (let cy = 0, j = 0; cy < 3; cy++) {
          for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 3 - cy; cx++, j++) {
            const f = fx[cx] * fy2;
            p += p_ac[j] * f;
            q += q_ac[j] * f;
          }
        }

        // Decode A
        if (hasAlpha) for (let cy = 0, j = 0; cy < 5; cy++) for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 5 - cy; cx++, j++) a += a_ac[j] * fx[cx] * fy2;

        // Convert to RGB
        const b = l - 2 / 3 * p;
        const r = (3 * l - b + q) / 2;
        const g = r - q;
        rgba[i] = max(0, 255 * min(1, r));
        rgba[i + 1] = max(0, 255 * min(1, g));
        rgba[i + 2] = max(0, 255 * min(1, b));
        rgba[i + 3] = max(0, 255 * min(1, a));
      }
    }
    return {
      w,
      h,
      rgba
    };
  }

  /**
   * Extracts the average color from a ThumbHash. RGB is not be premultiplied by A.
   *
   * @param hash The bytes of the ThumbHash.
   * @returns The RGBA values for the average color. Each value ranges from 0 to 1.
   */
  function thumbHashToAverageRGBA(hash) {
    const {
      min,
      max
    } = Math;
    const header = hash[0] | hash[1] << 8 | hash[2] << 16;
    const l = (header & 63) / 63;
    const p = (header >> 6 & 63) / 31.5 - 1;
    const q = (header >> 12 & 63) / 31.5 - 1;
    const hasAlpha = header >> 23;
    const a = hasAlpha ? (hash[5] & 15) / 15 : 1;
    const b = l - 2 / 3 * p;
    const r = (3 * l - b + q) / 2;
    const g = r - q;
    return {
      r: max(0, min(1, r)),
      g: max(0, min(1, g)),
      b: max(0, min(1, b)),
      a
    };
  }

  /**
   * Extracts the approximate aspect ratio of the original image.
   *
   * @param hash The bytes of the ThumbHash.
   * @returns The approximate aspect ratio (i.e. width / height).
   */
  function thumbHashToApproximateAspectRatio(hash) {
    const header = hash[3];
    const hasAlpha = hash[2] & 0x80;
    const isLandscape = hash[4] & 0x80;
    const lx = isLandscape ? hasAlpha ? 5 : 7 : header & 7;
    const ly = isLandscape ? header & 7 : hasAlpha ? 5 : 7;
    return lx / ly;
  }

  /**
   * Encodes an RGBA image to a PNG data URL. RGB should not be premultiplied by
   * A. This is optimized for speed and simplicity and does not optimize for size
   * at all. This doesn't do any compression (all values are stored uncompressed).
   *
   * @param w The width of the input image. Must be ≤100px.
   * @param h The height of the input image. Must be ≤100px.
   * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.
   * @returns A data URL containing a PNG for the input image.
   */
  function rgbaToDataURL(w, h, rgba) {
    const row = w * 4 + 1;
    const idat = 6 + h * (5 + row);
    const bytes = [137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, w >> 8, w & 255, 0, 0, h >> 8, h & 255, 8, 6, 0, 0, 0, 0, 0, 0, 0, idat >>> 24, idat >> 16 & 255, idat >> 8 & 255, idat & 255, 73, 68, 65, 84, 120, 1];
    const table = [0, 498536548, 997073096, 651767980, 1994146192, 1802195444, 1303535960, 1342533948, -306674912, -267414716, -690576408, -882789492, -1687895376, -2032938284, -1609899400, -1111625188];
    let a = 1,
      b = 0;
    for (let y = 0, i = 0, end = row - 1; y < h; y++, end += row - 1) {
      bytes.push(y + 1 < h ? 0 : 1, row & 255, row >> 8, ~row & 255, row >> 8 ^ 255, 0);
      for (b = (b + a) % 65521; i < end; i++) {
        const u = rgba[i] & 255;
        bytes.push(u);
        a = (a + u) % 65521;
        b = (b + a) % 65521;
      }
    }
    bytes.push(b >> 8, b & 255, a >> 8, a & 255, 0, 0, 0, 0, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130);
    for (let [start, end] of [[12, 29], [37, 41 + idat]]) {
      let c = ~0;
      for (let i = start; i < end; i++) {
        c ^= bytes[i];
        c = c >>> 4 ^ table[c & 15];
        c = c >>> 4 ^ table[c & 15];
      }
      c = ~c;
      bytes[end++] = c >>> 24;
      bytes[end++] = c >> 16 & 255;
      bytes[end++] = c >> 8 & 255;
      bytes[end++] = c & 255;
    }
    return 'data:image/png;base64,' + btoa(String.fromCharCode(...bytes));
  }

  /**
   * Decodes a ThumbHash to a PNG data URL. This is a convenience function that
   * just calls "thumbHashToRGBA" followed by "rgbaToDataURL".
   *
   * @param hash The bytes of the ThumbHash.
   * @returns A data URL containing a PNG for the rendered ThumbHash.
   */
  function thumbHashToDataURL(hash) {
    const image = thumbHashToRGBA(hash);
    return rgbaToDataURL(image.w, image.h, image.rgba);
  }

  /**
   * Convenience function added to the original thumbhash code, allows generating a thumbhash image directly from
   * thumbhash string.
   * @param thumbhash string from which thumbhashDataURL should be generated
   * @returns A data URL containing a PNG for the rendered ThumbHash
   */
  function thumbHashStringToDataURL(thumbhash) {
    const hash = Uint8Array.from(atob(thumbhash), c => c.charCodeAt(0));
    return thumbHashToDataURL(hash);
  }
},883,[],"node_modules/expo-image/src/utils/thumbhash/thumbhash.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "isBlurhashValid", {
    enumerable: true,
    get: function () {
      return isBlurhashValid;
    }
  });
  var _base = require(_dependencyMap[0], "./base83");
  var _error = require(_dependencyMap[1], "./error");
  var _utils = require(_dependencyMap[2], "./utils");
  /**
   * Returns an error message if invalid or undefined if valid
   * @param blurhash
   */
  const validateBlurhash = blurhash => {
    if (!blurhash || blurhash.length < 6) {
      throw new _error.ValidationError('The blurhash string must be at least 6 characters');
    }
    const sizeFlag = (0, _base.decode83)(blurhash[0]);
    const numY = Math.floor(sizeFlag / 9) + 1;
    const numX = sizeFlag % 9 + 1;
    if (blurhash.length !== 4 + 2 * numX * numY) {
      throw new _error.ValidationError(`blurhash length mismatch: length is ${blurhash.length} but it should be ${4 + 2 * numX * numY}`);
    }
  };
  const isBlurhashValid = blurhash => {
    try {
      validateBlurhash(blurhash);
    } catch (error) {
      return {
        result: false,
        errorReason: error.message
      };
    }
    return {
      result: true
    };
  };
  const decodeDC = value => {
    const intR = value >> 16;
    const intG = value >> 8 & 255;
    const intB = value & 255;
    return [(0, _utils.sRGBToLinear)(intR), (0, _utils.sRGBToLinear)(intG), (0, _utils.sRGBToLinear)(intB)];
  };
  const decodeAC = (value, maximumValue) => {
    const quantR = Math.floor(value / (19 * 19));
    const quantG = Math.floor(value / 19) % 19;
    const quantB = value % 19;
    const rgb = [(0, _utils.signPow)((quantR - 9) / 9, 2.0) * maximumValue, (0, _utils.signPow)((quantG - 9) / 9, 2.0) * maximumValue, (0, _utils.signPow)((quantB - 9) / 9, 2.0) * maximumValue];
    return rgb;
  };
  const decode = (blurhash, width, height, punch) => {
    validateBlurhash(blurhash);
    punch = (punch || 1) | 1;
    const sizeFlag = (0, _base.decode83)(blurhash[0]);
    const numY = Math.floor(sizeFlag / 9) + 1;
    const numX = sizeFlag % 9 + 1;
    const quantisedMaximumValue = (0, _base.decode83)(blurhash[1]);
    const maximumValue = (quantisedMaximumValue + 1) / 166;
    const colors = new Array(numX * numY);
    for (let i = 0; i < colors.length; i++) {
      if (i === 0) {
        const value = (0, _base.decode83)(blurhash.substring(2, 6));
        colors[i] = decodeDC(value);
      } else {
        const value = (0, _base.decode83)(blurhash.substring(4 + i * 2, 6 + i * 2));
        colors[i] = decodeAC(value, maximumValue * punch);
      }
    }
    const bytesPerRow = width * 4;
    const pixels = new Uint8ClampedArray(bytesPerRow * height);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let r = 0;
        let g = 0;
        let b = 0;
        for (let j = 0; j < numY; j++) {
          for (let i = 0; i < numX; i++) {
            const basis = Math.cos(Math.PI * x * i / width) * Math.cos(Math.PI * y * j / height);
            const color = colors[i + j * numX];
            r += color[0] * basis;
            g += color[1] * basis;
            b += color[2] * basis;
          }
        }
        const intR = (0, _utils.linearTosRGB)(r);
        const intG = (0, _utils.linearTosRGB)(g);
        const intB = (0, _utils.linearTosRGB)(b);
        pixels[4 * x + 0 + y * bytesPerRow] = intR;
        pixels[4 * x + 1 + y * bytesPerRow] = intG;
        pixels[4 * x + 2 + y * bytesPerRow] = intB;
        pixels[4 * x + 3 + y * bytesPerRow] = 255; // alpha
      }
    }
    return pixels;
  };
  var _default = decode;
},884,[885,886,887],"node_modules/expo-image/src/utils/blurhash/decode.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "decode83", {
    enumerable: true,
    get: function () {
      return decode83;
    }
  });
  Object.defineProperty(exports, "encode83", {
    enumerable: true,
    get: function () {
      return encode83;
    }
  });
  const digitCharacters = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '#', '$', '%', '*', '+', ',', '-', '.', ':', ';', '=', '?', '@', '[', ']', '^', '_', '{', '|', '}', '~'];
  const decode83 = str => {
    let value = 0;
    for (let i = 0; i < str.length; i++) {
      const c = str[i];
      const digit = digitCharacters.indexOf(c);
      value = value * 83 + digit;
    }
    return value;
  };
  const encode83 = (n, length) => {
    let result = '';
    for (let i = 1; i <= length; i++) {
      const digit = Math.floor(n) / Math.pow(83, length - i) % 83;
      result += digitCharacters[Math.floor(digit)];
    }
    return result;
  };
},885,[],"node_modules/expo-image/src/utils/blurhash/base83.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "ValidationError", {
    enumerable: true,
    get: function () {
      return ValidationError;
    }
  });
  class ValidationError extends Error {
    constructor(message) {
      super(message);
      this.name = 'ValidationError';
      this.message = message;
    }
  }
},886,[],"node_modules/expo-image/src/utils/blurhash/error.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "sRGBToLinear", {
    enumerable: true,
    get: function () {
      return sRGBToLinear;
    }
  });
  Object.defineProperty(exports, "linearTosRGB", {
    enumerable: true,
    get: function () {
      return linearTosRGB;
    }
  });
  Object.defineProperty(exports, "sign", {
    enumerable: true,
    get: function () {
      return sign;
    }
  });
  Object.defineProperty(exports, "signPow", {
    enumerable: true,
    get: function () {
      return signPow;
    }
  });
  const sRGBToLinear = value => {
    const v = value / 255;
    if (v <= 0.04045) {
      return v / 12.92;
    } else {
      return Math.pow((v + 0.055) / 1.055, 2.4);
    }
  };
  const linearTosRGB = value => {
    const v = Math.max(0, Math.min(1, value));
    if (v <= 0.0031308) {
      return Math.trunc(v * 12.92 * 255 + 0.5);
    } else {
      return Math.trunc((1.055 * Math.pow(v, 1 / 2.4) - 0.055) * 255 + 0.5);
    }
  };
  const sign = n => n < 0 ? -1 : 1;
  const signPow = (val, exp) => sign(val) * Math.pow(Math.abs(val), exp);
},887,[],"node_modules/expo-image/src/utils/blurhash/utils.ts");
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return ImageRefWeb;
    }
  });
  var _expo = require(_dependencyMap[0], "expo");
  class ImageRefWeb extends _expo.SharedRef {
    nativeRefType = 'image';
    uri = null;
    width = 0;
    height = 0;
    mediaType = null;
    scale = 1;
    isAnimated = false;
    static init(uri, width, height, mediaType) {
      return Object.assign(new ImageRefWeb(), {
        uri,
        width,
        height,
        mediaType,
        isAnimated: mediaType === 'image/gif'
      });
    }
  }
},888,[550],"node_modules/expo-image/src/web/ImageRef.ts");
__r(552);
__r(2);
__r(0);
//# sourceMappingURL=http://localhost:8081/node_modules/expo-router/entry.map?platform=web&dev=true&hot=false&lazy=true&transform.routerRoot=app&transform.reactCompiler=true